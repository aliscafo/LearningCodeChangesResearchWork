1711
#method_before
private void postPrepareSanStorageForEdit(SanStorageModel model, boolean isStorageActive) {
    StorageModel storageModel = (StorageModel) getWindow();
    StorageDomain storage = (StorageDomain) getSelectedItem();
    model.setStorageDomain(storage);
    VDS host = storageModel.getHost().getSelectedItem();
    Guid hostId = host != null && isStorageActive ? host.getId() : null;
    AsyncDataProvider.getInstance().getLunsByVgId(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            SanStorageModel sanStorageModel = (SanStorageModel) target;
            ArrayList<LUNs> lunList = (ArrayList<LUNs>) returnValue;
            sanStorageModel.applyData(lunList, true);
        }
    }, storageModel.getHash()), storage.getStorage(), hostId);
}
#method_after
private void postPrepareSanStorageForEdit(final SanStorageModel model, boolean isStorageActive) {
    StorageModel storageModel = (StorageModel) getWindow();
    StorageDomain storage = (StorageDomain) getSelectedItem();
    model.setStorageDomain(storage);
    VDS host = storageModel.getHost().getSelectedItem();
    Guid hostId = host != null && isStorageActive ? host.getId() : null;
    AsyncDataProvider.getInstance().getLunsByVgId(new AsyncQuery(storageModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<LUNs> lunList = (ArrayList<LUNs>) returnValue;
            model.applyData(lunList, true);
        }
    }), storage.getStorage(), hostId);
}
#end_block

#method_before
private void cancel() {
    setWindow(null);
    Frontend.getInstance().unsubscribe();
}
#method_after
private void cancel() {
    setWindow(null);
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    // Add progress listeners
    Frontend.getInstance().getQueryStartedEvent().addListener(this);
    Frontend.getInstance().getQueryCompleteEvent().addListener(this);
    Frontend.getInstance().subscribeAdditionalQueries(new VdcQueryType[] { VdcQueryType.Search, VdcQueryType.GetStoragePoolById, VdcQueryType.GetNextAvailableDiskAliasNameByVMId, VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, VdcQueryType.GetAllVdsByStoragePool, VdcQueryType.GetAllAttachableDisks, VdcQueryType.GetAllDisksByVmId, VdcQueryType.GetAllRelevantQuotasForStorage, VdcQueryType.OsRepository, VdcQueryType.GetDiskProfilesByStorageDomainId });
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#method_after
@Override
public void initialize() {
    super.initialize();
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#end_block

#method_before
protected void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<StorageDomain>();
            for (StorageDomain a : storageDomains) {
                if (!a.getStorageDomainType().isIsoOrImportExportDomain() && a.getStatus() == StorageDomainStatus.Active) {
                    filteredStorageDomains.add(a);
                }
            }
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains);
            diskModel.getStorageDomain().setSelectedItem(storage);
            diskModel.setMessage(storage == null ? CONSTANTS.noActiveStorageDomainsInDC() : "");
        }
    }, getHash()), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#method_after
protected void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<StorageDomain>();
            for (StorageDomain a : storageDomains) {
                if (!a.getStorageDomainType().isIsoOrImportExportDomain() && a.getStatus() == StorageDomainStatus.Active) {
                    filteredStorageDomains.add(a);
                }
            }
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains);
            diskModel.getStorageDomain().setSelectedItem(storage);
            diskModel.setMessage(storage == null ? CONSTANTS.noActiveStorageDomainsInDC() : "");
        }
    }), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#end_block

#method_before
private void updateHosts(StoragePool datacenter) {
    AsyncDataProvider.getInstance().getHostListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
            ArrayList<VDS> filteredHosts = new ArrayList<VDS>();
            for (VDS host : hosts) {
                if (isHostAvailable(host)) {
                    filteredHosts.add(host);
                }
            }
            diskModel.getHost().setItems(filteredHosts);
        }
    }, getHash()), datacenter.getId());
}
#method_after
private void updateHosts(StoragePool datacenter) {
    AsyncDataProvider.getInstance().getHostListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
            ArrayList<VDS> filteredHosts = new ArrayList<VDS>();
            for (VDS host : hosts) {
                if (isHostAvailable(host)) {
                    filteredHosts.add(host);
                }
            }
            diskModel.getHost().setItems(filteredHosts);
        }
    }), datacenter.getId());
}
#end_block

#method_before
private void updateDatacenters() {
    boolean isInVm = getVm() != null;
    getDataCenter().setIsAvailable(!isInVm);
    // $NON-NLS-1$
    setMessage("");
    if (isInVm) {
        AsyncDataProvider.getInstance().getDataCenterById((new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                StoragePool dataCenter = (StoragePool) returnValue;
                ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
                if (isDatacenterAvailable(dataCenter)) {
                    dataCenters.add(dataCenter);
                }
                diskModel.getDataCenter().setItems(dataCenters);
                if (dataCenters.isEmpty()) {
                    diskModel.setMessage(CONSTANTS.relevantDCnotActive());
                }
            }
        }, getHash())), getVm().getStoragePoolId());
    } else {
        AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                ArrayList<StoragePool> filteredDataCenters = new ArrayList<StoragePool>();
                for (StoragePool dataCenter : dataCenters) {
                    if (isDatacenterAvailable(dataCenter)) {
                        filteredDataCenters.add(dataCenter);
                    }
                }
                diskModel.getDataCenter().setItems(filteredDataCenters);
                if (filteredDataCenters.isEmpty()) {
                    diskModel.setMessage(CONSTANTS.noActiveDataCenters());
                }
            }
        }, getHash()));
    }
}
#method_after
private void updateDatacenters() {
    boolean isInVm = getVm() != null;
    getDataCenter().setIsAvailable(!isInVm);
    // $NON-NLS-1$
    setMessage("");
    if (isInVm) {
        AsyncDataProvider.getInstance().getDataCenterById((new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                StoragePool dataCenter = (StoragePool) returnValue;
                ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
                if (isDatacenterAvailable(dataCenter)) {
                    dataCenters.add(dataCenter);
                }
                diskModel.getDataCenter().setItems(dataCenters);
                if (dataCenters.isEmpty()) {
                    diskModel.setMessage(CONSTANTS.relevantDCnotActive());
                }
            }
        })), getVm().getStoragePoolId());
    } else {
        AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                ArrayList<StoragePool> filteredDataCenters = new ArrayList<StoragePool>();
                for (StoragePool dataCenter : dataCenters) {
                    if (isDatacenterAvailable(dataCenter)) {
                        filteredDataCenters.add(dataCenter);
                    }
                }
                diskModel.getDataCenter().setItems(filteredDataCenters);
                if (filteredDataCenters.isEmpty()) {
                    diskModel.setMessage(CONSTANTS.noActiveDataCenters());
                }
            }
        }));
    }
}
#end_block

#method_before
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#method_after
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }), getVm().getId());
}
#end_block

#method_before
private void updateShareableDiskEnabled(StoragePool datacenter) {
    boolean isShareableDiskEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.ShareableDiskEnabled, datacenter.getcompatibility_version().getValue());
    getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupported());
    getIsShareable().setIsChangable(isShareableDiskEnabled && isEditEnabled());
}
#method_after
private void updateShareableDiskEnabled(StoragePool datacenter) {
    boolean isShareableDiskEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.ShareableDiskEnabled, datacenter.getCompatibilityVersion().getValue());
    getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupported());
    getIsShareable().setIsChangable(isShareableDiskEnabled && isEditEnabled());
}
#end_block

#method_before
private void updateDirectLunDiskEnabled(StoragePool datacenter) {
    if (getDiskStorageType().getEntity() != DiskStorageType.LUN) {
        return;
    }
    boolean isDirectLUNDiskkEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.DirectLUNDiskEnabled, datacenter.getcompatibility_version().getValue());
    getIsDirectLunDiskAvaialable().setEntity(isDirectLUNDiskkEnabled);
    // $NON-NLS-1$
    setMessage(!isDirectLUNDiskkEnabled ? CONSTANTS.directLUNDiskNotSupported() : "");
}
#method_after
private void updateDirectLunDiskEnabled(StoragePool datacenter) {
    if (getDiskStorageType().getEntity() != DiskStorageType.LUN) {
        return;
    }
    boolean isDirectLUNDiskkEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.DirectLUNDiskEnabled, datacenter.getCompatibilityVersion().getValue());
    getIsDirectLunDiskAvaialable().setEntity(isDirectLUNDiskkEnabled);
    // $NON-NLS-1$
    setMessage(!isDirectLUNDiskkEnabled ? CONSTANTS.directLUNDiskNotSupported() : "");
}
#end_block

#method_before
private void updateDiskProfiles(StoragePool selectedItem) {
    StorageDomain storageDomain = getStorageDomain().getSelectedItem();
    if (storageDomain == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(storageDomain.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object innerModel, Object value) {
            AbstractDiskModel.this.setDiskProfilesList((List<DiskProfile>) ((VdcQueryReturnValue) value).getReturnValue());
        }
    }, getHash()));
}
#method_after
private void updateDiskProfiles(StoragePool selectedItem) {
    StorageDomain storageDomain = getStorageDomain().getSelectedItem();
    if (storageDomain == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(storageDomain.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object innerModel, Object value) {
            AbstractDiskModel.this.setDiskProfilesList((List<DiskProfile>) ((VdcQueryReturnValue) value).getReturnValue());
        }
    }));
}
#end_block

#method_before
private void updateQuota(StoragePool datacenter) {
    if (datacenter.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED) || getDiskStorageType().getEntity() != DiskStorageType.IMAGE) {
        getQuota().setIsAvailable(false);
        return;
    }
    getQuota().setIsAvailable(true);
    StorageDomain storageDomain = getStorageDomain().getSelectedItem();
    if (storageDomain == null) {
        return;
    }
    IdQueryParameters parameters = new IdQueryParameters(storageDomain.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForStorage, parameters, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object innerModel, Object innerReturnValue) {
            ArrayList<Quota> quotaList = ((VdcQueryReturnValue) innerReturnValue).getReturnValue();
            if (quotaList != null && !quotaList.isEmpty()) {
                getQuota().setItems(quotaList);
            }
            Guid defaultQuota = getDisk() != null ? ((DiskImage) getDisk()).getQuotaId() : null;
            if (defaultQuota != null) {
                for (Quota quota : quotaList) {
                    if (quota.getId().equals(defaultQuota)) {
                        getQuota().setSelectedItem(quota);
                        return;
                    }
                }
                Quota quota = new Quota();
                quota.setId(defaultQuota);
                if (getDisk() != null) {
                    quota.setQuotaName(getDiskImage().getQuotaName());
                }
                quotaList.add(quota);
                getQuota().setItems(quotaList);
                getQuota().setSelectedItem(quota);
            }
        }
    }, getHash()));
}
#method_after
private void updateQuota(StoragePool datacenter) {
    if (datacenter.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED) || getDiskStorageType().getEntity() != DiskStorageType.IMAGE) {
        getQuota().setIsAvailable(false);
        return;
    }
    getQuota().setIsAvailable(true);
    StorageDomain storageDomain = getStorageDomain().getSelectedItem();
    if (storageDomain == null) {
        return;
    }
    IdQueryParameters parameters = new IdQueryParameters(storageDomain.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForStorage, parameters, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object innerModel, Object innerReturnValue) {
            ArrayList<Quota> quotaList = ((VdcQueryReturnValue) innerReturnValue).getReturnValue();
            if (quotaList != null && !quotaList.isEmpty()) {
                getQuota().setItems(quotaList);
            }
            Guid defaultQuota = getDisk() != null ? ((DiskImage) getDisk()).getQuotaId() : null;
            if (defaultQuota != null) {
                for (Quota quota : quotaList) {
                    if (quota.getId().equals(defaultQuota)) {
                        getQuota().setSelectedItem(quota);
                        return;
                    }
                }
                Quota quota = new Quota();
                quota.setId(defaultQuota);
                if (getDisk() != null) {
                    quota.setQuotaName(getDiskImage().getQuotaName());
                }
                quotaList.add(quota);
                getQuota().setItems(quotaList);
                getQuota().setSelectedItem(quota);
            }
        }
    }));
}
#end_block

#method_before
private void storageDomain_SelectedItemChanged() {
    StorageDomain selectedStorage = getStorageDomain().getSelectedItem();
    if (selectedStorage != null) {
        updateVolumeType(selectedStorage.getStorageType());
        getIsWipeAfterDelete().setEntity(selectedStorage.getWipeAfterDelete());
    }
    updateQuota(getDataCenter().getSelectedItem());
    updateDiskProfiles(getDataCenter().getSelectedItem());
}
#method_after
private void storageDomain_SelectedItemChanged() {
    StorageDomain selectedStorage = getStorageDomain().getSelectedItem();
    if (selectedStorage != null) {
        updateVolumeType(selectedStorage.getStorageType());
        if (getIsNew()) {
            getIsWipeAfterDelete().setEntity(selectedStorage.getWipeAfterDelete());
        }
    }
    updateQuota(getDataCenter().getSelectedItem());
    updateDiskProfiles(getDataCenter().getSelectedItem());
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getIsReadOnly()) {
            updateScsiPassthroguhChangeability();
        } else if (sender == getIsScsiPassthrough()) {
            updateSgIoUnfilteredChangeability();
            updateReadOnlyChangeability();
        } else if (sender == getDiskStorageType()) {
            diskStorageType_EntityChanged();
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVolumeType()) {
            volumeType_SelectedItemChanged();
        } else if (sender == getDiskInterface()) {
            DiskInterface_SelectedItemChanged();
        } else if (sender == getDataCenter()) {
            datacenter_SelectedItemChanged();
        } else if (sender == getStorageDomain()) {
            storageDomain_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getIsReadOnly()) {
            updateScsiPassthroguhChangeability();
        } else if (sender == getIsScsiPassthrough()) {
            updateSgIoUnfilteredChangeability();
            updateReadOnlyChangeability();
        } else if (sender == getDiskStorageType()) {
            diskStorageType_EntityChanged();
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVolumeType()) {
            volumeType_SelectedItemChanged();
        } else if (sender == getDiskInterface()) {
            DiskInterface_SelectedItemChanged();
        } else if (sender == getDataCenter()) {
            datacenter_SelectedItemChanged();
        } else if (sender == getStorageDomain()) {
            storageDomain_SelectedItemChanged();
        }
    }
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    behavior.setHash(getHash());
    behavior.initialize();
    initDataCenter();
}
#method_after
@Override
public void initialize() {
    super.initialize();
    behavior.initialize();
    initDataCenter();
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            dataCenter_SelectedItemChanged();
        } else if (sender == getHost()) {
            host_SelectedItemChanged();
        } else if (sender == getAvailableStorageItems()) {
            if (getAvailableStorageItems().getSelectedItem() instanceof IStorageModel) {
                setSelectedItem(null);
                setSelectedItem(getAvailableStorageItems().getSelectedItem());
                updateWipeAfterDelete();
            }
        }
    } else if (ev.matchesDefinition(NfsStorageModel.pathChangedEventDefinition)) {
        nfsStorageModel_PathChanged(sender, args);
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            dataCenter_SelectedItemChanged();
        } else if (sender == getHost()) {
            host_SelectedItemChanged();
        } else if (sender == getAvailableStorageItems()) {
            if (getAvailableStorageItems().getSelectedItem() instanceof IStorageModel) {
                setSelectedItem(null);
                setSelectedItem(getAvailableStorageItems().getSelectedItem());
                updateWipeAfterDelete();
            }
        }
    } else if (ev.matchesDefinition(NfsStorageModel.pathChangedEventDefinition)) {
        nfsStorageModel_PathChanged(sender, args);
    }
}
#end_block

#method_before
private void host_SelectedItemChanged() {
    VDS host = getHost().getSelectedItem();
    if (getSelectedItem() != null) {
        // When changing host clear items for san storage model.
        if (getSelectedItem() instanceof SanStorageModelBase) {
            SanStorageModelBase sanStorageModel = (SanStorageModelBase) getSelectedItem();
            sanStorageModel.setHash(getHash());
            if (getStorage() == null) {
                sanStorageModel.setItems(null);
            }
        }
        if (host != null) {
            getSelectedItem().getUpdateCommand().execute();
            VDSType vdsType = this.getHost().getSelectedItem().getVdsType();
            // $NON-NLS-1$
            String prefix = vdsType.equals(VDSType.oVirtNode) ? localFSPath : "";
            if (!StringHelper.isNullOrEmpty(prefix)) {
                for (Object item : getItems()) {
                    if (item instanceof LocalStorageModel) {
                        LocalStorageModel model = (LocalStorageModel) item;
                        model.getPath().setEntity(prefix);
                        model.getPath().setIsChangable(false);
                    }
                }
            }
        }
    }
}
#method_after
private void host_SelectedItemChanged() {
    VDS host = getHost().getSelectedItem();
    if (getSelectedItem() != null) {
        // When changing host clear items for san storage model.
        if (getSelectedItem() instanceof SanStorageModelBase) {
            SanStorageModelBase sanStorageModel = (SanStorageModelBase) getSelectedItem();
            if (getStorage() == null) {
                sanStorageModel.setItems(null);
            }
        }
        if (host != null) {
            getSelectedItem().getUpdateCommand().execute();
            VDSType vdsType = this.getHost().getSelectedItem().getVdsType();
            // $NON-NLS-1$
            String prefix = vdsType.equals(VDSType.oVirtNode) ? localFSPath : "";
            if (!StringHelper.isNullOrEmpty(prefix)) {
                for (Object item : getItems()) {
                    if (item instanceof LocalStorageModel) {
                        LocalStorageModel model = (LocalStorageModel) item;
                        model.getPath().setEntity(prefix);
                        model.getPath().setIsChangable(false);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
private void initDataCenter() {
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case DataCenter:
            case Cluster:
            case Storages:
            case Storage:
                {
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
            case Host:
                {
                    VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
                    getHost().setIsChangable(false);
                    getHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                    getHost().setSelectedItem(host);
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
        }
    } else {
        if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) // We are either adding a new storage or editing an unattached storage
        // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
        // [TODO: In case of an Unattached SD, choose only DCs of the same type]
        {
            AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(new Object[] { this, behavior }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    StorageModel storageModel = (StorageModel) array[0];
                    StorageModelBehavior storageModelBehavior = (StorageModelBehavior) array[1];
                    List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                    dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
                    StorageModel.addEmptyDataCenterToList(dataCenters);
                    StoragePool oldSelectedItem = storageModel.getDataCenter().getSelectedItem();
                    storageModel.getDataCenter().setItems(dataCenters);
                    if (oldSelectedItem != null) {
                        storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(oldSelectedItem.getId())));
                    } else {
                        storageModel.getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrDefault(dataCenters) : Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(UnassignedDataCenterId)));
                    }
                }
            }, getHash()));
        } else // "Edit Storage" mode:
        {
            AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    List<StoragePool> dataCenters = new ArrayList<StoragePool>();
                    List<StoragePool> dataCentersWithStorage = (ArrayList<StoragePool>) returnValue;
                    if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                        StorageModel.addEmptyDataCenterToList(dataCenters);
                    } else {
                        dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCentersWithStorage.get(0) }));
                    }
                    storageModel.getDataCenter().setItems(dataCenters);
                    storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                }
            }, getHash()), getStorage().getId());
        }
    }
}
#method_after
private void initDataCenter() {
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case DataCenter:
            case Cluster:
            case Storages:
            case Storage:
                {
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
            case Host:
                {
                    VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
                    getHost().setIsChangable(false);
                    getHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                    getHost().setSelectedItem(host);
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
        }
    } else {
        if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) // We are either adding a new storage or editing an unattached storage
        // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
        // [TODO: In case of an Unattached SD, choose only DCs of the same type]
        {
            AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    StorageModelBehavior storageModelBehavior = behavior;
                    List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                    dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
                    StorageModel.addEmptyDataCenterToList(dataCenters);
                    StoragePool oldSelectedItem = storageModel.getDataCenter().getSelectedItem();
                    storageModel.getDataCenter().setItems(dataCenters);
                    if (oldSelectedItem != null) {
                        storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(oldSelectedItem.getId())));
                    } else {
                        storageModel.getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrDefault(dataCenters) : Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(UnassignedDataCenterId)));
                    }
                }
            }));
        } else // "Edit Storage" mode:
        {
            AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    List<StoragePool> dataCenters = new ArrayList<StoragePool>();
                    List<StoragePool> dataCentersWithStorage = (ArrayList<StoragePool>) returnValue;
                    if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                        StorageModel.addEmptyDataCenterToList(dataCenters);
                    } else {
                        dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCentersWithStorage.get(0) }));
                    }
                    storageModel.getDataCenter().setItems(dataCenters);
                    storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                }
            }), getStorage().getId());
        }
    }
}
#end_block

#method_before
void updateHost() {
    if (getDataCenter().getItems() == null) {
        return;
    }
    if (getSelectedItem() == null) {
        return;
    }
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    boolean localFsOnly = getSelectedItem() instanceof LocalStorageModel;
    Guid dataCenterId = dataCenter == null ? null : dataCenter.getId();
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            StorageModel storageModel = (StorageModel) model;
            Collection<VDS> hosts = (Collection<VDS>) returnValue;
            storageModel.postUpdateHost(hosts);
        }
    }, getHash()), dataCenterId, localFsOnly);
}
#method_after
void updateHost() {
    if (getDataCenter().getItems() == null) {
        return;
    }
    if (getSelectedItem() == null) {
        return;
    }
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    boolean localFsOnly = getSelectedItem() instanceof LocalStorageModel;
    Guid dataCenterId = dataCenter == null ? null : dataCenter.getId();
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            StorageModel storageModel = (StorageModel) model;
            Collection<VDS> hosts = (Collection<VDS>) returnValue;
            storageModel.postUpdateHost(hosts);
        }
    }), dataCenterId, localFsOnly);
}
#end_block

#method_before
void updateFormat() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getSelectedItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getSelectedItem().getRole().isDataDomain()) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.NFS || getSelectedItem().getType() == StorageType.LOCALFS) && (dataCenter.getcompatibility_version().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getcompatibility_version().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else // Unassigned DC:
        {
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangable(true);
            if (getSelectedItem().getType() != StorageType.POSIXFS && getSelectedItem().getType() != StorageType.GLUSTERFS) {
                formats.add(StorageFormatType.V1);
            }
            if ((getSelectedItem().getType() == StorageType.FCP || getSelectedItem().getType() == StorageType.ISCSI) && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#method_after
void updateFormat() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getSelectedItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getSelectedItem().getRole().isDataDomain()) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.NFS || getSelectedItem().getType() == StorageType.LOCALFS) && (dataCenter.getCompatibilityVersion().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getCompatibilityVersion().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getCompatibilityVersion().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getCompatibilityVersion().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else // Unassigned DC:
        {
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangable(true);
            if (getSelectedItem().getType() != StorageType.POSIXFS && getSelectedItem().getType() != StorageType.GLUSTERFS) {
                formats.add(StorageFormatType.V1);
            }
            if ((getSelectedItem().getType() == StorageType.FCP || getSelectedItem().getType() == StorageType.ISCSI) && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#end_block

#method_before
private void updateWipeAfterDelete() {
    StorageType storageType = getAvailableStorageItems().getSelectedItem().getType();
    if (isNewStorage()) {
        AsyncDataProvider.getInstance().getStorageDomainWipeAfterDelete(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                StorageModel storageModel = (StorageModel) model;
                storageModel.getWipeAfterDelete().setEntity((Boolean) returnValue);
            }
        }), storageType);
    } else {
        getWipeAfterDelete().setEntity(getStorage().getWipeAfterDelete());
    }
}
#method_after
private void updateWipeAfterDelete() {
    StorageType storageType = getAvailableStorageItems().getSelectedItem().getType();
    if (isNewStorage()) {
        AsyncDataProvider.getInstance().getStorageDomainDefaultWipeAfterDelete(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                StorageModel storageModel = (StorageModel) model;
                storageModel.getWipeAfterDelete().setEntity((Boolean) returnValue);
            }
        }), storageType);
    } else {
        getWipeAfterDelete().setEntity(getStorage().getWipeAfterDelete());
    }
}
#end_block

#method_before
void addStyles() {
    storageTypeListEditor.setLabelStyleName(style.label());
    storageTypeListEditor.addContentWidgetStyleName(style.storageContentWidget());
    formatListEditor.setLabelStyleName(style.label());
    formatListEditor.addContentWidgetStyleName(style.formatContentWidget());
    activateDomainEditor.addContentWidgetStyleName(style.activateDomainEditor());
    wipeAfterDeleteExpanderContent.setStyleName(style.wipeAfterDeleteExpanderContent());
}
#method_after
void addStyles() {
    storageTypeListEditor.setLabelStyleName(style.label());
    storageTypeListEditor.addContentWidgetStyleName(style.storageContentWidget());
    formatListEditor.setLabelStyleName(style.label());
    formatListEditor.addContentWidgetStyleName(style.formatContentWidget());
    activateDomainEditor.addContentWidgetStyleName(style.activateDomainEditor());
    advancedParametersExpanderContent.setStyleName(style.advancedParametersExpanderContent());
}
#end_block

#method_before
protected boolean validateCustomProperties(VmStatic vmStaticFromParams, List<String> reasons) {
    return VmPropertiesUtils.getInstance().validateVmProperties(getVdsGroup().getcompatibility_version(), vmStaticFromParams.getCustomProperties(), reasons);
}
#method_after
protected boolean validateCustomProperties(VmStatic vmStaticFromParams, List<String> reasons) {
    return VmPropertiesUtils.getInstance().validateVmProperties(getVdsGroup().getCompatibilityVersion(), vmStaticFromParams.getCustomProperties(), reasons);
}
#end_block

#method_before
@Test
public void testAllDomainsExistAndActive() {
    setUpGeneralValidations();
    setUpDiskValidations();
    doReturn(getNonEmptyDiskList()).when(cmd).getDisksList();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST)).when(multipleStorageDomainsValidator).allDomainsExistAndActive();
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.name()));
}
#method_after
@Test
public void testAllDomainsExistAndActive() {
    setUpGeneralValidations();
    setUpDiskValidations();
    doReturn(Collections.emptyList()).when(cmd).getDisksList();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST)).when(multipleStorageDomainsValidator).allDomainsExistAndActive();
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.name()));
}
#end_block

#method_before
@Test
public void testAllDomainsHaveSpaceForNewDisksFailure() {
    setUpGeneralValidations();
    setUpDiskValidations();
    List<DiskImage> disksList = getNonEmptyDiskList();
    doReturn(disksList).when(cmd).getDisksList();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
}
#method_after
@Test
public void testAllDomainsHaveSpaceForNewDisksFailure() {
    setUpGeneralValidations();
    setUpDiskValidations();
    List<DiskImage> disksList = Collections.emptyList();
    doReturn(disksList).when(cmd).getDisksList();
    doReturn(disksList).when(cmd).getDisksListForChecks();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
}
#end_block

#method_before
@Test
public void testAllDomainsHaveSpaceForNewDisksSuccess() {
    setUpGeneralValidations();
    setUpDiskValidations();
    List<DiskImage> disksList = getNonEmptyDiskList();
    doReturn(disksList).when(cmd).getDisksList();
    doReturn(ValidationResult.VALID).when(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(cmd);
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
}
#method_after
@Test
public void testAllDomainsHaveSpaceForNewDisksSuccess() {
    setUpGeneralValidations();
    setUpDiskValidations();
    List<DiskImage> disksList = Collections.emptyList();
    doReturn(disksList).when(cmd).getDisksList();
    doReturn(ValidationResult.VALID).when(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(cmd);
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
}
#end_block

#method_before
@Test
public void testAllDomainsWithinThreshold() {
    setUpGeneralValidations();
    setUpDiskValidations();
    doReturn(getNonEmptyDiskList()).when(cmd).getDisksList();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleStorageDomainsValidator).allDomainsExistAndActive();
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.name()));
}
#method_after
@Test
public void testAllDomainsWithinThreshold() {
    setUpGeneralValidations();
    setUpDiskValidations();
    doReturn(Collections.emptyList()).when(cmd).getDisksList();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleStorageDomainsValidator).allDomainsExistAndActive();
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.name()));
}
#end_block

#method_before
private static List<DiskImage> getNonEmptyDiskList() {
    List<DiskImage> diskList = new ArrayList<>();
    DiskImage newDiskImage = new DiskImage();
    diskList.add(newDiskImage);
    return diskList;
}
#method_after
private static List<DiskImage> getNonEmptyDiskList() {
    List<DiskImage> diskList = new ArrayList<>();
    DiskImage newDiskImage = new DiskImage();
    newDiskImage.setStorageIds(new ArrayList<Guid>());
    diskList.add(newDiskImage);
    return diskList;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    return validateStorageDomains();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    return validateStorage();
}
#end_block

#method_before
protected boolean validateVM(VmValidator vmValidator) {
    LiveSnapshotValidator validator = new LiveSnapshotValidator(getStoragePool().getcompatibility_version(), getVds());
    return (getVm().isDown() || validate(validator.canDoSnapshot())) && validate(vmValidator.vmNotSavingRestoring()) && validate(vmValidator.validateVmStatusUsingMatrix(VdcActionType.CreateAllSnapshotsFromVm));
}
#method_after
protected boolean validateVM(VmValidator vmValidator) {
    LiveSnapshotValidator validator = new LiveSnapshotValidator(getStoragePool().getCompatibilityVersion(), getVds());
    return (getVm().isDown() || validate(validator.canDoSnapshot())) && validate(vmValidator.vmNotSavingRestoring()) && validate(vmValidator.validateVmStatusUsingMatrix(VdcActionType.CreateAllSnapshotsFromVm));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warn("Detaching Storage Domain '{}' from it's previous storage pool '{}'" + " has failed. The meta data of the Storage Domain might still" + " indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                    createDefaultDiskProfile();
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        updateStorageDomainFormatIfNeeded(getStorageDomain());
                        registerAllOvfDisks(getAllOVFDisks());
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getCompatibilityVersion())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warn("Detaching Storage Domain '{}' from it's previous storage pool '{}'" + " has failed. The meta data of the Storage Domain might still" + " indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                    createDefaultDiskProfile();
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        updateStorageDomainFormatIfNeeded(getStorageDomain());
                        registerAllOvfDisks(getAllOVFDisks());
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
private void createDefaultDiskProfile() {
    if (FeatureSupported.storageQoS(getStoragePool().getcompatibility_version()) && getDiskProfileDao().getAllForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        final DiskProfile diskProfile = DiskProfileHelper.createDiskProfile(getStorageDomain().getId(), getStorageDomainName());
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Void runInTransaction() {
                getDiskProfileDao().save(diskProfile);
                getCompensationContext().snapshotNewEntity(diskProfile);
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
}
#method_after
private void createDefaultDiskProfile() {
    if (FeatureSupported.storageQoS(getStoragePool().getCompatibilityVersion()) && getDiskProfileDao().getAllForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        final DiskProfile diskProfile = DiskProfileHelper.createDiskProfile(getStorageDomain().getId(), getStorageDomainName());
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Void runInTransaction() {
                getDiskProfileDao().save(diskProfile);
                getCompensationContext().snapshotNewEntity(diskProfile);
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList(getAllOVFDisks());
    if (!ovfStoreDiskImages.isEmpty()) {
        if (!FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getcompatibility_version())) {
            AuditLogDirector.log(this, AuditLogType.RETRIEVE_UNREGISTERED_ENTITIES_NOT_SUPPORTED_IN_DC_VERSION);
            return Collections.emptyList();
        }
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        return OvfUtils.getOvfEntities((byte[]) vdcReturnValue.getActionReturnValue(), getParameters().getStorageDomainId());
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), getParameters().getStorageDomainId());
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), getParameters().getStorageDomainId(), e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", getParameters().getStorageDomainId());
        AuditLogDirector.log(this, AuditLogType.OVF_STORE_DOES_NOT_EXISTS);
    }
    return Collections.emptyList();
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList(getAllOVFDisks());
    if (!ovfStoreDiskImages.isEmpty()) {
        if (!FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getCompatibilityVersion())) {
            AuditLogDirector.log(this, AuditLogType.RETRIEVE_UNREGISTERED_ENTITIES_NOT_SUPPORTED_IN_DC_VERSION);
            return Collections.emptyList();
        }
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        return OvfUtils.getOvfEntities((byte[]) vdcReturnValue.getActionReturnValue(), getParameters().getStorageDomainId());
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), getParameters().getStorageDomainId());
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), getParameters().getStorageDomainId(), e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", getParameters().getStorageDomainId());
        AuditLogDirector.log(this, AuditLogType.OVF_STORE_DOES_NOT_EXISTS);
    }
    return Collections.emptyList();
}
#end_block

#method_before
protected void updateStoragePoolMasterDomainVersionInDiffTransaction() {
    executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            int master_domain_version = getStoragePoolDAO().increaseStoragePoolMasterVersion(getStoragePool().getId());
            getStoragePool().setmaster_domain_version(master_domain_version);
            return null;
        }
    });
}
#method_after
protected void updateStoragePoolMasterDomainVersionInDiffTransaction() {
    executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            int master_domain_version = getStoragePoolDAO().increaseStoragePoolMasterVersion(getStoragePool().getId());
            getStoragePool().setMasterDomainVersion(master_domain_version);
            return null;
        }
    });
}
#end_block

#method_before
protected void calcStoragePoolStatusByDomainsStatus() {
    List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    // set masterDomain to the first element of domains with type=master, or null if non have this type.
    StorageDomain masterDomain = LinqUtils.firstOrNull(domains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain a) {
            return a.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintenance : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.NonResponsive;
    if (newStatus != getStoragePool().getStatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setStatus(newStatus);
        StoragePool poolFromDb = getStoragePoolDAO().get(getStoragePool().getId());
        if ((getStoragePool().getspm_vds_id() == null && poolFromDb.getspm_vds_id() != null) || (getStoragePool().getspm_vds_id() != null && !getStoragePool().getspm_vds_id().equals(poolFromDb.getspm_vds_id()))) {
            getStoragePool().setspm_vds_id(poolFromDb.getspm_vds_id());
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setspm_vds_id(null);
        }
        executeInScope(TransactionScopeOption.Required, new TransactionMethod<StoragePool>() {

            @Override
            public StoragePool runInTransaction() {
                getStoragePoolDAO().update(getStoragePool());
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    }
}
#method_after
protected void calcStoragePoolStatusByDomainsStatus() {
    List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    // set masterDomain to the first element of domains with type=master, or null if non have this type.
    StorageDomain masterDomain = LinqUtils.firstOrNull(domains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain a) {
            return a.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintenance : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.NonResponsive;
    if (newStatus != getStoragePool().getStatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setStatus(newStatus);
        StoragePool poolFromDb = getStoragePoolDAO().get(getStoragePool().getId());
        if ((getStoragePool().getSpmVdsId() == null && poolFromDb.getSpmVdsId() != null) || (getStoragePool().getSpmVdsId() != null && !getStoragePool().getSpmVdsId().equals(poolFromDb.getSpmVdsId()))) {
            getStoragePool().setSpmVdsId(poolFromDb.getSpmVdsId());
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setSpmVdsId(null);
        }
        executeInScope(TransactionScopeOption.Required, new TransactionMethod<StoragePool>() {

            @Override
            public StoragePool runInTransaction() {
                getStoragePoolDAO().update(getStoragePool());
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    }
}
#end_block

#method_before
protected void updateStorageDomainFormatIfNeeded(StorageDomain domain) {
    final StorageDomainType sdType = domain.getStorageDomainType();
    if (sdType != StorageDomainType.Data && sdType != StorageDomainType.Master) {
        log.debug("Skipping format update for domain '{}' (type '{}')", getStorageDomain().getId(), sdType);
        return;
    }
    final StorageDomainStatic storageStaticData = domain.getStorageStaticData();
    final StorageFormatType targetFormat = getStoragePool().getStoragePoolFormatType();
    if (storageStaticData.getStorageFormat() != targetFormat) {
        log.info("Updating storage domain '{}' (type '{}') to format '{}'", getStorageDomain().getId(), sdType, targetFormat);
        storageStaticData.setStorageFormat(targetFormat);
        getStorageDomainStaticDAO().update(storageStaticData);
    } else {
        log.debug("Skipping format update for domain '{}' format is '{}'", getStorageDomain().getId(), storageStaticData.getStorageFormat());
    }
}
#method_after
protected void updateStorageDomainFormatIfNeeded(StorageDomain domain) {
    final StorageDomainType sdType = domain.getStorageDomainType();
    if (!sdType.isDataDomain()) {
        log.debug("Skipping format update for domain '{}' (type '{}')", getStorageDomain().getId(), sdType);
        return;
    }
    final StorageDomainStatic storageStaticData = domain.getStorageStaticData();
    final StorageFormatType targetFormat = getStoragePool().getStoragePoolFormatType();
    if (storageStaticData.getStorageFormat() != targetFormat) {
        log.info("Updating storage domain '{}' (type '{}') to format '{}'", getStorageDomain().getId(), sdType, targetFormat);
        storageStaticData.setStorageFormat(targetFormat);
        getStorageDomainStaticDAO().update(storageStaticData);
    } else {
        log.debug("Skipping format update for domain '{}' format is '{}'", getStorageDomain().getId(), storageStaticData.getStorageFormat());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // FIXME: check ReconstructMasterDomain canDoAction?
    boolean returnValue = checkStoragePool();
    if (returnValue) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL);
            return false;
        } else if (getStorageDomain() != null && getStorageDomain().getStatus() != null && getStorageDomain().getStatus() == StorageDomainStatus.Active) {
            addStorageDomainStatusIllegalMessage();
            returnValue = false;
        } else if (electNewMaster(false) != null) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.STORAGE_POOL_REINITIALIZE_WITH_MORE_THAN_ONE_DATA_DOMAIN.toString());
            returnValue = false;
        } else {
            StorageDomain domain = getNewMasterDomain();
            if (domain.getStorageDomainSharedStatus() != StorageDomainSharedStatus.Unattached) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                returnValue = false;
            }
        }
    }
    return returnValue && initializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = checkStoragePool();
    if (!validate(new StorageDomainValidator(getStorageDomain()).isInProcess()) || !validate(new StoragePoolValidator(getStoragePool()).isAnyDomainInProcess())) {
        return false;
    }
    if (returnValue) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL);
            return false;
        } else if (getStorageDomain() != null && getStorageDomain().getStatus() != null && getStorageDomain().getStatus() == StorageDomainStatus.Active) {
            addStorageDomainStatusIllegalMessage();
            returnValue = false;
        } else if (electNewMaster(false) != null) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.STORAGE_POOL_REINITIALIZE_WITH_MORE_THAN_ONE_DATA_DOMAIN.toString());
            returnValue = false;
        } else {
            StorageDomain domain = loadTargetedMasterDomain();
            if (domain.getStorageDomainSharedStatus() != StorageDomainSharedStatus.Unattached) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                returnValue = false;
            }
        }
    }
    return returnValue && initializeVds();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (StorageHelperDirector.getInstance().getItem(getNewMasterDomain().getStorageType()).connectStorageToDomainByVdsId(getNewMasterDomain(), getVds().getId())) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getNewMasterDomainId(), null, EventType.RECOVERY, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                getParameters().setStorageDomainId(getMasterDomainIdFromDb());
                StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
                DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
                getParameters().setVdsId(getVds().getId());
                VdcReturnValueBase returnVal = getBackend().runInternalAction(VdcActionType.ReconstructMasterDomain, getParameters());
                boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
                if (!reconstructVerbExecuted) {
                    getStoragePoolIsoMapDAO().remove(domainPoolMap.getId());
                }
                if (returnVal.getSucceeded()) {
                    updateStorageDomainFormat(getNewMasterDomain());
                }
                setSucceeded(returnVal.getSucceeded());
                return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
            }
        });
    } else {
        getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
    }
}
#method_after
@Override
protected void executeCommand() {
    StorageDomain newMasterDomain = loadTargetedMasterDomain();
    if (StorageHelperDirector.getInstance().getItem(newMasterDomain.getStorageType()).connectStorageToDomainByVdsId(newMasterDomain, getVds().getId())) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getNewMasterDomainId(), null, EventType.RECOVERY, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                getParameters().setStorageDomainId(getMasterDomainIdFromDb());
                StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
                DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
                getParameters().setVdsId(getVds().getId());
                VdcReturnValueBase returnVal = runInternalAction(VdcActionType.ReconstructMasterDomain, getParameters(), cloneContextAndDetachFromParent());
                boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
                if (!reconstructVerbExecuted) {
                    getStoragePoolIsoMapDAO().remove(domainPoolMap.getId());
                }
                if (returnVal.getSucceeded()) {
                    updateStorageDomainFormatIfNeeded(loadTargetedMasterDomain());
                }
                setSucceeded(returnVal.getSucceeded());
                return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
            }
        });
    } else {
        getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
    }
}
#end_block

#method_before
@Override
public void init(StorageQos qos) {
    if (qos.getMaxThroughput() == null && qos.getMaxReadThroughput() == null && qos.getMaxWriteThroughput() == null) {
        getThroughput().getChoiceGroupNone().setEntity(true);
        getThroughput().getChoiceGroupTotal().setEntity(false);
        getThroughput().getChoiceGroupReadWrite().setEntity(false);
    } else {
        getThroughput().getTotal().setEntity(qos.getMaxThroughput());
        getThroughput().getRead().setEntity(qos.getMaxReadThroughput());
        getThroughput().getWrite().setEntity(qos.getMaxWriteThroughput());
        getThroughput().getChoiceGroupNone().setEntity(true);
        getThroughput().getChoiceGroupTotal().setEntity(false);
        getThroughput().getChoiceGroupReadWrite().setEntity(false);
    }
    if (qos.getMaxIops() == null && qos.getMaxReadIops() == null && qos.getMaxWriteIops() == null) {
        getIops().getChoiceGroupNone().setEntity(true);
        getIops().getChoiceGroupTotal().setEntity(false);
        getIops().getChoiceGroupReadWrite().setEntity(false);
    } else {
        getIops().getTotal().setEntity(qos.getMaxIops());
        getIops().getRead().setEntity(qos.getMaxReadIops());
        getIops().getWrite().setEntity(qos.getMaxWriteIops());
        getIops().getChoiceGroupNone().setEntity(true);
        getIops().getChoiceGroupTotal().setEntity(false);
        getIops().getChoiceGroupReadWrite().setEntity(false);
    }
}
#method_after
@Override
public void init(StorageQos qos) {
    initStorageParameterModel(qos.getMaxThroughput(), qos.getMaxReadThroughput(), qos.getMaxWriteThroughput(), getThroughput());
    initStorageParameterModel(qos.getMaxIops(), qos.getMaxReadIops(), qos.getMaxWriteIops(), getIops());
}
#end_block

#method_before
@Override
public void flush(StorageQos storageQos) {
    if (getThroughput().getChoiceGroupTotal().getEntity()) {
        storageQos.setMaxThroughput(getThroughput().getTotal().getEntity());
    } else if (getThroughput().getChoiceGroupReadWrite().getEntity()) {
        storageQos.setMaxReadThroughput(getThroughput().getRead().getEntity());
        storageQos.setMaxWriteThroughput(getThroughput().getWrite().getEntity());
    } else {
        storageQos.setMaxThroughput(null);
        storageQos.setMaxReadThroughput(null);
        storageQos.setMaxWriteThroughput(null);
    }
    if (getIops().getChoiceGroupTotal().getEntity()) {
        storageQos.setMaxIops(getIops().getTotal().getEntity());
    } else if (getIops().getChoiceGroupReadWrite().getEntity()) {
        storageQos.setMaxReadIops(getIops().getRead().getEntity());
        storageQos.setMaxWriteIops(getIops().getWrite().getEntity());
    } else {
        storageQos.setMaxIops(null);
        storageQos.setMaxReadIops(null);
        storageQos.setMaxWriteIops(null);
    }
}
#method_after
@Override
public void flush(StorageQos storageQos) {
    storageQos.setMaxThroughput(null);
    storageQos.setMaxReadThroughput(null);
    storageQos.setMaxWriteThroughput(null);
    if (getThroughput().getChoiceGroupTotal().getEntity()) {
        storageQos.setMaxThroughput(getThroughput().getTotal().getEntity());
    } else if (getThroughput().getChoiceGroupReadWrite().getEntity()) {
        storageQos.setMaxReadThroughput(getThroughput().getRead().getEntity());
        storageQos.setMaxWriteThroughput(getThroughput().getWrite().getEntity());
    }
    storageQos.setMaxIops(null);
    storageQos.setMaxReadIops(null);
    storageQos.setMaxWriteIops(null);
    if (getIops().getChoiceGroupTotal().getEntity()) {
        storageQos.setMaxIops(getIops().getTotal().getEntity());
    } else if (getIops().getChoiceGroupReadWrite().getEntity()) {
        storageQos.setMaxReadIops(getIops().getRead().getEntity());
        storageQos.setMaxWriteIops(getIops().getWrite().getEntity());
    }
}
#end_block

#method_before
public boolean validate() {
    if (getChoiceGroupNone().getEntity() && !getChoiceGroupTotal().getEntity() && !getChoiceGroupReadWrite().getEntity()) {
        return true;
    }
    validateValue(getTotal(), (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxTotal));
    validateValue(getRead(), (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxRead));
    validateValue(getWrite(), (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxWrite));
    if (getTotal().getEntity() != null && (getRead().getEntity() != null || getWrite().getEntity() != null)) {
        setErrorMsg(getTotal());
        setErrorMsg(getRead());
        setErrorMsg(getWrite());
    }
    setIsValid(getTotal().getIsValid() && getRead().getIsValid() && getWrite().getIsValid());
    return getIsValid();
}
#method_after
public boolean validate() {
    if (getChoiceGroupNone().getEntity()) {
        return true;
    }
    validateValue(getTotal(), (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxTotal));
    validateValue(getRead(), (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxRead));
    validateValue(getWrite(), (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxWrite));
    if (getTotal().getEntity() != null && (getRead().getEntity() != null || getWrite().getEntity() != null)) {
        setErrorMsg(getTotal());
        setErrorMsg(getRead());
        setErrorMsg(getWrite());
    }
    setIsValid(getTotal().getIsValid() && getRead().getIsValid() && getWrite().getIsValid());
    return getIsValid();
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (this.equals(sender)) {
        getChoiceGroupNone().setIsChangable(getIsChangable());
        getChoiceGroupTotal().setIsChangable(getIsChangable());
        getChoiceGroupReadWrite().setIsChangable(getIsChangable());
    } else if (((EntityModel) sender).getEntity() == Boolean.TRUE) {
        if (!getChoiceGroupNone().equals(sender)) {
            getChoiceGroupNone().setEntity(false);
        }
        if (!getChoiceGroupTotal().equals(sender)) {
            getChoiceGroupTotal().setEntity(false);
            getTotal().setEntity(null);
        }
        if (!getChoiceGroupReadWrite().equals(sender)) {
            getChoiceGroupReadWrite().setEntity(false);
            getRead().setEntity(null);
            getWrite().setEntity(null);
        }
        updateChangeability();
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (this.equals(sender)) {
        getChoiceGroupNone().setIsChangable(getIsChangable());
        getChoiceGroupTotal().setIsChangable(getIsChangable());
        getChoiceGroupReadWrite().setIsChangable(getIsChangable());
    } else if ((sender instanceof EntityModel) && (Boolean.TRUE.equals(((EntityModel) sender).getEntity()))) {
        if (!getChoiceGroupNone().equals(sender)) {
            getChoiceGroupNone().setEntity(false);
        }
        if (!getChoiceGroupTotal().equals(sender)) {
            getChoiceGroupTotal().setEntity(false);
            getTotal().setEntity(null);
        }
        if (!getChoiceGroupReadWrite().equals(sender)) {
            getChoiceGroupReadWrite().setEntity(false);
            getRead().setEntity(null);
            getWrite().setEntity(null);
        }
        updateChangeability();
    }
}
#end_block

#method_before
private void initTable(final ApplicationTemplates templates, ApplicationConstants constants, CommonApplicationConstants commonConstants) {
    getTable().enableColumnResizing();
    final String elementIdPrefix = getTable().getContentTableElementId();
    getTable().addColumn(new VmImageColumn<VmTemplate>(new OsTypeExtractor<VmTemplate>() {

        @Override
        public int extractOsType(VmTemplate item) {
            return item.getOsId();
        }
    }), "", // $NON-NLS-1$ //$NON-NLS-2$
    "77px");
    Cell<VmTemplate> nameCell = new AbstractCell<VmTemplate>() {

        @Override
        public void render(Context context, VmTemplate template, SafeHtmlBuilder sb) {
            sb.append(templates.vmNameCellItem(// $NON-NLS-1$
            ElementIdUtils.createTableCellElementId(elementIdPrefix, "name", context), template.getName()));
        }
    };
    Column<VmTemplate, VmTemplate> nameColumn = new Column<VmTemplate, VmTemplate>(nameCell) {

        @Override
        public VmTemplate getValue(VmTemplate template) {
            return template;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, commonConstants.templateName(), "22em");
    final TextCellWithTooltip subversionNumberCell = new TextCellWithTooltip(TextCellWithTooltip.UNLIMITED_LENGTH);
    final TextColumnWithTooltip<VmTemplate> subversionNumberColumn = new TextColumnWithTooltip<VmTemplate>(subversionNumberCell) {

        @Override
        public String getValue(VmTemplate template) {
            // $NON-NLS-1$ //$NON-NLS-2$;
            return "(" + template.getTemplateVersionNumber() + ")";
        }
    };
    // $NON-NLS-1$
    table.addColumn(subversionNumberColumn, commonConstants.templateVersion(), "9em");
    final TextCellWithTooltip subversionNameCell = new TextCellWithTooltip(TextCellWithTooltip.UNLIMITED_LENGTH);
    final TextColumnWithTooltip subversionNameColumn = new TextColumnWithTooltip<VmTemplate>(subversionNameCell) {

        @Override
        public String getValue(VmTemplate template) {
            return template.getTemplateVersionName() != null && !template.getTemplateVersionName().isEmpty() ? template.getTemplateVersionName() : "";
        }
    };
    // $NON-NLS-1$
    table.addColumn(subversionNameColumn, commonConstants.templateVersionName(), "22em");
    final TextCellWithTooltip descriptionCell = new TextCellWithTooltip(TextCellWithTooltip.UNLIMITED_LENGTH);
    final TextColumnWithTooltip descriptionColumn = new TextColumnWithTooltip<VmTemplate>(descriptionCell) {

        @Override
        public String getValue(VmTemplate template) {
            return template.getDescription() != null && !template.getDescription().isEmpty() ? template.getDescription() : "";
        }
    };
    table.addColumn(descriptionColumn, commonConstants.templateDescription());
    getTable().addActionButton(new UserPortalButtonDefinition<VmTemplate>(constants.editTemplate()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getEditCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<VmTemplate>(constants.removeTemplate()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
}
#method_after
private void initTable(final ApplicationTemplates templates, ApplicationConstants constants, CommonApplicationConstants commonConstants) {
    getTable().enableColumnResizing();
    final String elementIdPrefix = getTable().getContentTableElementId();
    getTable().addColumn(new VmImageColumn<VmTemplate>(new OsTypeExtractor<VmTemplate>() {

        @Override
        public int extractOsType(VmTemplate item) {
            return item.getOsId();
        }
    }), "", // $NON-NLS-1$ //$NON-NLS-2$
    "77px");
    Cell<VmTemplate> nameCell = new AbstractCell<VmTemplate>() {

        @Override
        public void render(Context context, VmTemplate template, SafeHtmlBuilder sb) {
            sb.append(templates.vmNameCellItem(// $NON-NLS-1$
            ElementIdUtils.createTableCellElementId(elementIdPrefix, "name", context), template.getName()));
        }
    };
    Column<VmTemplate, VmTemplate> nameColumn = new Column<VmTemplate, VmTemplate>(nameCell) {

        @Override
        public VmTemplate getValue(VmTemplate template) {
            return template;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, commonConstants.templateName(), "350px");
    final TextCellWithTooltip subversionNumberCell = new TextCellWithTooltip(TextCellWithTooltip.UNLIMITED_LENGTH);
    final TextColumnWithTooltip<VmTemplate> subversionNumberColumn = new TextColumnWithTooltip<VmTemplate>(subversionNumberCell) {

        @Override
        public String getValue(VmTemplate template) {
            // $NON-NLS-1$ //$NON-NLS-2$;
            return "(" + template.getTemplateVersionNumber() + ")";
        }
    };
    // $NON-NLS-1$
    table.addColumn(subversionNumberColumn, commonConstants.templateVersion(), "140px");
    final TextCellWithTooltip subversionNameCell = new TextCellWithTooltip(TextCellWithTooltip.UNLIMITED_LENGTH);
    final TextColumnWithTooltip subversionNameColumn = new TextColumnWithTooltip<VmTemplate>(subversionNameCell) {

        @Override
        public String getValue(VmTemplate template) {
            return template.getTemplateVersionName() != null && !template.getTemplateVersionName().isEmpty() ? template.getTemplateVersionName() : "";
        }
    };
    // $NON-NLS-1$
    table.addColumn(subversionNameColumn, commonConstants.templateVersionName(), "350px");
    final TextCellWithTooltip descriptionCell = new TextCellWithTooltip(TextCellWithTooltip.UNLIMITED_LENGTH);
    final TextColumnWithTooltip descriptionColumn = new TextColumnWithTooltip<VmTemplate>(descriptionCell) {

        @Override
        public String getValue(VmTemplate template) {
            return template.getDescription() != null && !template.getDescription().isEmpty() ? template.getDescription() : "";
        }
    };
    table.addColumn(descriptionColumn, commonConstants.templateDescription());
    getTable().addActionButton(new UserPortalButtonDefinition<VmTemplate>(constants.editTemplate()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getEditCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<VmTemplate>(constants.removeTemplate()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeGeoRepPauseFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterHostIsNotPartOfCluster:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
        case GlusterLibgfapiException:
        case GlfsStatvfsException:
        case GlfsInitException:
        case GlfsFiniException:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeGeoRepStartFailedException:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeGeoRepPauseFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterHostIsNotPartOfCluster:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeGeoRepResumeFailed:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
        case GlusterVolumeGeoRepStatusFailed:
        case GlusterVolumeGeoRepStatusDetailFailed:
        case GlusterLibgfapiException:
        case GlfsStatvfsException:
        case GlfsInitException:
        case GlfsFiniException:
        case GlusterGeoRepSessionDeleteFailedException:
        case GlusterVolumeGeoRepStopFailedException:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
public void close() {
    this.client.close();
}
#method_after
@Override
public void close() {
    XmlRpcUtils.shutDownConnection(this.httpClient);
    this.client.close();
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("status");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            updateHeartbeatPolicy(false);
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                updateHeartbeatPolicy(true);
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    RequestBuilder rb = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options);
    if (fencingPolicy != null) {
        // if fencing policy is null, fence proxy does not support fencing policy parameter
        rb.withParameter("fencingPolicy", fencingPolicy);
    }
    return new FenceStatusReturnForXmlRpc(new FutureMap(this.client, rb.build()));
}
#method_after
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("policy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new FenceStatusReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createStorageDomain(int domainType, String sdUUID, String domainName, String arg, int storageType, String storageFormatType) {
    // storageFormatType not used and it can be removed from interface
    JsonRpcRequest request = new RequestBuilder("StorageDomain.create").withParameter("storagedomainID", sdUUID).withParameter("domainType", domainType).withParameter("typeArgs", arg).withParameter("name", domainName).withParameter("domainClass", storageType).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc createStorageDomain(int domainType, String sdUUID, String domainName, String arg, int storageType, String storageFormatType) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.create").withParameter("storagedomainID", sdUUID).withParameter("domainType", domainType).withParameter("typeArgs", arg).withParameter("name", domainName).withParameter("domainClass", storageType).withOptionalParameter("version", storageFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String spUUID, int domainType, int poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturnForXmlRpc(response);
}
#method_after
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String spUUID, int domainType, String poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public DevicesVisibilityMapReturnForXmlRpc getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<String>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visibles");
    return new DevicesVisibilityMapReturnForXmlRpc(response);
}
#method_after
@Override
public DevicesVisibilityMapReturnForXmlRpc getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<String>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visible");
    return new DevicesVisibilityMapReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> poll() {
    final JsonRpcRequest request = new RequestBuilder("Host.ping").build();
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request);
        }
    });
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@Override
public FutureTask<Map<String, Object>> poll() {
    return timeBoundPoll(0, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepPause(String masterVolumeName, String slaveHost, String slaveVolumeName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepPause(String masterVolumeName, String slaveHost, String slaveVolumeName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("vmID", (String) params.get("vmId")).withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
public HttpClient getHttpClient() {
    return httpClient;
}
#method_after
@Override
public HttpClient getHttpClient() {
    return httpClient;
}
#end_block

#method_before
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String sdUUID, int domainType, int poolType, String path) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getStorageDomainsList(sdUUID, domainType, poolType, path);
        StorageDomainListReturnForXmlRpc wrapper = new StorageDomainListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String sdUUID, int domainType, String poolType, String path) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getStorageDomainsList(sdUUID, domainType, poolType, path);
        StorageDomainListReturnForXmlRpc wrapper = new StorageDomainListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
public void close() {
    this.client.close();
}
#method_after
@Override
public void close() {
    XmlRpcUtils.shutDownConnection(this.httpClient);
    this.client.close();
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("status");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#end_block

#method_before
private void updateHeartbeatPolicy(boolean isheartbeat) {
    RetryPolicy policy = client.getRetryPolicy();
    policy.setHeartbeat(isheartbeat);
    client.setRetryPolicy(policy);
}
#method_after
private void updateHeartbeatPolicy(boolean isheartbeat) {
    RetryPolicy policy = client.getClientRetryPolicy();
    policy.setHeartbeat(isheartbeat);
    client.setClientRetryPolicy(policy);
}
#end_block

#method_before
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("fencingPolicy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("power").withResponseType(String.class);
    return new FenceStatusReturnForXmlRpc(response);
}
#method_after
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("policy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new FenceStatusReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String spUUID, int domainType, int poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturnForXmlRpc(response);
}
#method_after
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String spUUID, int domainType, String poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public DevicesVisibilityMapReturnForXmlRpc getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<String>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visibles");
    return new DevicesVisibilityMapReturnForXmlRpc(response);
}
#method_after
@Override
public DevicesVisibilityMapReturnForXmlRpc getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<String>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visible");
    return new DevicesVisibilityMapReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> poll() {
    final JsonRpcRequest request = new RequestBuilder("Host.ping").build();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request);
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            return callable.isDone();
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@Override
public FutureTask<Map<String, Object>> poll() {
    return timeBoundPoll(0, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("vmID", (String) params.get("vmId")).withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterHostIsNotPartOfCluster:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeGeoRepResumeFailed:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
        case GlusterLibgfapiException:
        case GlfsStatvfsException:
        case GlfsInitException:
        case GlfsFiniException:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeGeoRepStartFailedException:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterHostIsNotPartOfCluster:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeGeoRepResumeFailed:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
        case GlusterVolumeGeoRepStatusFailed:
        case GlusterVolumeGeoRepStatusDetailFailed:
        case GlusterLibgfapiException:
        case GlfsStatvfsException:
        case GlfsInitException:
        case GlfsFiniException:
        case GlusterGeoRepSessionDeleteFailedException:
        case GlusterVolumeGeoRepStopFailedException:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String sdUUID, int domainType, int poolType, String path) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getStorageDomainsList(sdUUID, domainType, poolType, path);
        StorageDomainListReturnForXmlRpc wrapper = new StorageDomainListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String sdUUID, int domainType, String poolType, String path) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getStorageDomainsList(sdUUID, domainType, poolType, path);
        StorageDomainListReturnForXmlRpc wrapper = new StorageDomainListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getDbFacade().getStorageServerConnectionDao().getStorageConnectionsByStorageTypeAndStatus(getParameters().getId(), getParameters().getStorageType(), EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Inactive, StorageDomainStatus.Unknown, StorageDomainStatus.Maintenance, StorageDomainStatus.PreparingForMaintenance)));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getDbFacade().getStorageServerConnectionDao().getStorageConnectionsByStorageTypeAndStatus(getParameters().getId(), getParameters().getStorageType(), EnumSet.allOf(StorageDomainStatus.class)));
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    Map<DiskImage, Guid> map = new HashMap<>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        map.put(diskImage, diskImage.getStorageIds().get(0));
    }
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version(), getCurrentUser()));
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    Map<DiskImage, Guid> map = new HashMap<>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        map.put(diskImage, diskImage.getStorageIds().get(0));
    }
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    setStoragePoolId(getVm().getStoragePoolId());
    LiveSnapshotValidator validator = new LiveSnapshotValidator(getStoragePool().getcompatibility_version(), getVds());
    if (!validate(validator.canDoSnapshot())) {
        return false;
    }
    if (!isValidParametersList() || !checkImagesStatus() || !validateSpaceRequirements() || !performVmRelatedChecks()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        getReturnValue().setCanDoAction(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getTargetStorageDomainId()) && performStorageDomainsChecks(parameters) && isSameSourceAndDest(parameters));
        if (!getReturnValue().getCanDoAction()) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    setStoragePoolId(getVm().getStoragePoolId());
    LiveSnapshotValidator validator = new LiveSnapshotValidator(getStoragePool().getCompatibilityVersion(), getVds());
    if (!validate(validator.canDoSnapshot())) {
        return false;
    }
    if (!isValidParametersList() || !checkImagesStatus() || !validateSpaceRequirements() || !performVmRelatedChecks()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        getReturnValue().setCanDoAction(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getTargetStorageDomainId()) && performStorageDomainsChecks(parameters) && isSameSourceAndDest(parameters));
        if (!getReturnValue().getCanDoAction()) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#end_block

#method_before
public static ValidationResult setAndValidateDiskProfiles(Map<DiskImage, Guid> map, Version version, DbUser user) {
    if (map == null || !FeatureSupported.storageQoS(version)) {
        return ValidationResult.VALID;
    }
    Map<Guid, List<DiskProfile>> storageDiskProfilesMap = new HashMap<>();
    Set<Guid> permittedDiskProfilesIds = new HashSet<>();
    for (Entry<DiskImage, Guid> entry : map.entrySet()) {
        DiskImage diskImage = entry.getKey();
        Guid storageDomainId = entry.getValue();
        if (diskImage.getDiskProfileId() == null && storageDomainId != null) {
            List<DiskProfile> diskProfilesList = storageDiskProfilesMap.get(storageDomainId);
            if (diskProfilesList == null) {
                diskProfilesList = getDiskProfileDao().getAllForStorageDomain(storageDomainId);
                storageDiskProfilesMap.put(storageDomainId, diskProfilesList);
            }
            // Set Disk Profile according to permissions
            if (!updateDiskProfileForBackwardCompatibility(diskImage, diskProfilesList, permittedDiskProfilesIds, user)) {
                return new ValidationResult(VdcBllMessages.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        } else {
            DiskProfile diskProfile = getDiskProfileDao().get(diskImage.getDiskProfileId());
            ValidationResult result = new DiskProfileValidator(diskProfile).isParentEntityValid(storageDomainId);
            if (result != ValidationResult.VALID) {
                return result;
            }
            if (!diskProfilePermitted(diskProfile, permittedDiskProfilesIds, user)) {
                return new ValidationResult(VdcBllMessages.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
public static ValidationResult setAndValidateDiskProfiles(Map<DiskImage, Guid> map, Version version, DbUser user) {
    if (map == null || !FeatureSupported.storageQoS(version)) {
        return ValidationResult.VALID;
    }
    Map<Guid, List<DiskProfile>> storageDiskProfilesMap = new HashMap<>();
    // caching disk profile ids that was already checked.
    Set<Guid> permittedDiskProfilesIds = new HashSet<>();
    for (Entry<DiskImage, Guid> entry : map.entrySet()) {
        DiskImage diskImage = entry.getKey();
        Guid storageDomainId = entry.getValue();
        if (diskImage.getDiskProfileId() == null && storageDomainId != null) {
            List<DiskProfile> diskProfilesList = storageDiskProfilesMap.get(storageDomainId);
            if (diskProfilesList == null) {
                diskProfilesList = getDiskProfileDao().getAllForStorageDomain(storageDomainId);
                storageDiskProfilesMap.put(storageDomainId, diskProfilesList);
            }
            // Set Disk Profile according to permissions
            if (!updateDiskProfileForBackwardCompatibility(diskImage, diskProfilesList, permittedDiskProfilesIds, user)) {
                return new ValidationResult(VdcBllMessages.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        } else {
            DiskProfile diskProfile = getDiskProfileDao().get(diskImage.getDiskProfileId());
            ValidationResult result = new DiskProfileValidator(diskProfile).isParentEntityValid(storageDomainId);
            if (result != ValidationResult.VALID) {
                return result;
            }
            if (!isDiskProfilePermitted(diskProfile, permittedDiskProfilesIds, user)) {
                return new ValidationResult(VdcBllMessages.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private static boolean updateDiskProfileForBackwardCompatibility(DiskImage diskImage, List<DiskProfile> diskProfilesList, Set<Guid> permittedDiskProfilesIds, DbUser user) {
    if (diskProfilesList.isEmpty()) {
        return false;
    }
    for (DiskProfile diskProfile : diskProfilesList) {
        if (diskProfilePermitted(diskProfile, permittedDiskProfilesIds, user)) {
            permittedDiskProfilesIds.add(diskProfile.getId());
            diskImage.setDiskProfileId(diskProfile.getId());
            return true;
        }
    }
    return false;
}
#method_after
private static boolean updateDiskProfileForBackwardCompatibility(DiskImage diskImage, List<DiskProfile> diskProfilesList, Set<Guid> permittedDiskProfilesIds, DbUser user) {
    for (DiskProfile diskProfile : diskProfilesList) {
        if (isDiskProfilePermitted(diskProfile, permittedDiskProfilesIds, user)) {
            permittedDiskProfilesIds.add(diskProfile.getId());
            diskImage.setDiskProfileId(diskProfile.getId());
            return true;
        }
    }
    return false;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version(), getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVm().getDiskMap() != null) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (Disk disk : getParameters().getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                map.put(diskImage, imageToDestinationDomainMap.get(diskImage.getId()));
            }
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version(), getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVm().getDiskMap() != null) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (Disk disk : getParameters().getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                map.put(diskImage, imageToDestinationDomainMap.get(diskImage.getId()));
            }
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVmTemplate().getDiskList() != null) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
            map.put(diskImage, imageToDestinationDomainMap.get(diskImage.getId()));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version(), getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVmTemplate().getDiskList() != null) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
            map.put(diskImage, imageToDestinationDomainMap.get(diskImage.getId()));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(Collections.singletonMap(getParameters().getDiskImage(), getStorageDomainId()), getStoragePool().getcompatibility_version(), getCurrentUser()));
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(Collections.singletonMap(getParameters().getDiskImage(), getStorageDomainId()), getStoragePool().getCompatibilityVersion(), getCurrentUser()));
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    getImage().setDiskProfileId(getParameters().getDiskProfileId());
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(Collections.singletonMap(getImage(), getParameters().getStorageDomainId()), getStoragePool().getcompatibility_version(), getCurrentUser()));
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    getImage().setDiskProfileId(getParameters().getDiskProfileId());
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(Collections.singletonMap(getImage(), getParameters().getStorageDomainId()), getStoragePool().getCompatibilityVersion(), getCurrentUser()));
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version(), getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
private boolean canAddShareableDisk() {
    if (getParameters().getDiskInfo().isShareable()) {
        if (!Config.<Boolean>getValue(ConfigValues.ShareableDiskEnabled, getStoragePool().getcompatibility_version().getValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        } else if (!isVolumeFormatSupportedForShareable(((DiskImage) getParameters().getDiskInfo()).getVolumeFormat())) {
            return failCanDoAction(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    }
    return true;
}
#method_after
private boolean canAddShareableDisk() {
    if (getParameters().getDiskInfo().isShareable()) {
        if (!Config.<Boolean>getValue(ConfigValues.ShareableDiskEnabled, getStoragePool().getCompatibilityVersion().getValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        } else if (!isVolumeFormatSupportedForShareable(((DiskImage) getParameters().getDiskInfo()).getVolumeFormat())) {
            return failCanDoAction(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(Collections.singletonMap(getDiskImageInfo(), getStorageDomainId()), getStoragePool().getcompatibility_version(), getCurrentUser()));
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(Collections.singletonMap(getDiskImageInfo(), getStorageDomainId()), getStoragePool().getCompatibilityVersion(), getCurrentUser()));
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version(), getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
private boolean validateCanUpdateShareable() {
    if (DiskStorageType.LUN == getOldDisk().getDiskStorageType()) {
        return true;
    }
    // Check if VM is not during snapshot.
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (isUpdatedToShareable(getOldDisk(), getNewDisk())) {
        StorageDomainStatic sds = getStorageDomainStaticDAO().get(((DiskImage) getNewDisk()).getStorageIds().get(0));
        if (sds.getStorageType() == StorageType.GLUSTERFS) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
        }
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(getOldDisk().getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) getOldDisk()).getImageTemplateId())) {
            return failCanDoAction(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
        }
        if (!isVersionSupportedForShareable(getOldDisk(), getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        }
        if (!isVolumeFormatSupportedForShareable(((DiskImage) getNewDisk()).getVolumeFormat())) {
            return failCanDoAction(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    } else if (isUpdatedToNonShareable(getOldDisk(), getNewDisk())) {
        if (vmsDiskOrSnapshotAttachedTo.size() > 1) {
            return failCanDoAction(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
        }
    }
    return true;
}
#method_after
private boolean validateCanUpdateShareable() {
    if (DiskStorageType.LUN == getOldDisk().getDiskStorageType()) {
        return true;
    }
    // Check if VM is not during snapshot.
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (isUpdatedToShareable(getOldDisk(), getNewDisk())) {
        StorageDomainStatic sds = getStorageDomainStaticDAO().get(((DiskImage) getNewDisk()).getStorageIds().get(0));
        if (sds.getStorageType() == StorageType.GLUSTERFS) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
        }
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(getOldDisk().getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) getOldDisk()).getImageTemplateId())) {
            return failCanDoAction(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
        }
        if (!isVersionSupportedForShareable(getOldDisk(), getStoragePoolDAO().get(getVm().getStoragePoolId()).getCompatibilityVersion().getValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        }
        if (!isVolumeFormatSupportedForShareable(((DiskImage) getNewDisk()).getVolumeFormat())) {
            return failCanDoAction(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    } else if (isUpdatedToNonShareable(getOldDisk(), getNewDisk())) {
        if (vmsDiskOrSnapshotAttachedTo.size() > 1) {
            return failCanDoAction(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (isDiskImage()) {
        DiskImage diskImage = (DiskImage) getNewDisk();
        // when disk profile isn't updated, skip check.
        if (diskImage.getDiskProfileId() != null && diskImage.getDiskProfileId().equals(((DiskImage) getOldDisk()).getDiskProfileId())) {
            return true;
        }
        Map<DiskImage, Guid> map = new HashMap<>();
        map.put(diskImage, diskImage.getStorageIds().get(0));
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version(), getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (isDiskImage()) {
        DiskImage diskImage = (DiskImage) getNewDisk();
        // when disk profile isn't updated, skip check.
        if (diskImage.getDiskProfileId() != null && diskImage.getDiskProfileId().equals(((DiskImage) getOldDisk()).getDiskProfileId())) {
            return true;
        }
        Map<DiskImage, Guid> map = new HashMap<>();
        map.put(diskImage, diskImage.getStorageIds().get(0));
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    log.info("Power-Management: " + getAction() + " of Host " + getVdsName() + " initiated.");
    audit(AuditLogType.FENCE_OPERATION_STARTED);
    VDSStatus lastStatus = getVds().getStatus();
    VDSFenceReturnValue result = null;
    try {
        setup();
        result = fence();
        handleResult(result);
        if (getSucceeded()) {
            log.info("Power-Management: " + getAction() + " Host " + getVdsName() + " succeeded.");
            audit(AuditLogType.FENCE_OPERATION_SUCCEEDED);
        } else {
            log.info("Power-Management: " + getAction() + " Host " + getVdsName() + " failed.");
            audit(AuditLogType.FENCE_OPERATION_FAILED);
        }
    } finally {
        if (!getSucceeded()) {
            setStatus(lastStatus);
            if (!wasSkippedDueToPolicy(result)) {
                // show alert only if command was not skipped due to fencing policy
                alertIfPowerManagementOperationFailed();
            }
            throw new VdcBLLException(VdcBllErrors.VDS_FENCE_OPERATION_FAILED);
        } else {
            teardown();
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    log.info("Power-Management: {} of host '{}' initiated.", getAction(), getVdsName());
    audit(AuditLogType.FENCE_OPERATION_STARTED);
    VDSStatus lastStatus = getVds().getStatus();
    VDSFenceReturnValue result = null;
    try {
        setup();
        result = fence();
        handleResult(result);
        if (getSucceeded()) {
            log.info("Power-Management: {} host '{}' succeeded.", getAction(), getVdsName());
            audit(AuditLogType.FENCE_OPERATION_SUCCEEDED);
        } else {
            log.info("Power-Management: {} host '{}' failed.", getAction(), getVdsName());
            audit(AuditLogType.FENCE_OPERATION_FAILED);
        }
    } finally {
        if (!getSucceeded()) {
            setStatus(lastStatus);
            if (!wasSkippedDueToPolicy(result)) {
                // show alert only if command was not skipped due to fencing policy
                alertIfPowerManagementOperationFailed();
            }
            throw new VdcBLLException(VdcBllErrors.VDS_FENCE_OPERATION_FAILED);
        } else {
            teardown();
        }
    }
}
#end_block

#method_before
private VDSFenceReturnValue fence(FenceAgent fenceAgent, int retries) {
    FenceExecutor fenceExecutor = createFenceExecutor();
    VDSFenceReturnValue fenceExecutionResult = fenceExecutor.fence(getAction(), fenceAgent);
    if (wasSkippedDueToStatus(fenceExecutionResult)) {
        log.info("Attemp to {} VDS using fence agent{} skipped: Host is already at the requested state.", getAction().name().toLowerCase(), fenceAgent.getId());
    } else if (wasSkippedDueToPolicy(fenceExecutionResult)) {
        // fencing execution was skipped due to fencing policy
        return fenceExecutionResult;
    } else {
        if (fenceExecutionResult.getSucceeded()) {
            boolean requiredStatusAchieved = waitForStatus();
            int i = 0;
            while (!requiredStatusAchieved && i < retries) {
                fenceExecutionResult = fenceExecutor.fence(getAction(), fenceAgent);
                requiredStatusAchieved = waitForStatus();
                i++;
            }
            if (requiredStatusAchieved) {
                handleSpecificCommandActions();
            } else {
                auditFailure();
            }
            fenceExecutionResult.setSucceeded(requiredStatusAchieved);
        } else {
            logAgentFailure(fenceExecutionResult);
        }
    }
    return fenceExecutionResult;
}
#method_after
private VDSFenceReturnValue fence(FenceAgent fenceAgent, int retries) {
    FenceExecutor fenceExecutor = createFenceExecutor();
    VDSFenceReturnValue fenceExecutionResult = fenceExecutor.fence(getAction(), fenceAgent);
    if (wasSkippedDueToStatus(fenceExecutionResult)) {
        log.info("Attemp to {} host using fence agent '{}' skipped, host is already at the requested state.", getAction().name().toLowerCase(), fenceAgent.getId());
    } else if (wasSkippedDueToPolicy(fenceExecutionResult)) {
        // fencing execution was skipped due to fencing policy
        return fenceExecutionResult;
    } else {
        if (fenceExecutionResult.getSucceeded()) {
            boolean requiredStatusAchieved = waitForStatus();
            int i = 0;
            while (!requiredStatusAchieved && i < retries) {
                fenceExecutionResult = fenceExecutor.fence(getAction(), fenceAgent);
                requiredStatusAchieved = waitForStatus();
                i++;
            }
            if (requiredStatusAchieved) {
                handleSpecificCommandActions();
            } else {
                auditFailure();
            }
            fenceExecutionResult.setSucceeded(requiredStatusAchieved);
        } else {
            logAgentFailure(fenceExecutionResult);
        }
    }
    return fenceExecutionResult;
}
#end_block

#method_before
private void logAgentFailure(final VDSFenceReturnValue result) {
    if (!wasSkippedDueToPolicy(result)) {
        log.error("Failed to {} VDS using fence agent {} (if other agents are running, {} may still succeed).", getAction().name().toLowerCase(), result.getFenceAgentUsed().getId() == null ? "New Agent (no ID)" : result.getFenceAgentUsed().getId(), getAction().name().toLowerCase());
    }
}
#method_after
private void logAgentFailure(final VDSFenceReturnValue result) {
    if (!wasSkippedDueToPolicy(result)) {
        log.error("Failed to {} host using fence agent {} (if other agents are running, {} may still succeed).", getAction().name().toLowerCase(), result.getFenceAgentUsed().getId() == null ? "New Agent (no ID)" : result.getFenceAgentUsed().getId(), getAction().name().toLowerCase());
    }
}
#end_block

#method_before
protected boolean waitForStatus() {
    FenceExecutor executor = createFenceExecutor();
    int i = 1;
    int j = 1;
    boolean requiredStatusReached = false;
    String requiredStatus = getRequiredStatus();
    String hostName = getVds().getName();
    log.info("Waiting for vds {} to reach status {}", hostName, requiredStatus);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(SLEEP_BEFORE_FIRST_ATTEMPT);
    int retries = getWaitForStatusRerties();
    while (!requiredStatusReached && i <= retries) {
        log.info("Attempt {} to get vds {} status", i, hostName);
        VDSFenceReturnValue returnValue = executor.checkStatus();
        if (returnValue != null && returnValue.getSucceeded()) {
            String status = ((FenceStatusReturnValue) returnValue.getReturnValue()).getStatus();
            if (status.equalsIgnoreCase(VDSM_STATUS_UNKONWN)) {
                // Allow command to fail temporarily
                if (j <= UNKNOWN_RESULT_ALLOWED && i <= retries) {
                    ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    i++;
                    j++;
                } else {
                    // No need to retry , agent definitions are corrupted
                    log.error("Host {} PM Agent definitions are corrupted, aborting fence operation.", hostName);
                    break;
                }
            } else {
                if (requiredStatus.equalsIgnoreCase(status)) {
                    requiredStatusReached = true;
                    log.info("vds {} status is {}", hostName, requiredStatus);
                } else {
                    i++;
                    if (i <= retries) {
                        ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    }
                }
            }
        } else {
            log.error("Failed to get host {} status.", hostName);
            break;
        }
    }
    return requiredStatusReached;
}
#method_after
protected boolean waitForStatus() {
    FenceExecutor executor = createFenceExecutor();
    int i = 1;
    int j = 1;
    boolean requiredStatusReached = false;
    String requiredStatus = getRequiredStatus();
    String hostName = getVds().getName();
    log.info("Waiting for host '{}' to reach status '{}'", hostName, requiredStatus);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(SLEEP_BEFORE_FIRST_ATTEMPT);
    int retries = getWaitForStatusRerties();
    while (!requiredStatusReached && i <= retries) {
        log.info("Attempt {} to get host '{}' status", i, hostName);
        VDSFenceReturnValue returnValue = executor.checkStatus();
        if (returnValue != null && returnValue.getSucceeded()) {
            String status = ((FenceStatusReturnValue) returnValue.getReturnValue()).getStatus();
            if (status.equalsIgnoreCase(VDSM_STATUS_UNKONWN)) {
                // Allow command to fail temporarily
                if (j <= UNKNOWN_RESULT_ALLOWED && i <= retries) {
                    ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    i++;
                    j++;
                } else {
                    // No need to retry , agent definitions are corrupted
                    log.error("Host '{}' PM Agent definitions are corrupted, aborting fence operation.", hostName);
                    break;
                }
            } else {
                if (requiredStatus.equalsIgnoreCase(status)) {
                    requiredStatusReached = true;
                    log.info("Host '{}' status is '{}'", hostName, requiredStatus);
                } else {
                    i++;
                    if (i <= retries) {
                        ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    }
                }
            }
        } else {
            log.error("Failed to get host '{}' status.", hostName);
            break;
        }
    }
    return requiredStatusReached;
}
#end_block

#method_before
protected void auditFailure() {
    // Send an Alert
    String actionName = (getParameters().getParentCommand() == VdcActionType.RestartVds) ? FenceActionType.Restart.name() : getAction().name();
    AuditLogableBase auditLogable = new AuditLogableBase();
    auditLogable.addCustomValue("Host", getVds().getName());
    auditLogable.addCustomValue("Status", actionName);
    auditLogable.setVdsId(getVds().getId());
    AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED);
    log.error("Failed to verify host {} {} status. Have retried {} times with delay of {} seconds between each retry.", getVds().getName(), getAction().name(), getWaitForStatusRerties(), getDelayInSeconds());
}
#method_after
protected void auditFailure() {
    // Send an Alert
    String actionName = (getParameters().getParentCommand() == VdcActionType.RestartVds) ? FenceActionType.Restart.name() : getAction().name();
    AuditLogableBase auditLogable = new AuditLogableBase();
    auditLogable.addCustomValue("Host", getVds().getName());
    auditLogable.addCustomValue("Status", actionName);
    auditLogable.setVdsId(getVds().getId());
    AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED);
    log.error("Failed to verify host '{}' {} status. Have retried {} times with delay of {} seconds between each retry.", getVds().getName(), getAction().name(), getWaitForStatusRerties(), getDelayInSeconds());
}
#end_block

#method_before
protected void logConcurrentAgentsFailure(FenceActionType action, List<FenceAgent> agents, VDSFenceReturnValue result) {
    StringBuilder builder = new StringBuilder();
    for (FenceAgent agent : agents) {
        builder.append(agent.getId()).append(", ");
    }
    String agentIds = builder.toString();
    agentIds = agentIds.substring(0, agentIds.length() - 2);
    log.error("Failed to {} VDS using fence agents {} concurrently: ", agentIds, result.getExceptionString());
}
#method_after
protected void logConcurrentAgentsFailure(FenceActionType action, List<FenceAgent> agents, VDSFenceReturnValue result) {
    StringBuilder builder = new StringBuilder();
    for (FenceAgent agent : agents) {
        builder.append(agent.getId()).append(", ");
    }
    String agentIds = builder.toString();
    agentIds = agentIds.substring(0, agentIds.length() - 2);
    log.error("Failed to {} host using fence agents '{}' concurrently: {}", action.name(), agentIds, result.getExceptionString());
}
#end_block

#method_before
private String injectLocalHost(String url) {
    Matcher m = urlPattern.matcher(url);
    if (m.matches()) {
        String host = m.group("host");
        if (host != null) {
            if (host.equals("localhost") || host.startsWith("127.") || host.equals("::1")) {
                url = String.format("%s%s%s", m.group("prefix") != null ? m.group("prefix") : "", LOCALHOST_PLACEHOLDER, m.group("suffix") != null ? m.group("suffix") : "");
            }
        }
    }
    return url;
}
#method_after
private String injectLocalHost(String url) {
    Matcher m = urlPattern.matcher(url);
    if (m.matches()) {
        String host = m.group("host");
        if (host != null) {
            if (localHostNames.contains(host) || host.startsWith("127.") || host.equals("::1")) {
                url = String.format("%s%s%s", m.group("prefix") != null ? m.group("prefix") : "", LOCALHOST_PLACEHOLDER, m.group("suffix") != null ? m.group("suffix") : "");
            }
        }
    }
    return url;
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String redirectUrl = targetUrl;
    if (StringUtils.isNotEmpty(redirectUrl)) {
        String pathInfo = request.getPathInfo();
        if (StringUtils.isNotEmpty(pathInfo)) {
            redirectUrl += pathInfo;
        }
        String queryString = request.getQueryString();
        if (StringUtils.isNotEmpty(queryString)) {
            if (redirectUrl.indexOf("?") == -1) {
                redirectUrl += "?";
            } else {
                redirectUrl += "&";
            }
            redirectUrl += queryString;
        }
    } else {
        redirectUrl = url404;
    }
    String localhost = request.getHeader("Host");
    if (localhost == null) {
        localhost = EngineLocalConfig.getInstance().getHost();
    }
    response.sendRedirect(redirectUrl.replace(LOCALHOST_PLACEHOLDER, localhost));
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String redirectUrl = targetUrl;
    if (StringUtils.isNotEmpty(redirectUrl)) {
        String pathInfo = request.getPathInfo();
        if (StringUtils.isNotEmpty(pathInfo)) {
            redirectUrl += pathInfo;
        }
        String queryString = request.getQueryString();
        if (StringUtils.isNotEmpty(queryString)) {
            if (redirectUrl.indexOf("?") == -1) {
                redirectUrl += "?";
            } else {
                redirectUrl += "&";
            }
            redirectUrl += queryString;
        }
    } else {
        redirectUrl = url404;
    }
    String localhost = request.getHeader("Host");
    if (localhost != null) {
        if (localhost.charAt(0) == '[') {
            int n = localhost.indexOf("]");
            if (n != -1) {
                localhost = localhost.substring(0, n + 1);
            }
        } else {
            int n = localhost.indexOf(":");
            if (n != -1) {
                localhost = localhost.substring(0, n);
            }
        }
    } else {
        localhost = EngineLocalConfig.getInstance().getHost();
    }
    response.sendRedirect(redirectUrl.replace(LOCALHOST_PLACEHOLDER, localhost));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (mVdsStatic == null ? 0 : mVdsStatic.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (spmStatus == null ? 0 : spmStatus.hashCode());
    result = prime * result + (mImagesLastCheck == null ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + (mImagesLastDelay == null ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + (mInterfaceList == null ? 0 : mInterfaceList.hashCode());
    result = prime * result + (mNetworkList == null ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (privateDomains == null ? 0 : privateDomains.hashCode());
    result = prime * result + (vdsSpmId == null ? 0 : vdsSpmId.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (vdsGroupCompatibilityVersion == null ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + (vdsGroupCpuName == null ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + (vdsGroupDescription == null ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + (vdsGroupName == null ? 0 : vdsGroupName.hashCode());
    result = prime * result + (vdsGroupVirtService == null ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + (vdsGroupGlusterService == null ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (balloonEnabled ? 0 : 1);
    result = prime * result + (countThreadsAsCores ? 0 : 1);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (vdsStatic == null ? 0 : vdsStatic.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (spmStatus == null ? 0 : spmStatus.hashCode());
    result = prime * result + (imagesLastCheck == null ? 0 : imagesLastCheck.hashCode());
    result = prime * result + (imagesLastDelay == null ? 0 : imagesLastDelay.hashCode());
    result = prime * result + (interfaces == null ? 0 : interfaces.hashCode());
    result = prime * result + (networks == null ? 0 : networks.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (privateDomains == null ? 0 : privateDomains.hashCode());
    result = prime * result + (vdsSpmId == null ? 0 : vdsSpmId.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (vdsGroupCompatibilityVersion == null ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + (vdsGroupCpuName == null ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + (vdsGroupDescription == null ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + (vdsGroupName == null ? 0 : vdsGroupName.hashCode());
    result = prime * result + (vdsGroupVirtService == null ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + (vdsGroupGlusterService == null ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (balloonEnabled ? 0 : 1);
    result = prime * result + (countThreadsAsCores ? 0 : 1);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDS)) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(mVdsStatic, other.mVdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && spmStatus == other.spmStatus && ObjectUtils.objectsEqual(mImagesLastCheck, other.mImagesLastCheck) && ObjectUtils.objectsEqual(mImagesLastDelay, other.mImagesLastDelay) && ObjectUtils.objectsEqual(mInterfaceList, other.mInterfaceList) && ObjectUtils.objectsEqual(mNetworkList, other.mNetworkList) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && balloonEnabled == other.balloonEnabled && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDS)) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(vdsStatic, other.vdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && spmStatus == other.spmStatus && ObjectUtils.objectsEqual(imagesLastCheck, other.imagesLastCheck) && ObjectUtils.objectsEqual(imagesLastDelay, other.imagesLastDelay) && ObjectUtils.objectsEqual(interfaces, other.interfaces) && ObjectUtils.objectsEqual(networks, other.networks) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && balloonEnabled == other.balloonEnabled && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#end_block

#method_before
public Guid getVdsGroupId() {
    return mVdsStatic.getVdsGroupId();
}
#method_after
public Guid getVdsGroupId() {
    return vdsStatic.getVdsGroupId();
}
#end_block

#method_before
public void setVdsGroupId(Guid value) {
    mVdsStatic.setVdsGroupId(value);
}
#method_after
public void setVdsGroupId(Guid value) {
    vdsStatic.setVdsGroupId(value);
}
#end_block

#method_before
@Override
public Guid getId() {
    return mVdsStatic.getId();
}
#method_after
@Override
public Guid getId() {
    return vdsStatic.getId();
}
#end_block

#method_before
@Override
public void setId(Guid value) {
    mVdsStatic.setId(value);
    mVdsDynamic.setId(value);
    mVdsStatistics.setId(value);
}
#method_after
@Override
public void setId(Guid value) {
    vdsStatic.setId(value);
    vdsDynamic.setId(value);
    vdsStatistics.setId(value);
}
#end_block

#method_before
@Override
public String getName() {
    return mVdsStatic.getName();
}
#method_after
@Override
public String getName() {
    return vdsStatic.getName();
}
#end_block

#method_before
public void setVdsName(String value) {
    mVdsStatic.setVdsName(value);
}
#method_after
public void setVdsName(String value) {
    vdsStatic.setVdsName(value);
}
#end_block

#method_before
public String getUniqueId() {
    return mVdsStatic.getUniqueID();
}
#method_after
public String getUniqueId() {
    return vdsStatic.getUniqueID();
}
#end_block

#method_before
public void setUniqueId(String value) {
    mVdsStatic.setUniqueID(value);
}
#method_after
public void setUniqueId(String value) {
    vdsStatic.setUniqueID(value);
}
#end_block

#method_before
public String getHostName() {
    return mVdsStatic.getHostName();
}
#method_after
public String getHostName() {
    return vdsStatic.getHostName();
}
#end_block

#method_before
public void setHostName(String value) {
    mVdsStatic.setHostName(value);
}
#method_after
public void setHostName(String value) {
    vdsStatic.setHostName(value);
}
#end_block

#method_before
@Override
public String getComment() {
    return mVdsStatic.getComment();
}
#method_after
@Override
public String getComment() {
    return vdsStatic.getComment();
}
#end_block

#method_before
@Override
public void setComment(String value) {
    mVdsStatic.setComment(value);
}
#method_after
@Override
public void setComment(String value) {
    vdsStatic.setComment(value);
}
#end_block

#method_before
public int getPort() {
    return mVdsStatic.getPort();
}
#method_after
public int getPort() {
    return vdsStatic.getPort();
}
#end_block

#method_before
public void setPort(int value) {
    mVdsStatic.setPort(value);
}
#method_after
public void setPort(int value) {
    vdsStatic.setPort(value);
}
#end_block

#method_before
public VdsProtocol getProtocol() {
    return mVdsStatic.getProtocol();
}
#method_after
public VdsProtocol getProtocol() {
    return vdsStatic.getProtocol();
}
#end_block

#method_before
public void setProtocol(VdsProtocol value) {
    mVdsStatic.setProtocol(value);
}
#method_after
public void setProtocol(VdsProtocol value) {
    vdsStatic.setProtocol(value);
}
#end_block

#method_before
public int getSshPort() {
    return mVdsStatic.getSshPort();
}
#method_after
public int getSshPort() {
    return vdsStatic.getSshPort();
}
#end_block

#method_before
public void setSshPort(int value) {
    mVdsStatic.setSshPort(value);
}
#method_after
public void setSshPort(int value) {
    vdsStatic.setSshPort(value);
}
#end_block

#method_before
public String getSshUsername() {
    return mVdsStatic.getSshUsername();
}
#method_after
public String getSshUsername() {
    return vdsStatic.getSshUsername();
}
#end_block

#method_before
public void setSshUsername(String value) {
    mVdsStatic.setSshUsername(value);
}
#method_after
public void setSshUsername(String value) {
    vdsStatic.setSshUsername(value);
}
#end_block

#method_before
public boolean isServerSslEnabled() {
    return mVdsStatic.isServerSslEnabled();
}
#method_after
public boolean isServerSslEnabled() {
    return vdsStatic.isServerSslEnabled();
}
#end_block

#method_before
public void setServerSslEnabled(boolean value) {
    mVdsStatic.setServerSslEnabled(value);
}
#method_after
public void setServerSslEnabled(boolean value) {
    vdsStatic.setServerSslEnabled(value);
}
#end_block

#method_before
public VDSType getVdsType() {
    return mVdsStatic.getVdsType();
}
#method_after
public VDSType getVdsType() {
    return vdsStatic.getVdsType();
}
#end_block

#method_before
public void setVdsType(VDSType value) {
    mVdsStatic.setVdsType(value);
}
#method_after
public void setVdsType(VDSType value) {
    vdsStatic.setVdsType(value);
}
#end_block

#method_before
@Override
public VDSStatus getStatus() {
    return mVdsDynamic.getStatus();
}
#method_after
@Override
public VDSStatus getStatus() {
    return vdsDynamic.getStatus();
}
#end_block

#method_before
@Override
public void setStatus(VDSStatus value) {
    mVdsDynamic.setStatus(value);
}
#method_after
@Override
public void setStatus(VDSStatus value) {
    vdsDynamic.setStatus(value);
}
#end_block

#method_before
public Integer getCpuCores() {
    return mVdsDynamic.getCpuCores();
}
#method_after
public Integer getCpuCores() {
    return vdsDynamic.getCpuCores();
}
#end_block

#method_before
public void setCpuCores(Integer value) {
    mVdsDynamic.setCpuCores(value);
}
#method_after
public void setCpuCores(Integer value) {
    vdsDynamic.setCpuCores(value);
}
#end_block

#method_before
public Integer getCpuThreads() {
    return mVdsDynamic.getCpuThreads();
}
#method_after
public Integer getCpuThreads() {
    return vdsDynamic.getCpuThreads();
}
#end_block

#method_before
public void setCpuThreads(Integer value) {
    mVdsDynamic.setCpuThreads(value);
}
#method_after
public void setCpuThreads(Integer value) {
    vdsDynamic.setCpuThreads(value);
}
#end_block

#method_before
public String getHardwareUUID() {
    return mVdsDynamic.getHardwareUUID();
}
#method_after
public String getHardwareUUID() {
    return vdsDynamic.getHardwareUUID();
}
#end_block

#method_before
public String getHardwareManufacturer() {
    return mVdsDynamic.getHardwareManufacturer();
}
#method_after
public String getHardwareManufacturer() {
    return vdsDynamic.getHardwareManufacturer();
}
#end_block

#method_before
public String getHardwareFamily() {
    return mVdsDynamic.getHardwareFamily();
}
#method_after
public String getHardwareFamily() {
    return vdsDynamic.getHardwareFamily();
}
#end_block

#method_before
public String getHardwareSerialNumber() {
    return mVdsDynamic.getHardwareSerialNumber();
}
#method_after
public String getHardwareSerialNumber() {
    return vdsDynamic.getHardwareSerialNumber();
}
#end_block

#method_before
public String getHardwareProductName() {
    return mVdsDynamic.getHardwareProductName();
}
#method_after
public String getHardwareProductName() {
    return vdsDynamic.getHardwareProductName();
}
#end_block

#method_before
public String getHardwareVersion() {
    return mVdsDynamic.getHardwareVersion();
}
#method_after
public String getHardwareVersion() {
    return vdsDynamic.getHardwareVersion();
}
#end_block

#method_before
public void setHardwareUUID(String value) {
    mVdsDynamic.setHardwareUUID(value);
}
#method_after
public void setHardwareUUID(String value) {
    vdsDynamic.setHardwareUUID(value);
}
#end_block

#method_before
public void setHardwareFamily(String value) {
    mVdsDynamic.setHardwareFamily(value);
}
#method_after
public void setHardwareFamily(String value) {
    vdsDynamic.setHardwareFamily(value);
}
#end_block

#method_before
public void setHardwareSerialNumber(String value) {
    mVdsDynamic.setHardwareSerialNumber(value);
}
#method_after
public void setHardwareSerialNumber(String value) {
    vdsDynamic.setHardwareSerialNumber(value);
}
#end_block

#method_before
public void setHardwareVersion(String value) {
    mVdsDynamic.setHardwareVersion(value);
}
#method_after
public void setHardwareVersion(String value) {
    vdsDynamic.setHardwareVersion(value);
}
#end_block

#method_before
public void setHardwareProductName(String value) {
    mVdsDynamic.setHardwareProductName(value);
}
#method_after
public void setHardwareProductName(String value) {
    vdsDynamic.setHardwareProductName(value);
}
#end_block

#method_before
public void setHardwareManufacturer(String value) {
    mVdsDynamic.setHardwareManufacturer(value);
}
#method_after
public void setHardwareManufacturer(String value) {
    vdsDynamic.setHardwareManufacturer(value);
}
#end_block

#method_before
public Integer getCpuSockets() {
    return mVdsDynamic.getCpuSockets();
}
#method_after
public Integer getCpuSockets() {
    return vdsDynamic.getCpuSockets();
}
#end_block

#method_before
public void setCpuSockets(Integer value) {
    mVdsDynamic.setCpuSockets(value);
}
#method_after
public void setCpuSockets(Integer value) {
    vdsDynamic.setCpuSockets(value);
}
#end_block

#method_before
public String getCpuModel() {
    return mVdsDynamic.getCpuModel();
}
#method_after
public String getCpuModel() {
    return vdsDynamic.getCpuModel();
}
#end_block

#method_before
public void setCpuModel(String value) {
    mVdsDynamic.setCpuModel(value);
}
#method_after
public void setCpuModel(String value) {
    vdsDynamic.setCpuModel(value);
}
#end_block

#method_before
public String getOnlineCpus() {
    return mVdsDynamic.getOnlineCpus();
}
#method_after
public String getOnlineCpus() {
    return vdsDynamic.getOnlineCpus();
}
#end_block

#method_before
public void setOnlineCpus(String value) {
    mVdsDynamic.setOnlineCpus(value);
}
#method_after
public void setOnlineCpus(String value) {
    vdsDynamic.setOnlineCpus(value);
}
#end_block

#method_before
public Double getCpuSpeedMh() {
    return mVdsDynamic.getCpuSpeedMh();
}
#method_after
public Double getCpuSpeedMh() {
    return vdsDynamic.getCpuSpeedMh();
}
#end_block

#method_before
public void setCpuSpeedMh(Double value) {
    mVdsDynamic.setCpuSpeedMh(value);
}
#method_after
public void setCpuSpeedMh(Double value) {
    vdsDynamic.setCpuSpeedMh(value);
}
#end_block

#method_before
public String getIfTotalSpeed() {
    return mVdsDynamic.getIfTotalSpeed();
}
#method_after
public String getIfTotalSpeed() {
    return vdsDynamic.getIfTotalSpeed();
}
#end_block

#method_before
public void setIfTotalSpeed(String value) {
    mVdsDynamic.setIfTotalSpeed(value);
}
#method_after
public void setIfTotalSpeed(String value) {
    vdsDynamic.setIfTotalSpeed(value);
}
#end_block

#method_before
public Boolean getKvmEnabled() {
    return mVdsDynamic.getKvmEnabled();
}
#method_after
public Boolean getKvmEnabled() {
    return vdsDynamic.getKvmEnabled();
}
#end_block

#method_before
public void setKvmEnabled(Boolean value) {
    mVdsDynamic.setKvmEnabled(value);
}
#method_after
public void setKvmEnabled(Boolean value) {
    vdsDynamic.setKvmEnabled(value);
}
#end_block

#method_before
public Integer getPhysicalMemMb() {
    return mVdsDynamic.getPhysicalMemMb();
}
#method_after
public Integer getPhysicalMemMb() {
    return vdsDynamic.getPhysicalMemMb();
}
#end_block

#method_before
public void setPhysicalMemMb(Integer value) {
    mVdsDynamic.setPhysicalMemMb(value);
}
#method_after
public void setPhysicalMemMb(Integer value) {
    vdsDynamic.setPhysicalMemMb(value);
}
#end_block

#method_before
public String getSupportedClusterLevels() {
    return mVdsDynamic.getSupportedClusterLevels();
}
#method_after
public String getSupportedClusterLevels() {
    return vdsDynamic.getSupportedClusterLevels();
}
#end_block

#method_before
public void setSupportedClusterLevels(String value) {
    mVdsDynamic.setSupportedClusterLevels(value);
}
#method_after
public void setSupportedClusterLevels(String value) {
    vdsDynamic.setSupportedClusterLevels(value);
}
#end_block

#method_before
public HashSet<Version> getSupportedClusterVersionsSet() {
    return mVdsDynamic.getSupportedClusterVersionsSet();
}
#method_after
public HashSet<Version> getSupportedClusterVersionsSet() {
    return vdsDynamic.getSupportedClusterVersionsSet();
}
#end_block

#method_before
public String getSupportedEngines() {
    return mVdsDynamic.getSupportedEngines();
}
#method_after
public String getSupportedEngines() {
    return vdsDynamic.getSupportedEngines();
}
#end_block

#method_before
public void setSupportedEngines(String value) {
    mVdsDynamic.setSupportedEngines(value);
}
#method_after
public void setSupportedEngines(String value) {
    vdsDynamic.setSupportedEngines(value);
}
#end_block

#method_before
public HashSet<Version> getSupportedENGINESVersionsSet() {
    return mVdsDynamic.getSupportedEngineVersionsSet();
}
#method_after
public HashSet<Version> getSupportedENGINESVersionsSet() {
    return vdsDynamic.getSupportedEngineVersionsSet();
}
#end_block

#method_before
public Double getCpuIdle() {
    return mVdsStatistics.getCpuIdle();
}
#method_after
public Double getCpuIdle() {
    return vdsStatistics.getCpuIdle();
}
#end_block

#method_before
public void setCpuIdle(Double value) {
    mVdsStatistics.setCpuIdle(value);
}
#method_after
public void setCpuIdle(Double value) {
    vdsStatistics.setCpuIdle(value);
}
#end_block

#method_before
public Double getCpuLoad() {
    return mVdsStatistics.getCpuLoad();
}
#method_after
public Double getCpuLoad() {
    return vdsStatistics.getCpuLoad();
}
#end_block

#method_before
public void setCpuLoad(Double value) {
    mVdsStatistics.setCpuLoad(value);
}
#method_after
public void setCpuLoad(Double value) {
    vdsStatistics.setCpuLoad(value);
}
#end_block

#method_before
public Double getCpuSys() {
    return mVdsStatistics.getCpuSys();
}
#method_after
public Double getCpuSys() {
    return vdsStatistics.getCpuSys();
}
#end_block

#method_before
public void setCpuSys(Double value) {
    mVdsStatistics.setCpuSys(value);
}
#method_after
public void setCpuSys(Double value) {
    vdsStatistics.setCpuSys(value);
}
#end_block

#method_before
public Double getCpuUser() {
    return mVdsStatistics.getCpuUser();
}
#method_after
public Double getCpuUser() {
    return vdsStatistics.getCpuUser();
}
#end_block

#method_before
public void setCpuUser(Double value) {
    mVdsStatistics.setCpuUser(value);
}
#method_after
public void setCpuUser(Double value) {
    vdsStatistics.setCpuUser(value);
}
#end_block

#method_before
public Integer getMemCommited() {
    return mVdsDynamic.getMemCommited();
}
#method_after
public Integer getMemCommited() {
    return vdsDynamic.getMemCommited();
}
#end_block

#method_before
public void setMemCommited(Integer value) {
    mVdsDynamic.setMemCommited(value);
    calculateFreeVirtualMemory();
}
#method_after
public void setMemCommited(Integer value) {
    vdsDynamic.setMemCommited(value);
    calculateFreeVirtualMemory();
}
#end_block

#method_before
public Integer getVmActive() {
    return mVdsDynamic.getVmActive();
}
#method_after
public Integer getVmActive() {
    return vdsDynamic.getVmActive();
}
#end_block

#method_before
public void setVmActive(Integer value) {
    mVdsDynamic.setVmActive(value);
}
#method_after
public void setVmActive(Integer value) {
    vdsDynamic.setVmActive(value);
}
#end_block

#method_before
public int getHighlyAvailableScore() {
    return mVdsStatistics.getHighlyAvailableScore();
}
#method_after
public int getHighlyAvailableScore() {
    return vdsStatistics.getHighlyAvailableScore();
}
#end_block

#method_before
public void setHighlyAvailableScore(int value) {
    mVdsStatistics.setHighlyAvailableScore(value);
}
#method_after
public void setHighlyAvailableScore(int value) {
    vdsStatistics.setHighlyAvailableScore(value);
}
#end_block

#method_before
public boolean getHighlyAvailableIsConfigured() {
    return mVdsStatistics.getHighlyAvailableIsConfigured();
}
#method_after
public boolean getHighlyAvailableIsConfigured() {
    return vdsStatistics.getHighlyAvailableIsConfigured();
}
#end_block

#method_before
public void setHighlyAvailableIsConfigured(boolean value) {
    mVdsStatistics.setHighlyAvailableIsConfigured(value);
}
#method_after
public void setHighlyAvailableIsConfigured(boolean value) {
    vdsStatistics.setHighlyAvailableIsConfigured(value);
}
#end_block

#method_before
public boolean getHighlyAvailableIsActive() {
    return mVdsStatistics.getHighlyAvailableIsActive();
}
#method_after
public boolean getHighlyAvailableIsActive() {
    return vdsStatistics.getHighlyAvailableIsActive();
}
#end_block

#method_before
public void setHighlyAvailableIsActive(boolean value) {
    mVdsStatistics.setHighlyAvailableIsActive(value);
}
#method_after
public void setHighlyAvailableIsActive(boolean value) {
    vdsStatistics.setHighlyAvailableIsActive(value);
}
#end_block

#method_before
public boolean getHighlyAvailableGlobalMaintenance() {
    return mVdsStatistics.getHighlyAvailableGlobalMaintenance();
}
#method_after
public boolean getHighlyAvailableGlobalMaintenance() {
    return vdsStatistics.getHighlyAvailableGlobalMaintenance();
}
#end_block

#method_before
public void setHighlyAvailableGlobalMaintenance(boolean value) {
    mVdsStatistics.setHighlyAvailableGlobalMaintenance(value);
}
#method_after
public void setHighlyAvailableGlobalMaintenance(boolean value) {
    vdsStatistics.setHighlyAvailableGlobalMaintenance(value);
}
#end_block

#method_before
public boolean getHighlyAvailableLocalMaintenance() {
    return mVdsStatistics.getHighlyAvailableLocalMaintenance();
}
#method_after
public boolean getHighlyAvailableLocalMaintenance() {
    return vdsStatistics.getHighlyAvailableLocalMaintenance();
}
#end_block

#method_before
public void setHighlyAvailableLocalMaintenance(boolean value) {
    mVdsStatistics.setHighlyAvailableLocalMaintenance(value);
}
#method_after
public void setHighlyAvailableLocalMaintenance(boolean value) {
    vdsStatistics.setHighlyAvailableLocalMaintenance(value);
}
#end_block

#method_before
public int getVmCount() {
    return mVdsDynamic.getVmCount();
}
#method_after
public int getVmCount() {
    return vdsDynamic.getVmCount();
}
#end_block

#method_before
public void setVmCount(int value) {
    mVdsDynamic.setVmCount(value);
}
#method_after
public void setVmCount(int value) {
    vdsDynamic.setVmCount(value);
}
#end_block

#method_before
public Integer getVmsCoresCount() {
    return mVdsDynamic.getVmsCoresCount();
}
#method_after
public Integer getVmsCoresCount() {
    return vdsDynamic.getVmsCoresCount();
}
#end_block

#method_before
public void setVmsCoresCount(Integer value) {
    mVdsDynamic.setVmsCoresCount(value);
}
#method_after
public void setVmsCoresCount(Integer value) {
    vdsDynamic.setVmsCoresCount(value);
}
#end_block

#method_before
public Integer getVmMigrating() {
    return mVdsDynamic.getVmMigrating();
}
#method_after
public Integer getVmMigrating() {
    return vdsDynamic.getVmMigrating();
}
#end_block

#method_before
public void setVmMigrating(Integer value) {
    mVdsDynamic.setVmMigrating(value);
}
#method_after
public void setVmMigrating(Integer value) {
    vdsDynamic.setVmMigrating(value);
}
#end_block

#method_before
public Integer getUsageMemPercent() {
    return mVdsStatistics.getUsageMemPercent();
}
#method_after
public Integer getUsageMemPercent() {
    return vdsStatistics.getUsageMemPercent();
}
#end_block

#method_before
public void setUsageMemPercent(Integer value) {
    mVdsStatistics.setUsageMemPercent(value);
}
#method_after
public void setUsageMemPercent(Integer value) {
    vdsStatistics.setUsageMemPercent(value);
}
#end_block

#method_before
public Integer getUsageCpuPercent() {
    return mVdsStatistics.getUsageCpuPercent();
}
#method_after
public Integer getUsageCpuPercent() {
    return vdsStatistics.getUsageCpuPercent();
}
#end_block

#method_before
public void setUsageCpuPercent(Integer value) {
    mVdsStatistics.setUsageCpuPercent(value);
}
#method_after
public void setUsageCpuPercent(Integer value) {
    vdsStatistics.setUsageCpuPercent(value);
}
#end_block

#method_before
public Integer getUsageNetworkPercent() {
    return mVdsStatistics.getUsageNetworkPercent();
}
#method_after
public Integer getUsageNetworkPercent() {
    return vdsStatistics.getUsageNetworkPercent();
}
#end_block

#method_before
public void setUsageNetworkPercent(Integer value) {
    mVdsStatistics.setUsageNetworkPercent(value);
}
#method_after
public void setUsageNetworkPercent(Integer value) {
    vdsStatistics.setUsageNetworkPercent(value);
}
#end_block

#method_before
public Integer getGuestOverhead() {
    return mVdsDynamic.getGuestOverhead();
}
#method_after
public Integer getGuestOverhead() {
    return vdsDynamic.getGuestOverhead();
}
#end_block

#method_before
public void setGuestOverhead(Integer value) {
    mVdsDynamic.setGuestOverhead(value);
}
#method_after
public void setGuestOverhead(Integer value) {
    vdsDynamic.setGuestOverhead(value);
}
#end_block

#method_before
public Integer getReservedMem() {
    return mVdsDynamic.getReservedMem();
}
#method_after
public Integer getReservedMem() {
    return vdsDynamic.getReservedMem();
}
#end_block

#method_before
public void setReservedMem(Integer value) {
    mVdsDynamic.setReservedMem(value);
}
#method_after
public void setReservedMem(Integer value) {
    vdsDynamic.setReservedMem(value);
}
#end_block

#method_before
public Long getBootTime() {
    return mVdsStatistics.getBootTime();
}
#method_after
public Long getBootTime() {
    return vdsStatistics.getBootTime();
}
#end_block

#method_before
public void setBootTime(Long value) {
    mVdsStatistics.setBootTime(value);
}
#method_after
public void setBootTime(Long value) {
    vdsStatistics.setBootTime(value);
}
#end_block

#method_before
public VDSStatus getPreviousStatus() {
    return mVdsDynamic.getPreviousStatus();
}
#method_after
public VDSStatus getPreviousStatus() {
    return vdsDynamic.getPreviousStatus();
}
#end_block

#method_before
public void setPreviousStatus(VDSStatus value) {
    mVdsDynamic.setPreviousStatus(value);
}
#method_after
public void setPreviousStatus(VDSStatus value) {
    vdsDynamic.setPreviousStatus(value);
}
#end_block

#method_before
public Long getMemAvailable() {
    return mVdsStatistics.getMemAvailable();
}
#method_after
public Long getMemAvailable() {
    return vdsStatistics.getMemAvailable();
}
#end_block

#method_before
public void setMemAvailable(Long value) {
    mVdsStatistics.setMemAvailable(value);
}
#method_after
public void setMemAvailable(Long value) {
    vdsStatistics.setMemAvailable(value);
}
#end_block

#method_before
public Long getMemFree() {
    return mVdsStatistics.getMemFree();
}
#method_after
public Long getMemFree() {
    return vdsStatistics.getMemFree();
}
#end_block

#method_before
public void setMemFree(Long value) {
    mVdsStatistics.setMemFree(value);
}
#method_after
public void setMemFree(Long value) {
    vdsStatistics.setMemFree(value);
}
#end_block

#method_before
public Long getMemShared() {
    return mVdsStatistics.getMemShared();
}
#method_after
public Long getMemShared() {
    return vdsStatistics.getMemShared();
}
#end_block

#method_before
public void setMemShared(Long value) {
    mVdsStatistics.setMemShared(value);
}
#method_after
public void setMemShared(Long value) {
    vdsStatistics.setMemShared(value);
}
#end_block

#method_before
public String getConsoleAddress() {
    return mVdsStatic.getConsoleAddress();
}
#method_after
public String getConsoleAddress() {
    return vdsStatic.getConsoleAddress();
}
#end_block

#method_before
public void setConsoleAddress(String value) {
    mVdsStatic.setConsoleAddress(value);
}
#method_after
public void setConsoleAddress(String value) {
    vdsStatic.setConsoleAddress(value);
}
#end_block

#method_before
public Integer getMemCommitedPercent() {
    Integer commited = mVdsDynamic.getMemCommited();
    Integer physical = mVdsDynamic.getPhysicalMemMb();
    if (commited == null || physical == null || physical == 0) {
        return 0;
    }
    return (commited * 100) / physical;
}
#method_after
public Integer getMemCommitedPercent() {
    Integer commited = vdsDynamic.getMemCommited();
    Integer physical = vdsDynamic.getPhysicalMemMb();
    if (commited == null || physical == null || physical == 0) {
        return 0;
    }
    return (commited * 100) / physical;
}
#end_block

#method_before
public Integer getMemSharedPercent() {
    Long shared = mVdsStatistics.getMemShared();
    Integer physical = mVdsDynamic.getPhysicalMemMb();
    if (shared == null || physical == null || physical == 0) {
        return 0;
    }
    return (int) ((shared * 100) / physical);
}
#method_after
public Integer getMemSharedPercent() {
    Long shared = vdsStatistics.getMemShared();
    Integer physical = vdsDynamic.getPhysicalMemMb();
    if (shared == null || physical == null || physical == 0) {
        return 0;
    }
    return (int) ((shared * 100) / physical);
}
#end_block

#method_before
public Long getSwapFree() {
    return mVdsStatistics.getSwapFree();
}
#method_after
public Long getSwapFree() {
    return vdsStatistics.getSwapFree();
}
#end_block

#method_before
public void setSwapFree(Long value) {
    mVdsStatistics.setSwapFree(value);
}
#method_after
public void setSwapFree(Long value) {
    vdsStatistics.setSwapFree(value);
}
#end_block

#method_before
public Long getSwapTotal() {
    return mVdsStatistics.getSwapTotal();
}
#method_after
public Long getSwapTotal() {
    return vdsStatistics.getSwapTotal();
}
#end_block

#method_before
public void setSwapTotal(Long value) {
    mVdsStatistics.setSwapTotal(value);
}
#method_after
public void setSwapTotal(Long value) {
    vdsStatistics.setSwapTotal(value);
}
#end_block

#method_before
public Integer getKsmCpuPercent() {
    return mVdsStatistics.getKsmCpuPercent();
}
#method_after
public Integer getKsmCpuPercent() {
    return vdsStatistics.getKsmCpuPercent();
}
#end_block

#method_before
public void setKsmCpuPercent(Integer value) {
    mVdsStatistics.setKsmCpuPercent(value);
}
#method_after
public void setKsmCpuPercent(Integer value) {
    vdsStatistics.setKsmCpuPercent(value);
}
#end_block

#method_before
public Long getKsmPages() {
    return mVdsStatistics.getKsmPages();
}
#method_after
public Long getKsmPages() {
    return vdsStatistics.getKsmPages();
}
#end_block

#method_before
public void setKsmPages(Long value) {
    mVdsStatistics.setKsmPages(value);
}
#method_after
public void setKsmPages(Long value) {
    vdsStatistics.setKsmPages(value);
}
#end_block

#method_before
public Boolean getKsmState() {
    return mVdsStatistics.getKsmState();
}
#method_after
public Boolean getKsmState() {
    return vdsStatistics.getKsmState();
}
#end_block

#method_before
public void setKsmState(Boolean value) {
    mVdsStatistics.setKsmState(value);
}
#method_after
public void setKsmState(Boolean value) {
    vdsStatistics.setKsmState(value);
}
#end_block

#method_before
public String getSoftwareVersion() {
    return mVdsDynamic.getSoftwareVersion();
}
#method_after
public String getSoftwareVersion() {
    return vdsDynamic.getSoftwareVersion();
}
#end_block

#method_before
public void setSoftwareVersion(String value) {
    mVdsDynamic.setSoftwareVersion(value);
}
#method_after
public void setSoftwareVersion(String value) {
    vdsDynamic.setSoftwareVersion(value);
}
#end_block

#method_before
public String getVersionName() {
    return mVdsDynamic.getVersionName();
}
#method_after
public String getVersionName() {
    return vdsDynamic.getVersionName();
}
#end_block

#method_before
public void setVersionName(String value) {
    mVdsDynamic.setVersionName(value);
}
#method_after
public void setVersionName(String value) {
    vdsDynamic.setVersionName(value);
}
#end_block

#method_before
public String getBuildName() {
    return mVdsDynamic.getBuildName();
}
#method_after
public String getBuildName() {
    return vdsDynamic.getBuildName();
}
#end_block

#method_before
public void setBuildName(String value) {
    mVdsDynamic.setBuildName(value);
}
#method_after
public void setBuildName(String value) {
    vdsDynamic.setBuildName(value);
}
#end_block

#method_before
public String getCpuFlags() {
    return mVdsDynamic.getCpuFlags();
}
#method_after
public String getCpuFlags() {
    return vdsDynamic.getCpuFlags();
}
#end_block

#method_before
public void setCpuFlags(String value) {
    mVdsDynamic.setCpuFlags(value);
}
#method_after
public void setCpuFlags(String value) {
    vdsDynamic.setCpuFlags(value);
}
#end_block

#method_before
public Date getCpuOverCommitTimestamp() {
    return mVdsStatistics.getCpuOverCommitTimeStamp();
}
#method_after
public Date getCpuOverCommitTimestamp() {
    return vdsStatistics.getCpuOverCommitTimeStamp();
}
#end_block

#method_before
public void setCpuOverCommitTimestamp(Date value) {
    mVdsStatistics.setCpuOverCommitTimeStamp(value);
}
#method_after
public void setCpuOverCommitTimestamp(Date value) {
    vdsStatistics.setCpuOverCommitTimeStamp(value);
}
#end_block

#method_before
public int getVdsStrength() {
    return mVdsStatic.getVdsStrength();
}
#method_after
public int getVdsStrength() {
    return vdsStatic.getVdsStrength();
}
#end_block

#method_before
public void setVdsStrength(int value) {
    mVdsStatic.setVdsStrength(value);
}
#method_after
public void setVdsStrength(int value) {
    vdsStatic.setVdsStrength(value);
}
#end_block

#method_before
public Integer getPendingVcpusCount() {
    return mVdsDynamic.getPendingVcpusCount();
}
#method_after
public Integer getPendingVcpusCount() {
    return vdsDynamic.getPendingVcpusCount();
}
#end_block

#method_before
public void setPendingVcpusCount(Integer value) {
    mVdsDynamic.setPendingVcpusCount(value);
}
#method_after
public void setPendingVcpusCount(Integer value) {
    vdsDynamic.setPendingVcpusCount(value);
}
#end_block

#method_before
public int getPendingVmemSize() {
    return mVdsDynamic.getPendingVmemSize();
}
#method_after
public int getPendingVmemSize() {
    return vdsDynamic.getPendingVmemSize();
}
#end_block

#method_before
public void setPendingVmemSize(int value) {
    mVdsDynamic.setPendingVmemSize(value);
}
#method_after
public void setPendingVmemSize(int value) {
    vdsDynamic.setPendingVmemSize(value);
}
#end_block

#method_before
public Boolean getNetConfigDirty() {
    return mVdsDynamic.getNetConfigDirty();
}
#method_after
public Boolean getNetConfigDirty() {
    return vdsDynamic.getNetConfigDirty();
}
#end_block

#method_before
public void setNetConfigDirty(Boolean value) {
    mVdsDynamic.setNetConfigDirty(value);
}
#method_after
public void setNetConfigDirty(Boolean value) {
    vdsDynamic.setNetConfigDirty(value);
}
#end_block

#method_before
public boolean isPmKdumpDetection() {
    return mVdsStatic.isPmKdumpDetection();
}
#method_after
public boolean isPmKdumpDetection() {
    return vdsStatic.isPmKdumpDetection();
}
#end_block

#method_before
public void setPmKdumpDetection(boolean pmKdumpDetection) {
    mVdsStatic.setPmKdumpDetection(pmKdumpDetection);
}
#method_after
public void setPmKdumpDetection(boolean pmKdumpDetection) {
    vdsStatic.setPmKdumpDetection(pmKdumpDetection);
}
#end_block

#method_before
public boolean isPmEnabled() {
    return mVdsStatic.isPmEnabled();
}
#method_after
public boolean isPmEnabled() {
    return vdsStatic.isPmEnabled();
}
#end_block

#method_before
public void setPmEnabled(boolean value) {
    mVdsStatic.setPmEnabled(value);
}
#method_after
public void setPmEnabled(boolean value) {
    vdsStatic.setPmEnabled(value);
}
#end_block

#method_before
public String getPmProxyPreferences() {
    return mVdsStatic.getPmProxyPreferences();
}
#method_after
public String getPmProxyPreferences() {
    return vdsStatic.getPmProxyPreferences();
}
#end_block

#method_before
public void setPmProxyPreferences(String pmProxyPreferences) {
    mVdsStatic.setPmProxyPreferences(pmProxyPreferences);
}
#method_after
public void setPmProxyPreferences(String pmProxyPreferences) {
    vdsStatic.setPmProxyPreferences(pmProxyPreferences);
}
#end_block

#method_before
public String getHostOs() {
    return mVdsDynamic.getHostOs();
}
#method_after
public String getHostOs() {
    return vdsDynamic.getHostOs();
}
#end_block

#method_before
public void setHostOs(String value) {
    mVdsDynamic.setHostOs(value);
}
#method_after
public void setHostOs(String value) {
    vdsDynamic.setHostOs(value);
}
#end_block

#method_before
public String getKvmVersion() {
    return mVdsDynamic.getKvmVersion();
}
#method_after
public String getKvmVersion() {
    return vdsDynamic.getKvmVersion();
}
#end_block

#method_before
public void setKvmVersion(String value) {
    mVdsDynamic.setKvmVersion(value);
}
#method_after
public void setKvmVersion(String value) {
    vdsDynamic.setKvmVersion(value);
}
#end_block

#method_before
public RpmVersion getLibvirtVersion() {
    return mVdsDynamic.getLibvirtVersion();
}
#method_after
public RpmVersion getLibvirtVersion() {
    return vdsDynamic.getLibvirtVersion();
}
#end_block

#method_before
public void setLibvirtVersion(RpmVersion value) {
    mVdsDynamic.setLibvirtVersion(value);
}
#method_after
public void setLibvirtVersion(RpmVersion value) {
    vdsDynamic.setLibvirtVersion(value);
}
#end_block

#method_before
public String getSpiceVersion() {
    return mVdsDynamic.getSpiceVersion();
}
#method_after
public String getSpiceVersion() {
    return vdsDynamic.getSpiceVersion();
}
#end_block

#method_before
public void setSpiceVersion(String value) {
    mVdsDynamic.setSpiceVersion(value);
}
#method_after
public void setSpiceVersion(String value) {
    vdsDynamic.setSpiceVersion(value);
}
#end_block

#method_before
public RpmVersion getGlusterVersion() {
    return mVdsDynamic.getGlusterVersion();
}
#method_after
public RpmVersion getGlusterVersion() {
    return vdsDynamic.getGlusterVersion();
}
#end_block

#method_before
public void setGlusterVersion(RpmVersion value) {
    mVdsDynamic.setGlusterVersion(value);
}
#method_after
public void setGlusterVersion(RpmVersion value) {
    vdsDynamic.setGlusterVersion(value);
}
#end_block

#method_before
public String getKernelVersion() {
    return mVdsDynamic.getKernelVersion();
}
#method_after
public String getKernelVersion() {
    return vdsDynamic.getKernelVersion();
}
#end_block

#method_before
public void setKernelVersion(String value) {
    mVdsDynamic.setKernelVersion(value);
}
#method_after
public void setKernelVersion(String value) {
    vdsDynamic.setKernelVersion(value);
}
#end_block

#method_before
public void setIScsiInitiatorName(String value) {
    mVdsDynamic.setIScsiInitiatorName(value);
}
#method_after
public void setIScsiInitiatorName(String value) {
    vdsDynamic.setIScsiInitiatorName(value);
}
#end_block

#method_before
public String getIScsiInitiatorName() {
    return mVdsDynamic.getIScsiInitiatorName();
}
#method_after
public String getIScsiInitiatorName() {
    return vdsDynamic.getIScsiInitiatorName();
}
#end_block

#method_before
public Map<String, List<Map<String, String>>> getHBAs() {
    return mVdsDynamic.getHBAs();
}
#method_after
public Map<String, List<Map<String, String>>> getHBAs() {
    return vdsDynamic.getHBAs();
}
#end_block

#method_before
public void setHBAs(Map<String, List<Map<String, String>>> HBAs) {
    mVdsDynamic.setHBAs(HBAs);
}
#method_after
public void setHBAs(Map<String, List<Map<String, String>>> HBAs) {
    vdsDynamic.setHBAs(HBAs);
}
#end_block

#method_before
public void setTransparentHugePagesState(VdsTransparentHugePagesState value) {
    mVdsDynamic.setTransparentHugePagesState(value);
}
#method_after
public void setTransparentHugePagesState(VdsTransparentHugePagesState value) {
    vdsDynamic.setTransparentHugePagesState(value);
}
#end_block

#method_before
public VdsTransparentHugePagesState getTransparentHugePagesState() {
    return mVdsDynamic.getTransparentHugePagesState();
}
#method_after
public VdsTransparentHugePagesState getTransparentHugePagesState() {
    return vdsDynamic.getTransparentHugePagesState();
}
#end_block

#method_before
public int getAnonymousHugePages() {
    return mVdsStatistics.getAnonymousHugePages();
}
#method_after
public int getAnonymousHugePages() {
    return vdsStatistics.getAnonymousHugePages();
}
#end_block

#method_before
public void setAnonymousHugePages(int value) {
    mVdsStatistics.setAnonymousHugePages(value);
}
#method_after
public void setAnonymousHugePages(int value) {
    vdsStatistics.setAnonymousHugePages(value);
}
#end_block

#method_before
public VdsStatic getStaticData() {
    return mVdsStatic;
}
#method_after
public VdsStatic getStaticData() {
    return vdsStatic;
}
#end_block

#method_before
public void setStaticData(VdsStatic value) {
    mVdsStatic = value;
}
#method_after
public void setStaticData(VdsStatic value) {
    vdsStatic = value;
}
#end_block

#method_before
public VdsDynamic getDynamicData() {
    return mVdsDynamic;
}
#method_after
public VdsDynamic getDynamicData() {
    return vdsDynamic;
}
#end_block

#method_before
public void setDynamicData(VdsDynamic value) {
    mVdsDynamic = value;
}
#method_after
public void setDynamicData(VdsDynamic value) {
    vdsDynamic = value;
}
#end_block

#method_before
public VdsStatistics getStatisticsData() {
    return mVdsStatistics;
}
#method_after
public VdsStatistics getStatisticsData() {
    return vdsStatistics;
}
#end_block

#method_before
public void setStatisticsData(VdsStatistics value) {
    mVdsStatistics = value;
}
#method_after
public void setStatisticsData(VdsStatistics value) {
    vdsStatistics = value;
}
#end_block

#method_before
public ArrayList<Network> getNetworks() {
    return mNetworkList;
}
#method_after
public ArrayList<Network> getNetworks() {
    return networks;
}
#end_block

#method_before
public ArrayList<VdsNetworkInterface> getInterfaces() {
    return mInterfaceList;
}
#method_after
public ArrayList<VdsNetworkInterface> getInterfaces() {
    return interfaces;
}
#end_block

#method_before
public Double getImagesLastCheck() {
    return mImagesLastCheck;
}
#method_after
public Double getImagesLastCheck() {
    return imagesLastCheck;
}
#end_block

#method_before
public void setImagesLastCheck(Double value) {
    mImagesLastCheck = value;
}
#method_after
public void setImagesLastCheck(Double value) {
    imagesLastCheck = value;
}
#end_block

#method_before
public Double getImagesLastDelay() {
    return mImagesLastDelay;
}
#method_after
public Double getImagesLastDelay() {
    return imagesLastDelay;
}
#end_block

#method_before
public void setImagesLastDelay(Double value) {
    mImagesLastDelay = value;
}
#method_after
public void setImagesLastDelay(Double value) {
    imagesLastDelay = value;
}
#end_block

#method_before
public void setVersion(RpmVersion value) {
    mVdsDynamic.setVersion(value);
}
#method_after
public void setVersion(RpmVersion value) {
    vdsDynamic.setVersion(value);
}
#end_block

#method_before
public RpmVersion getVersion() {
    return mVdsDynamic.getVersion();
}
#method_after
public RpmVersion getVersion() {
    return vdsDynamic.getVersion();
}
#end_block

#method_before
public String getPartialVersion() {
    return mVdsDynamic.getVersion().getValue().substring(0, 2);
}
#method_after
public String getPartialVersion() {
    return vdsDynamic.getVersion().getValue().substring(0, 2);
}
#end_block

#method_before
public long getOtpValidity() {
    return mVdsStatic.getOtpValidity();
}
#method_after
public long getOtpValidity() {
    return vdsStatic.getOtpValidity();
}
#end_block

#method_before
public void setOtpValidity(long value) {
    mVdsStatic.setOtpValidity(value);
}
#method_after
public void setOtpValidity(long value) {
    vdsStatic.setOtpValidity(value);
}
#end_block

#method_before
public int getVdsSpmPriority() {
    return mVdsStatic.getVdsSpmPriority();
}
#method_after
public int getVdsSpmPriority() {
    return vdsStatic.getVdsSpmPriority();
}
#end_block

#method_before
public void setVdsSpmPriority(int value) {
    mVdsStatic.setVdsSpmPriority(value);
}
#method_after
public void setVdsSpmPriority(int value) {
    vdsStatic.setVdsSpmPriority(value);
}
#end_block

#method_before
public NonOperationalReason getNonOperationalReason() {
    return mVdsDynamic.getNonOperationalReason();
}
#method_after
public NonOperationalReason getNonOperationalReason() {
    return vdsDynamic.getNonOperationalReason();
}
#end_block

#method_before
public void setNonOperationalReason(NonOperationalReason nonOperationalReason) {
    mVdsDynamic.setNonOperationalReason(nonOperationalReason);
}
#method_after
public void setNonOperationalReason(NonOperationalReason nonOperationalReason) {
    vdsDynamic.setNonOperationalReason(nonOperationalReason);
}
#end_block

#method_before
public boolean isAutoRecoverable() {
    return mVdsStatic.isAutoRecoverable();
}
#method_after
public boolean isAutoRecoverable() {
    return vdsStatic.isAutoRecoverable();
}
#end_block

#method_before
public void setAutoRecoverable(boolean autoRecoverable) {
    mVdsStatic.setAutoRecoverable(autoRecoverable);
}
#method_after
public void setAutoRecoverable(boolean autoRecoverable) {
    vdsStatic.setAutoRecoverable(autoRecoverable);
}
#end_block

#method_before
public String getSshKeyFingerprint() {
    return mVdsStatic.getSshKeyFingerprint();
}
#method_after
public String getSshKeyFingerprint() {
    return vdsStatic.getSshKeyFingerprint();
}
#end_block

#method_before
public void setSshKeyFingerprint(String sshKeyFingerprint) {
    mVdsStatic.setSshKeyFingerprint(sshKeyFingerprint);
}
#method_after
public void setSshKeyFingerprint(String sshKeyFingerprint) {
    vdsStatic.setSshKeyFingerprint(sshKeyFingerprint);
}
#end_block

#method_before
public Guid getHostProviderId() {
    return mVdsStatic.getHostProviderId();
}
#method_after
public Guid getHostProviderId() {
    return vdsStatic.getHostProviderId();
}
#end_block

#method_before
public void setHostProviderId(Guid hostProviderId) {
    mVdsStatic.setHostProviderId(hostProviderId);
}
#method_after
public void setHostProviderId(Guid hostProviderId) {
    vdsStatic.setHostProviderId(hostProviderId);
}
#end_block

#method_before
@Override
public String toString() {
    // is not enough, remove this once mVdsStatic can not be null
    return "Host[" + (mVdsStatic == null ? "null" : (mVdsStatic.getName() + "," + mVdsStatic.getId())) + "]";
}
#method_after
@Override
public String toString() {
    // is not enough, remove this once vdsStatic can not be null
    return "Host[" + (vdsStatic == null ? "null" : (vdsStatic.getName() + "," + vdsStatic.getId())) + "]";
}
#end_block

#method_before
public void setSupportedEmulatedMachines(String supportedEmulatedMachines) {
    mVdsDynamic.setSupportedEmulatedMachines(supportedEmulatedMachines);
}
#method_after
public void setSupportedEmulatedMachines(String supportedEmulatedMachines) {
    vdsDynamic.setSupportedEmulatedMachines(supportedEmulatedMachines);
}
#end_block

#method_before
public String getSupportedEmulatedMachines() {
    return mVdsDynamic.getSupportedEmulatedMachines();
}
#method_after
public String getSupportedEmulatedMachines() {
    return vdsDynamic.getSupportedEmulatedMachines();
}
#end_block

#method_before
public boolean isPowerManagementControlledByPolicy() {
    return mVdsDynamic.isPowerManagementControlledByPolicy();
}
#method_after
public boolean isPowerManagementControlledByPolicy() {
    return vdsDynamic.isPowerManagementControlledByPolicy();
}
#end_block

#method_before
public void setPowerManagementControlledByPolicy(boolean powerManagementControlledByPolicy) {
    mVdsDynamic.setPowerManagementControlledByPolicy(powerManagementControlledByPolicy);
}
#method_after
public void setPowerManagementControlledByPolicy(boolean powerManagementControlledByPolicy) {
    vdsDynamic.setPowerManagementControlledByPolicy(powerManagementControlledByPolicy);
}
#end_block

#method_before
public boolean isDisablePowerManagementPolicy() {
    return mVdsStatic.isDisablePowerManagementPolicy();
}
#method_after
public boolean isDisablePowerManagementPolicy() {
    return vdsStatic.isDisablePowerManagementPolicy();
}
#end_block

#method_before
public void setDisablePowerManagementPolicy(boolean disablePowerManagementPolicy) {
    mVdsStatic.setDisablePowerManagementPolicy(disablePowerManagementPolicy);
}
#method_after
public void setDisablePowerManagementPolicy(boolean disablePowerManagementPolicy) {
    vdsStatic.setDisablePowerManagementPolicy(disablePowerManagementPolicy);
}
#end_block

#method_before
public Set<VmRngDevice.Source> getSupportedRngSources() {
    return mVdsDynamic.getSupportedRngSources();
}
#method_after
public Set<VmRngDevice.Source> getSupportedRngSources() {
    return vdsDynamic.getSupportedRngSources();
}
#end_block

#method_before
public KdumpStatus getKdumpStatus() {
    return mVdsDynamic.getKdumpStatus();
}
#method_after
public KdumpStatus getKdumpStatus() {
    return vdsDynamic.getKdumpStatus();
}
#end_block

#method_before
public void setKdumpStatus(KdumpStatus kdumpStatus) {
    mVdsDynamic.setKdumpStatus(kdumpStatus);
}
#method_after
public void setKdumpStatus(KdumpStatus kdumpStatus) {
    vdsDynamic.setKdumpStatus(kdumpStatus);
}
#end_block

#method_before
public SELinuxMode getSELinuxEnforceMode() {
    return mVdsDynamic.getSELinuxEnforceMode();
}
#method_after
public SELinuxMode getSELinuxEnforceMode() {
    return vdsDynamic.getSELinuxEnforceMode();
}
#end_block

#method_before
public void setSELinuxEnforceMode(Integer value) {
    mVdsDynamic.setSELinuxEnforceMode(value);
}
#method_after
public void setSELinuxEnforceMode(Integer value) {
    vdsDynamic.setSELinuxEnforceMode(value);
}
#end_block

#method_before
public void setNumaNodeList(List<VdsNumaNode> numaNodeList) {
    mVdsDynamic.setNumaNodeList(numaNodeList);
}
#method_after
public void setNumaNodeList(List<VdsNumaNode> numaNodeList) {
    vdsDynamic.setNumaNodeList(numaNodeList);
}
#end_block

#method_before
public List<VdsNumaNode> getNumaNodeList() {
    return mVdsDynamic.getNumaNodeList();
}
#method_after
public List<VdsNumaNode> getNumaNodeList() {
    return vdsDynamic.getNumaNodeList();
}
#end_block

#method_before
public AutoNumaBalanceStatus getAutoNumaBalancing() {
    return mVdsDynamic.getAutoNumaBalancing();
}
#method_after
public AutoNumaBalanceStatus getAutoNumaBalancing() {
    return vdsDynamic.getAutoNumaBalancing();
}
#end_block

#method_before
public void setAutoNumaBalancing(AutoNumaBalanceStatus autoNumaBalancing) {
    mVdsDynamic.setAutoNumaBalancing(autoNumaBalancing);
}
#method_after
public void setAutoNumaBalancing(AutoNumaBalanceStatus autoNumaBalancing) {
    vdsDynamic.setAutoNumaBalancing(autoNumaBalancing);
}
#end_block

#method_before
public boolean isNumaSupport() {
    return mVdsDynamic.isNumaSupport();
}
#method_after
public boolean isNumaSupport() {
    return vdsDynamic.isNumaSupport();
}
#end_block

#method_before
public void setNumaSupport(boolean numaSupport) {
    mVdsDynamic.setNumaSupport(numaSupport);
}
#method_after
public void setNumaSupport(boolean numaSupport) {
    vdsDynamic.setNumaSupport(numaSupport);
}
#end_block

#method_before
public void setLiveSnapshotSupport(Boolean value) {
    mVdsDynamic.setLiveSnapshotSupport(value);
}
#method_after
public void setLiveSnapshotSupport(Boolean value) {
    vdsDynamic.setLiveSnapshotSupport(value);
}
#end_block

#method_before
public Boolean getLiveSnapshotSupport() {
    return mVdsDynamic.getLiveSnapshotSupport();
}
#method_after
public Boolean getLiveSnapshotSupport() {
    return vdsDynamic.getLiveSnapshotSupport();
}
#end_block

#method_before
public void setLiveMergeSupport(boolean value) {
    mVdsDynamic.setLiveMergeSupport(value);
}
#method_after
public void setLiveMergeSupport(boolean value) {
    vdsDynamic.setLiveMergeSupport(value);
}
#end_block

#method_before
public boolean getLiveMergeSupport() {
    return mVdsDynamic.getLiveMergeSupport();
}
#method_after
public boolean getLiveMergeSupport() {
    return vdsDynamic.getLiveMergeSupport();
}
#end_block

#method_before
private static void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    String message = null;
    String resolvedMessage = null;
    AuditLogSeverity severity = logType.getSeverity();
    AuditLog auditLog = null;
    // handle external log messages invoked by plugins via the API
    if (auditLogable.isExternal()) {
        // message is sent as an argument, no need to resolve.
        resolvedMessage = message = loggerString;
        String username = null;
        if (auditLogable.getUserId() != null) {
            DbUser user = getDbFacadeInstance().getDbUserDao().get(auditLogable.getUserId());
            if (user != null) {
                username = user.getLoginName() + "@" + user.getDomain();
            }
        }
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), username, auditLogable.getVmIdRef(), auditLogable.getVmIdRef() != null ? getDbFacadeInstance().getVmDao().get(auditLogable.getVmIdRef()).getName() : null, auditLogable.getVdsIdRef(), auditLogable.getVdsIdRef() != null ? getDbFacadeInstance().getVdsDao().get(auditLogable.getVdsIdRef()).getName() : null, auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateIdRef() != null ? getDbFacadeInstance().getVmTemplateDao().get(auditLogable.getVmTemplateIdRef()).getName() : null, auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
    } else if ((message = messages.get(logType)) != null) {
        // Application log message from AuditLogMessages
        resolvedMessage = resolveMessage(message, auditLogable);
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName() + "@" + auditLogable.getProfileName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
    }
    if (auditLog != null) {
        auditLog.setStorageDomainId(auditLogable.getStorageDomainId());
        auditLog.setStorageDomainName(auditLogable.getStorageDomainName());
        auditLog.setStoragePoolId(auditLogable.getStoragePoolId());
        auditLog.setStoragePoolName(auditLogable.getStoragePoolName());
        auditLog.setVdsGroupId(auditLogable.getVdsGroupId());
        auditLog.setVdsGroupName(auditLogable.getVdsGroupName());
        auditLog.setCorrelationId(auditLogable.getCorrelationId());
        auditLog.setJobId(auditLogable.getJobId());
        auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
        auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
        auditLog.setExternal(auditLogable.isExternal());
        auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
        auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
        auditLog.setCallStack(auditLogable.getCallStack());
        auditLog.setRepeatable(auditLogable.isRepeatable());
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        String logMessage;
        if (!"".equals(loggerString)) {
            logMessage = MessageFormat.format(loggerString.replaceAll("'", ""), resolvedMessage);
        } else {
            logMessage = auditLog.toStringForLogging();
        }
        switch(severity) {
            case NORMAL:
                log.info(logMessage);
                break;
            case ERROR:
                log.error(logMessage);
                break;
            case ALERT:
            case WARNING:
                log.warn(logMessage);
                break;
        }
    }
}
#method_after
private static void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    String message = null;
    String resolvedMessage = null;
    AuditLogSeverity severity = logType.getSeverity();
    AuditLog auditLog = null;
    // handle external log messages invoked by plugins via the API
    if (auditLogable.isExternal()) {
        // message is sent as an argument, no need to resolve.
        resolvedMessage = message = loggerString;
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmIdRef() != null ? getDbFacadeInstance().getVmDao().get(auditLogable.getVmIdRef()).getName() : null, auditLogable.getVdsIdRef(), auditLogable.getVdsIdRef() != null ? getDbFacadeInstance().getVdsDao().get(auditLogable.getVdsIdRef()).getName() : null, auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateIdRef() != null ? getDbFacadeInstance().getVmTemplateDao().get(auditLogable.getVmTemplateIdRef()).getName() : null, auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
    } else if ((message = messages.get(logType)) != null) {
        // Application log message from AuditLogMessages
        resolvedMessage = resolveMessage(message, auditLogable);
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
    }
    if (auditLog != null) {
        auditLog.setStorageDomainId(auditLogable.getStorageDomainId());
        auditLog.setStorageDomainName(auditLogable.getStorageDomainName());
        auditLog.setStoragePoolId(auditLogable.getStoragePoolId());
        auditLog.setStoragePoolName(auditLogable.getStoragePoolName());
        auditLog.setVdsGroupId(auditLogable.getVdsGroupId());
        auditLog.setVdsGroupName(auditLogable.getVdsGroupName());
        auditLog.setCorrelationId(auditLogable.getCorrelationId());
        auditLog.setJobId(auditLogable.getJobId());
        auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
        auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
        auditLog.setExternal(auditLogable.isExternal());
        auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
        auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
        auditLog.setCallStack(auditLogable.getCallStack());
        auditLog.setRepeatable(auditLogable.isRepeatable());
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        String logMessage;
        if (!"".equals(loggerString)) {
            logMessage = MessageFormat.format(loggerString.replaceAll("'", ""), resolvedMessage);
        } else {
            logMessage = auditLog.toStringForLogging();
        }
        switch(severity) {
            case NORMAL:
                log.info(logMessage);
                break;
            case ERROR:
                log.error(logMessage);
                break;
            case ALERT:
            case WARNING:
                log.warn(logMessage);
                break;
        }
    }
}
#end_block

#method_before
public String getUserName() {
    if (StringUtils.isEmpty(mUserName) && getCurrentUser() != null) {
        mUserName = getCurrentUser().getLoginName();
    }
    return mUserName;
}
#method_after
public String getUserName() {
    if (StringUtils.isEmpty(mUserName) && getCurrentUser() != null) {
        mUserName = String.format("%s[%s]", getCurrentUser().getLoginName(), getCurrentUser().getDomain());
    }
    return mUserName;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    setUserName(getLoginUserName());
    setProfileName(getParameters().getProfileName());
    boolean autheticated = isUserCanBeAuthenticated();
    // only admin users can use LoginAdmin command
    if (autheticated) {
        autheticated = getCurrentUser().isAdmin();
        if (!autheticated) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        }
    }
    if (!autheticated) {
        logAutheticationFailure();
    }
    return autheticated;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean autheticated = super.canDoAction();
    // only admin users can use LoginAdmin command
    if (autheticated) {
        autheticated = getCurrentUser().isAdmin();
        if (!autheticated) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            logAutheticationFailure();
        }
    }
    return autheticated;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    setUserName(getLoginUserName());
    setProfileName(getParameters().getProfileName());
    boolean result = isUserCanBeAuthenticated();
    if (!result) {
        logAutheticationFailure();
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    String user = getParameters().getLoginName();
    if (StringUtils.isEmpty(user)) {
        ExtMap authRecord = (ExtMap) getParameters().getAuthRecord();
        if (authRecord != null) {
            user = authRecord.get(AuthRecord.PRINCIPAL);
        }
    }
    String profile = getParameters().getProfileName();
    if (StringUtils.isEmpty(profile)) {
        profile = "N/A";
    }
    setUserName(String.format("%s@%s", user, profile));
    boolean result = isUserCanBeAuthenticated();
    if (!result) {
        logAutheticationFailure();
    }
    return result;
}
#end_block

#method_before
private boolean attachUserToSession(AuthenticationProfile profile, ExtMap authRecord, ExtMap principalRecord) {
    try {
        byte[] s = new byte[64];
        SecureRandom.getInstance("SHA1PRNG").nextBytes(s);
        engineSessionId = new Base64(0).encodeToString(s);
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }
    SessionDataContainer.getInstance().setUser(engineSessionId, getCurrentUser());
    SessionDataContainer.getInstance().refresh(engineSessionId);
    SessionDataContainer.getInstance().setAuthn(engineSessionId, profile.getAuthn());
    SessionDataContainer.getInstance().setAuthRecord(engineSessionId, authRecord);
    SessionDataContainer.getInstance().setPrincipal(engineSessionId, authRecord.<String>get(Authn.AuthRecord.PRINCIPAL));
    SessionDataContainer.getInstance().setPrincipalRecord(engineSessionId, principalRecord);
    // when trying to log on to virtual machines:
    if (getParameters().getPassword() != null) {
        SessionDataContainer.getInstance().setPassword(engineSessionId, getParameters().getPassword());
    }
    int userSessionHardLimit = Config.<Integer>getValue(ConfigValues.UserSessionHardLimit);
    Date validTo = userSessionHardLimit != 0 ? DateUtils.addMinutes(new Date(), userSessionHardLimit) : null;
    if (authRecord.<String>get(AuthRecord.VALID_TO) != null) {
        try {
            Date fromExtension = new SimpleDateFormat("yyyyMMddHHmmssZ").parse(authRecord.<String>get(AuthRecord.VALID_TO));
            if (validTo != null) {
                validTo = validTo.compareTo(fromExtension) < 0 ? validTo : fromExtension;
            } else {
                validTo = fromExtension;
            }
        } catch (ParseException e) {
            log.warn("Error parsing AuthRecord.VALID_TO. Default VALID_TO value will be set on session: {}", e.getMessage());
            log.debug("Exception", e);
        }
    }
    SessionDataContainer.getInstance().setHardLimit(engineSessionId, validTo);
    return true;
}
#method_after
private boolean attachUserToSession(AuthenticationProfile profile, ExtMap authRecord, ExtMap principalRecord) {
    try {
        byte[] s = new byte[64];
        SecureRandom.getInstance("SHA1PRNG").nextBytes(s);
        engineSessionId = new Base64(0).encodeToString(s);
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }
    SessionDataContainer.getInstance().setUser(engineSessionId, getCurrentUser());
    SessionDataContainer.getInstance().refresh(engineSessionId);
    SessionDataContainer.getInstance().setProfile(engineSessionId, profile);
    SessionDataContainer.getInstance().setAuthRecord(engineSessionId, authRecord);
    SessionDataContainer.getInstance().setPrincipalRecord(engineSessionId, principalRecord);
    // when trying to log on to virtual machines:
    if (getParameters().getPassword() != null) {
        SessionDataContainer.getInstance().setPassword(engineSessionId, getParameters().getPassword());
    }
    int userSessionHardLimit = Config.<Integer>getValue(ConfigValues.UserSessionHardLimit);
    Date validTo = userSessionHardLimit != 0 ? DateUtils.addMinutes(new Date(), userSessionHardLimit) : null;
    if (authRecord.<String>get(AuthRecord.VALID_TO) != null) {
        try {
            Date fromExtension = new SimpleDateFormat("yyyyMMddHHmmssZ").parse(authRecord.<String>get(AuthRecord.VALID_TO));
            if (validTo != null) {
                validTo = validTo.compareTo(fromExtension) < 0 ? validTo : fromExtension;
            } else {
                validTo = fromExtension;
            }
        } catch (ParseException e) {
            log.warn("Error parsing AuthRecord.VALID_TO. Default VALID_TO value will be set on session: {}", e.getMessage());
            log.debug("Exception", e);
        }
    }
    SessionDataContainer.getInstance().setHardLimit(engineSessionId, validTo);
    return true;
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        log.error("Can't login because authentication profile '{}' doesn't exist.", getParameters().getProfileName());
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    ExtensionProxy authnExtension = profile.getAuthn();
    ExtMap authRecord = (ExtMap) getParameters().getAuthRecord();
    int reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
    if (getParameters().getAuthType() != null) {
        if (AuthType.NEGOTIATION == getParameters().getAuthType()) {
            reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_NEGOTIATE;
        }
    }
    String loginName = null;
    if (authRecord == null) {
        reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
        // Verify that the login name and password have been provided:
        loginName = getParameters().getLoginName();
        if (loginName == null) {
            log.error("Can't login user because no login name has been provided.");
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        String password = getParameters().getPassword();
        if (password == null) {
            log.error("Can't login user '{}' because no password has been provided.", loginName);
            return false;
        }
        if (!AuthzUtils.supportsPasswordAuthentication(authnExtension)) {
            log.error("Can't login user '{}' because the authentication profile '{}' doesn't support password" + " authentication.", loginName, profile.getName());
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        DbUser curUser = null;
        String curPassword = null;
        SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
        if (StringUtils.isEmpty(getParameters().getSessionId())) {
            curUser = sessionDataContainer.getUser(engineSessionId, false);
            curPassword = sessionDataContainer.getPassword(engineSessionId);
        } else {
            curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
            curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
        }
        // verify that in auto login mode , user is not taken from session.
        if (curUser != null && !StringUtils.isEmpty(curPassword)) {
            loginName = curUser.getLoginName();
            password = curPassword;
        }
        authRecord = authenticate(profile, loginName, password);
    }
    // Perform the actual authentication:
    if (authRecord == null) {
        return false;
    }
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
    if (principalRecord == null) {
        log.info("Can't login user '{}' with authentication profile '{}' because the user doesn't exist in the" + " directory.", authRecord.<String>get(Authn.AuthRecord.PRINCIPAL), profile.getName());
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_NOT_FOUND, loginName, authRecord, null, "Principal record was not found. User name is %1$s", loginName);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(AuthzUtils.getName(profile.getAuthz()), principalRecord);
    getDbUserDAO().saveOrUpdate(dbUser);
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_LOGIN_NO_PERMISSION, dbUser.getLoginName(), authRecord, principalRecord, "The user %1$s is not authorized to perform login", dbUser.getLoginName());
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debug("Checking if user '{}' is an admin, result {}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    AcctUtils.reportRecords(reportReason, dbUser.getLoginName(), authRecord, principalRecord, "User %1$s which has princnipal name %2$s logged in ", dbUser.getLoginName(), principalRecord.<String>get(Authz.PrincipalRecord.NAME));
    return attachUserToSession(profile, authRecord, principalRecord);
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        log.error("Can't login because authentication profile '{}' doesn't exist.", getParameters().getProfileName());
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    ExtensionProxy authnExtension = profile.getAuthn();
    ExtMap authRecord = (ExtMap) getParameters().getAuthRecord();
    int reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
    if (getParameters().getAuthType() != null) {
        if (AuthType.NEGOTIATION == getParameters().getAuthType()) {
            reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_NEGOTIATE;
        }
    }
    String loginName = null;
    if (authRecord == null) {
        reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
        // Verify that the login name and password have been provided:
        loginName = getParameters().getLoginName();
        if (loginName == null) {
            log.error("Can't login user because no login name has been provided.");
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        String password = getParameters().getPassword();
        if (password == null) {
            log.error("Can't login user '{}' because no password has been provided.", loginName);
            return false;
        }
        if (!AuthzUtils.supportsPasswordAuthentication(authnExtension)) {
            log.error("Can't login user '{}' because the authentication profile '{}' doesn't support password" + " authentication.", loginName, profile.getName());
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        DbUser curUser = null;
        String curPassword = null;
        SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
        if (StringUtils.isEmpty(getParameters().getSessionId())) {
            curUser = sessionDataContainer.getUser(engineSessionId, false);
            curPassword = sessionDataContainer.getPassword(engineSessionId);
        } else {
            curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
            curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
        }
        // verify that in auto login mode , user is not taken from session.
        if (curUser != null && !StringUtils.isEmpty(curPassword)) {
            loginName = curUser.getLoginName();
            password = curPassword;
        }
        authRecord = authenticate(profile, loginName, password);
    }
    // Perform the actual authentication:
    if (authRecord == null) {
        return false;
    }
    /*
         * set principal based on what we
         * have so far
         */
    setUserName(String.format("%s@%s", authRecord.get(Authn.AuthRecord.PRINCIPAL), profile.getName()));
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
    if (principalRecord == null) {
        log.info("Can't login user '{}' with authentication profile '{}' because the user doesn't exist in the" + " directory.", authRecord.<String>get(Authn.AuthRecord.PRINCIPAL), profile.getName());
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_NOT_FOUND, profile.getAuthzName(), loginName, authRecord, null, "Principal record was not found. User name is %1$s", loginName);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(AuthzUtils.getName(profile.getAuthz()), principalRecord);
    getDbUserDAO().saveOrUpdate(dbUser);
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_LOGIN_NO_PERMISSION, profile.getAuthzName(), dbUser.getLoginName(), authRecord, principalRecord, "The user %1$s is not authorized to perform login", dbUser.getLoginName());
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debug("Checking if user '{}' is an admin, result {}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    AcctUtils.reportRecords(reportReason, profile.getAuthzName(), dbUser.getLoginName(), authRecord, principalRecord, "User %1$s which has princnipal name %2$s logged in ", dbUser.getLoginName(), principalRecord.<String>get(Authz.PrincipalRecord.NAME));
    return attachUserToSession(profile, authRecord, principalRecord);
}
#end_block

#method_before
private void logEventForUser(String userName, AuditLogType auditLogType) {
    AuditLogableBase msg = new AuditLogableBase();
    msg.setUserName(userName + "@" + getProfileName());
    AuditLogDirector.log(msg, auditLogType);
}
#method_after
private void logEventForUser(String userName, AuditLogType auditLogType) {
    AuditLogableBase msg = new AuditLogableBase();
    msg.setUserName(userName);
    AuditLogDirector.log(msg, auditLogType);
}
#end_block

#method_before
protected void logAutheticationFailure() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.setUserName(getUserName() + "@" + getProfileName());
    AuditLogDirector.log(logable, AuditLogType.USER_VDC_LOGIN_FAILED);
}
#method_after
protected void logAutheticationFailure() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.setUserName(getUserName());
    AuditLogDirector.log(logable, AuditLogType.USER_VDC_LOGIN_FAILED);
}
#end_block

#method_before
private ExtMap authenticate(AuthenticationProfile profile, String user, String password) {
    ExtensionProxy authnExtension = profile.getAuthn();
    ExtMap authRecord = null;
    if (isCredentialsAuth(authnExtension)) {
        ExtensionProxy mapper = profile.getMapper();
        if (mapper != null) {
            user = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_USER).mput(Mapping.InvokeKeys.USER, user), true).<String>get(Mapping.InvokeKeys.USER, user);
        }
    }
    ExtMap outputMap = authnExtension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, password));
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    if (authResult != Authn.AuthResult.SUCCESS) {
        log.info("Can't login user '{}' with authentication profile '{}' because the authentication failed.", user, getParameters().getProfileName());
        AuditLogType auditLogType = auditLogMap.get(authResult);
        // anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            logEventForUser(user, auditLogType);
        }
        if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                addCanDoActionMessageVariable("URL", outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL));
                addedUserPasswordExpiredCDA = true;
            }
            if (outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                addCanDoActionMessageVariable("MSG", outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            VdcBllMessages msg = vdcBllMessagesMap.get(authResult);
            if (msg == null) {
                msg = VdcBllMessages.USER_FAILED_TO_AUTHENTICATE;
            }
            addCanDoActionMessage(msg);
        }
    } else {
        authRecord = outputMap.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD);
    }
    return authRecord;
}
#method_after
private ExtMap authenticate(AuthenticationProfile profile, String user, String password) {
    ExtensionProxy authnExtension = profile.getAuthn();
    ExtMap authRecord = null;
    if (isCredentialsAuth(authnExtension)) {
        ExtensionProxy mapper = profile.getMapper();
        if (mapper != null) {
            user = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_USER).mput(Mapping.InvokeKeys.USER, user), true).<String>get(Mapping.InvokeKeys.USER, user);
        }
    }
    ExtMap outputMap = authnExtension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, password));
    /*
         * set principal based on what we
         * have so far
         */
    if (outputMap.get(Authn.InvokeKeys.PRINCIPAL) != null) {
        setUserName(String.format("%s@%s", outputMap.get(Authn.InvokeKeys.PRINCIPAL), profile.getName()));
    }
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    if (authResult != Authn.AuthResult.SUCCESS) {
        log.info("Can't login user '{}' with authentication profile '{}' because the authentication failed.", user, getParameters().getProfileName());
        AuditLogType auditLogType = auditLogMap.get(authResult);
        // anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            logEventForUser(user, auditLogType);
        }
        if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                addCanDoActionMessageVariable("URL", outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL));
                addedUserPasswordExpiredCDA = true;
            }
            if (outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                addCanDoActionMessageVariable("MSG", outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            VdcBllMessages msg = vdcBllMessagesMap.get(authResult);
            if (msg == null) {
                msg = VdcBllMessages.USER_FAILED_TO_AUTHENTICATE;
            }
            addCanDoActionMessage(msg);
        }
    } else {
        authRecord = outputMap.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD);
    }
    return authRecord;
}
#end_block

#method_before
private boolean internalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = TransactionSupport.suspend();
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warn("CanDoAction of action '{}' failed for user {}@{}. Reasons: {}", getActionType(), getUserName(), getProfileName(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            TransactionSupport.resume(transaction);
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#method_after
private boolean internalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = TransactionSupport.suspend();
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warn("CanDoAction of action '{}' failed for user {}. Reasons: {}", getActionType(), getUserName(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            TransactionSupport.resume(transaction);
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
public void processOnClientIpChange(final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    final AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vmId);
    String username = vmDynamic.getConsoleCurrentUserName();
    event.setUserName(username);
    // (this happened when user close the console to spice/vnc)
    if (StringUtils.isEmpty(vmDynamic.getClientIp())) {
        vmDynamic.setConsoleCurrentUserName(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_DISCONNECTED);
    } else {
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_CONNECTED);
    }
}
#method_after
@Override
public void processOnClientIpChange(final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    final AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vmId);
    event.setUserName(vmDynamic.getConsoleCurrentUserName());
    // (this happened when user close the console to spice/vnc)
    if (StringUtils.isEmpty(vmDynamic.getClientIp())) {
        vmDynamic.setConsoleCurrentUserName(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_DISCONNECTED);
    } else {
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_CONNECTED);
    }
}
#end_block

#method_before
public static void endStep(ExecutionContext context, Step step, boolean exitStatus) {
    if (context == null) {
        return;
    }
    if (context.isMonitored()) {
        Job job = context.getJob();
        try {
            if (step != null) {
                step.markStepEnded(exitStatus);
                JobRepositoryFactory.getJobRepository().updateStep(step);
            }
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null && !exitStatus) {
                // step failure will cause the job to be marked as failed
                context.setCompleted(true);
                job.markJobEnded(false);
                JobRepositoryFactory.getJobRepository().updateCompletedJobAndSteps(job);
            } else {
                Step parentStep = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && parentStep != null) {
                    context.setCompleted(true);
                    if (!exitStatus && job != null) {
                        job.markJobEnded(false);
                        JobRepositoryFactory.getJobRepository().updateCompletedJobAndSteps(job);
                    }
                }
            }
        } catch (Exception e) {
            log.error("Exception", e);
        }
    }
}
#method_after
public static void endStep(ExecutionContext context, Step step, boolean exitStatus) {
    if (context == null) {
        return;
    }
    if (context.isMonitored()) {
        Job job = context.getJob();
        try {
            if (step != null) {
                step.markStepEnded(exitStatus);
                JobRepositoryFactory.getJobRepository().updateStep(step);
            }
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null && !exitStatus) {
                // step failure will cause the job to be marked as failed
                context.setCompleted(true);
                job.markJobEnded(false);
                JobRepositoryFactory.getJobRepository().updateCompletedJobAndSteps(job);
            } else {
                Step parentStep = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && parentStep != null) {
                    context.setCompleted(true);
                    if (job != null && !exitStatus) {
                        job.markJobEnded(false);
                        JobRepositoryFactory.getJobRepository().updateCompletedJobAndSteps(job);
                    }
                }
            }
        } catch (Exception e) {
            log.error("Exception", e);
        }
    }
}
#end_block

#method_before
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        validate(getVirtioRngValidator().canAddRngDevice(getVdsGroup(), getParameters().getRngDevice()));
    }
    if (!getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_ALREADY_EXISTS);
    }
    return true;
}
#method_after
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        if (!validate(getVirtioRngValidator().canAddRngDevice(getVdsGroup(), getParameters().getRngDevice()))) {
            return false;
        }
    }
    if (!getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_ALREADY_EXISTS);
    }
    return true;
}
#end_block

#method_before
public ValidationResult canAddRngDevice(VDSGroup cluster, VmRngDevice rngDevice) {
    VmRngDevice.Source source = rngDevice.getSource();
    boolean supported = cluster != null && isFeatureSupported(cluster.getcompatibility_version()) && cluster.getRequiredRngSources().contains(source);
    if (supported) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
}
#method_after
public ValidationResult canAddRngDevice(VDSGroup cluster, VmRngDevice rngDevice) {
    VmRngDevice.Source source = rngDevice.getSource();
    boolean supported = cluster != null && isFeatureSupported(cluster.getcompatibility_version()) && cluster.getRequiredRngSources().contains(source);
    if (!supported) {
        return new ValidationResult(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        validate(getVirtioRngValidator().canAddRngDevice(getVdsGroup(), getParameters().getRngDevice()));
    }
    if (getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_NOT_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        if (!validate(getVirtioRngValidator().canAddRngDevice(getVdsGroup(), getParameters().getRngDevice()))) {
            return false;
        }
    }
    if (getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_NOT_FOUND);
    }
    return true;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    setUpMockQueryParameters();
    setUpSpyQuery();
    for (MockConfigDescriptor<?> mcd : getExtraCofigDescriptors()) {
        mcr.mockConfigValue(mcd);
    }
}
#method_after
@Before
public void setUp() throws Exception {
    setUpMockQueryParameters();
    setUpSpyQuery();
    for (MockConfigDescriptor<?> mcd : getExtraConfigDescriptors()) {
        mcr.mockConfigValue(mcd);
    }
}
#end_block

#method_before
protected boolean validateFreeSpace(StorageDomainValidator storageDomainValidator, List<DiskImage> disksList) {
    return validate(storageDomainValidator.hasSpaceForNewDisks(disksList));
}
#method_after
protected boolean validateFreeSpace(StorageDomainValidator storageDomainValidator, List<DiskImage> disksList) {
    Collection<DiskImage> disks = ImagesHandler.getDisksDummiesForStorageAllocations(disksList);
    return validate(storageDomainValidator.hasSpaceForNewDisks(disks));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getParameters().getNewVmId() != null && getVmStaticDao().get(getParameters().getNewVmId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    return true;
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic vmDynamic = new VmDynamic();
    vmDynamic.setId(getVmId());
    vmDynamic.setStatus(VMStatus.Down);
    vmDynamic.setVmHost("");
    vmDynamic.setVmIp("");
    vmDynamic.setVmFQDN("");
    vmDynamic.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    vmDynamic.setLastStopTime(new Date());
    getDbFacade().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic vmDynamic = new VmDynamic();
    vmDynamic.setId(getVmId());
    vmDynamic.setStatus(VMStatus.Down);
    vmDynamic.setVmHost("");
    vmDynamic.setVmIp("");
    vmDynamic.setVmFQDN("");
    vmDynamic.setLastStopTime(new Date());
    getDbFacade().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
private void onCloneVM() {
    UnitVmModel model = (UnitVmModel) getWindow();
    CloneVmFromSnapshotModelBehavior behavior = (CloneVmFromSnapshotModelBehavior) model.getBehavior();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    VM vm = behavior.getVm();
    // Save changes.
    buildVmOnClone(model, vm);
    vm.setCustomProperties(model.getCustomProperties().getEntity());
    vm.setUseHostCpuFlags(model.getHostCpu().getEntity());
    vm.setDiskMap(behavior.getVm().getDiskMap());
    HashMap<Guid, DiskImage> imageToDestinationDomainMap = model.getDisksAllocationModel().getImageToDestinationDomainMap();
    AddVmFromSnapshotParameters parameters = new AddVmFromSnapshotParameters(vm.getStaticData(), snapshot.getId());
    parameters.setDiskInfoDestinationMap(imageToDestinationDomainMap);
    setupAddVmFromSnapshotParameters(parameters);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    parameters.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    if (!StringHelper.isNullOrEmpty(model.getVmId().getEntity())) {
        parameters.setNewVmId(new Guid(model.getVmId().getEntity()));
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVmFromSnapshot, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmSnapshotListModel vmSnapshotListModel = (VmSnapshotListModel) result.getState();
            vmSnapshotListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmSnapshotListModel.cancel();
                vmSnapshotListModel.updateActionAvailability();
            }
        }
    }, this);
}
#method_after
private void onCloneVM() {
    UnitVmModel model = (UnitVmModel) getWindow();
    CloneVmFromSnapshotModelBehavior behavior = (CloneVmFromSnapshotModelBehavior) model.getBehavior();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    VM vm = behavior.getVm();
    // Save changes.
    buildVmOnClone(model, vm);
    vm.setCustomProperties(model.getCustomProperties().getEntity());
    vm.setUseHostCpuFlags(model.getHostCpu().getEntity());
    vm.setDiskMap(behavior.getVm().getDiskMap());
    HashMap<Guid, DiskImage> imageToDestinationDomainMap = model.getDisksAllocationModel().getImageToDestinationDomainMap();
    AddVmFromSnapshotParameters parameters = new AddVmFromSnapshotParameters(vm.getStaticData(), snapshot.getId());
    parameters.setDiskInfoDestinationMap(imageToDestinationDomainMap);
    setupAddVmFromSnapshotParameters(parameters);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    parameters.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    setGraphicsDevicesToParams(model, parameters);
    if (!StringHelper.isNullOrEmpty(model.getVmId().getEntity())) {
        parameters.setVmId(new Guid(model.getVmId().getEntity()));
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVmFromSnapshot, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmSnapshotListModel vmSnapshotListModel = (VmSnapshotListModel) result.getState();
            vmSnapshotListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmSnapshotListModel.cancel();
                vmSnapshotListModel.updateActionAvailability();
            }
        }
    }, this);
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(model.getTemplate().getSelectedItem() instanceof LatestVmTemplate);
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#end_block

#method_before
private void saveNewVm(final UnitVmModel model) {
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    VM vm = getcurrentVm();
    vm.setUseLatestVersion(model.getTemplate().getSelectedItem() instanceof LatestVmTemplate);
    AddVmParameters parameters = new AddVmParameters(vm);
    parameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setBalloonEnabled(balloonEnabled(model));
    parameters.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    setRngDeviceToParams(model, parameters);
    setGraphicsDevicesToParams(model, parameters);
    if (!StringHelper.isNullOrEmpty(model.getVmId().getEntity())) {
        parameters.setNewVmId(new Guid(model.getVmId().getEntity()));
    }
    Frontend.getInstance().runAction(model.getProvisioning().getEntity() ? VdcActionType.AddVmFromTemplate : VdcActionType.AddVm, parameters, createUnitVmModelNetworkAsyncCallback(vm, model), this);
}
#method_after
private void saveNewVm(final UnitVmModel model) {
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    VM vm = getcurrentVm();
    if (!StringHelper.isNullOrEmpty(model.getVmId().getEntity())) {
        vm.setId(new Guid(model.getVmId().getEntity()));
    }
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    AddVmParameters parameters = new AddVmParameters(vm);
    parameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setBalloonEnabled(balloonEnabled(model));
    parameters.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    setRngDeviceToParams(model, parameters);
    setGraphicsDevicesToParams(model, parameters);
    if (!StringHelper.isNullOrEmpty(model.getVmId().getEntity())) {
        parameters.setVmId(new Guid(model.getVmId().getEntity()));
    }
    Frontend.getInstance().runAction(model.getProvisioning().getEntity() ? VdcActionType.AddVmFromTemplate : VdcActionType.AddVm, parameters, createUnitVmModelNetworkAsyncCallback(vm, model), this);
}
#end_block

#method_before
public void cancel() {
    Frontend.getInstance().unsubscribe();
    cancelConfirmation();
    setGuideContext(null);
    setWindow(null);
    updateActionAvailability();
}
#method_after
public void cancel() {
    cancelConfirmation();
    setGuideContext(null);
    setWindow(null);
    updateActionAvailability();
}
#end_block

#method_before
public String getHibernationVolHandle() {
    return this.vmDynamic.getHibernationVolHandle();
}
#method_after
public String getHibernationVolHandle() {
    return hibernationVolHandle;
}
#end_block

#method_before
public void setHibernationVolHandle(String value) {
    this.vmDynamic.setHibernationVolHandle(value);
}
#method_after
public void setHibernationVolHandle(String value) {
    this.hibernationVolHandle = value;
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    getGraphicsInfos().putAll(vm.getGraphicsInfos());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    getGraphicsInfos().putAll(vm.getGraphicsInfos());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (guestAgentStatus == null ? 0 : guestAgentStatus.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    result = prime * result + (stopReason == null ? 0 : stopReason.hashCode());
    result = prime * result + exitReason.hashCode();
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + graphicsInfos.hashCode();
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (guestAgentStatus == null ? 0 : guestAgentStatus.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    result = prime * result + (stopReason == null ? 0 : stopReason.hashCode());
    result = prime * result + exitReason.hashCode();
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + graphicsInfos.hashCode();
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(guestAgentStatus, other.guestAgentStatus) && ObjectUtils.objectsEqual(currentCd, other.currentCd) && ObjectUtils.objectsEqual(stopReason, other.stopReason) && exitReason == other.exitReason && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine)) && ObjectUtils.objectsEqual(graphicsInfos, other.getGraphicsInfos());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(guestAgentStatus, other.guestAgentStatus) && ObjectUtils.objectsEqual(currentCd, other.currentCd) && ObjectUtils.objectsEqual(stopReason, other.stopReason) && exitReason == other.exitReason && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine)) && ObjectUtils.objectsEqual(graphicsInfos, other.getGraphicsInfos());
}
#end_block

#method_before
public static void refreshVmsToolsVersion(Guid poolId, Set<String> isoList) {
    // List<VM> vms = DbFacade.getInstance().getVmDao().getAllForVmPool(poolId);
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAllForStoragePool(poolId);
    for (VDSGroup cluster : clusters) {
        List<VM> vms = DbFacade.getInstance().getVmDao().getAllForVdsGroup(cluster.getId());
        for (VM vm : vms) {
            if (vm.getAppList() != null && vm.getAppList().toLowerCase().contains("rhev-tools")) {
                Matcher m = TOOLS_PATTERN.matcher(vm.getAppList().toLowerCase());
                if (m.matches()) {
                    GuestAgentStatus oldStatus = vm.getGuestAgentStatus();
                    GuestAgentStatus currStatus = getAgentStatus(m.group(1), isoList);
                    if (oldStatus != currStatus) {
                        vm.setGuestAgentStatus(currStatus);
                        DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
                    }
                }
            }
        }
    }
}
#method_after
public static void refreshVmsToolsVersion(Guid poolId, Set<String> isoList) {
    String latestVersion = getLatestGuestToolsVersion(isoList);
    if (latestVersion == null) {
        return;
    }
    List<VM> vms = DbFacade.getInstance().getVmDao().getAllForStoragePool(poolId);
    for (VM vm : vms) {
        if (vm.getAppList() != null && vm.getAppList().toLowerCase().contains("rhev-tools")) {
            Matcher m = TOOLS_PATTERN.matcher(vm.getAppList().toLowerCase());
            if (m.matches() && m.groupCount() > 0) {
                String toolsVersion = m.group(1);
                if (toolsVersion.compareTo(latestVersion) < 0 && vm.getGuestAgentStatus() != GuestAgentStatus.UpdateNeeded) {
                    vm.setGuestAgentStatus(GuestAgentStatus.UpdateNeeded);
                    DbFacade.getInstance().getVmDynamicDao().updateGuestAgentStatus(vm.getId(), vm.getGuestAgentStatus());
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    GraphicsInfo spice = vm.getGraphicsInfos().get(GraphicsType.SPICE);
    GraphicsInfo vnc = vm.getGraphicsInfos().get(GraphicsType.VNC);
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getAppList()).addValue("guest_cur_user_name", vm.getGuestCurrentUserName()).addValue("console_cur_user_name", vm.getConsoleCurrentUserName()).addValue("console_user_id", vm.getConsoleUserId()).addValue("guest_last_login_time", vm.getGuestLastLoginTime()).addValue("guest_last_logout_time", vm.getGuestLastLogoutTime()).addValue("guest_os", vm.getGuestOs()).addValue("migrating_to_vds", vm.getMigratingToVds()).addValue("run_on_vds", vm.getRunOnVds()).addValue("status", vm.getStatus()).addValue("vm_host", vm.getVmHost()).addValue("vm_ip", vm.getVmIp()).addValue("vm_fqdn", vm.getVmFQDN()).addValue("last_start_time", vm.getLastStartTime()).addValue("last_stop_time", vm.getLastStopTime()).addValue("vm_pid", vm.getVmPid()).addValue("display", vm.getDisplay()).addValue("acpi_enable", vm.getAcpiEnable()).addValue("session", vm.getSession()).addValue("display_ip", vm.getDisplayIp()).addValue("display_type", vm.getDisplayType()).addValue("kvm_enable", vm.getKvmEnable()).addValue("boot_sequence", vm.getBootSequence()).addValue("display_secure_port", vm.getDisplaySecurePort()).addValue("utc_diff", vm.getUtcDiff()).addValue("last_vds_run_on", vm.getLastVdsRunOn()).addValue("client_ip", vm.getClientIp()).addValue("guest_requested_memory", vm.getGuestRequestedMemory()).addValue("hibernation_vol_handle", vm.getHibernationVolHandle()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage()).addValue("hash", vm.getHash()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()).addValue("last_watchdog_event", vm.getLastWatchdogEvent()).addValue("last_watchdog_action", vm.getLastWatchdogAction()).addValue("is_run_once", vm.isRunOnce()).addValue("cpu_name", vm.getCpuName()).addValue("guest_agent_status", vm.getGuestAgentStatus().getValue()).addValue("current_cd", vm.getCurrentCd()).addValue("reason", vm.getStopReason()).addValue("exit_reason", vm.getExitReason().getValue()).addValue("guest_cpu_count", vm.getGuestCpuCount()).addValue("emulated_machine", vm.getEmulatedMachine()).addValue("spice_port", spice != null ? spice.getPort() : null).addValue("spice_tls_port", spice != null ? spice.getTlsPort() : null).addValue("spice_ip", spice != null ? spice.getIp() : null).addValue("vnc_port", vnc != null ? vnc.getPort() : null).addValue("vnc_ip", vnc != null ? vnc.getIp() : null);
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    GraphicsInfo spice = vm.getGraphicsInfos().get(GraphicsType.SPICE);
    GraphicsInfo vnc = vm.getGraphicsInfos().get(GraphicsType.VNC);
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getAppList()).addValue("guest_cur_user_name", vm.getGuestCurrentUserName()).addValue("console_cur_user_name", vm.getConsoleCurrentUserName()).addValue("console_user_id", vm.getConsoleUserId()).addValue("guest_last_login_time", vm.getGuestLastLoginTime()).addValue("guest_last_logout_time", vm.getGuestLastLogoutTime()).addValue("guest_os", vm.getGuestOs()).addValue("migrating_to_vds", vm.getMigratingToVds()).addValue("run_on_vds", vm.getRunOnVds()).addValue("status", vm.getStatus()).addValue("vm_host", vm.getVmHost()).addValue("vm_ip", vm.getVmIp()).addValue("vm_fqdn", vm.getVmFQDN()).addValue("last_start_time", vm.getLastStartTime()).addValue("last_stop_time", vm.getLastStopTime()).addValue("vm_pid", vm.getVmPid()).addValue("acpi_enable", vm.getAcpiEnable()).addValue("session", vm.getSession()).addValue("kvm_enable", vm.getKvmEnable()).addValue("boot_sequence", vm.getBootSequence()).addValue("utc_diff", vm.getUtcDiff()).addValue("last_vds_run_on", vm.getLastVdsRunOn()).addValue("client_ip", vm.getClientIp()).addValue("guest_requested_memory", vm.getGuestRequestedMemory()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage()).addValue("hash", vm.getHash()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()).addValue("last_watchdog_event", vm.getLastWatchdogEvent()).addValue("last_watchdog_action", vm.getLastWatchdogAction()).addValue("is_run_once", vm.isRunOnce()).addValue("cpu_name", vm.getCpuName()).addValue("guest_agent_status", vm.getGuestAgentStatus().getValue()).addValue("current_cd", vm.getCurrentCd()).addValue("reason", vm.getStopReason()).addValue("exit_reason", vm.getExitReason().getValue()).addValue("guest_cpu_count", vm.getGuestCpuCount()).addValue("emulated_machine", vm.getEmulatedMachine()).addValue("spice_port", spice != null ? spice.getPort() : null).addValue("spice_tls_port", spice != null ? spice.getTlsPort() : null).addValue("spice_ip", spice != null ? spice.getIp() : null).addValue("vnc_port", vnc != null ? vnc.getPort() : null).addValue("vnc_ip", vnc != null ? vnc.getIp() : null);
}
#end_block

#method_before
@Override
public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDynamic entity = new VmDynamic();
    entity.setAppList(rs.getString("app_list"));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
    VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(exitStatus);
    entity.setPauseStatus(pauseStatus);
    entity.setHash(rs.getString("hash"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setLastWatchdogAction(rs.getString("last_watchdog_action"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setGuestAgentStatus(GuestAgentStatus.forValue(rs.getInt("guest_agent_status")));
    entity.setCurrentCd(rs.getString("current_cd"));
    entity.setStopReason(rs.getString("reason"));
    VmExitReason exitReason = VmExitReason.forValue(rs.getInt("exit_reason"));
    entity.setExitReason(exitReason);
    entity.setGuestCpuCount(rs.getInt("guest_cpu_count"));
    entity.setEmulatedMachine(rs.getString("emulated_machine"));
    setGraphicsToEntity(rs, entity);
    return entity;
}
#method_after
@Override
public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDynamic entity = new VmDynamic();
    entity.setAppList(rs.getString("app_list"));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
    VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(exitStatus);
    entity.setPauseStatus(pauseStatus);
    entity.setHash(rs.getString("hash"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setLastWatchdogAction(rs.getString("last_watchdog_action"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setGuestAgentStatus(GuestAgentStatus.forValue(rs.getInt("guest_agent_status")));
    entity.setCurrentCd(rs.getString("current_cd"));
    entity.setStopReason(rs.getString("reason"));
    VmExitReason exitReason = VmExitReason.forValue(rs.getInt("exit_reason"));
    entity.setExitReason(exitReason);
    entity.setGuestCpuCount(rs.getInt("guest_cpu_count"));
    entity.setEmulatedMachine(rs.getString("emulated_machine"));
    setGraphicsToEntity(rs, entity);
    return entity;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    result = prime * result + (stopReason == null ? 0 : stopReason.hashCode());
    result = prime * result + exitReason.hashCode();
    result = prime * result + graphicsInfos.hashCode();
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    result = prime * result + (stopReason == null ? 0 : stopReason.hashCode());
    result = prime * result + exitReason.hashCode();
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + graphicsInfos.hashCode();
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd) && ObjectUtils.objectsEqual(stopReason, other.stopReason) && exitReason == other.exitReason) && ObjectUtils.objectsEqual(graphicsInfos, other.getGraphicsInfos());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd) && ObjectUtils.objectsEqual(stopReason, other.stopReason) && exitReason == other.exitReason && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine)) && ObjectUtils.objectsEqual(graphicsInfos, other.getGraphicsInfos());
}
#end_block

#method_before
@Override
public int compareTo(VmDynamic o) {
    return BusinessEntityGuidComparator.<VmDynamic>newInstance().compare(this, o);
}
#method_after
@Override
public int compareTo(VmDynamic o) {
    return BusinessEntityComparator.<VmDynamic, Guid>newInstance().compare(this, o);
}
#end_block

#method_before
public static Object clone(Object instance) {
    if (instance instanceof VM) {
        return cloneVM((VM) instance);
    }
    if (instance instanceof VDS) {
        return cloneVDS((VDS) instance);
    }
    if (instance instanceof VDSGroup) {
        return cloneVDSGroup((VDSGroup) instance);
    }
    if (instance instanceof StoragePool) {
        return cloneStorage_pool((StoragePool) instance);
    }
    if (instance instanceof Network) {
        return cloneNetwork((Network) instance);
    }
    if (instance instanceof NetworkCluster) {
        return cloneNetworkCluster((NetworkCluster) instance);
    }
    if (instance instanceof ProviderNetwork) {
        return cloneProviderNetwork((ProviderNetwork) instance);
    }
    if (instance instanceof VmPool) {
        return cloneVmPool((VmPool) instance);
    }
    if (instance instanceof StorageDomainStatic) {
        return cloneStorageDomainStatic((StorageDomainStatic) instance);
    }
    if (instance instanceof VmTemplate) {
        return cloneVmTemplate((VmTemplate) instance);
    }
    if (instance instanceof VmNetworkInterface) {
        return cloneVmNetworkInterface((VmNetworkInterface) instance);
    }
    if (instance instanceof VdsNetworkInterface) {
        return cloneVdsNetworkInterface((VdsNetworkInterface) instance);
    }
    if (instance instanceof VmStatic) {
        return cloneVmStatic((VmStatic) instance);
    }
    if (instance instanceof Version) {
        return cloneVersion((Version) instance);
    }
    if (instance instanceof ClusterPolicy) {
        return cloneClusterPolicy((ClusterPolicy) instance);
    }
    // Throw exception to determine development needs.
    throw new NotImplementedException();
}
#method_after
public static Object clone(Object instance) {
    if (instance instanceof VM) {
        return cloneVM((VM) instance);
    }
    if (instance instanceof VDS) {
        return cloneVDS((VDS) instance);
    }
    if (instance instanceof VDSGroup) {
        return cloneVDSGroup((VDSGroup) instance);
    }
    if (instance instanceof StoragePool) {
        return cloneStorage_pool((StoragePool) instance);
    }
    if (instance instanceof Network) {
        return cloneNetwork((Network) instance);
    }
    if (instance instanceof NetworkCluster) {
        return cloneNetworkCluster((NetworkCluster) instance);
    }
    if (instance instanceof ProviderNetwork) {
        return cloneProviderNetwork((ProviderNetwork) instance);
    }
    if (instance instanceof VmPool) {
        return cloneVmPool((VmPool) instance);
    }
    if (instance instanceof StorageDomainStatic) {
        return cloneStorageDomainStatic((StorageDomainStatic) instance);
    }
    if (instance instanceof VmTemplate) {
        return cloneVmTemplate((VmTemplate) instance);
    }
    if (instance instanceof VmNetworkInterface) {
        return cloneVmNetworkInterface((VmNetworkInterface) instance);
    }
    if (instance instanceof VmStatic) {
        return cloneVmStatic((VmStatic) instance);
    }
    if (instance instanceof Version) {
        return cloneVersion((Version) instance);
    }
    if (instance instanceof ClusterPolicy) {
        return cloneClusterPolicy((ClusterPolicy) instance);
    }
    // Throw exception to determine development needs.
    throw new NotImplementedException();
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.getGraphicsInfos().putAll(instance.getGraphicsInfos());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.getGraphicsInfos().putAll(instance.getGraphicsInfos());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    vm.setCustomCpuName(instance.getCustomCpuName());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    vm.setCpuProfileId(instance.getCpuProfileId());
    vm.setAutoConverge(instance.getAutoConverge());
    vm.setMigrateCompressed(instance.getMigrateCompressed());
    vm.setPredefinedProperties(instance.getPredefinedProperties());
    vm.setUserDefinedProperties(instance.getUserDefinedProperties());
    vm.setCustomProperties(instance.getCustomProperties());
    vm.setSingleQxlPci(instance.getSingleQxlPci());
    vm.setMinAllocatedMem(instance.getMinAllocatedMem());
    return vm;
}
#end_block

#method_before
private static Object cloneVDS(VDS instance) {
    VDS obj = new VDS();
    obj.setHostName(instance.getHostName());
    obj.setSshKeyFingerprint(instance.getSshKeyFingerprint());
    obj.setSshPort(instance.getSshPort());
    obj.setSshUsername(instance.getSshUsername());
    obj.setManagementIp(instance.getManagementIp());
    obj.setPmUser(instance.getPmUser());
    obj.setPmPassword(instance.getPmPassword());
    obj.setPmType(instance.getPmType());
    obj.setPmOptionsMap(instance.getPmOptionsMap());
    obj.setPmSecondaryIp(instance.getManagementIp());
    obj.setPmSecondaryUser(instance.getPmUser());
    obj.setPmSecondaryPassword(instance.getPmPassword());
    obj.setPmSecondaryType(instance.getPmType());
    obj.setPmSecondaryOptionsMap(instance.getPmOptionsMap());
    obj.setpm_enabled(instance.getpm_enabled());
    obj.setPmSecondaryConcurrent(instance.isPmSecondaryConcurrent());
    obj.setDisablePowerManagementPolicy(instance.isDisablePowerManagementPolicy());
    obj.setPmKdumpDetection(instance.isPmKdumpDetection());
    obj.setPort(instance.getPort());
    obj.setServerSslEnabled(instance.isServerSslEnabled());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setVdsName(instance.getName());
    obj.setVdsStrength(instance.getVdsStrength());
    obj.setVdsType(instance.getVdsType());
    obj.setUniqueId(instance.getUniqueId());
    obj.setVdsSpmPriority(instance.getVdsSpmPriority());
    return obj;
}
#method_after
private static Object cloneVDS(VDS instance) {
    VDS obj = new VDS();
    obj.setHostName(instance.getHostName());
    obj.setSshKeyFingerprint(instance.getSshKeyFingerprint());
    obj.setSshPort(instance.getSshPort());
    obj.setSshUsername(instance.getSshUsername());
    obj.setFenceAgents(cloneAgents(instance.getFenceAgents()));
    obj.setDisablePowerManagementPolicy(instance.isDisablePowerManagementPolicy());
    obj.setPmKdumpDetection(instance.isPmKdumpDetection());
    obj.setPort(instance.getPort());
    obj.setServerSslEnabled(instance.isServerSslEnabled());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setVdsName(instance.getName());
    obj.setVdsStrength(instance.getVdsStrength());
    obj.setVdsType(instance.getVdsType());
    obj.setUniqueId(instance.getUniqueId());
    obj.setVdsSpmPriority(instance.getVdsSpmPriority());
    return obj;
}
#end_block

#method_before
private static VDSGroup cloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setcpu_name(instance.getcpu_name());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    obj.setEmulatedMachine(instance.getEmulatedMachine());
    obj.setDetectEmulatedMachine(instance.isDetectEmulatedMachine());
    obj.setArchitecture(instance.getArchitecture());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setFencingPolicy(new FencingPolicy(instance.getFencingPolicy()));
    return obj;
}
#method_after
private static VDSGroup cloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setcpu_name(instance.getcpu_name());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    obj.setEmulatedMachine(instance.getEmulatedMachine());
    obj.setDetectEmulatedMachine(instance.isDetectEmulatedMachine());
    obj.setArchitecture(instance.getArchitecture());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setFencingPolicy(new FencingPolicy(instance.getFencingPolicy()));
    obj.setAutoConverge(instance.getAutoConverge());
    obj.setMigrateCompressed(instance.getMigrateCompressed());
    return obj;
}
#end_block

#method_before
private static StorageDomainStatic cloneStorageDomainStatic(StorageDomainStatic instance) {
    StorageDomainStatic obj = new StorageDomainStatic();
    obj.setConnection(instance.getConnection());
    obj.setId(instance.getId());
    obj.setStorage(instance.getStorage());
    obj.setStorageDomainType(instance.getStorageDomainType());
    obj.setStorageType(instance.getStorageType());
    obj.setStorageName(instance.getStorageName());
    obj.setStorageFormat(instance.getStorageFormat());
    return obj;
}
#method_after
private static StorageDomainStatic cloneStorageDomainStatic(StorageDomainStatic instance) {
    StorageDomainStatic obj = new StorageDomainStatic();
    obj.setConnection(instance.getConnection());
    obj.setId(instance.getId());
    obj.setStorage(instance.getStorage());
    obj.setStorageDomainType(instance.getStorageDomainType());
    obj.setStorageType(instance.getStorageType());
    obj.setStorageName(instance.getStorageName());
    obj.setStorageFormat(instance.getStorageFormat());
    obj.setWipeAfterDelete(instance.getWipeAfterDelete());
    return obj;
}
#end_block

#method_before
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setCreatedByUserId(instance.getCreatedByUserId());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    return obj;
}
#method_after
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    obj.setCustomCpuName(instance.getCustomCpuName());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setCreatedByUserId(instance.getCreatedByUserId());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    obj.setCpuProfileId(instance.getCpuProfileId());
    obj.setAutoConverge(instance.getAutoConverge());
    obj.setMigrateCompressed(instance.getMigrateCompressed());
    obj.setPredefinedProperties(instance.getPredefinedProperties());
    obj.setUserDefinedProperties(instance.getUserDefinedProperties());
    obj.setCustomProperties(instance.getCustomProperties());
    return obj;
}
#end_block

#method_before
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    return obj;
}
#method_after
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    obj.setCustomCpuName(instance.getCustomCpuName());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    obj.setCpuProfileId(instance.getCpuProfileId());
    obj.setAutoConverge(instance.getAutoConverge());
    obj.setMigrateCompressed(instance.getMigrateCompressed());
    obj.setPredefinedProperties(instance.getPredefinedProperties());
    obj.setUserDefinedProperties(instance.getUserDefinedProperties());
    obj.setCustomProperties(instance.getCustomProperties());
    return obj;
}
#end_block

#method_before
public String getHibernationVolHandle() {
    return this.vmDynamic.getHibernationVolHandle();
}
#method_after
public String getHibernationVolHandle() {
    return hibernationVolHandle;
}
#end_block

#method_before
public void setHibernationVolHandle(String value) {
    this.vmDynamic.setHibernationVolHandle(value);
}
#method_after
public void setHibernationVolHandle(String value) {
    this.hibernationVolHandle = value;
}
#end_block

#method_before
public void updateRunTimeStatisticsData(VmStatistics vmStatistics, VM vm) {
    setElapsedTime(vmStatistics.getelapsed_time());
    setUsageNetworkPercent(vmStatistics.getusage_network_percent());
    vm.getStatisticsData().setDisksUsage(vmStatistics.getDisksUsage());
    // -------- cpu --------------
    setCpuSys(vmStatistics.getcpu_sys());
    setCpuUser(vmStatistics.getcpu_user());
    if ((getCpuSys() != null) && (getCpuUser() != null)) {
        Double percent = (getCpuSys() + getCpuUser()) / vm.getNumOfCpus();
        setUsageCpuPercent(percent.intValue());
        if (getUsageCpuPercent() != null && getUsageCpuPercent() > 100) {
            setUsageCpuPercent(100);
        }
    }
    // -------- memory --------------
    setUsageMemPercent(vmStatistics.getusage_mem_percent());
    // -------- migration --------------
    setMigrationProgressPercent(vmStatistics.getMigrationProgressPercent());
}
#method_after
public void updateRunTimeStatisticsData(VmStatistics vmStatistics, VM vm) {
    Integer usageHistoryLimit = Config.getValue(ConfigValues.UsageHistoryLimit);
    setElapsedTime(vmStatistics.getelapsed_time());
    setUsageNetworkPercent(vmStatistics.getusage_network_percent());
    addNetworkUsageHistory(getUsageNetworkPercent(), usageHistoryLimit);
    vm.getStatisticsData().setDisksUsage(vmStatistics.getDisksUsage());
    // -------- cpu --------------
    setCpuSys(vmStatistics.getcpu_sys());
    setCpuUser(vmStatistics.getcpu_user());
    if ((getCpuSys() != null) && (getCpuUser() != null)) {
        Double percent = (getCpuSys() + getCpuUser()) / vm.getNumOfCpus();
        setUsageCpuPercent(percent.intValue());
        if (getUsageCpuPercent() != null && getUsageCpuPercent() > 100) {
            setUsageCpuPercent(100);
        }
    }
    addCpuUsageHistory(getUsageCpuPercent(), usageHistoryLimit);
    // -------- memory --------------
    setUsageMemPercent(vmStatistics.getusage_mem_percent());
    addMemoryUsageHistory(getUsageMemPercent(), usageHistoryLimit);
    // -------- migration --------------
    setMigrationProgressPercent(vmStatistics.getMigrationProgressPercent());
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + ((initializationType == null) ? 0 : initializationType.hashCode());
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuFlagsData == null) ? 0 : vdsGroupCpuFlagsData.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + vmtOsId;
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + ((initializationType == null) ? 0 : initializationType.hashCode());
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + vmtOsId;
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return isDedicatedVdsOnSameCluster(vmStaticFromParams);
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    if (!validateCustomProperties(vmStaticFromParams, reasons)) {
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return VmHandler.validateDedicatedVdsExistOnSameCluster(vmStaticFromParams, getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors(getParameters().graphicsTypesToBeSet()) && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getVdsGroup().getcompatibility_version(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getVdsGroup().getcompatibility_version(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
protected boolean validateFreeSpace(StorageDomainValidator storageDomainValidator, List<DiskImage> disksList) {
    return validate(storageDomainValidator.hasSpaceForNewDisks(disksList));
}
#method_after
protected boolean validateFreeSpace(StorageDomainValidator storageDomainValidator, List<DiskImage> disksList) {
    Collection<DiskImage> disks = ImagesHandler.getDisksDummiesForStorageAllocations(disksList);
    return validate(storageDomainValidator.hasSpaceForNewDisks(disks));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), getParameters().graphicsTypesToBeSet(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (vmFromParams.getId() != null && getVmStaticDao().get(vmFromParams.getId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    return true;
}
#end_block

#method_before
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.errorFormat("Can not find any default active domain for one of the disks of template with id : {0}", vmDisksSource.getId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#method_after
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.error("Can not find any default active domain for one of the disks of template with id '{}'", vmDisksSource.getId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#end_block

#method_before
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setvolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<Guid>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    return newImage;
}
#method_after
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setvolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<Guid>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    newImage.setDiskProfileId(image.getDiskProfileId());
    return newImage;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                        addGraphicsDevice();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmNumaNodes();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    addGraphicsDevice();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.error("Failed to add vm . The reasons are: {}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
private void addGraphicsDevice() {
    for (GraphicsType type : GraphicsType.values()) {
        GraphicsDevice graphicsDevice = getParameters().getGraphicsDevices().get(type);
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#method_after
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#end_block

#method_before
private void updateSmartCardDevices() {
    // add or remove the smartcard according to user request
    if (getVm().isSmartcardEnabled() != getVmTemplate().isSmartcardEnabled()) {
        VmDeviceUtils.updateSmartcardDevice(getVm().getId(), getVm().isSmartcardEnabled());
    }
}
#method_after
private void updateSmartCardDevices() {
    // if vm smartcard settings is different from device source's
    // add or remove the smartcard according to user request
    boolean smartcardOnDeviceSource = getInstanceTypeId() != null ? getInstanceType().isSmartcardEnabled() : getVmTemplate().isSmartcardEnabled();
    if (getVm().isSmartcardEnabled() != smartcardOnDeviceSource) {
        VmDeviceUtils.updateSmartcardDevice(getVm().getId(), getVm().isSmartcardEnabled());
    }
}
#end_block

#method_before
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getType(), payload.getSpecParams(), true, true, null);
    }
}
#method_after
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null);
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
    if (instanceTypeId != null) {
        copyDiskDevicesFromTemplate();
    }
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setLastStopTime(new Date());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic vmDynamic = new VmDynamic();
    vmDynamic.setId(getVmId());
    vmDynamic.setStatus(VMStatus.Down);
    vmDynamic.setVmHost("");
    vmDynamic.setVmIp("");
    vmDynamic.setVmFQDN("");
    vmDynamic.setLastStopTime(new Date());
    getDbFacade().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? (getReturnValue().getVdsmTaskIdList().size() > 0 ? AuditLogType.USER_ADD_VM_STARTED : AuditLogType.USER_ADD_VM) : AuditLogType.USER_FAILED_ADD_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
        default:
            return AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? (!getReturnValue().getVdsmTaskIdList().isEmpty() ? AuditLogType.USER_ADD_VM_STARTED : AuditLogType.USER_ADD_VM) : AuditLogType.USER_FAILED_ADD_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
        default:
            return AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
    }
}
#end_block

#method_before
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (instanceTypeId != null && !checkInstanceTypeImagePermissions(instanceTypeId)) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance on the cluster is enough
        if (permSubject.getObjectType() == VdcObjectType.VdsGroups && instanceTypeId != null) {
            permSubject.setActionGroup(ActionGroup.CREATE_INSTANCE);
            if (checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
                continue;
            }
            // create_vm is overriding in case no create_instance, try again with it
            permSubject.setActionGroup(getActionType().getActionGroup());
        }
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (getInstanceTypeId() != null && !checkInstanceTypeImagePermissions(getInstanceTypeId())) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance on the cluster is enough
        if (permSubject.getObjectType() == VdcObjectType.VdsGroups && getInstanceTypeId() != null) {
            permSubject.setActionGroup(ActionGroup.CREATE_INSTANCE);
            if (checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
                continue;
            }
            // create_vm is overriding in case no create_instance, try again with it
            permSubject.setActionGroup(getActionType().getActionGroup());
        }
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getCurrentUser().getId(), false);
    for (Permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getad_element_id(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM);
    }
}
#method_after
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getEngineSessionSeqId(), false);
    for (Permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getad_element_id(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM);
    }
}
#end_block

#method_before
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permissions[] permsArray = new Permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permissions(getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permissions[] permsArray = new Permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permissions(getUserIdOfDiskOperator(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        DisplayType defaultDisplayType = osRepository.getGraphicsAndDisplays(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version()).get(0).getSecond();
        getParameters().getVmStaticData().setDefaultDisplayType(defaultDisplayType);
    }
}
#method_after
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        autoSelectDefaultDisplayType(getVmTemplateId());
    }
}
#end_block

#method_before
protected boolean checkNumberOfMonitors(Collection<GraphicsType> graphicsTypes) {
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return VmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors, getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkNumberOfMonitors() {
    Collection<GraphicsType> graphicsTypes = VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices());
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return VmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors, getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    GraphicsInfo spice = vm.getGraphicsInfos().get(GraphicsType.SPICE);
    GraphicsInfo vnc = vm.getGraphicsInfos().get(GraphicsType.VNC);
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getAppList()).addValue("guest_cur_user_name", vm.getGuestCurrentUserName()).addValue("console_cur_user_name", vm.getConsoleCurrentUserName()).addValue("console_user_id", vm.getConsoleUserId()).addValue("guest_last_login_time", vm.getGuestLastLoginTime()).addValue("guest_last_logout_time", vm.getGuestLastLogoutTime()).addValue("guest_os", vm.getGuestOs()).addValue("migrating_to_vds", vm.getMigratingToVds()).addValue("run_on_vds", vm.getRunOnVds()).addValue("status", vm.getStatus()).addValue("vm_host", vm.getVmHost()).addValue("vm_ip", vm.getVmIp()).addValue("vm_fqdn", vm.getVmFQDN()).addValue("last_start_time", vm.getLastStartTime()).addValue("last_stop_time", vm.getLastStopTime()).addValue("vm_pid", vm.getVmPid()).addValue("acpi_enable", vm.getAcpiEnable()).addValue("session", vm.getSession()).addValue("kvm_enable", vm.getKvmEnable()).addValue("boot_sequence", vm.getBootSequence()).addValue("utc_diff", vm.getUtcDiff()).addValue("last_vds_run_on", vm.getLastVdsRunOn()).addValue("client_ip", vm.getClientIp()).addValue("guest_requested_memory", vm.getGuestRequestedMemory()).addValue("hibernation_vol_handle", vm.getHibernationVolHandle()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage()).addValue("hash", vm.getHash()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()).addValue("last_watchdog_event", vm.getLastWatchdogEvent()).addValue("last_watchdog_action", vm.getLastWatchdogAction()).addValue("is_run_once", vm.isRunOnce()).addValue("cpu_name", vm.getCpuName()).addValue("current_cd", vm.getCurrentCd()).addValue("reason", vm.getStopReason()).addValue("exit_reason", vm.getExitReason().getValue()).addValue("guest_cpu_count", vm.getGuestCpuCount()).addValue("spice_port", spice != null ? spice.getPort() : null).addValue("spice_tls_port", spice != null ? spice.getTlsPort() : null).addValue("spice_ip", spice != null ? spice.getIp() : null).addValue("vnc_port", vnc != null ? vnc.getPort() : null).addValue("vnc_ip", vnc != null ? vnc.getIp() : null);
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    GraphicsInfo spice = vm.getGraphicsInfos().get(GraphicsType.SPICE);
    GraphicsInfo vnc = vm.getGraphicsInfos().get(GraphicsType.VNC);
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getAppList()).addValue("guest_cur_user_name", vm.getGuestCurrentUserName()).addValue("console_cur_user_name", vm.getConsoleCurrentUserName()).addValue("console_user_id", vm.getConsoleUserId()).addValue("guest_last_login_time", vm.getGuestLastLoginTime()).addValue("guest_last_logout_time", vm.getGuestLastLogoutTime()).addValue("guest_os", vm.getGuestOs()).addValue("migrating_to_vds", vm.getMigratingToVds()).addValue("run_on_vds", vm.getRunOnVds()).addValue("status", vm.getStatus()).addValue("vm_host", vm.getVmHost()).addValue("vm_ip", vm.getVmIp()).addValue("vm_fqdn", vm.getVmFQDN()).addValue("last_start_time", vm.getLastStartTime()).addValue("last_stop_time", vm.getLastStopTime()).addValue("vm_pid", vm.getVmPid()).addValue("acpi_enable", vm.getAcpiEnable()).addValue("session", vm.getSession()).addValue("kvm_enable", vm.getKvmEnable()).addValue("boot_sequence", vm.getBootSequence()).addValue("utc_diff", vm.getUtcDiff()).addValue("last_vds_run_on", vm.getLastVdsRunOn()).addValue("client_ip", vm.getClientIp()).addValue("guest_requested_memory", vm.getGuestRequestedMemory()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage()).addValue("hash", vm.getHash()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()).addValue("last_watchdog_event", vm.getLastWatchdogEvent()).addValue("last_watchdog_action", vm.getLastWatchdogAction()).addValue("is_run_once", vm.isRunOnce()).addValue("cpu_name", vm.getCpuName()).addValue("current_cd", vm.getCurrentCd()).addValue("reason", vm.getStopReason()).addValue("exit_reason", vm.getExitReason().getValue()).addValue("guest_cpu_count", vm.getGuestCpuCount()).addValue("emulated_machine", vm.getEmulatedMachine()).addValue("spice_port", spice != null ? spice.getPort() : null).addValue("spice_tls_port", spice != null ? spice.getTlsPort() : null).addValue("spice_ip", spice != null ? spice.getIp() : null).addValue("vnc_port", vnc != null ? vnc.getPort() : null).addValue("vnc_ip", vnc != null ? vnc.getIp() : null);
}
#end_block

#method_before
@Override
public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDynamic entity = new VmDynamic();
    entity.setAppList(rs.getString("app_list"));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
    VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(exitStatus);
    entity.setPauseStatus(pauseStatus);
    entity.setHash(rs.getString("hash"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setLastWatchdogAction(rs.getString("last_watchdog_action"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setCurrentCd(rs.getString("current_cd"));
    entity.setStopReason(rs.getString("reason"));
    VmExitReason exitReason = VmExitReason.forValue(rs.getInt("exit_reason"));
    entity.setExitReason(exitReason);
    entity.setGuestCpuCount(rs.getInt("guest_cpu_count"));
    setGraphicsToEntity(rs, entity);
    return entity;
}
#method_after
@Override
public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDynamic entity = new VmDynamic();
    entity.setAppList(rs.getString("app_list"));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
    VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(exitStatus);
    entity.setPauseStatus(pauseStatus);
    entity.setHash(rs.getString("hash"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setLastWatchdogAction(rs.getString("last_watchdog_action"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setCurrentCd(rs.getString("current_cd"));
    entity.setStopReason(rs.getString("reason"));
    VmExitReason exitReason = VmExitReason.forValue(rs.getInt("exit_reason"));
    entity.setExitReason(exitReason);
    entity.setGuestCpuCount(rs.getInt("guest_cpu_count"));
    entity.setEmulatedMachine(rs.getString("emulated_machine"));
    setGraphicsToEntity(rs, entity);
    return entity;
}
#end_block

#method_before
RequestBuilder createRequest() {
    RequestBuilder builder = new RequestBuilder(RequestBuilder.GET, restApiBaseUrl);
    // Control REST API session timeout
    // $NON-NLS-1$
    builder.setHeader("Session-TTL", restApiSessionTimeout);
    // Express additional preferences for serving this request
    // $NON-NLS-1$
    builder.setHeader(PREFER_HEADER, "persistent-auth, csrf-protection");
    // Add CSRF token, this is needed due to Prefer:csrf-protection
    if (restApiSessionId != null) {
        builder.setHeader(CSRF_HEADER, restApiSessionId);
    }
    return builder;
}
#method_after
RequestBuilder createRequest(String engineAuthToken) {
    RequestBuilder builder = createRequest();
    // Enforce expiry of existing session when acquiring new session
    String preferValue = builder.getHeader(PREFER_HEADER);
    // $NON-NLS-1$
    builder.setHeader(PREFER_HEADER, preferValue + ", new-auth");
    // Map this (physical) REST API session to current user's (logical) Engine session
    builder.setHeader(ENGINE_AUTH_TOKEN_HEADER, engineAuthToken);
    return builder;
}
#end_block

#method_before
void scheduleKeepAliveHeartbeat() {
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            boolean sessionInUse = restApiSessionId != null;
            if (sessionInUse && refreshRestApiSession) {
                // The browser takes care of sending JSESSIONID cookie for this request automatically
                sendRequest(createKeepAliveRequest(), new RestApiRequestCallback());
                // Reset the refresh flag
                refreshRestApiSession = false;
            }
            // Proceed with the heartbeat only when the session is still in use
            return sessionInUse;
        }
    }, SESSION_HEARTBEAT_MS);
}
#method_after
void scheduleKeepAliveHeartbeat() {
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            boolean sessionInUse = restApiSessionId != null;
            if (sessionInUse && refreshRestApiSession) {
                // The browser takes care of sending JSESSIONID cookie for this request automatically
                sendRequest(createRequest(), new RestApiRequestCallback());
                // Reset the refresh flag
                refreshRestApiSession = false;
            }
            // Proceed with the heartbeat only when the session is still in use
            return sessionInUse;
        }
    }, SESSION_HEARTBEAT_MS);
}
#end_block

#method_before
public void acquireSession(String engineAuthToken) {
    sendRequest(createNewSessionRequest(engineAuthToken), new RestApiRequestCallback() {

        @Override
        protected void processResponse(Response response) {
            // Obtain session ID from response header, as we're unable to access the
            // JSESSIONID cookie directly (cookie is set for REST API specific path)
            String sessionIdFromHeader = HttpUtils.getHeader(response, SESSION_ID_HEADER);
            if (sessionIdFromHeader != null) {
                setSessionId(sessionIdFromHeader, true);
            }
            reuseSession();
        }
    });
}
#method_after
public void acquireSession(String engineAuthToken) {
    sendRequest(createRequest(engineAuthToken), new RestApiRequestCallback() {

        @Override
        protected void processResponse(Response response) {
            // Obtain session ID from response header, as we're unable to access the
            // JSESSIONID cookie directly (cookie is set for REST API specific path)
            String sessionIdFromHeader = HttpUtils.getHeader(response, SESSION_ID_HEADER);
            if (sessionIdFromHeader != null) {
                setSessionId(sessionIdFromHeader, true);
            }
            reuseSession();
        }
    });
}
#end_block

#method_before
private boolean addOperation(final VdcOperation<?, ?> operation, final boolean isPublic) {
    // If the user is logged in, or the user is not logged in and the operation does not allow duplicates (aka
    // it is a query, and not an action). And the operation is not already in the queue || the operation is
    // an action (allows duplicates). Then add this operation to the queue, and process the queue immediately.
    final boolean isAllowedToExecute = loggedIn || isPublic;
    final boolean operationCanBeAdded = !operationQueue.contains(operation) || operation.allowDuplicates();
    if (isAllowedToExecute) {
        if (operationCanBeAdded && operationQueue.add(operation)) {
            processor.processOperation(this);
            for (OperationCallback callback : operationCallbacks) {
                callback.operationExecuted(operation);
            }
        }
    }
    return isAllowedToExecute;
}
#method_after
private boolean addOperation(final VdcOperation<?, ?> operation, final boolean isPublic) {
    // If the user is logged in, or the user is not logged in and the operation does not allow duplicates (aka
    // it is a query, and not an action). And the operation is not already in the queue || the operation is
    // an action (allows duplicates). Then add this operation to the queue, and process the queue immediately.
    final boolean isAllowedToExecute = loggedIn || isPublic;
    final boolean operationCanBeAdded = !operationQueue.contains(operation) || operation.allowDuplicates();
    if (isAllowedToExecute) {
        if (operationCanBeAdded && operationQueue.add(operation)) {
            processor.processOperation(this);
            if (engineSessionRefreshed(operation)) {
                EngineSessionRefreshedEvent.fire(eventBus);
            }
        }
    }
    return isAllowedToExecute;
}
#end_block

#method_before
@Override
public void requestSuggestions(Request request, Callback callback) {
    List<RenderableSuggestion<T>> suggestions = new ArrayList<RenderableSuggestion<T>>();
    String query = request.getQuery();
    for (T row : data) {
        RenderableSuggestion<T> suggestionCandidate = new RenderableSuggestion<T>(row, renderer);
        if (this.matcher.match(query, suggestionCandidate.getReplacementString(), suggestionCandidate.getDisplayString())) {
            suggestions.add(suggestionCandidate);
        }
    }
    callback.onSuggestionsReady(request, new Response(suggestions));
}
#method_after
@Override
public void requestSuggestions(Request request, Callback callback) {
    List<RenderableSuggestion<T>> suggestions = new ArrayList<RenderableSuggestion<T>>();
    String query = request.getQuery();
    for (T row : data) {
        RenderableSuggestion<T> suggestionCandidate = new RenderableSuggestion<T>(row, renderer);
        if (this.matcher.match(query, suggestionCandidate)) {
            suggestions.add(suggestionCandidate);
        }
    }
    callback.onSuggestionsReady(request, new Response(suggestions));
}
#end_block

#method_before
@Override
public boolean match(String query, String replacementString, String displayString) {
    if (replacementString == null || query == null) {
        return false;
    }
    return replacementString.toLowerCase().startsWith(query.toLowerCase());
}
#method_after
@Override
public boolean match(String query, MultiWordSuggestOracle.MultiWordSuggestion suggestion) {
    if (suggestion.getReplacementString() == null || query == null) {
        return false;
    }
    return suggestion.getReplacementString().toLowerCase().startsWith(query.toLowerCase());
}
#end_block

#method_before
@Override
public boolean match(String query, String replacementString, String displayString) {
    if (replacementString == null || query == null) {
        return false;
    }
    final String lowerQuery = query.toLowerCase();
    final String lowerReplacement = replacementString.toLowerCase();
    // $NON-NLS-1$
    final String[] querySegments = lowerQuery.split("\\s");
    for (String querySegment : querySegments) {
        if (!lowerReplacement.contains(querySegment)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean match(String query, MultiWordSuggestOracle.MultiWordSuggestion suggestion) {
    if (suggestion.getReplacementString() == null || query == null) {
        return false;
    }
    final String lowerQuery = query.toLowerCase();
    final String lowerReplacement = suggestion.getReplacementString().toLowerCase();
    // $NON-NLS-1$
    final String[] querySegments = lowerQuery.split("\\s");
    for (String querySegment : querySegments) {
        if (!lowerReplacement.contains(querySegment)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void discoverHostName_SelectedItemChanged() {
    if (Boolean.TRUE.equals(getIsDiscoveredHosts().getEntity())) {
        ExternalDiscoveredHost dhost = (ExternalDiscoveredHost) getExternalDiscoveredHosts().getSelectedItem();
        ExternalHostGroup dhg = (ExternalHostGroup) getExternalHostGroups().getSelectedItem();
        if (dhost != null && dhg != null) {
            setOriginalName(dhost.getName());
            getName().setEntity(dhost.getName());
            // $NON-NLS-1$
            getHost().setEntity(dhost.getName() + "." + dhg.getDomainName());
        }
    }
}
#method_after
private void discoverHostName_SelectedItemChanged() {
    if (Boolean.TRUE.equals(getIsDiscoveredHosts().getEntity())) {
        ExternalDiscoveredHost dhost = (ExternalDiscoveredHost) getExternalDiscoveredHosts().getSelectedItem();
        ExternalHostGroup dhg = (ExternalHostGroup) getExternalHostGroups().getSelectedItem();
        if (dhost != null && dhg != null) {
            setOriginalName(dhost.getName());
            getName().setEntity(dhost.getName());
            getHost().setEntity(// $NON-NLS-1$
            dhost.getName() + "." + // $NON-NLS-1$
            (dhg.getDomainName() != null ? dhg.getDomainName() : ""));
        }
    }
}
#end_block

#method_before
private void externalHostGroups_SelectedItemChanged() {
    ExternalHostGroup dhg = (ExternalHostGroup) getExternalHostGroups().getSelectedItem();
    if (dhg != null) {
        // $NON-NLS-1$
        getHost().setEntity(getName().getEntity() + "." + dhg.getDomainName());
    }
}
#method_after
private void externalHostGroups_SelectedItemChanged() {
    ExternalHostGroup dhg = (ExternalHostGroup) getExternalHostGroups().getSelectedItem();
    if (dhg != null) {
        getHost().setEntity(// $NON-NLS-1$
        getName().getEntity() + "." + // $NON-NLS-1$
        (dhg.getDomainName() != null ? dhg.getDomainName() : ""));
    }
}
#end_block

#method_before
protected boolean validateFreeSpace(StorageDomainValidator storageDomainValidator, List<DiskImage> disksList) {
    // This change is for storage allocation validations, "real" override for these values is done in CreateSnapshotCommand.
    for (DiskImage disk : disksList) {
        disk.setVolumeType(VolumeType.Sparse);
        disk.setvolumeFormat(VolumeFormat.COW);
    }
    return validate(storageDomainValidator.hasSpaceForNewDisks(disksList));
}
#method_after
protected boolean validateFreeSpace(StorageDomainValidator storageDomainValidator, List<DiskImage> disksList) {
    Collection<DiskImage> disks = ImagesHandler.getDisksDummiesForStorageAllocations(disksList);
    return validate(storageDomainValidator.hasSpaceForNewDisks(disks));
}
#end_block

#method_before
protected void initializeStorageDomain() {
    getStorageDomain().setId(Guid.newGuid());
}
#method_after
protected void initializeStorageDomain() {
    getStorageDomain().setId(Guid.newGuid());
    updateStorageDomainWipeAfterDelete();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType() == StorageType.LOCALFS) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!Guid.isNullOrEmpty(getParameters().getStoragePoolId()) && getTargetStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    ensureStorageFormatInitialized();
    AttachDomainValidator attachDomainValidator = getAttachDomainValidator();
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(attachDomainValidator.isStorageDomainFormatCorrectForDC()) || !validate(sdValidator.isStorageFormatCompatibleWithDomain())) {
        return false;
    }
    return canAddDomain();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType() == StorageType.LOCALFS) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!Guid.isNullOrEmpty(getParameters().getStoragePoolId()) && getTargetStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    ensureStorageFormatInitialized();
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = getAttachDomainValidator();
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(storageDomainToPoolRelationValidator.isStorageDomainFormatCorrectForDC()) || !validate(sdValidator.isStorageFormatCompatibleWithDomain())) {
        return false;
    }
    return canAddDomain();
}
#end_block

#method_before
public AttachDomainValidator getAttachDomainValidator() {
    return new AttachDomainValidator(getStorageDomain(), getTargetStoragePool());
}
#method_after
public StorageDomainToPoolRelationValidator getAttachDomainValidator() {
    return new StorageDomainToPoolRelationValidator(getStorageDomain().getStorageStaticData(), getTargetStoragePool());
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList(getAllOVFDisks());
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        return OvfUtils.getOvfEntities((byte[]) vdcReturnValue.getActionReturnValue(), getParameters().getStorageDomainId());
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), getParameters().getStorageDomainId());
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), getParameters().getStorageDomainId(), e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", getParameters().getStorageDomainId());
        AuditLogDirector.log(this, AuditLogType.OVF_STORE_DOES_NOT_EXISTS);
    }
    return Collections.emptyList();
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList(getAllOVFDisks());
    if (!ovfStoreDiskImages.isEmpty()) {
        if (!FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getcompatibility_version())) {
            AuditLogDirector.log(this, AuditLogType.RETRIEVE_UNREGISTERED_ENTITIES_NOT_SUPPORTED_IN_DC_VERSION);
            return Collections.emptyList();
        }
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        return OvfUtils.getOvfEntities((byte[]) vdcReturnValue.getActionReturnValue(), getParameters().getStorageDomainId());
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), getParameters().getStorageDomainId());
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), getParameters().getStorageDomainId(), e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", getParameters().getStorageDomainId());
        AuditLogDirector.log(this, AuditLogType.OVF_STORE_DOES_NOT_EXISTS);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // We can share only ISO or Export domain , or a data domain
    // which is not attached.
    AttachDomainValidator attachDomainValidator = new AttachDomainValidator(getStorageDomain(), getStoragePool());
    boolean returnValue = checkStoragePool() && initializeVds() && checkStorageDomain() && validate(attachDomainValidator.validateDomainCanBeAttachedToPool());
    if (returnValue && getStoragePool().getStatus() == StoragePoolStatus.Uninitialized && getStorageDomain().getStorageDomainType() != StorageDomainType.Data) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ADD_STORAGE_POOL_WITHOUT_DATA_DOMAIN);
    }
    if (returnValue && getStoragePool().getStatus() != StoragePoolStatus.Uninitialized) {
        returnValue = checkMasterDomainIsUp();
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    // We can share only ISO or Export domain , or a data domain
    // which is not attached.
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = new StorageDomainToPoolRelationValidator(getStorageDomain().getStorageStaticData(), getStoragePool());
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    boolean returnValue = checkStoragePool() && initializeVds() && checkStorageDomain() && validate(storageDomainValidator.checkStorageDomainSharedStatusNotLocked()) && validate(storageDomainToPoolRelationValidator.validateDomainCanBeAttachedToPool());
    if (returnValue && getStoragePool().getStatus() == StoragePoolStatus.Uninitialized && getStorageDomain().getStorageDomainType() != StorageDomainType.Data) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ADD_STORAGE_POOL_WITHOUT_DATA_DOMAIN);
    }
    if (returnValue && getStoragePool().getStatus() != StoragePoolStatus.Uninitialized) {
        returnValue = checkMasterDomainIsUp();
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    StorageDomain dom = getStorageDomain();
    if (dom == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
        return false;
    }
    VDS vds = getVds();
    boolean localFs = isLocalFs(dom);
    StorageDomainValidator domainValidator = createDomainValidator(dom);
    if (!checkStorageDomain() || !validate(domainValidator.checkStorageDomainSharedStatusNotLocked())) {
        return false;
    }
    if (!localFs && !validate(domainValidator.isStorageDomainNotInAnyPool())) {
        return false;
    }
    if (localFs && isDomainAttached(dom) && !canDetachDomain(getParameters().getDestroyingPool(), false, true)) {
        return false;
    }
    if (vds == null) {
        if (localFs) {
            if (!initializeVds()) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_HOST_ID);
            return false;
        }
    }
    if (dom.getStorageType() == StorageType.GLANCE) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_MANAGE_STORAGE_DOMAIN);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    StorageDomain dom = getStorageDomain();
    if (dom == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
        return false;
    }
    VDS vds = getVds();
    boolean localFs = isLocalFs(dom);
    StorageDomainToPoolRelationValidator domainPoolValidator = createDomainToPoolValidator(dom);
    StorageDomainValidator domainValidator = new StorageDomainValidator(dom);
    if (!checkStorageDomain() || !validate(domainValidator.checkStorageDomainSharedStatusNotLocked())) {
        return false;
    }
    if (!localFs && !validate(domainPoolValidator.isStorageDomainNotInAnyPool())) {
        return false;
    }
    if (localFs && isDomainAttached(dom) && !canDetachDomain(getParameters().getDestroyingPool(), false, true)) {
        return false;
    }
    if (vds == null) {
        if (localFs) {
            if (!initializeVds()) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_HOST_ID);
            return false;
        }
    }
    if (dom.getStorageType() == StorageType.GLANCE) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_MANAGE_STORAGE_DOMAIN);
        return false;
    }
    return true;
}
#end_block

#method_before
public ValidationResult hasSpaceForNewDisks(Collection<DiskImage> diskImages) {
    double availableSize = storageDomain.getAvailableDiskSizeInBytes();
    double totalSizeForDisks = getTotalSizeForNewDisks(diskImages);
    return validateRequiredSpace(availableSize, totalSizeForDisks);
}
#method_after
public ValidationResult hasSpaceForNewDisks(Collection<DiskImage> diskImages) {
    Long availableSize = storageDomain.getAvailableDiskSizeInBytes();
    double totalSizeForDisks = getTotalSizeForNewDisks(diskImages);
    return validateRequiredSpace(availableSize, totalSizeForDisks);
}
#end_block

#method_before
public ValidationResult hasSpaceForClonedDisks(Collection<DiskImage> diskImages) {
    double availableSize = storageDomain.getAvailableDiskSizeInBytes();
    double totalSizeForDisks = getTotalSizeForClonedDisks(diskImages);
    return validateRequiredSpace(availableSize, totalSizeForDisks);
}
#method_after
public ValidationResult hasSpaceForClonedDisks(Collection<DiskImage> diskImages) {
    Long availableSize = storageDomain.getAvailableDiskSizeInBytes();
    double totalSizeForDisks = getTotalSizeForClonedDisks(diskImages);
    return validateRequiredSpace(availableSize, totalSizeForDisks);
}
#end_block

#method_before
public ValidationResult hasSpaceForDisksWithSnapshots(Collection<DiskImage> diskImages) {
    double availableSize = storageDomain.getAvailableDiskSizeInBytes();
    double totalSizeForDisks = getTotalSizeForDisksWithSnapshots(diskImages);
    return validateRequiredSpace(availableSize, totalSizeForDisks);
}
#method_after
public ValidationResult hasSpaceForDisksWithSnapshots(Collection<DiskImage> diskImages) {
    Long availableSize = storageDomain.getAvailableDiskSizeInBytes();
    double totalSizeForDisks = getTotalSizeForDisksWithSnapshots(diskImages);
    return validateRequiredSpace(availableSize, totalSizeForDisks);
}
#end_block

#method_before
public ValidationResult hasSpaceForAllDisks(Collection<DiskImage> newDiskImages, Collection<DiskImage> clonedDiskImages) {
    double availableSize = storageDomain.getAvailableDiskSizeInBytes();
    double totalSizeForNewDisks = getTotalSizeForNewDisks(newDiskImages);
    double totalSizeForClonedDisks = getTotalSizeForClonedDisks(clonedDiskImages);
    double totalSizeForDisks = totalSizeForNewDisks + totalSizeForClonedDisks;
    return validateRequiredSpace(availableSize, totalSizeForDisks);
}
#method_after
public ValidationResult hasSpaceForAllDisks(Collection<DiskImage> newDiskImages, Collection<DiskImage> clonedDiskImages) {
    Long availableSize = storageDomain.getAvailableDiskSizeInBytes();
    double totalSizeForNewDisks = getTotalSizeForNewDisks(newDiskImages);
    double totalSizeForClonedDisks = getTotalSizeForClonedDisks(clonedDiskImages);
    double totalSizeForDisks = totalSizeForNewDisks + totalSizeForClonedDisks;
    return validateRequiredSpace(availableSize, totalSizeForDisks);
}
#end_block

#method_before
private ValidationResult validateRequiredSpace(double availableSize, double requiredSize) {
    if (availableSize >= requiredSize) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN, storageName());
}
#method_after
private ValidationResult validateRequiredSpace(Long availableSize, double requiredSize) {
    // If availableSize is not yet set, we'll allow the operation.
    if (availableSize == null || availableSize.doubleValue() >= requiredSize) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN, storageName());
}
#end_block

#method_before
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    lun.setvolume_group_id(volumeGroupId);
    if (DbFacade.getInstance().getLunDao().get(lun.getLUN_id()) == null) {
        DbFacade.getInstance().getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        DbFacade.getInstance().getLunDao().update(lun);
    }
    if (storageType == StorageType.FCP) {
        // No need to handle connections (FCP storage doesn't utilize connections).
        return;
    }
    for (StorageServerConnections connection : lun.getLunConnections()) {
        List<StorageServerConnections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
        if (connections.isEmpty()) {
            connection.setid(Guid.newGuid().toString());
            connection.setstorage_type(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setid(connections.get(0).getid());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUN_storage_server_connection_map_id(lun.getLUN_id(), connection.getid())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUN_storage_server_connection_map(lun.getLUN_id(), connection.getid()));
        }
    }
}
#method_after
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    lun.setvolume_group_id(volumeGroupId);
    if (DbFacade.getInstance().getLunDao().get(lun.getLUN_id()) == null) {
        DbFacade.getInstance().getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        DbFacade.getInstance().getLunDao().update(lun);
    }
    if (storageType == StorageType.FCP) {
        // No need to handle connections (FCP storage doesn't utilize connections).
        return;
    }
    for (StorageServerConnections connection : lun.getLunConnections()) {
        StorageServerConnections dbConnection = ISCSIStorageHelper.findConnectionWithSameDetails(connection);
        if (dbConnection == null) {
            connection.setid(Guid.newGuid().toString());
            connection.setstorage_type(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setid(dbConnection.getid());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUN_storage_server_connection_map_id(lun.getLUN_id(), connection.getid())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUN_storage_server_connection_map(lun.getLUN_id(), connection.getid()));
        }
    }
}
#end_block

#method_before
@Before
public void setUp() {
    Guid storageDomainID = Guid.newGuid();
    storageDomain = new StorageDomain();
    storageDomain.setId(storageDomainID);
    storageDomain.setStatus(StorageDomainStatus.Maintenance);
    Guid vdsID = Guid.newGuid();
    VDS vds = new VDS();
    vds.setId(vdsID);
    RemoveStorageDomainParameters params = new RemoveStorageDomainParameters();
    params.setVdsId(vdsID);
    params.setStorageDomainId(storageDomainID);
    params.setDoFormat(true);
    command = spy(new RemoveStorageDomainCommand<>(params));
    doReturn(storageDomainDAOMock).when(command).getStorageDomainDAO();
    doReturn(storageDomain).when(storageDomainDAOMock).get(storageDomainID);
    doReturn(Collections.singletonList(storageDomain)).when(storageDomainDAOMock).getAllForStorageDomain(storageDomainID);
    doReturn(storagePoolIsoMapDAOMock).when(command).getStoragePoolIsoMapDAO();
    doReturn(Collections.emptyList()).when(storagePoolIsoMapDAOMock).getAllForStorage(storageDomainID);
    doReturn(vdsDAOMock).when(command).getVdsDAO();
    doReturn(vds).when(vdsDAOMock).get(vdsID);
    StorageDomainValidatorForTesting domainValidator = spy(new StorageDomainValidatorForTesting(storageDomain));
    doReturn(storagePoolIsoMapDAOMock).when(domainValidator).getStoragePoolIsoMapDao();
    doReturn(domainValidator).when(command).createDomainValidator(storageDomain);
}
#method_after
@Before
public void setUp() {
    Guid storageDomainID = Guid.newGuid();
    storageDomain = new StorageDomain();
    storageDomain.setId(storageDomainID);
    storageDomain.setStatus(StorageDomainStatus.Maintenance);
    Guid vdsID = Guid.newGuid();
    VDS vds = new VDS();
    vds.setId(vdsID);
    RemoveStorageDomainParameters params = new RemoveStorageDomainParameters();
    params.setVdsId(vdsID);
    params.setStorageDomainId(storageDomainID);
    params.setDoFormat(true);
    command = spy(new RemoveStorageDomainCommand<>(params));
    doReturn(storageDomainDAOMock).when(command).getStorageDomainDAO();
    doReturn(storageDomain).when(storageDomainDAOMock).get(storageDomainID);
    doReturn(Collections.singletonList(storageDomain)).when(storageDomainDAOMock).getAllForStorageDomain(storageDomainID);
    doReturn(storagePoolIsoMapDAOMock).when(command).getStoragePoolIsoMapDAO();
    doReturn(Collections.emptyList()).when(storagePoolIsoMapDAOMock).getAllForStorage(storageDomainID);
    doReturn(vdsDAOMock).when(command).getVdsDAO();
    doReturn(vds).when(vdsDAOMock).get(vdsID);
    StorageDomainToPoolRelationValidatorTesting domainToPoolValidator = spy(new StorageDomainToPoolRelationValidatorTesting(storageDomain, null));
    doReturn(storagePoolIsoMapDAOMock).when(domainToPoolValidator).getStoragePoolIsoMapDao();
    doReturn(domainToPoolValidator).when(command).createDomainToPoolValidator(storageDomain);
}
#end_block

#method_before
private boolean checkStorageDomainsInPool() {
    if (!getParameters().getIsInternal()) {
        boolean _hasData = false;
        StorageFormatType storageFormat = null;
        for (Guid storageDomainId : getParameters().getStorages()) {
            StorageDomain domain = DbFacade.getInstance().getStorageDomainDao().get(storageDomainId);
            AttachDomainValidator attachDomainValidator = new AttachDomainValidator(domain, getStoragePool());
            if (isStorageDomainNotNull(domain) && validate(attachDomainValidator.validateDomainCanBeAttachedToPool())) {
                if (domain.getStorageDomainType() == StorageDomainType.Data) {
                    _hasData = true;
                    if (storageFormat == null) {
                        storageFormat = domain.getStorageFormat();
                    } else if (storageFormat != domain.getStorageFormat()) {
                        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ADD_STORAGE_POOL_WITH_DIFFERENT_STORAGE_FORMAT);
                        return false;
                    }
                }
            } else {
                return false;
            }
        }
        if (!_hasData) {
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ADD_STORAGE_POOL_WITHOUT_DATA_AND_ISO_DOMAINS);
            return false;
        }
    }
    return true;
}
#method_after
private boolean checkStorageDomainsInPool() {
    if (!getParameters().getIsInternal()) {
        boolean _hasData = false;
        StorageFormatType storageFormat = null;
        for (Guid storageDomainId : getParameters().getStorages()) {
            StorageDomain domain = DbFacade.getInstance().getStorageDomainDao().get(storageDomainId);
            StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = new StorageDomainToPoolRelationValidator(domain.getStorageStaticData(), getStoragePool());
            StorageDomainValidator domainValidator = new StorageDomainValidator(domain);
            if (isStorageDomainNotNull(domain) && validate(domainValidator.checkStorageDomainSharedStatusNotLocked()) && validate(storageDomainToPoolRelationValidator.validateDomainCanBeAttachedToPool())) {
                if (domain.getStorageDomainType() == StorageDomainType.Data) {
                    _hasData = true;
                    if (storageFormat == null) {
                        storageFormat = domain.getStorageFormat();
                    } else if (storageFormat != domain.getStorageFormat()) {
                        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ADD_STORAGE_POOL_WITH_DIFFERENT_STORAGE_FORMAT);
                        return false;
                    }
                }
            } else {
                return false;
            }
        }
        if (!_hasData) {
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ADD_STORAGE_POOL_WITHOUT_DATA_AND_ISO_DOMAINS);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && checkStoragePool() && checkStoragePoolStatus(StoragePoolStatus.Uninitialized) && initializeVds() && checkStorageDomainsInPool();
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && checkStoragePool() && checkStoragePoolStatus(StoragePoolStatus.Uninitialized) && initializeVds() && checkStorageDomainsInPool() && isDomainAttachedToDifferentStoragePool();
    return returnValue;
}
#end_block

#method_before
public VDSFenceReturnValue checkStatus() {
    VDSFenceReturnValue returnValue = null;
    VDS proxyHost = proxyLocator.findProxyHost();
    if (proxyHost == null) {
        returnValue = proxyNotFound();
    } else {
        for (FenceAgent agent : _vds.getFenceAgents()) {
            returnValue = fence(FenceActionType.Status, agent, proxyHost);
            if (returnValue.getSucceeded()) {
                returnValue.setProxyHostUsed(proxyHost);
                returnValue.setFenceAgentUsed(agent);
                break;
            }
        }
    }
    return returnValue;
}
#method_after
public VDSFenceReturnValue checkStatus() {
    VDSFenceReturnValue returnValue = null;
    VDS proxyHost = proxyLocator.findProxyHost();
    if (proxyHost == null) {
        returnValue = proxyNotFound();
    } else {
        for (FenceAgent agent : _vds.getFenceAgents()) {
            returnValue = fence(FenceActionType.Status, agent, proxyHost);
            if (returnValue.getSucceeded()) {
                returnValue.setProxyHostUsed(proxyHost);
                returnValue.setFenceAgentUsed(agent);
                break;
            }
        }
    }
    if (returnValue == null) {
        returnValue = new VDSFenceReturnValue();
        returnValue.setSucceeded(false);
        returnValue.setExceptionString("No fence-agents found for host " + _vds.getName());
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getName();
        String hostName = vds.getHostName();
        int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
        } else if (getVdsDAO().getByName(vdsName) != null) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        } else if (getVdsDAO().getAllForHostname(hostName).size() != 0) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
        } else if (!ValidationUtils.validatePort(vds.getSshPort())) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT);
        } else if ((StringUtils.isBlank(vds.getSshUsername())) || (vds.getSshUsername().length() > BusinessEntitiesDefinitions.USER_LOGIN_NAME_SIZE)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME);
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
            } else if (!getParameters().getAddPending() && (getParameters().getAuthMethod() == AuthenticationMethod.Password) && StringUtils.isEmpty(getParameters().getPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!isPowerManagementLegal(getParameters().getVdsStaticData().isPmEnabled(), getParameters().getFenceAgents(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (returnValue && getParameters().getNetworkProviderId() != null) {
        returnValue = validateNetworkProviderProperties(getParameters().getNetworkProviderId(), getParameters().getNetworkMappings());
    }
    if (returnValue && isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
            if (upServer == null) {
                returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
            }
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        HostValidator validator = getHostValidator();
        returnValue = validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.hostNameIsValid()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.portIsValid()) && validate(validator.sshUserNameNotEmpty()) && validate(validator.validateSingleHostAttachedToLocalStorage()) && validate(validator.securityKeysExists()) && validate(validator.passwordNotEmpty(getParameters().getAddPending(), getParameters().getAuthMethod(), getParameters().getPassword()));
    }
    if (!(returnValue && isPowerManagementLegal(getParameters().getVdsStaticData().isPmEnabled(), getParameters().getFenceAgents(), getVdsGroup().getcompatibility_version().toString()) && canConnect(getParameters().getvds()))) {
        return false;
    }
    if (getParameters().getNetworkProviderId() != null && !validateNetworkProviderProperties(getParameters().getNetworkProviderId(), getParameters().getNetworkMappings())) {
        return false;
    }
    if (isGlusterSupportEnabled() && clusterHasNonInitializingServers()) {
        // allow simultaneous installation of hosts, but if a host has completed install, only
        // allow addition of another host if it can be peer probed to cluster.
        VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
        if (upServer == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StopGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionVDSParameters(upServer.getId(), getGeoRepSession().getMasterVolumeName(), getGeoRepSession().getSlaveHostName(), getGeoRepSession().getSlaveVolumeName(), getParameters().isForce()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        getGeoRepSession().setStatus(GeoRepSessionStatus.STOPPED);
        getGlusterGeoRepDao().updateSession(getGeoRepSession());
    } else {
        handleVdsError(AuditLogType.GEOREP_SESSION_STOP_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StopGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionVDSParameters(upServer.getId(), getGeoRepSession().getMasterVolumeName(), getGeoRepSession().getSlaveHostName(), getGeoRepSession().getSlaveVolumeName(), getParameters().isForce()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        getGeoRepSession().setStatus(GeoRepSessionStatus.STOPPED);
        getGlusterGeoRepDao().updateSession(getGeoRepSession());
    } else {
        handleVdsError(AuditLogType.GEOREP_SESSION_STOP_FAILED, returnValue.getVdsError().getMessage());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DeleteGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionVDSParameters(upServer.getId(), getGeoRepSession().getMasterVolumeName(), getGeoRepSession().getSlaveHostName(), getGeoRepSession().getSlaveVolumeName()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        getGlusterGeoRepDao().remove(getGeoRepSession().getId());
    } else {
        handleVdsError(AuditLogType.GEOREP_SESSION_DELETE_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DeleteGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionVDSParameters(upServer.getId(), getGeoRepSession().getMasterVolumeName(), getGeoRepSession().getSlaveHostName(), getGeoRepSession().getSlaveVolumeName()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        getGlusterGeoRepDao().remove(getGeoRepSession().getId());
    } else {
        handleVdsError(AuditLogType.GEOREP_SESSION_DELETE_FAILED, returnValue.getVdsError().getMessage());
    }
}
#end_block

#method_before
public HttpClient getHttpClient() {
    return httpClient;
}
#method_after
@Override
public HttpClient getHttpClient() {
    return httpClient;
}
#end_block

#method_before
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String sdUUID, int domainType, int poolType, String path) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getStorageDomainsList(sdUUID, domainType, poolType, path);
        StorageDomainListReturnForXmlRpc wrapper = new StorageDomainListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String sdUUID, int domainType, String poolType, String path) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getStorageDomainsList(sdUUID, domainType, poolType, path);
        StorageDomainListReturnForXmlRpc wrapper = new StorageDomainListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepStart(String masterVolumeName, String slaveHost, String slaveVolumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepStart(masterVolumeName, slaveHost, slaveVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepStart(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepStart(volumeName, remoteHost, remoteVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeGeoRepStartFailedException:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterHostIsNotPartOfCluster:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
        case GlusterLibgfapiException:
        case GlfsStatvfsException:
        case GlfsInitException:
        case GlfsFiniException:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeGeoRepStartFailedException:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterHostIsNotPartOfCluster:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
        case GlusterVolumeGeoRepStatusFailed:
        case GlusterVolumeGeoRepStatusDetailFailed:
        case GlusterLibgfapiException:
        case GlfsStatvfsException:
        case GlfsInitException:
        case GlfsFiniException:
        case GlusterGeoRepSessionDeleteFailedException:
        case GlusterVolumeGeoRepStopFailedException:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
public void close() {
    this.client.close();
}
#method_after
@Override
public void close() {
    XmlRpcUtils.shutDownConnection(this.httpClient);
    this.client.close();
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("status");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            updateHeartbeatPolicy(false);
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                updateHeartbeatPolicy(true);
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    RequestBuilder rb = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options);
    if (fencingPolicy != null) {
        // if fencing policy is null, fence proxy does not support fencing policy parameter
        rb.withParameter("fencingPolicy", fencingPolicy);
    }
    return new FenceStatusReturnForXmlRpc(new FutureMap(this.client, rb.build()));
}
#method_after
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("policy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new FenceStatusReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createStorageDomain(int domainType, String sdUUID, String domainName, String arg, int storageType, String storageFormatType) {
    // storageFormatType not used and it can be removed from interface
    JsonRpcRequest request = new RequestBuilder("StorageDomain.create").withParameter("storagedomainID", sdUUID).withParameter("domainType", domainType).withParameter("typeArgs", arg).withParameter("name", domainName).withParameter("domainClass", storageType).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc createStorageDomain(int domainType, String sdUUID, String domainName, String arg, int storageType, String storageFormatType) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.create").withParameter("storagedomainID", sdUUID).withParameter("domainType", domainType).withParameter("typeArgs", arg).withParameter("name", domainName).withParameter("domainClass", storageType).withOptionalParameter("version", storageFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String spUUID, int domainType, int poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturnForXmlRpc(response);
}
#method_after
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String spUUID, int domainType, String poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public DevicesVisibilityMapReturnForXmlRpc getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<String>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visibles");
    return new DevicesVisibilityMapReturnForXmlRpc(response);
}
#method_after
@Override
public DevicesVisibilityMapReturnForXmlRpc getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<String>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visible");
    return new DevicesVisibilityMapReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> poll() {
    final JsonRpcRequest request = new RequestBuilder("Host.ping").build();
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request);
        }
    });
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@Override
public FutureTask<Map<String, Object>> poll() {
    return timeBoundPoll(0, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepStart(String masterVolumeName, String slaveHost, String slaveVolumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepStart").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepStart(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("vmID", (String) params.get("vmId")).withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
public static void init() {
    if (!glusterModeSupported()) {
        log.debug("Gluster mode not supported. Will not schedule jobs for refreshing Gluster data.");
        return;
    }
    log.debug("Initializing Gluster Jobs Manager");
    SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance();
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshLightWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshHeavyWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterHookSyncJob.getInstance(), "refreshHooks", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHooks), getRefreshRate(ConfigValues.GlusterRefreshRateHooks), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterServiceSyncJob.getInstance(), "refreshGlusterServices", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterTasksSyncJob.getInstance(), "gluster_async_task_poll_event", new Class[0], new Class[0], getRefreshRate(ConfigValues.GlusterRefreshRateTasks), getRefreshRate(ConfigValues.GlusterRefreshRateTasks), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterGeoRepSyncJob.getInstance(), "gluster_georep_poll_event", new Class[0], new Class[0], getRefreshRate(ConfigValues.GlusterRefreshRateGeoRepDiscovery), getRefreshRate(ConfigValues.GlusterRefreshRateGeoRepDiscovery), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterGeoRepSyncJob.getInstance(), "gluster_georepstatus_poll_event", new Class[0], new Class[0], getRefreshRate(ConfigValues.GlusterRefreshRateGeoRepStatus), getRefreshRate(ConfigValues.GlusterRefreshRateGeoRepStatus), TimeUnit.SECONDS);
}
#method_after
public static void init() {
    if (!glusterModeSupported()) {
        log.debug("Gluster mode not supported. Will not schedule jobs for refreshing Gluster data.");
        return;
    }
    log.debug("Initializing Gluster Jobs Manager");
    SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance();
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshLightWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshHeavyWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterHookSyncJob.getInstance(), "refreshHooks", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHooks), getRefreshRate(ConfigValues.GlusterRefreshRateHooks), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterServiceSyncJob.getInstance(), "refreshGlusterServices", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterTasksSyncJob.getInstance(), "gluster_async_task_poll_event", new Class[0], new Class[0], getRefreshRate(ConfigValues.GlusterRefreshRateTasks), getRefreshRate(ConfigValues.GlusterRefreshRateTasks), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterGeoRepSyncJob.getInstance(), "gluster_georep_poll_event", new Class[0], new Class[0], getRefreshRate(ConfigValues.GlusterRefreshRateGeoRepDiscoveryInSecs), getRefreshRate(ConfigValues.GlusterRefreshRateGeoRepDiscoveryInSecs), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterGeoRepSyncJob.getInstance(), "gluster_georepstatus_poll_event", new Class[0], new Class[0], getRefreshRate(ConfigValues.GlusterRefreshRateGeoRepStatusInSecs), getRefreshRate(ConfigValues.GlusterRefreshRateGeoRepStatusInSecs), TimeUnit.SECONDS);
}
#end_block

#method_before
private GlusterGeoRepSessionDetails populatePairDetails(Map<String, Object> innerMap, GlusterGeoRepSession session) {
    GlusterGeoRepSessionDetails details = getSessionDetails(innerMap, session);
    if (details != null) {
        Long filesSynced = innerMap.containsKey(FILES_SYNCED) ? Long.parseLong(innerMap.get(FILES_SYNCED).toString()) : null;
        Long filesPending = innerMap.containsKey(FILES_PENDING) ? Long.parseLong(innerMap.get(FILES_PENDING).toString()) : null;
        Long bytesPending = innerMap.containsKey(BYTES_PENDING) ? Long.parseLong(innerMap.get(BYTES_PENDING).toString()) : null;
        Long deletesPending = innerMap.containsKey(DELETES_PENDING) ? Long.parseLong(innerMap.get(DELETES_PENDING).toString()) : null;
        Long filesSkipped = innerMap.containsKey(FILES_SKIPPED) ? Long.parseLong(innerMap.get(FILES_SKIPPED).toString()) : null;
        details.setFilesPending(filesPending);
        details.setFilesSkipped(filesSkipped);
        details.setFilesSynced(filesSynced);
        details.setBytesPending(bytesPending);
        details.setDeletesPending(deletesPending);
    }
    return details;
}
#method_after
private GlusterGeoRepSessionDetails populatePairDetails(Map<String, Object> innerMap) {
    GlusterGeoRepSessionDetails details = getSessionDetails(innerMap);
    if (details != null) {
        Long filesSynced = innerMap.containsKey(FILES_SYNCED) ? Long.parseLong(innerMap.get(FILES_SYNCED).toString()) : null;
        Long filesPending = innerMap.containsKey(FILES_PENDING) ? Long.parseLong(innerMap.get(FILES_PENDING).toString()) : null;
        Long bytesPending = innerMap.containsKey(BYTES_PENDING) ? Long.parseLong(innerMap.get(BYTES_PENDING).toString()) : null;
        Long deletesPending = innerMap.containsKey(DELETES_PENDING) ? Long.parseLong(innerMap.get(DELETES_PENDING).toString()) : null;
        Long filesSkipped = innerMap.containsKey(FILES_SKIPPED) ? Long.parseLong(innerMap.get(FILES_SKIPPED).toString()) : null;
        details.setFilesPending(filesPending);
        details.setFilesSkipped(filesSkipped);
        details.setFilesSynced(filesSynced);
        details.setBytesPending(bytesPending);
        details.setDeletesPending(deletesPending);
    }
    return details;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void populateSessionDetails(Map<String, Object> innerMap) {
    if (innerMap.containsKey(VOLUME_NAME)) {
        String masterVolumeName = (String) innerMap.get(VOLUME_NAME);
        GlusterGeoRepSession session = getSession(masterVolumeName, innerMap);
        if (innerMap.containsKey(GEO_REP_PAIRS)) {
            for (Object sessionPair : (Object[]) innerMap.get(GEO_REP_PAIRS)) {
                geoRepDetails.add(populatePairDetails((Map<String, Object>) sessionPair, session));
            }
        }
        session.setSessionDetails(geoRepDetails);
        geoRepSessions.add(session);
    }
}
#method_after
@SuppressWarnings("unchecked")
private void populateSessionDetails(Map<String, Object> innerMap) {
    if (innerMap.containsKey(VOLUME_NAME)) {
        String masterVolumeName = (String) innerMap.get(VOLUME_NAME);
        GlusterGeoRepSession session = getSession(masterVolumeName, innerMap);
        if (innerMap.containsKey(GEO_REP_PAIRS)) {
            for (Object sessionPair : (Object[]) innerMap.get(GEO_REP_PAIRS)) {
                geoRepDetails.add(populatePairDetails((Map<String, Object>) sessionPair));
            }
        }
        session.setSessionDetails(geoRepDetails);
        geoRepSessions.add(session);
    }
}
#end_block

#method_before
protected GlusterGeoRepSessionDetails getSessionDetails(Map<String, Object> innerMap, GlusterGeoRepSession session) {
    GlusterGeoRepSessionDetails details = new GlusterGeoRepSessionDetails();
    Guid masterNodeGlusterId;
    if (innerMap.containsKey(MASTER_NODE_UUID)) {
        masterNodeGlusterId = new Guid(innerMap.get(MASTER_NODE_UUID).toString());
    } else {
        log.error("Master node uuid is not available");
        return null;
    }
    String masterBrickDir = (innerMap.containsKey(MASTER_BRICK)) ? innerMap.get(MASTER_BRICK).toString() : null;
    GlusterServer glusterServer = getDbUtils().getServerByUuid(masterNodeGlusterId);
    if (glusterServer != null) {
        GlusterBrickEntity brick = getDbUtils().getGlusterBrickByServerUuidAndBrickDir(glusterServer.getId(), masterBrickDir);
        if (brick != null) {
            details.setMasterBrickId(brick.getId());
        }
    }
    if (details.getMasterBrickId() == null) {
        log.error("Brick information could not be retrieved for gluster host id {} and brick dir {}", masterNodeGlusterId, masterBrickDir);
    }
    String slave = innerMap.containsKey(SLAVE) ? innerMap.get(SLAVE).toString() : null;
    String[] slaveSplit = (slave != null) ? slave.split("([://]+)") : null;
    if (slaveSplit != null && slaveSplit.length >= 2) {
        details.setSlaveHostName(slaveSplit[slaveSplit.length - 2]);
    }
    details.setStatus(GeoRepSessionStatus.from((String) innerMap.get(STATUS)));
    details.setCrawlStatus(GeoRepCrawlStatus.from((String) innerMap.get(CRAWL_STATUS)));
    details.setCheckPointStatus((String) innerMap.get(CHECK_POINT_STATUS));
    return details;
}
#method_after
protected GlusterGeoRepSessionDetails getSessionDetails(Map<String, Object> innerMap) {
    GlusterGeoRepSessionDetails details = new GlusterGeoRepSessionDetails();
    Guid masterNodeGlusterId;
    if (innerMap.containsKey(MASTER_NODE_UUID)) {
        masterNodeGlusterId = new Guid(innerMap.get(MASTER_NODE_UUID).toString());
    } else {
        log.error("Master node uuid is not available");
        return null;
    }
    String masterBrickDir = (innerMap.containsKey(MASTER_BRICK)) ? innerMap.get(MASTER_BRICK).toString() : null;
    GlusterServer glusterServer = getDbUtils().getServerByUuid(masterNodeGlusterId);
    if (glusterServer != null) {
        GlusterBrickEntity brick = getDbUtils().getGlusterBrickByServerUuidAndBrickDir(glusterServer.getId(), masterBrickDir);
        if (brick != null) {
            details.setMasterBrickId(brick.getId());
        }
    }
    if (details.getMasterBrickId() == null) {
        log.error("Brick information could not be retrieved for gluster host id {} and brick dir {}", masterNodeGlusterId, masterBrickDir);
    }
    String slave = innerMap.containsKey(SLAVE) ? innerMap.get(SLAVE).toString() : null;
    String[] slaveSplit = (slave != null) ? slave.split("([://]+)") : null;
    if (slaveSplit != null && slaveSplit.length >= 2) {
        details.setSlaveHostName(slaveSplit[slaveSplit.length - 2]);
    }
    details.setStatus(GeoRepSessionStatus.from((String) innerMap.get(STATUS)));
    details.setCrawlStatus(GeoRepCrawlStatus.from((String) innerMap.get(CRAWL_STATUS)));
    details.setCheckPointStatus((String) innerMap.get(CHECK_POINT_STATUS));
    return details;
}
#end_block

#method_before
private GlusterGeoRepSession populateSession(String volumeName, Map<String, Object> innerMap) {
    GlusterGeoRepSession geoRepSession = getSession(volumeName, innerMap);
    ArrayList<GlusterGeoRepSessionDetails> geoRepSessionDetails = new ArrayList<GlusterGeoRepSessionDetails>();
    if (innerMap.containsKey(GEO_REP_PAIRS)) {
        for (Object sessionPair : (Object[]) innerMap.get(GEO_REP_PAIRS)) {
            geoRepSessionDetails.add(getSessionDetails((Map<String, Object>) sessionPair, geoRepSession));
        }
    }
    geoRepSession.setSessionDetails(geoRepSessionDetails);
    return geoRepSession;
}
#method_after
private GlusterGeoRepSession populateSession(String volumeName, Map<String, Object> innerMap) {
    GlusterGeoRepSession geoRepSession = getSession(volumeName, innerMap);
    ArrayList<GlusterGeoRepSessionDetails> geoRepSessionDetails = new ArrayList<GlusterGeoRepSessionDetails>();
    if (innerMap.containsKey(GEO_REP_PAIRS)) {
        for (Object sessionPair : (Object[]) innerMap.get(GEO_REP_PAIRS)) {
            geoRepSessionDetails.add(getSessionDetails((Map<String, Object>) sessionPair));
        }
    }
    geoRepSession.setSessionDetails(geoRepSessionDetails);
    return geoRepSession;
}
#end_block

#method_before
private void refreshGeoRepSessionStatusInCluster(final VDSGroup cluster) {
    List<GlusterGeoRepSession> geoRepSessions = getGeoRepDao().getGeoRepSessionsInCluster(cluster.getId());
    refreshGeoRepSessionStatus(cluster, geoRepSessions);
}
#method_after
private void refreshGeoRepSessionStatusInCluster(final VDSGroup cluster) {
    if (!supportsGlusterGeoRepFeature(cluster)) {
        return;
    }
    List<GlusterGeoRepSession> geoRepSessions = getGeoRepDao().getGeoRepSessionsInCluster(cluster.getId());
    refreshGeoRepSessionStatusForSessions(cluster, geoRepSessions);
}
#end_block

#method_before
public void refreshGeoRepDataForVolume(final GlusterVolumeEntity volume) {
    VDSGroup cluster = getClusterDao().get(volume.getClusterId());
    discoverGeoRepDataForVolume(cluster, volume);
    List<GlusterGeoRepSession> geoRepSessions = getGeoRepDao().getGeoRepSessions(volume.getId());
    refreshGeoRepSessionStatus(cluster, geoRepSessions);
}
#method_after
public void refreshGeoRepDataForVolume(final GlusterVolumeEntity volume) {
    if (volume == null) {
        throw new VdcBLLException(VdcBllErrors.GlusterVolumeGeoRepSyncFailed, "No volume information");
    }
    VDSGroup cluster = getClusterDao().get(volume.getClusterId());
    discoverGeoRepDataInCluster(cluster, volume.getName());
    List<GlusterGeoRepSession> geoRepSessions = getGeoRepDao().getGeoRepSessions(volume.getId());
    refreshGeoRepSessionStatusForSessions(cluster, geoRepSessions);
}
#end_block

#method_before
public void discoverGeoRepDataInCluster(VDSGroup cluster) {
    if (!supportsGlusterGeoRepFeature(cluster)) {
        return;
    }
    Map<String, GlusterGeoRepSession> sessionsMap = getSessionsFromCLI(cluster, null);
    if (sessionsMap == null) {
        log.debug("Error in retrieving sessions for cluster: {} from CLI, nothing to do", cluster.getName());
        return;
    }
    updateDiscoveredSessions(cluster, sessionsMap, null);
}
#method_after
private void discoverGeoRepDataInCluster(VDSGroup cluster) {
    discoverGeoRepDataInCluster(cluster, null);
}
#end_block

#method_before
public void discoverGeoRepDataInCluster(VDSGroup cluster) {
    if (!supportsGlusterGeoRepFeature(cluster)) {
        return;
    }
    Map<String, GlusterGeoRepSession> sessionsMap = getSessionsFromCLI(cluster, null);
    if (sessionsMap == null) {
        log.debug("Error in retrieving sessions for cluster: {} from CLI, nothing to do", cluster.getName());
        return;
    }
    updateDiscoveredSessions(cluster, sessionsMap, null);
}
#method_after
private void discoverGeoRepDataInCluster(VDSGroup cluster, String volumeName) {
    if (!supportsGlusterGeoRepFeature(cluster)) {
        return;
    }
    Map<String, GlusterGeoRepSession> sessionsMap = getSessionsFromCLI(cluster, volumeName);
    if (sessionsMap == null) {
        log.debug("No sessions retrieved for cluster: {} from CLI, nothing to do", cluster.getName());
        return;
    }
    updateDiscoveredSessions(cluster, sessionsMap);
}
#end_block

#method_before
private void updateDiscoveredSessions(VDSGroup cluster, Map<String, GlusterGeoRepSession> sessionsMap, GlusterVolumeEntity volume) {
    removeDeletedSessions(cluster.getId(), sessionsMap, volume);
    // for each geo-rep session, find session in database and update details.
    for (GlusterGeoRepSession session : sessionsMap.values()) {
        GlusterVolumeEntity masterVolume = getVolume(cluster, session.getMasterVolumeName());
        if (masterVolume == null) {
            log.info("Could not find corresponding volume for geo-rep session '{}' and volume '{}' - status will not be updated.", session.getSessionKey(), session.getMasterVolumeName());
        } else {
            session.setMasterVolumeId(masterVolume.getId());
            // update consolidated status
            updateGeoRepStatus(masterVolume, session);
        }
        // check if session exists in database
        GlusterGeoRepSession sessionInDb = getGeoRepDao().getGeoRepSession(session.getSessionKey());
        if (sessionInDb == null) {
            // save the session in database first.
            log.debug("detected new geo-rep session '{}' for volume '{}'", session.getSessionKey(), session.getMasterVolumeName());
            if (Guid.isNullOrEmpty(session.getId())) {
                session.setId(Guid.newGuid());
            }
            if (session.getSlaveNodeUuid() == null && session.getSlaveVolumeId() == null) {
                // populate ids from the ones that exist in engine
                List<VDS> slaveHosts = getVdsDao().getAllForHostname(session.getSlaveHostName());
                if (slaveHosts != null && !slaveHosts.isEmpty()) {
                    session.setSlaveNodeUuid(slaveHosts.get(0).getId());
                    GlusterVolumeEntity slaveVol = getVolumeDao().getByName(slaveHosts.get(0).getVdsGroupId(), session.getSlaveVolumeName());
                    if (slaveVol != null) {
                        session.setSlaveVolumeId(slaveVol.getId());
                    }
                }
            }
            getGeoRepDao().save(session);
            logGeoRepMessage(AuditLogType.GLUSTER_GEOREP_SESSION_DETECTED_FROM_CLI, cluster.getId(), session);
        } else {
            session.setId(sessionInDb.getId());
            getGeoRepDao().updateSession(session);
        }
        updateSessionDetailsInDB(session);
    }
}
#method_after
private void updateDiscoveredSessions(VDSGroup cluster, Map<String, GlusterGeoRepSession> sessionsMap) {
    removeDeletedSessions(cluster.getId(), sessionsMap);
    // for each geo-rep session, find session in database and update details.
    for (GlusterGeoRepSession session : sessionsMap.values()) {
        GlusterVolumeEntity masterVolume = getVolume(cluster, session.getMasterVolumeName());
        if (masterVolume == null) {
            log.info("Could not find corresponding volume for geo-rep session '{}' and volume '{}' - status will not be updated.", session.getSessionKey(), session.getMasterVolumeName());
        } else {
            session.setMasterVolumeId(masterVolume.getId());
            // update consolidated status
            updateGeoRepStatus(masterVolume, session);
        }
        // check if session exists in database
        GlusterGeoRepSession sessionInDb = getGeoRepDao().getGeoRepSession(session.getSessionKey());
        if (sessionInDb == null) {
            // save the session in database first.
            log.debug("detected new geo-rep session '{}' for volume '{}'", session.getSessionKey(), session.getMasterVolumeName());
            if (Guid.isNullOrEmpty(session.getId())) {
                session.setId(Guid.newGuid());
            }
            if (session.getSlaveNodeUuid() == null && session.getSlaveVolumeId() == null) {
                updateSlaveNodeAndVolumeId(session);
            }
            getGeoRepDao().save(session);
            logGeoRepMessage(AuditLogType.GLUSTER_GEOREP_SESSION_DETECTED_FROM_CLI, cluster.getId(), session);
        } else {
            if (sessionInDb.getSlaveNodeUuid() == null && sessionInDb.getSlaveVolumeId() == null && session.getSlaveNodeUuid() == null && session.getSlaveVolumeId() == null) {
                updateSlaveNodeAndVolumeId(session);
            }
            session.setId(sessionInDb.getId());
            getGeoRepDao().updateSession(session);
        }
        updateSessionDetailsInDB(session);
    }
}
#end_block

#method_before
private void removeDeletedSessions(Guid clusterId, final Map<String, GlusterGeoRepSession> sessionsMap, GlusterVolumeEntity volume) {
    List<GlusterGeoRepSession> sessionsInDb;
    if (volume != null) {
        sessionsInDb = getGeoRepDao().getGeoRepSessions(volume.getId());
    } else {
        sessionsInDb = getGeoRepDao().getGeoRepSessionsInCluster(clusterId);
    }
    if (sessionsInDb == null || sessionsInDb.isEmpty()) {
        return;
    }
    List<GlusterGeoRepSession> sessionsToDelete = new ArrayList<>();
    for (GlusterGeoRepSession grepSession : sessionsInDb) {
        if (sessionsMap.get(grepSession.getSessionKey()) == null) {
            sessionsToDelete.add(grepSession);
        }
    }
    for (final GlusterGeoRepSession session : sessionsToDelete) {
        log.debug("geo-rep session '{}' detected removed for volume '{}'", session.getSessionKey(), session.getMasterVolumeName());
        getGeoRepDao().remove(session.getId());
        logGeoRepMessage(AuditLogType.GLUSTER_GEOREP_SESSION_DELETED_FROM_CLI, clusterId, session);
    }
}
#method_after
private void removeDeletedSessions(Guid clusterId, final Map<String, GlusterGeoRepSession> sessionsMap) {
    List<GlusterGeoRepSession> sessionsInDb = getGeoRepDao().getGeoRepSessionsInCluster(clusterId);
    if (CollectionUtils.isEmpty(sessionsInDb)) {
        return;
    }
    List<GlusterGeoRepSession> sessionsToDelete = new ArrayList<>();
    for (GlusterGeoRepSession grepSession : sessionsInDb) {
        if (sessionsMap.get(grepSession.getSessionKey()) == null) {
            sessionsToDelete.add(grepSession);
        }
    }
    for (final GlusterGeoRepSession session : sessionsToDelete) {
        log.info("geo-rep session '{}' detected removed for volume '{}'", session.getSessionKey(), session.getMasterVolumeName());
        getGeoRepDao().remove(session.getId());
        logGeoRepMessage(AuditLogType.GLUSTER_GEOREP_SESSION_DELETED_FROM_CLI, clusterId, session);
    }
}
#end_block

#method_before
@Override
public void updateSession(GlusterGeoRepSession geoRepSession) {
    getCallsHandler().executeModification("UpdateGlusterGeoRepSessionStatus", createIdParameterMapper(geoRepSession.getId()).addValue("status", EnumUtils.nameOrNull(geoRepSession.getStatus())));
}
#method_after
@Override
public void updateSession(GlusterGeoRepSession geoRepSession) {
    getCallsHandler().executeModification("UpdateGlusterGeoRepSession", createIdParameterMapper(geoRepSession.getId()).addValue("status", EnumUtils.nameOrNull(geoRepSession.getStatus())).addValue("slave_host_uuid", geoRepSession.getSlaveNodeUuid()).addValue("slave_volume_id", geoRepSession.getSlaveVolumeId()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().getAddProvisioned()) {
        if (getParameters().getComputeResource() == null) {
            log.error("Failed to provision: Compute resource cannot be empty");
            throw new VdcBLLException(VdcBllErrors.PROVIDER_PROVISION_MISSING_COMPUTERESOURCE);
        }
        if (getParameters().getHostGroup() == null) {
            log.error("Failed to provision: Host group cannot be empty");
            throw new VdcBLLException(VdcBllErrors.PROVIDER_PROVISION_MISSING_HOSTGROUP);
        }
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        getParameters().getvds().getStaticData().setHostProviderId(getParameters().getProviderId());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        AuditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending() && !getParameters().getAddProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().getAddProvisioned()) {
        if (getParameters().getComputeResource() == null) {
            log.error("Failed to provision: Compute resource cannot be empty");
            throw new VdcBLLException(VdcBllErrors.PROVIDER_PROVISION_MISSING_COMPUTERESOURCE);
        }
        if (getParameters().getHostGroup() == null) {
            log.error("Failed to provision: Host group cannot be empty");
            throw new VdcBLLException(VdcBllErrors.PROVIDER_PROVISION_MISSING_HOSTGROUP);
        }
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        getParameters().getvds().getStaticData().setHostProviderId(getParameters().getProviderId());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        AuditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            testVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending() && !getParameters().getAddProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getName();
        String hostName = vds.getHostName();
        int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
        } else if (getVdsDAO().getByName(vdsName) != null) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        } else if (getVdsDAO().getAllForHostname(hostName).size() != 0) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
        } else if (!ValidationUtils.validatePort(vds.getSshPort())) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT);
        } else if ((StringUtils.isBlank(vds.getSshUsername())) || (vds.getSshUsername().length() > BusinessEntitiesDefinitions.USER_LOGIN_NAME_SIZE)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME);
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
            } else if (!getParameters().getAddPending() && (getParameters().getAuthMethod() == AuthenticationMethod.Password) && StringUtils.isEmpty(getParameters().getPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!isPowerManagementLegal()) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (returnValue && getParameters().getNetworkProviderId() != null) {
        returnValue = validateNetworkProviderProperties(getParameters().getNetworkProviderId(), getParameters().getNetworkMappings());
    }
    if (returnValue && isGlusterSupportEnabled()) {
        // allow addition of another host if it can be peer probed to cluster.
        if (clusterHasNonInitializingServers()) {
            VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
            if (upServer == null) {
                returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
            }
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        HostValidator validator = getHostValidator();
        returnValue = validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.hostNameIsValid()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.portIsValid()) && validate(validator.sshUserNameNotEmpty()) && validate(validator.validateSingleHostAttachedToLocalStorage()) && validate(validator.securityKeysExists()) && validate(validator.passwordNotEmpty(getParameters().getAddPending(), getParameters().getAuthMethod(), getParameters().getPassword()));
    }
    if (!(returnValue && isPowerManagementLegal(getParameters().getVdsStaticData().isPmEnabled(), getParameters().getFenceAgents(), getVdsGroup().getcompatibility_version().toString()) && canConnect(getParameters().getvds()))) {
        return false;
    }
    if (getParameters().getNetworkProviderId() != null && !validateNetworkProviderProperties(getParameters().getNetworkProviderId(), getParameters().getNetworkMappings())) {
        return false;
    }
    if (isGlusterSupportEnabled() && clusterHasNonInitializingServers()) {
        // allow simultaneous installation of hosts, but if a host has completed install, only
        // allow addition of another host if it can be peer probed to cluster.
        VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
        if (upServer == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
        }
    }
    return true;
}
#end_block

#method_before
private boolean clusterHasNonInitializingServers() {
    for (VDS vds : getVdsDAO().getAllForVdsGroup(getVdsGroupId())) {
        if (vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.InstallingOS && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.Initializing)
            return true;
    }
    return false;
}
#method_after
private boolean clusterHasNonInitializingServers() {
    for (VDS vds : getVdsDAO().getAllForVdsGroup(getVdsGroupId())) {
        if (vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.InstallingOS && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.Initializing && vds.getStatus() != VDSStatus.InstallFailed)
            return true;
    }
    return false;
}
#end_block

#method_before
private void setupCommonMock(boolean glusterEnabled) throws Exception {
    when(commandMock.canDoAction()).thenCallRealMethod();
    when(commandMock.canConnect(Mockito.any(VDS.class))).thenCallRealMethod();
    when(commandMock.getParameters()).thenReturn(parameters);
    when(commandMock.isGlusterSupportEnabled()).thenReturn(glusterEnabled);
    when(commandMock.getVdsGroupDAO()).thenReturn(groupDAOMock);
    when(commandMock.getClusterUtils()).thenReturn(clusterUtils);
    when(vdsDaoMock.get(vdsId)).thenReturn(null);
    when(commandMock.getVdsDAO()).thenReturn(vdsDaoMock);
    when(commandMock.validateVdsGroup()).thenReturn(true);
    when(commandMock.validateSingleHostAttachedToLocalStorage()).thenReturn(true);
    when(commandMock.isPowerManagementLegal()).thenReturn(true);
    when(commandMock.getSSHClient()).thenReturn(sshClient);
    doNothing().when(sshClient).connect();
    doNothing().when(sshClient).authenticate();
}
#method_after
private void setupCommonMock(boolean glusterEnabled) throws Exception {
    mockHostValidator();
    when(commandMock.canDoAction()).thenCallRealMethod();
    when(commandMock.canConnect(any(VDS.class))).thenCallRealMethod();
    when(commandMock.getParameters()).thenReturn(parameters);
    when(commandMock.isGlusterSupportEnabled()).thenReturn(glusterEnabled);
    when(commandMock.getVdsGroupDAO()).thenReturn(groupDAOMock);
    when(commandMock.getClusterUtils()).thenReturn(clusterUtils);
    when(vdsDaoMock.get(vdsId)).thenReturn(null);
    when(commandMock.getVdsDAO()).thenReturn(vdsDaoMock);
    when(commandMock.validateVdsGroup()).thenReturn(true);
    when(commandMock.isPowerManagementLegal(any(Boolean.class), anyListOf(FenceAgent.class), any(String.class))).thenReturn(true);
    when(commandMock.getSSHClient()).thenReturn(sshClient);
    Version version = new Version("1.2.3");
    VDSGroup vdsGroup = new VDSGroup();
    vdsGroup.setcompatibility_version(version);
    when(commandMock.getVdsGroup()).thenReturn(vdsGroup);
    when(commandMock.isPowerManagementLegal(parameters.getVdsStaticData().isPmEnabled(), parameters.getFenceAgents(), new Version("1.2.3").toString())).thenReturn(true);
    doNothing().when(sshClient).connect();
    doNothing().when(sshClient).authenticate();
}
#end_block

#method_before
@Test
public void findMissingEnumNames() {
    // Find missing ConfigurationValues enum names in ConfigValues enum
    boolean foundMissingKeys = false;
    List<ConfigurationValues> missingKeys = new ArrayList<ConfigurationValues>();
    for (ConfigurationValues configValue : ConfigurationValues.values()) {
        if (!configValuesEnumNames.contains(configValue.toString())) {
            log.error("Found missing key: {}", configValue);
            foundMissingKeys = true;
            missingKeys.add(configValue);
            break;
        }
    }
    assertFalse("Found missing keys: " + missingKeys, foundMissingKeys);
}
#method_after
@Test
public void findMissingEnumNames() {
    // Find missing ConfigurationValues enum names in ConfigValues enum
    Set<ConfigurationValues> missingKeys = new TreeSet<ConfigurationValues>();
    for (ConfigurationValues configValue : ConfigurationValues.values()) {
        if (!configValuesEnumNames.contains(configValue.toString())) {
            log.error("Found missing key: {}", configValue);
            missingKeys.add(configValue);
        }
    }
    assertTrue("Found missing keys: " + missingKeys, missingKeys.isEmpty());
}
#end_block

#method_before
public ValidationResult mixedClusterServicesSupported() {
    boolean mixedClusterEnavled = Config.<Boolean>getValue(ConfigValues.AllowClusterWithVirtGlusterEnabled);
    return ValidationResult.failWith(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED).when(cluster.supportsGlusterService() && cluster.supportsVirtService() && !mixedClusterEnavled);
}
#method_after
public ValidationResult mixedClusterServicesSupported() {
    boolean mixedClusterEnabled = Config.<Boolean>getValue(ConfigValues.AllowClusterWithVirtGlusterEnabled);
    return ValidationResult.failWith(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED).when(cluster.supportsGlusterService() && cluster.supportsVirtService() && !mixedClusterEnabled);
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {");
    Iterator<Entry<String, Object>> attributes = constructSerializationAttributes().entrySet().iterator();
    builder.append(attributes.next());
    while (attributes.hasNext()) {
        builder.append(", ").append(attributes.next());
    }
    builder.append("}");
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {");
    Map<String, Object> attributes = constructStringAttributes();
    if (attributes != null && !attributes.isEmpty()) {
        Iterator<Entry<String, Object>> i = attributes.entrySet().iterator();
        appendEntry(builder, i.next());
        while (i.hasNext()) {
            builder.append(", ");
            appendEntry(builder, i.next());
        }
    }
    builder.append("}");
    return builder.toString();
}
#end_block

#method_before
protected boolean validateSpaceRequirements() {
    int numOfVms = getParameters().getVmsCount();
    List<DiskImage> disksList = new ArrayList<>();
    // Number of added disks multiplies by the vms number
    for (int i = 0; i < numOfVms; ++i) {
        disksList.addAll(diskInfoDestinationMap.values());
    }
    // At this point the disks are the template's, which could have another volume type/format
    // This change is for storage allocation validations, "real" override for these values is done in CreateSnapshotCommand.
    /*for (DiskImage diskImage : disksList) {
            diskImage.setVolumeType(VolumeType.Sparse);
            destStorages
            if (dest storage is block){
                diskImage.setvolumeFormat(VolumeFormat.COW);
            } else {  //really needed?
                diskImage.setvolumeFormat(VolumeFormat.RAW);
            }
        }*/
    Guid spId = getVmTemplate().getStoragePoolId();
    Set<Guid> sdIds = destStorages.keySet();
    MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(spId, sdIds);
    return validate(storageDomainsValidator.allDomainsWithinThresholds()) && validate(storageDomainsValidator.allDomainsHaveSpaceForNewDisks(disksList));
}
#method_after
protected boolean validateSpaceRequirements() {
    int numOfVms = getParameters().getVmsCount();
    List<DiskImage> diskDummies = getDiskList();
    List<DiskImage> disksList = new ArrayList<>();
    // Number of added disks multiplies by the vms number
    for (int i = 0; i < numOfVms; ++i) {
        disksList.addAll(diskDummies);
    }
    Guid spId = getVmTemplate().getStoragePoolId();
    Set<Guid> sdIds = destStorages.keySet();
    MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(spId, sdIds);
    return validate(storageDomainsValidator.allDomainsWithinThresholds()) && validate(storageDomainsValidator.allDomainsHaveSpaceForNewDisks(disksList));
}
#end_block

#method_before
public void setHibernationVolHandle(String value) {
    this.hibernationVolHandle = (value);
}
#method_after
public void setHibernationVolHandle(String value) {
    this.hibernationVolHandle = value;
}
#end_block

#method_before
@Override
protected boolean canAddDomain() {
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    if (!validate(validator.isHostedEngineStorage())) {
        return false;
    }
    if (getStorageDomainStaticDAO().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    List<LUNs> lunsOnStorage = getLUNsFromVgInfo(getStorageDomain().getStorage());
    if (CollectionUtils.containsAny(Entities.getIds(lunsOnStorage), Entities.getIds(getDbFacade().getLunDao().getAll()))) {
        log.info("There are existing luns in the system which are part of VG id '{}'", getStorageDomain().getStorage());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_STORAGE_DOMAIN_EXTERNAL_LUN_DISK_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean canAddDomain() {
    if (getStorageDomainStaticDAO().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    if (!validate(validator.isHostedEngineStorage())) {
        return false;
    }
    List<LUNs> lunsOnStorage = getLUNsFromVgInfo(getStorageDomain().getStorage());
    if (CollectionUtils.containsAny(Entities.getIds(lunsOnStorage), Entities.getIds(getAllLuns()))) {
        log.info("There are existing luns in the system which are part of VG id '{}'", getStorageDomain().getStorage());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_STORAGE_DOMAIN_EXTERNAL_LUN_DISK_EXIST);
    }
    return true;
}
#end_block

#method_before
protected boolean checkExistingStorageDomain() {
    if (getStorageDomainStaticDAO().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    Pair<StorageDomainStatic, Guid> domainFromIrs = executeHSMGetStorageDomainInfo(new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getStorageDomain().getId()));
    if (domainFromIrs == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    if (!validate(validator.isHostedEngineStorage())) {
        return false;
    }
    return concreteCheckExistingStorageDomain(domainFromIrs);
}
#method_after
protected boolean checkExistingStorageDomain() {
    if (getStorageDomainStaticDAO().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    Pair<StorageDomainStatic, Guid> domainFromIrs = executeHSMGetStorageDomainInfo(new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getStorageDomain().getId()));
    if (domainFromIrs == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    StorageDomain storageDomainFromIrs = new StorageDomain();
    storageDomainFromIrs.setStorageStaticData(domainFromIrs.getFirst());
    StorageDomainValidator validator = new StorageDomainValidator(storageDomainFromIrs);
    if (!validate(validator.isHostedEngineStorage())) {
        return false;
    }
    return concreteCheckExistingStorageDomain(domainFromIrs);
}
#end_block

#method_before
@Test
public void testAddHostedEngineStorageFails() {
    parameters.getStorageDomain().setStorageName(StorageConstants.HOSTED_ENGINE_STORAGE_DOMAIN_NAME);
    assertFalse(command.canAddDomain());
    CanDoActionTestUtils.assertCanDoActionMessages("", command, VdcBllMessages.ACTION_TYPE_FAILED_HOSTED_ENGINE_STORAGE);
}
#method_after
@Test
public void testAddHostedEngineStorageFails() {
    when(command.getLUNsFromVgInfo(parameters.getStorageDomain().getStorage())).thenReturn(getLUNs());
    doReturn(new ArrayList<LUNs>()).when(command).getAllLuns();
    parameters.getStorageDomain().setStorageName(StorageConstants.HOSTED_ENGINE_STORAGE_DOMAIN_NAME);
    assertFalse(command.canAddDomain());
    CanDoActionTestUtils.assertCanDoActionMessages("Add self hosted engine storage domain succeeded where it should have failed", command, VdcBllMessages.ACTION_TYPE_FAILED_HOSTED_ENGINE_STORAGE);
}
#end_block

#method_before
@Test
public void testAttachedStorageDomainQuery() {
    mockVdsCommand();
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    storageDomainList.add(storageDomain);
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), Guid.newGuid());
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    returnedStorageDomainList.add(storageDomain.getStorageStaticData());
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testAttachedStorageDomainQuery() {
    mockVdsCommand();
    StoragePool storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    mockStoragePoolDao(storagePool);
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    storageDomainList.add(storageDomain);
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), Guid.newGuid());
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    returnedStorageDomainList.add(storageDomain.getStorageStaticData());
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testUnattachedStorageDomainQuery() {
    mockVdsCommand();
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    storageDomainList.add(storageDomain);
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), null);
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testUnattachedStorageDomainQuery() {
    mockVdsCommand();
    StoragePool storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    mockStoragePoolDao(storagePool);
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    storageDomainList.add(storageDomain);
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), null);
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testEmptyStorageDomainListQuery() {
    mockVdsCommand();
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), Guid.newGuid());
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testEmptyStorageDomainListQuery() {
    mockVdsCommand();
    StoragePool storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    mockStoragePoolDao(storagePool);
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), Guid.newGuid());
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    if (setVdsForConnectStorage() == null) {
        return;
    }
    storageDomainsWithAttachedStoragePoolId = filterAttachedStorageDomains();
    getQueryReturnValue().setReturnValue(storageDomainsWithAttachedStoragePoolId);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<StorageDomainStatic> storageDomainsWithAttachedStoragePoolId = new ArrayList<>();
    if ((getVdsForConnectStorage() != null) && isDataCenterValidForAttachedStorageDomains()) {
        storageDomainsWithAttachedStoragePoolId = filterAttachedStorageDomains();
    }
    getQueryReturnValue().setReturnValue(storageDomainsWithAttachedStoragePoolId);
}
#end_block

#method_before
protected List<StorageDomainStatic> filterAttachedStorageDomains() {
    List<StorageDomain> connectedStorageDomainsToVds = new ArrayList<>();
    for (StorageDomain storageDomain : getParameters().getStorageDomainList()) {
        if (!connectStorageDomain(storageDomain)) {
            logErrorMessage(storageDomain);
        } else {
            connectedStorageDomainsToVds.add(storageDomain);
        }
    }
    storageDomainsWithAttachedStoragePoolId = getAttachedStorageDomains(connectedStorageDomainsToVds);
    for (StorageDomain storageDomain : connectedStorageDomainsToVds) {
        if (!disConnectStorageDomain(storageDomain)) {
            log.warn("Could not disconnect Storage Domain {} from VDS '{}'. ", storageDomain.getName(), getVdsId());
        }
    }
    return storageDomainsWithAttachedStoragePoolId;
}
#method_after
protected List<StorageDomainStatic> filterAttachedStorageDomains() {
    List<StorageDomain> connectedStorageDomainsToVds = new ArrayList<>();
    for (StorageDomain storageDomain : getParameters().getStorageDomainList()) {
        if (!connectStorageDomain(storageDomain)) {
            logErrorMessage(storageDomain);
        } else {
            connectedStorageDomainsToVds.add(storageDomain);
        }
    }
    List<StorageDomainStatic> storageDomainsWithAttachedStoragePoolId = getAttachedStorageDomains(connectedStorageDomainsToVds);
    for (StorageDomain storageDomain : connectedStorageDomainsToVds) {
        if (!disconnectStorageDomain(storageDomain)) {
            log.warn("Could not disconnect Storage Domain {} from VDS '{}'. ", storageDomain.getName(), getVdsId());
        }
    }
    return storageDomainsWithAttachedStoragePoolId;
}
#end_block

#method_before
protected List<StorageDomainStatic> getAttachedStorageDomains(List<StorageDomain> storageDomains) {
    VDSReturnValue vdsReturnValue = null;
    List<StorageDomainStatic> storageDomainsWithAttachedStoragePoolId = new ArrayList<>();
    // Storage Pool
    for (StorageDomain storageDomain : storageDomains) {
        try {
            vdsReturnValue = runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), storageDomain.getId()));
        } catch (RuntimeException e) {
            logErrorMessage(storageDomain);
            continue;
        }
        if (!vdsReturnValue.getSucceeded()) {
            logErrorMessage(storageDomain);
            continue;
        }
        Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) vdsReturnValue.getReturnValue();
        if (domainFromIrs.getSecond() != null) {
            storageDomainsWithAttachedStoragePoolId.add(domainFromIrs.getFirst());
        }
    }
    return storageDomainsWithAttachedStoragePoolId;
}
#method_after
protected List<StorageDomainStatic> getAttachedStorageDomains(List<StorageDomain> storageDomains) {
    VDSReturnValue vdsReturnValue = null;
    List<StorageDomainStatic> storageDomainsWithAttachedStoragePoolId = new ArrayList<>();
    // another Storage Pool
    for (StorageDomain storageDomain : storageDomains) {
        try {
            vdsReturnValue = runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), storageDomain.getId()));
        } catch (RuntimeException e) {
            logErrorMessage(storageDomain);
            continue;
        }
        if (!vdsReturnValue.getSucceeded()) {
            logErrorMessage(storageDomain);
            continue;
        }
        Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) vdsReturnValue.getReturnValue();
        if (domainFromIrs.getSecond() != null) {
            storageDomainsWithAttachedStoragePoolId.add(domainFromIrs.getFirst());
        }
    }
    return storageDomainsWithAttachedStoragePoolId;
}
#end_block

#method_before
protected VDSBrokerFrontend getVdsBroker() {
    return Backend.getInstance().getResourceManager();
}
#method_after
protected VDSBrokerFrontend getVdsBroker() {
    return getBackend().getResourceManager();
}
#end_block

#method_before
@Test
public void testAttachedStorageDomainWithStorageDomainsParameterQuery() {
    mockVdsCommand();
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    storageDomainList.add(storageDomain);
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), Guid.newGuid());
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    returnedStorageDomainList.add(storageDomain.getStorageStaticData());
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testAttachedStorageDomainWithStorageDomainsParameterQuery() {
    mockVdsCommand();
    StoragePool storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    mockStoragePoolDao(storagePool);
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    storageDomainList.add(storageDomain);
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), Guid.newGuid());
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    returnedStorageDomainList.add(storageDomain.getStorageStaticData());
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testUnattachedStorageDomainWithStorageDomainsParameterQuery() {
    mockVdsCommand();
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    storageDomainList.add(storageDomain);
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), null);
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testUnattachedStorageDomainWithStorageDomainsParameterQuery() {
    mockVdsCommand();
    StoragePool storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    mockStoragePoolDao(storagePool);
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    storageDomainList.add(storageDomain);
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), null);
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testEmptyStorageDomainListQuery() {
    mockVdsCommand();
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), Guid.newGuid());
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testEmptyStorageDomainListQuery() {
    mockVdsCommand();
    StoragePool storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    mockStoragePoolDao(storagePool);
    // Create parameters
    List<StorageDomain> storageDomainList = new ArrayList<>();
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(storageDomainList);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), Guid.newGuid());
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testNullStorageDomainListQuery() {
    mockVdsCommand();
    // Create parameters
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(null);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), Guid.newGuid());
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testNullStorageDomainListQuery() {
    mockVdsCommand();
    StoragePool storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    mockStoragePoolDao(storagePool);
    // Create parameters
    StorageDomainsAndStoragePoolIdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getStorageDomainList()).thenReturn(null);
    // Run 'HSMGetStorageDomainInfo' command
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    Pair<StorageDomainStatic, Guid> storageDomainToPoolId = new Pair<>(storageDomain.getStorageStaticData(), Guid.newGuid());
    returnValue.setReturnValue(storageDomainToPoolId);
    when(vdsBrokerFrontendMock.RunVdsCommand(eq(VDSCommandType.HSMGetStorageDomainInfo), any(HSMGetStorageDomainInfoVDSCommandParameters.class))).thenReturn(returnValue);
    // Execute command
    getQuery().executeQueryCommand();
    // Assert the query's results
    List<StorageDomainStatic> returnedStorageDomainList = new ArrayList<>();
    assertEquals(returnedStorageDomainList, getQuery().getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
private boolean isDomainAttachedToDifferentStoragePool() {
    if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
        for (Guid storageDomainId : getParameters().getStorages()) {
            StorageDomain domain = DbFacade.getInstance().getStorageDomainDao().get(storageDomainId);
            if (domain.getStorageDomainType().isDataDomain() && isStorageDomainAttachedToStoragePool(domain)) {
                return failCanDoAction(VdcBllMessages.ERROR_CANNOT_ADD_STORAGE_DOMAIN_WITH_ATTACHED_DATA_DOMAIN);
            }
        }
    }
    return true;
}
#method_after
private boolean isDomainAttachedToDifferentStoragePool() {
    if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
        for (Guid storageDomainId : getParameters().getStorages()) {
            StorageDomain domain = getStorageDomainDAO().get(storageDomainId);
            if (domain.getStorageDomainType().isDataDomain() && isStorageDomainAttachedToStoragePool(domain)) {
                return failCanDoAction(VdcBllMessages.ERROR_CANNOT_ADD_STORAGE_DOMAIN_WITH_ATTACHED_DATA_DOMAIN);
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean isStorageDomainAttachedToStoragePool(StorageDomain storageDomain) {
    List<StorageDomain> storageDomainList = (List<StorageDomain>) getBackend().runInternalQuery(VdcQueryType.GetStorageDomainsWithAttachedStoragePoolGuid, new StorageDomainsAndStoragePoolIdQueryParameters(storageDomain, getStoragePoolId(), getVds().getId())).getReturnValue();
    return !storageDomainList.isEmpty();
}
#method_after
private boolean isStorageDomainAttachedToStoragePool(StorageDomain storageDomain) {
    List<StorageDomain> storageDomainList = (List<StorageDomain>) getBackend().runInternalQuery(VdcQueryType.GetStorageDomainsWithAttachedStoragePoolGuid, new StorageDomainsAndStoragePoolIdQueryParameters(storageDomain, getStoragePoolId(), getVds().getId(), false)).getReturnValue();
    return !storageDomainList.isEmpty();
}
#end_block

#method_before
private void setDetailList(final StorageEventListModel storageEventListModel, final PermissionListModel permissionListModel) {
    generalModel.setIsAvailable(false);
    dcListModel.setIsAvailable(false);
    this.vmBackupModel.setIsAvailable(false);
    this.templateBackupModel.setIsAvailable(false);
    vmRegisterListModel.setIsAvailable(false);
    templateRegisterListModel.setIsAvailable(false);
    vmListModel.setIsAvailable(false);
    templateListModel.setIsAvailable(false);
    isoListModel.setIsAvailable(false);
    diskListModel.setIsAvailable(false);
    snapshotListModel.setIsAvailable(false);
    this.diskProfileListModel.setIsAvailable(false);
    List<EntityModel> list = new ArrayList<EntityModel>();
    list.add(generalModel);
    list.add(dcListModel);
    list.add(vmBackupModel);
    list.add(templateBackupModel);
    list.add(vmRegisterListModel);
    list.add(templateRegisterListModel);
    list.add(vmListModel);
    list.add(templateListModel);
    list.add(isoListModel);
    list.add(diskListModel);
    list.add(snapshotListModel);
    list.add(this.diskProfileListModel);
    list.add(storageEventListModel);
    list.add(permissionListModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final StorageEventListModel storageEventListModel, final PermissionListModel<StorageListModel> permissionListModel) {
    generalModel.setIsAvailable(false);
    dcListModel.setIsAvailable(false);
    this.vmBackupModel.setIsAvailable(false);
    this.templateBackupModel.setIsAvailable(false);
    vmRegisterListModel.setIsAvailable(false);
    templateRegisterListModel.setIsAvailable(false);
    vmListModel.setIsAvailable(false);
    templateListModel.setIsAvailable(false);
    isoListModel.setIsAvailable(false);
    diskListModel.setIsAvailable(false);
    snapshotListModel.setIsAvailable(false);
    this.diskProfileListModel.setIsAvailable(false);
    List<EntityModel> list = new ArrayList<EntityModel>();
    list.add(generalModel);
    list.add(dcListModel);
    list.add(vmBackupModel);
    list.add(templateBackupModel);
    list.add(vmRegisterListModel);
    list.add(templateRegisterListModel);
    list.add(vmListModel);
    list.add(templateListModel);
    list.add(isoListModel);
    list.add(diskListModel);
    list.add(snapshotListModel);
    list.add(this.diskProfileListModel);
    list.add(storageEventListModel);
    list.add(permissionListModel);
    setDetailModels(list);
}
#end_block

#method_before
private void edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    model.setHelpTag(HelpTag.edit_domain);
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageNameEditable = model.isStorageActive() || model.isNewStorage();
    boolean isStorageEditable = model.isStorageNotLocked() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageNameEditable);
    model.getDescription().setIsChangable(isStorageEditable);
    model.getComment().setIsChangable(isStorageEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangable(false);
    model.setIsChangable(isStorageNameEditable || isStorageEditable);
    boolean isPathEditable = isPathEditable(storage);
    isStorageNameEditable = isStorageNameEditable || isPathEditable;
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            model.getHost().setIsChangable(isPathEditable);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case GLUSTERFS:
            item = prepareGlusterStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    UICommand command;
    if (isStorageNameEditable || isStorageEditable) {
        // $NON-NLS-1$
        command = createOKCommand("OnSave");
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        model.getCommands().add(command);
    } else {
        // close is created the same as cancel, but with a different title
        // thus most of creation code can be reused.
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        model.getCommands().add(command);
    }
}
#method_after
private void edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    model.setHelpTag(HelpTag.edit_domain);
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageNameEditable = model.isStorageActive() || model.isNewStorage();
    boolean isStoragePropertiesEditable = model.isStorageNotLocked() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageNameEditable);
    model.getDescription().setIsChangable(isStoragePropertiesEditable);
    model.getComment().setIsChangable(isStoragePropertiesEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangable(false);
    model.setIsChangable(isStorageNameEditable || isStoragePropertiesEditable);
    boolean isPathEditable = isPathEditable(storage);
    isStorageNameEditable = isStorageNameEditable || isPathEditable;
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            model.getHost().setIsChangable(isPathEditable);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case GLUSTERFS:
            item = prepareGlusterStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    UICommand command;
    if (isStorageNameEditable || isStoragePropertiesEditable) {
        // $NON-NLS-1$
        command = createOKCommand("OnSave");
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        model.getCommands().add(command);
    } else {
        // close is created the same as cancel, but with a different title
        // thus most of creation code can be reused.
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        model.getCommands().add(command);
    }
}
#end_block

#method_before
private void importDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new ImportStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().importPreConfiguredDomainTitle());
    model.setHelpTag(HelpTag.import_pre_configured_domain);
    // $NON-NLS-1$
    model.setHashName("import_pre-configured_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.getName().setIsAvailable(false);
    model.getDescription().setIsAvailable(false);
    model.getComment().setIsAvailable(false);
    model.getFormat().setIsAvailable(false);
    List<IStorageModel> items = AsyncDataProvider.getInstance().getIsoStorageModels();
    NfsStorageModel tempVar2 = new NfsStorageModel();
    tempVar2.setRole(StorageDomainType.ImportExport);
    items.add(tempVar2);
    model.setItems(items);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = createOKCommand("OnImport");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void importDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new ImportStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().importPreConfiguredDomainTitle());
    model.setHelpTag(HelpTag.import_pre_configured_domain);
    // $NON-NLS-1$
    model.setHashName("import_pre-configured_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.getName().setIsAvailable(false);
    model.getDescription().setIsAvailable(false);
    model.getComment().setIsAvailable(false);
    model.getFormat().setIsAvailable(false);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = createOKCommand("OnImport");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setEntity(storage.getStorageDomainType().isDataDomain());
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            List<VDS> hosts = (List<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setEntity(storage.getStorageDomainType().isDataDomain());
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#end_block

#method_before
private void dataCenter_SelectedItemChanged() {
    updateItemsAvailability();
    updateDataCenterAlert();
}
#method_after
private void dataCenter_SelectedItemChanged() {
    updateItemsAvailability();
    behavior.updateDataCenterAlert();
}
#end_block

#method_before
private boolean validateStoragePropertiesUpdate() {
    if (!checkStorageDomainStatusNotEqual(StorageDomainStatus.Locked) || !validateStorageNameUpdate()) {
        return false;
    }
    // Collect changed fields to update in a list.
    List<String> props = ObjectIdentityChecker.GetChangedFields(oldDomain, getStorageDomain().getStorageStaticData());
    if (props.isEmpty()) {
        return true;
    }
    // Allow change only to name & description field
    props.remove("storageName");
    props.remove("description");
    props.remove("comment");
    if (!props.isEmpty()) {
        log.warn("There was an attempt to update the following fields although they are not allowed to be updated: {}", StringUtils.join(props, ","));
        return failCanDoAction(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_DOMAIN_FIELDS);
    }
    return true;
}
#method_after
private boolean validateStoragePropertiesUpdate() {
    if (!checkStorageDomainStatusNotEqual(StorageDomainStatus.Locked) || !validateStorageNameUpdate()) {
        return false;
    }
    // Collect changed fields to update in a list.
    List<String> props = ObjectIdentityChecker.GetChangedFields(oldDomain, getStorageDomain().getStorageStaticData());
    // Allow changes to the following fields only:
    props.remove("storageName");
    props.remove("description");
    props.remove("comment");
    props.remove("wipeAfterDelete");
    if (!props.isEmpty()) {
        log.warn("There was an attempt to update the following fields although they are not allowed to be updated: {}", StringUtils.join(props, ","));
        return failCanDoAction(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_DOMAIN_FIELDS);
    }
    return true;
}
#end_block

#method_before
private boolean validateStorageNameUpdate() {
    storageDomainNameChanged = !StringUtils.equals(oldDomain.getStorageName(), getStorageDomain().getStorageName());
    if (storageDomainNameChanged) {
        if (!checkStorageDomainStatus(StorageDomainStatus.Active) || !checkStorageDomainNameLengthValid()) {
            return false;
        }
        // order to change description in spm
        if (storageDomainNameChanged && !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        if (storageDomainNameChanged && isStorageWithSameNameExists()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
        }
    }
    return true;
}
#method_after
private boolean validateStorageNameUpdate() {
    storageDomainNameChanged = !StringUtils.equals(oldDomain.getStorageName(), getStorageDomain().getStorageName());
    if (!storageDomainNameChanged) {
        return true;
    }
    return checkStorageDomainStatus(StorageDomainStatus.Active) && checkStorageDomainNameLengthValid() && isPoolUp() && validateNotTheSameName();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected List<StorageDomain> getStorageDomainsByVolumeGroupIds(List<String> vgIDs) {
    List<StorageDomain> storageDomains = new ArrayList<>();
    // Get existing PhysicalVolumes.
    List<String> existingLunIds = Entities.getLunIdsFromLunsList(getLunDAO().getAll());
    for (String vgID : vgIDs) {
        VDSReturnValue returnValue = null;
        try {
            returnValue = executeGetVGInfo(new GetVGInfoVDSCommandParameters(getParameters().getVdsId(), vgID));
        } catch (RuntimeException e) {
            log.error("Could not get info for VG ID: '{}': {}", vgID, e.getMessage());
            log.debug("Exception", e);
            continue;
        }
        ArrayList<LUNs> luns = (ArrayList<LUNs>) returnValue.getReturnValue();
        List<String> lunIdsOnStorage = Entities.getLunIdsFromLunsList(luns);
        if (CollectionUtils.containsAny(lunIdsOnStorage, existingLunIds)) {
            log.info("There are existing luns in the system which are part of VG id '{}'", vgID);
            continue;
        }
        // Get storage domain ID by a representative LUN
        LUNs lun = luns.get(0);
        Guid storageDomainId = lun.getStorageDomainId();
        // Get storage domain using GetStorageDomainInfo
        StorageDomain storageDomain = getStorageDomainById(storageDomainId);
        if (storageDomain != null) {
            storageDomains.add(storageDomain);
        }
    }
    return storageDomains;
}
#method_after
@SuppressWarnings("unchecked")
protected List<StorageDomain> getStorageDomainsByVolumeGroupIds(List<String> vgIDs) {
    List<StorageDomain> storageDomains = new ArrayList<>();
    // Get existing PhysicalVolumes.
    List<String> existingLunIds = Entities.getIds(getLunDAO().getAll());
    for (String vgID : vgIDs) {
        VDSReturnValue returnValue = null;
        try {
            returnValue = executeGetVGInfo(new GetVGInfoVDSCommandParameters(getParameters().getVdsId(), vgID));
        } catch (RuntimeException e) {
            log.error("Could not get info for VG ID: '{}': {}", vgID, e.getMessage());
            log.debug("Exception", e);
            continue;
        }
        ArrayList<LUNs> luns = (ArrayList<LUNs>) returnValue.getReturnValue();
        List<String> lunIdsOnStorage = Entities.getIds(luns);
        if (CollectionUtils.containsAny(lunIdsOnStorage, existingLunIds)) {
            log.info("There are existing luns in the system which are part of VG id '{}'", vgID);
            continue;
        }
        // Get storage domain ID by a representative LUN
        LUNs lun = luns.get(0);
        Guid storageDomainId = lun.getStorageDomainId();
        // Get storage domain using GetStorageDomainInfo
        StorageDomain storageDomain = getStorageDomainById(storageDomainId);
        if (storageDomain != null) {
            storageDomains.add(storageDomain);
        }
    }
    return storageDomains;
}
#end_block

#method_before
@Override
protected boolean canAddDomain() {
    if (getStorageDomainStaticDAO().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    List<LUNs> lunsOnStorage = getLUNsFromVgInfo(getStorageDomain().getStorage());
    if (CollectionUtils.containsAny(Entities.getLunIdsFromLunsList(lunsOnStorage), Entities.getLunIdsFromLunsList(getDbFacade().getLunDao().getAll()))) {
        log.info("There are existing luns in the system which are part of VG id '{}'", getStorageDomain().getStorage());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_STORAGE_DOMAIN_EXTERNAL_LUN_DISK_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean canAddDomain() {
    if (getStorageDomainStaticDAO().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    List<LUNs> lunsOnStorage = getLUNsFromVgInfo(getStorageDomain().getStorage());
    if (CollectionUtils.containsAny(Entities.getIds(lunsOnStorage), Entities.getIds(getDbFacade().getLunDao().getAll()))) {
        log.info("There are existing luns in the system which are part of VG id '{}'", getStorageDomain().getStorage());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_STORAGE_DOMAIN_EXTERNAL_LUN_DISK_EXIST);
    }
    return true;
}
#end_block

#method_before
public void setiqn(String value) {
    this.iqn = value;
}
#method_after
public void setiqn(String value) {
    this.iqn = getStringValueToSet(value);
}
#end_block

#method_before
public void setport(String value) {
    this.port = value;
}
#method_after
public void setport(String value) {
    this.port = getStringValueToSet(value);
}
#end_block

#method_before
public void setportal(String value) {
    this.portal = value;
}
#method_after
public void setportal(String value) {
    this.portal = getStringValueToSet(value);
}
#end_block

#method_before
public void setpassword(String value) {
    this.password = value;
}
#method_after
public void setpassword(String value) {
    this.password = getStringValueToSet(value);
}
#end_block

#method_before
public void setuser_name(String value) {
    this.username = value;
}
#method_after
public void setuser_name(String value) {
    this.username = getStringValueToSet(value);
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("{ id: ");
    sb.append(this.getid());
    sb.append(", connection: ");
    sb.append(this.getconnection());
    sb.append(", iqn: ");
    sb.append(this.getiqn());
    sb.append(", vfsType: ");
    sb.append(this.getVfsType());
    sb.append(", mountOptions: ");
    sb.append(this.getMountOptions());
    sb.append(", nfsVersion: ");
    sb.append(this.getNfsVersion());
    sb.append(", nfsRetrans: ");
    sb.append(this.getNfsRetrans());
    sb.append(", nfsTimeo: ");
    sb.append(this.getNfsTimeo());
    if (this.getIface() != null) {
        sb.append(", iface: ");
        sb.append(this.getIface());
    }
    if (getNetIfacename() != null) {
        sb.append(", netIfacename: ");
        sb.append(this.getNetIfacename());
    }
    sb.append(" };");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("{ id: ");
    sb.append(this.getid());
    sb.append(", connection: ");
    sb.append(this.getconnection());
    sb.append(", iqn: ");
    sb.append(this.getiqn());
    sb.append(", vfsType: ");
    sb.append(this.getVfsType());
    sb.append(", mountOptions: ");
    sb.append(this.getMountOptions());
    sb.append(", nfsVersion: ");
    sb.append(this.getNfsVersion());
    sb.append(", nfsRetrans: ");
    sb.append(this.getNfsRetrans());
    sb.append(", nfsTimeo: ");
    sb.append(this.getNfsTimeo());
    if (this.getIface() != null) {
        sb.append(", iface: ");
        sb.append(this.getIface());
    }
    if (getNetIfaceName() != null) {
        sb.append(", netIfaceName: ");
        sb.append(this.getNetIfaceName());
    }
    sb.append(" };");
    return sb.toString();
}
#end_block

#method_before
public static Map<String, String> createStructFromConnection(final StorageServerConnections connection, final StoragePool storagePool) {
    // for information, see _connectionDict2ConnectionInfo in vdsm/storage/hsm.py
    DefaultValueMap con = new DefaultValueMap();
    con.put("id", connection.getid(), Guid.Empty.toString());
    con.put("connection", connection.getconnection(), "");
    con.put("tpgt", connection.getportal(), "");
    con.put("port", connection.getport(), "");
    con.put("iqn", connection.getiqn(), "");
    con.put("user", connection.getuser_name(), "");
    con.put("password", connection.getpassword(), "");
    con.putIfNotEmpty("ifaceName", connection.getIface());
    con.putIfNotEmpty("netIfacename", connection.getNetIfacename());
    // through vds which has no storage pool
    if (storagePool == null || Config.<Boolean>getValue(ConfigValues.AdvancedNFSOptionsEnabled, storagePool.getcompatibility_version().getValue())) {
        // For mnt_options, vfs_type, and protocol_version - if they are null
        // or empty we should not send a key with an empty value
        con.putIfNotEmpty("mnt_options", connection.getMountOptions());
        con.putIfNotEmpty("vfs_type", connection.getVfsType());
        if (connection.getNfsVersion() != null) {
            con.put("protocol_version", connection.getNfsVersion().getValue());
        }
        con.putIfNotEmpty("timeout", connection.getNfsTimeo());
        con.putIfNotEmpty("retrans", connection.getNfsRetrans());
    }
    return con;
}
#method_after
public static Map<String, String> createStructFromConnection(final StorageServerConnections connection, final StoragePool storagePool) {
    // for information, see _connectionDict2ConnectionInfo in vdsm/storage/hsm.py
    DefaultValueMap con = new DefaultValueMap();
    con.put("id", connection.getid(), Guid.Empty.toString());
    con.put("connection", connection.getconnection(), "");
    con.putIfNotEmpty("tpgt", connection.getportal());
    con.put("port", connection.getport(), "");
    con.put("iqn", connection.getiqn(), "");
    con.put("user", connection.getuser_name(), "");
    con.put("password", connection.getpassword(), "");
    con.putIfNotEmpty("ifaceName", connection.getIface());
    con.putIfNotEmpty("netIfaceName", connection.getNetIfaceName());
    // through vds which has no storage pool
    if (storagePool == null || Config.<Boolean>getValue(ConfigValues.AdvancedNFSOptionsEnabled, storagePool.getcompatibility_version().getValue())) {
        // For mnt_options, vfs_type, and protocol_version - if they are null
        // or empty we should not send a key with an empty value
        con.putIfNotEmpty("mnt_options", connection.getMountOptions());
        con.putIfNotEmpty("vfs_type", connection.getVfsType());
        if (connection.getNfsVersion() != null) {
            con.put("protocol_version", connection.getNfsVersion().getValue());
        }
        con.putIfNotEmpty("timeout", connection.getNfsTimeo());
        con.putIfNotEmpty("retrans", connection.getNfsRetrans());
    }
    return con;
}
#end_block

#method_before
@Override
protected boolean runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    return runConnectionStorageToDomain(storageDomain, vdsId, type, null, Guid.Empty);
}
#method_after
@Override
protected Pair<Boolean, VdcFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    return runConnectionStorageToDomain(storageDomain, vdsId, type, null, Guid.Empty);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected boolean runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    boolean isSuccess = true;
    List<StorageServerConnections> list = (lun == null) ? DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage()) : lun.getLunConnections();
    if (list.size() != 0) {
        if (VDSCommandType.forValue(type) == VDSCommandType.DisconnectStorageServer) {
            list = filterConnectionsUsedByOthers(list, storageDomain.getStorage(), lun != null ? lun.getLUN_id() : "");
        } else if (VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            list = updateIfaces(list, vdsId);
        }
        Guid poolId = storagePoolId;
        if (storageDomain != null && storageDomain.getStoragePoolId() != null) {
            poolId = storageDomain.getStoragePoolId();
        }
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, poolId, StorageType.ISCSI, list));
        isSuccess = returnValue.getSucceeded();
        if (isSuccess && VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            isSuccess = isConnectSucceeded((Map<String, String>) returnValue.getReturnValue(), list);
        }
    }
    return isSuccess;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected Pair<Boolean, VdcFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    boolean isSuccess = true;
    VDSReturnValue returnValue = null;
    List<StorageServerConnections> list = (lun == null) ? DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage()) : lun.getLunConnections();
    if (list.size() != 0) {
        if (VDSCommandType.forValue(type) == VDSCommandType.DisconnectStorageServer) {
            list = filterConnectionsUsedByOthers(list, storageDomain.getStorage(), lun != null ? lun.getLUN_id() : "");
        } else if (VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            list = updateIfaces(list, vdsId);
        }
        Guid poolId = storagePoolId;
        if (storageDomain != null && storageDomain.getStoragePoolId() != null) {
            poolId = storageDomain.getStoragePoolId();
        }
        returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, poolId, StorageType.ISCSI, list));
        isSuccess = returnValue.getSucceeded();
        if (isSuccess && VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            isSuccess = isConnectSucceeded((Map<String, String>) returnValue.getReturnValue(), list);
        }
    }
    VdcFault vdcFault = null;
    if (!isSuccess && returnValue != null && returnValue.getVdsError() != null) {
        vdcFault = new VdcFault();
        vdcFault.setError(returnValue.getVdsError().getCode());
    }
    return new Pair<>(isSuccess, vdcFault);
}
#end_block

#method_before
public static List<StorageServerConnections> updateIfaces(List<StorageServerConnections> conns, Guid vdsId) {
    List<StorageServerConnections> res = new ArrayList<>(conns);
    for (StorageServerConnections conn : conns) {
        // Get list of endpoints (nics or vlans) that will initiate iscsi sessions.
        // Targets are represented by StorageServerConnections object (connection, iqn, port, portal).
        List<VdsNetworkInterface> ifaces = DbFacade.getInstance().getInterfaceDao().getIscsiIfacesByHostIdAndStorageTargetId(vdsId, conn.getid());
        if (!ifaces.isEmpty()) {
            VdsNetworkInterface vdsNetworkInterface = ifaces.remove(0);
            conn.setIface(vdsNetworkInterface.getName());
            conn.setNetIfacename(vdsNetworkInterface.isBridged() ? vdsNetworkInterface.getNetworkName() : vdsNetworkInterface.getName());
            // from more than one endpoint(initiator) we have to clone this connection per endpoint.
            for (VdsNetworkInterface iface : ifaces) {
                StorageServerConnections newConn = StorageServerConnections.copyOf(conn);
                newConn.setid(Guid.newGuid().toString());
                newConn.setIface(iface.getName());
                newConn.setNetIfacename(iface.isBridged() ? iface.getNetworkName() : iface.getName());
                res.add(newConn);
            }
        }
    }
    return res;
}
#method_after
public static List<StorageServerConnections> updateIfaces(List<StorageServerConnections> conns, Guid vdsId) {
    List<StorageServerConnections> res = new ArrayList<>(conns);
    for (StorageServerConnections conn : conns) {
        // Get list of endpoints (nics or vlans) that will initiate iscsi sessions.
        // Targets are represented by StorageServerConnections object (connection, iqn, port, portal).
        List<VdsNetworkInterface> ifaces = DbFacade.getInstance().getInterfaceDao().getIscsiIfacesByHostIdAndStorageTargetId(vdsId, conn.getid());
        if (!ifaces.isEmpty()) {
            VdsNetworkInterface removedInterface = ifaces.remove(0);
            setInterfaceProperties(conn, removedInterface);
            // from more than one endpoint(initiator) we have to clone this connection per endpoint.
            for (VdsNetworkInterface iface : ifaces) {
                StorageServerConnections newConn = StorageServerConnections.copyOf(conn);
                newConn.setid(Guid.newGuid().toString());
                setInterfaceProperties(newConn, iface);
                res.add(newConn);
            }
        }
    }
    return res;
}
#end_block

#method_before
private void fillConnectionDetailsIfNeeded(StorageServerConnections connection) {
    // it from the db by its details.
    if (connection.getid() == null) {
        List<StorageServerConnections> dbConnections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
        if (!dbConnections.isEmpty()) {
            connection.setid(dbConnections.get(0).getid());
        }
    }
}
#method_after
private void fillConnectionDetailsIfNeeded(StorageServerConnections connection) {
    // it from the db by its details.
    if (connection.getid() == null) {
        StorageServerConnections dbConnection = findConnectionWithSameDetails(connection);
        if (dbConnection != null) {
            connection.setid(dbConnection.getid());
        }
    }
}
#end_block

#method_before
@Override
public boolean isConnectSucceeded(final Map<String, String> returnValue, List<StorageServerConnections> connections) {
    boolean result = true;
    List<String> failedConnectionsList = LinqUtils.filter(returnValue.keySet(), new Predicate<String>() {

        @Override
        public boolean eval(String a) {
            return !"0".equals(returnValue.get(a));
        }
    });
    for (String failedConnection : failedConnectionsList) {
        List<LUNs> failedLuns = DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(failedConnection);
        if (!failedLuns.isEmpty()) {
            for (LUNs lun : failedLuns) {
                /**
                 * TODO: check if LUNs in the same pool.
                 */
                List<String> strings = LinqUtils.transformToList(DbFacade.getInstance().getStorageServerConnectionLunMapDao().getAll(lun.getLUN_id()), new Function<LUN_storage_server_connection_map, String>() {

                    @Override
                    public String eval(LUN_storage_server_connection_map a) {
                        return a.getstorage_server_connection();
                    }
                });
                if (CollectionUtils.subtract(strings, failedConnectionsList).size() == 0) {
                    // At case of failure the appropriate log message will be
                    // added
                    log.infoFormat("The lun with id {0} was reported as problematic !", lun.getphysical_volume_id());
                    for (String connectionFailed : failedConnectionsList) {
                        String connectionField = addToAuditLogErrorMessage(connectionFailed, returnValue.get(connectionFailed), connections, lun);
                        printLog(log, connectionField, returnValue.get(connectionFailed));
                    }
                    return false;
                }
            }
        } else {
            result = false;
            printLog(log, failedConnection, returnValue.get(failedConnection));
        }
    }
    return result;
}
#method_after
@Override
public boolean isConnectSucceeded(final Map<String, String> returnValue, List<StorageServerConnections> connections) {
    boolean result = true;
    List<String> failedConnectionsList = LinqUtils.filter(returnValue.keySet(), new Predicate<String>() {

        @Override
        public boolean eval(String a) {
            return !"0".equals(returnValue.get(a));
        }
    });
    for (String failedConnection : failedConnectionsList) {
        List<LUNs> failedLuns = DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(failedConnection);
        if (!failedLuns.isEmpty()) {
            for (LUNs lun : failedLuns) {
                /**
                 * TODO: check if LUNs in the same pool.
                 */
                List<String> strings = LinqUtils.transformToList(DbFacade.getInstance().getStorageServerConnectionLunMapDao().getAll(lun.getLUN_id()), new Function<LUN_storage_server_connection_map, String>() {

                    @Override
                    public String eval(LUN_storage_server_connection_map a) {
                        return a.getstorage_server_connection();
                    }
                });
                if (CollectionUtils.subtract(strings, failedConnectionsList).size() == 0) {
                    // At case of failure the appropriate log message will be
                    // added
                    log.info("The lun with id '{}' was reported as problematic", lun.getphysical_volume_id());
                    for (String connectionFailed : failedConnectionsList) {
                        String connectionField = addToAuditLogErrorMessage(connectionFailed, returnValue.get(connectionFailed), connections, lun);
                        printLog(log, connectionField, returnValue.get(connectionFailed));
                    }
                    return false;
                }
            }
        } else {
            result = false;
            printLog(log, failedConnection, returnValue.get(failedConnection));
        }
    }
    return result;
}
#end_block

#method_before
@Override
public boolean connectStorageToDomainByVdsId(StorageDomain storageDomain, Guid vdsId) {
    return runConnectionStorageToDomain(storageDomain, vdsId, VDSCommandType.ConnectStorageServer.getValue());
}
#method_after
@Override
public boolean connectStorageToDomainByVdsId(StorageDomain storageDomain, Guid vdsId) {
    return runConnectionStorageToDomain(storageDomain, vdsId, VDSCommandType.ConnectStorageServer.getValue()).getFirst();
}
#end_block

#method_before
@Override
public boolean disconnectStorageFromDomainByVdsId(StorageDomain storageDomain, Guid vdsId) {
    return runConnectionStorageToDomain(storageDomain, vdsId, VDSCommandType.DisconnectStorageServer.getValue());
}
#method_after
@Override
public boolean disconnectStorageFromDomainByVdsId(StorageDomain storageDomain, Guid vdsId) {
    return runConnectionStorageToDomain(storageDomain, vdsId, VDSCommandType.DisconnectStorageServer.getValue()).getFirst();
}
#end_block

#method_before
@Override
public boolean connectStorageToLunByVdsId(StorageDomain storageDomain, Guid vdsId, LUNs lun, Guid storagePoolId) {
    return runConnectionStorageToDomain(storageDomain, vdsId, VDSCommandType.ConnectStorageServer.getValue(), lun, storagePoolId);
}
#method_after
@Override
public boolean connectStorageToLunByVdsId(StorageDomain storageDomain, Guid vdsId, LUNs lun, Guid storagePoolId) {
    return runConnectionStorageToDomain(storageDomain, vdsId, VDSCommandType.ConnectStorageServer.getValue(), lun, storagePoolId).getFirst();
}
#end_block

#method_before
@Override
public boolean disconnectStorageFromLunByVdsId(StorageDomain storageDomain, Guid vdsId, LUNs lun) {
    return runConnectionStorageToDomain(storageDomain, vdsId, VDSCommandType.DisconnectStorageServer.getValue(), lun, Guid.Empty);
}
#method_after
@Override
public boolean disconnectStorageFromLunByVdsId(StorageDomain storageDomain, Guid vdsId, LUNs lun) {
    return runConnectionStorageToDomain(storageDomain, vdsId, VDSCommandType.DisconnectStorageServer.getValue(), lun, Guid.Empty).getFirst();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    proceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && !getStorageDomain().getId().equals(getNewMasterId(true))) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.Inactive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>getValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), getNewMasterId(true), domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    proceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && !getStorageDomain().getId().equals(_newMasterStorageDomainId)) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.Inactive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>getValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
private boolean connectVdsToNewMaster(VDS vds) {
    StorageDomain masterDomain = getNewMaster(true);
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).connectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.errorFormat("Error while trying connect host {0} to the needed storage server during the reinitialization of Data Center {1}", vds.getId(), getStoragePool().getId());
    return false;
}
#method_after
private boolean connectVdsToNewMaster(VDS vds) {
    StorageDomain masterDomain = getNewMaster(true);
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).connectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.error("Error while trying connect host {} to the needed storage server during the reinitialization" + " of Data Center '{}'", vds.getId(), getStoragePool().getId());
    return false;
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (_isLastMaster || !commandSucceeded) {
        log.warnFormat("skipping connect and refresh for all hosts, last master: {0}, command status: {1}", _isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() {
                try {
                    if (!connectVdsToNewMaster(vds)) {
                        log.warnFormat("failed to connect vds {0} to the new master {1}", vds.getId(), getNewMasterId(true));
                        return null;
                    }
                    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
                    try {
                        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterId(true), storagePoolIsoMap, true));
                    } catch (VdcBLLException ex) {
                        if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                            VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterId(true), storagePoolIsoMap));
                            if (!returnVal.getSucceeded()) {
                                log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                            }
                        } else {
                            log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                        }
                    }
                } catch (Exception e) {
                    log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (_isLastMaster || !commandSucceeded) {
        log.warn("skipping connect and refresh for all hosts, last master '{}', command status '{}'", _isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() {
                try {
                    if (!connectVdsToNewMaster(vds)) {
                        log.warn("failed to connect vds '{}' to the new master '{}'", vds.getId(), _newMasterStorageDomainId);
                        return null;
                    }
                    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
                    try {
                        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), _newMasterStorageDomainId, storagePoolIsoMap, true));
                    } catch (VdcBLLException ex) {
                        if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                            VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), _newMasterStorageDomainId, storagePoolIsoMap));
                            if (!returnVal.getSucceeded()) {
                                log.error("Post reconstruct actions (connectPool) did not complete on host '{}' in the pool. error {}", vds.getId(), returnVal.getVdsError().getMessage());
                            }
                        } else {
                            log.error("Post reconstruct actions (refreshPool)" + " did not complete on host '{}' in the pool. error {}", vds.getId(), ex.getMessage());
                        }
                    }
                } catch (Exception e) {
                    log.error("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host '{}' in the pool: {}", vds.getId(), e.getMessage());
                    log.debug("Exception", e);
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#end_block

#method_before
@Before
public void setUp() {
    cmd = spy(new ReconstructMasterDomainCommand<>(new ReconstructMasterParameters()));
    storagePoolIsoMap = new StoragePoolIsoMap(storageDomainId, storagePoolId, StorageDomainStatus.Active);
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setStoragePoolIsoMapData(storagePoolIsoMap);
    StoragePoolIsoMapDAO storagePoolIsoMapDao = mock(StoragePoolIsoMapDAO.class);
    doReturn(Collections.singletonList(storagePoolIsoMap)).when(storagePoolIsoMapDao).getAllForStoragePool(storagePoolId);
    StoragePool storagePool = new StoragePool();
    storagePool.setId(storagePoolId);
    StoragePoolValidator storagePoolValidator = spy(new StoragePoolValidator(storagePool));
    doReturn(storagePoolIsoMapDao).when(storagePoolValidator).getStoragePoolIsoMapDao();
    doReturn(storageDomain).when(cmd).getStorageDomain();
    doReturn(storagePool).when(cmd).getStoragePool();
    doReturn(storagePoolValidator).when(cmd).createStoragePoolValidator();
}
#method_after
@Before
public void setUp() {
    cmd = spy(new ReconstructMasterDomainCommand<>(new ReconstructMasterParameters()));
    initializeStorageDomains();
    initializeStoragePool();
    initializeStoragePoolValidator();
    doReturn(true).when(cmd).initializeVds();
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
        // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
        // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
        // ovfDisks cache list updated.
        List<DiskImage> ovfStoreDiskImages = new ArrayList(getAllOVFDisks());
        if (!ovfStoreDiskImages.isEmpty()) {
            while (!ovfStoreDiskImages.isEmpty()) {
                Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
                DiskImage ovfDisk = ovfDiskAndSize.getFirst();
                if (ovfDisk != null) {
                    try {
                        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                        getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                        if (vdcReturnValue.getSucceeded()) {
                            return OvfUtils.getOvfEntities((byte[]) vdcReturnValue.getActionReturnValue(), getParameters().getStorageDomainId());
                        } else {
                            log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), getParameters().getStorageDomainId());
                        }
                    } catch (RuntimeException e) {
                        // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                        // a RuntimeException if there is a problem to untar the file.
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), getParameters().getStorageDomainId(), e.getMessage());
                        log.debug("Exception", e);
                    }
                    ovfStoreDiskImages.remove(ovfDisk);
                }
            }
            AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
        } else {
            log.warn("There are no OVF_STORE disks on storage domain id {}", getParameters().getStorageDomainId());
            AuditLogDirector.log(this, AuditLogType.OVF_STORE_DOES_NOT_EXISTS);
        }
    } else {
        AuditLogDirector.log(this, AuditLogType.RETRIEVE_UNREGISTERED_ENTITIES_NOT_SUPPORTED_IN_DC_VERSION);
    }
    return Collections.emptyList();
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList(getAllOVFDisks());
    if (!ovfStoreDiskImages.isEmpty()) {
        if (!FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getcompatibility_version())) {
            AuditLogDirector.log(this, AuditLogType.RETRIEVE_UNREGISTERED_ENTITIES_NOT_SUPPORTED_IN_DC_VERSION);
            return Collections.emptyList();
        }
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        return OvfUtils.getOvfEntities((byte[]) vdcReturnValue.getActionReturnValue(), getParameters().getStorageDomainId());
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), getParameters().getStorageDomainId());
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), getParameters().getStorageDomainId(), e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", getParameters().getStorageDomainId());
        AuditLogDirector.log(this, AuditLogType.OVF_STORE_DOES_NOT_EXISTS);
    }
    return Collections.emptyList();
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setEntity(storage.getStorageDomainType().isDataDomain());
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            List<VDS> hosts = (List<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setEntity(storage.getStorageDomainType().isDataDomain());
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#end_block

#method_before
private boolean isItemSelectable(IStorageModel item, StoragePool dataCenter, boolean isNoStorageAttached) {
    // Local SD can be attached to a local DC only
    if (isLocalStorage(item) && !dataCenter.isLocal()) {
        return false;
    }
    // All storage domains can be attached to Unassigned DC
    if (StorageModel.UnassignedDataCenterId.equals(dataCenter.getId())) {
        return true;
    }
    // an attached domain of the same type already
    if (isNoStorageAttached && (item.getRole() == StorageDomainType.ISO || item.getRole() == StorageDomainType.ImportExport)) {
        return true;
    }
    // Allow import of data domains only if the data center supports OVF on any domain or in the "None" data center
    if (item.getRole() == StorageDomainType.Data) {
        return true;
    }
    return false;
}
#method_after
private boolean isItemSelectable(IStorageModel item, StoragePool dataCenter, boolean isNoStorageAttached) {
    // Local SD can be attached to a local DC only
    if (isLocalStorage(item) && !dataCenter.isLocal()) {
        return false;
    }
    // All storage domains can be attached to Unassigned DC
    if (StorageModel.UnassignedDataCenterId.equals(dataCenter.getId())) {
        return true;
    }
    // an attached domain of the same type already
    if (isNoStorageAttached && (item.getRole() == StorageDomainType.ISO || item.getRole() == StorageDomainType.ImportExport)) {
        return true;
    }
    if (item.getRole() == StorageDomainType.Data) {
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!checkStoragePool()) {
        return false;
    }
    if (!StringUtils.equals(getOldStoragePool().getName(), getStoragePool().getName()) && !isStoragePoolUnique(getStoragePool().getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
        return false;
    }
    if (getOldStoragePool().isLocal() != getStoragePool().isLocal() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
        return false;
    }
    if (!checkStoragePoolNameLengthValid()) {
        return false;
    }
    if (!getOldStoragePool().getcompatibility_version().equals(getStoragePool().getcompatibility_version())) {
        if (!isStoragePoolVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            return false;
        } else // decreasing of compatibility version is allowed under conditions
        if (getStoragePool().getcompatibility_version().compareTo(getOldStoragePool().getcompatibility_version()) < 0) {
            List<Network> networks = getNetworkDAO().getAllForDataCenter(getStoragePoolId());
            if (networks.size() == 1) {
                Network network = networks.get(0);
                NetworkValidator validator = getNetworkValidator(network);
                validator.setDataCenter(getStoragePool());
                if (!NetworkUtils.isManagementNetwork(network) || !validator.canNetworkCompatabilityBeDecreased()) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
                    return false;
                }
            } else if (networks.size() > 1) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
                return false;
            }
        } else {
            // Check all clusters has at least the same compatibility version.
            if (!checkAllClustersLevel()) {
                return false;
            }
        }
    }
    StoragePoolValidator validator = createStoragePoolValidator();
    return validate(validator.isNotLocalfsWithDefaultCluster());
}
#method_after
@Override
protected boolean canDoAction() {
    if (!checkStoragePool()) {
        return false;
    }
    // Name related validations
    if (!StringUtils.equals(getOldStoragePool().getName(), getStoragePool().getName()) && !isStoragePoolUnique(getStoragePool().getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (!checkStoragePoolNameLengthValid()) {
        return false;
    }
    List<StorageDomainStatic> poolDomains = getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId());
    if (getOldStoragePool().isLocal() != getStoragePool().isLocal() && !poolDomains.isEmpty()) {
        return failCanDoAction(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS);
    }
    if (!getOldStoragePool().getcompatibility_version().equals(getStoragePool().getcompatibility_version())) {
        if (!isStoragePoolVersionSupported()) {
            return failCanDoAction(VersionSupport.getUnsupportedVersionMessage());
        } else // decreasing of compatibility version is allowed under conditions
        if (getStoragePool().getcompatibility_version().compareTo(getOldStoragePool().getcompatibility_version()) < 0) {
            List<Network> networks = getNetworkDAO().getAllForDataCenter(getStoragePoolId());
            if (networks.size() == 1) {
                Network network = networks.get(0);
                NetworkValidator validator = getNetworkValidator(network);
                validator.setDataCenter(getStoragePool());
                if (!NetworkUtils.isManagementNetwork(network) || !validator.canNetworkCompatabilityBeDecreased()) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
                }
            } else if (networks.size() > 1) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
            }
        } else if (!checkAllClustersLevel()) {
            // Check all clusters has at least the same compatibility version.
            return false;
        }
    }
    StoragePoolValidator validator = createStoragePoolValidator();
    return validate(validator.isNotLocalfsWithDefaultCluster());
}
#end_block

#method_before
protected void spyCommand(StoragePoolManagementParameter params) {
    UpdateStoragePoolCommand<StoragePoolManagementParameter> realCommand = new UpdateStoragePoolCommand<StoragePoolManagementParameter>(params);
    StoragePoolValidator validator = spy(realCommand.createStoragePoolValidator());
    doReturn(vdsGroupDao).when(validator).getVdsGroupDao();
    cmd = spy(realCommand);
    doReturn(10).when(cmd).getStoragePoolNameSizeLimit();
    doReturn(createVersionSet().contains(cmd.getStoragePool().getcompatibility_version())).when(cmd).isStoragePoolVersionSupported();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(sdDao).when(cmd).getStorageDomainStaticDAO();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDAO();
    doReturn(vdsDao).when(cmd).getVdsDAO();
    doReturn(networkDao).when(cmd).getNetworkDAO();
    doReturn(validator).when(cmd).createStoragePoolValidator();
    doReturn(true).when(sdList).isEmpty();
    mcr.mockConfigValue(ConfigValues.AutoRegistrationDefaultVdsGroupID, DEFAULT_VDS_GROUP_ID);
    mcr.mockConfigValue(ConfigValues.ManagementNetwork, "test_mgmt");
    mcr.mockConfigValue(ConfigValues.NonVmNetworkSupported, false);
    mcr.mockConfigValue(ConfigValues.MTUOverrideSupported, false);
}
#method_after
protected void spyCommand(StoragePoolManagementParameter params) {
    UpdateStoragePoolCommand<StoragePoolManagementParameter> realCommand = new UpdateStoragePoolCommand<StoragePoolManagementParameter>(params);
    StoragePoolValidatorForTesting poolValidator = spy(new StoragePoolValidatorForTesting(params.getStoragePool()));
    doReturn(vdsGroupDao).when(poolValidator).getVdsGroupDao();
    cmd = spy(realCommand);
    doReturn(10).when(cmd).getStoragePoolNameSizeLimit();
    doReturn(createVersionSet().contains(cmd.getStoragePool().getcompatibility_version())).when(cmd).isStoragePoolVersionSupported();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(sdDao).when(cmd).getStorageDomainStaticDAO();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDAO();
    doReturn(vdsDao).when(cmd).getVdsDAO();
    doReturn(networkDao).when(cmd).getNetworkDAO();
    doReturn(poolValidator).when(cmd).createStoragePoolValidator();
    doReturn(true).when(sdList).isEmpty();
    mcr.mockConfigValue(ConfigValues.AutoRegistrationDefaultVdsGroupID, DEFAULT_VDS_GROUP_ID);
    mcr.mockConfigValue(ConfigValues.ManagementNetwork, "test_mgmt");
    mcr.mockConfigValue(ConfigValues.NonVmNetworkSupported, false);
    mcr.mockConfigValue(ConfigValues.MTUOverrideSupported, false);
}
#end_block

#method_before
public static StorageServerConnections findConnectionWithSameDetails(StorageServerConnections connection) {
    List<StorageServerConnections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
    for (StorageServerConnections dbConnection : connections) {
        if (ObjectUtils.objectsEqual(dbConnection.getpassword(), connection.getpassword())) {
            return connection;
        }
    }
    return null;
}
#method_after
public static StorageServerConnections findConnectionWithSameDetails(StorageServerConnections connection) {
    // As we encrypt the password when saving the connection to the DB and each encryption generates different
    // result,
    // we can't query the connections to check if connection with the exact
    // same details was already added - so we query the connections with the same (currently relevant) details and
    // then compare the password after it was already
    // decrypted.
    List<StorageServerConnections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
    for (StorageServerConnections dbConnection : connections) {
        if (ObjectUtils.objectsEqual(dbConnection.getpassword(), connection.getpassword())) {
            return dbConnection;
        }
    }
    return null;
}
#end_block

#method_before
protected void spyCommand(StoragePoolManagementParameter params) {
    UpdateStoragePoolCommand<StoragePoolManagementParameter> realCommand = new UpdateStoragePoolCommand<StoragePoolManagementParameter>(params);
    StoragePoolValidator validator = spy(realCommand.createStoragePoolValidator());
    doReturn(ValidationResult.VALID).when(validator).isNotLocalfsWithDefaultCluster();
    cmd = spy(realCommand);
    doReturn(10).when(cmd).getStoragePoolNameSizeLimit();
    doReturn(createVersionSet().contains(cmd.getStoragePool().getcompatibility_version())).when(cmd).isStoragePoolVersionSupported();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(sdDao).when(cmd).getStorageDomainStaticDAO();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDAO();
    doReturn(vdsDao).when(cmd).getVdsDAO();
    doReturn(networkDao).when(cmd).getNetworkDAO();
    doReturn(validator).when(cmd).createStoragePoolValidator();
    mcr.mockConfigValue(ConfigValues.AutoRegistrationDefaultVdsGroupID, DEFAULT_VDS_GROUP_ID);
    mcr.mockConfigValue(ConfigValues.ManagementNetwork, "test_mgmt");
    mcr.mockConfigValue(ConfigValues.NonVmNetworkSupported, false);
    mcr.mockConfigValue(ConfigValues.MTUOverrideSupported, false);
}
#method_after
protected void spyCommand(StoragePoolManagementParameter params) {
    UpdateStoragePoolCommand<StoragePoolManagementParameter> realCommand = new UpdateStoragePoolCommand<StoragePoolManagementParameter>(params);
    StoragePoolValidatorForTesting poolValidator = spy(new StoragePoolValidatorForTesting(params.getStoragePool()));
    doReturn(vdsGroupDao).when(poolValidator).getVdsGroupDao();
    cmd = spy(realCommand);
    doReturn(10).when(cmd).getStoragePoolNameSizeLimit();
    doReturn(createVersionSet().contains(cmd.getStoragePool().getcompatibility_version())).when(cmd).isStoragePoolVersionSupported();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(sdDao).when(cmd).getStorageDomainStaticDAO();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDAO();
    doReturn(vdsDao).when(cmd).getVdsDAO();
    doReturn(networkDao).when(cmd).getNetworkDAO();
    doReturn(poolValidator).when(cmd).createStoragePoolValidator();
    mcr.mockConfigValue(ConfigValues.AutoRegistrationDefaultVdsGroupID, DEFAULT_VDS_GROUP_ID);
    mcr.mockConfigValue(ConfigValues.ManagementNetwork, "test_mgmt");
    mcr.mockConfigValue(ConfigValues.NonVmNetworkSupported, false);
    mcr.mockConfigValue(ConfigValues.MTUOverrideSupported, false);
}
#end_block

#method_before
public static void parse(String path) {
    try {
        FileInputStream inputStream = new FileInputStream(path);
        OsInfoParser parser = new OsInfoParser(inputStream);
        parser.parse();
    } catch (FileNotFoundException e) {
        throw new RuntimeException("osinfo properties file cannot be found");
    } catch (ParseException e) {
        int line = e.currentToken.beginLine;
        int charPositionInLine = e.currentToken.beginColumn;
        String msg = e.getMessage();
        throw new RuntimeException("osinfo properties syntax error: " + ("line " + line + ":" + charPositionInLine + " " + msg));
    }
}
#method_after
public static void parse(String path) {
    try (FileInputStream inputStream = new FileInputStream(path)) {
        OsInfoParser parser = new OsInfoParser(inputStream);
        parser.parse();
    } catch (FileNotFoundException e) {
        throw new RuntimeException(String.format("osinfo properties file cannot be found: %s", path), e);
    } catch (IOException e) {
        throw new RuntimeException(String.format("error while reading osinfo properties file: %s", path), e);
    } catch (ParseException e) {
        throw new RuntimeException(String.format("osinfo properties syntax error: %s: %d, %d: error: %s", path, e.currentToken.beginLine, e.currentToken.beginColumn, e.getMessage()), e);
    }
}
#end_block

#method_before
public static CommandBase<?> createCommand(String className, Guid commandId) {
    Constructor<?> constructor = null;
    Boolean isAcessible = null;
    try {
        constructor = Class.forName(className).getDeclaredConstructor(Guid.class);
        // since this constructor is defined as protected, we must modify accessability and restore it afterwards
        if (!constructor.isAccessible()) {
            isAcessible = constructor.isAccessible();
            constructor.setAccessible(true);
        }
        CommandBase<?> cmd = (CommandBase<?>) constructor.newInstance(new Object[] { commandId });
        return Injector.injectMembers(cmd);
    } catch (Exception e) {
        log.error("CommandsFactory : Failed to get type information using reflection for Class  '{}', Command Id '{}': {}", className, commandId, e.getMessage());
        log.error("Exception", e);
        return null;
    } finally {
        if (isAcessible != null) {
            constructor.setAccessible(isAcessible);
        }
    }
}
#method_after
public static CommandBase<?> createCommand(String className, Guid commandId) {
    Constructor<?> constructor = null;
    Boolean isAcessible = null;
    try {
        constructor = Class.forName(className).getDeclaredConstructor(Guid.class);
        // since this constructor is defined as protected, we must modify accessability and restore it afterwards
        if (!constructor.isAccessible()) {
            isAcessible = constructor.isAccessible();
            constructor.setAccessible(true);
        }
        CommandBase<?> cmd = (CommandBase<?>) constructor.newInstance(commandId);
        return Injector.injectMembers(cmd);
    } catch (Exception e) {
        log.error("CommandsFactory : Failed to get type information using reflection for Class  '{}', Command Id '{}': {}", className, commandId, e.getMessage());
        log.error("Exception", e);
        return null;
    } finally {
        if (isAcessible != null) {
            constructor.setAccessible(isAcessible);
        }
    }
}
#end_block

#method_before
public static QueriesCommandBase<?> createQueryCommand(VdcQueryType query, VdcQueryParametersBase parameters, EngineContext engineContext) {
    Class<?> type = null;
    try {
        type = getQueryClass(query.name());
        QueriesCommandBase<?> result = null;
        if (engineContext == null) {
            result = (QueriesCommandBase<?>) findCommandConstructor(type, parameters.getClass()).newInstance(parameters);
        } else {
            result = (QueriesCommandBase<?>) findCommandConstructor(type, parameters.getClass(), EngineContext.class).newInstance(parameters, engineContext);
        }
        return result;
    } catch (Exception e) {
        log.error("Command Factory: Failed to create command '{}' using reflection: {}", type, e.getMessage());
        log.error("Exception", e);
        throw new RuntimeException(e);
    }
}
#method_after
public static QueriesCommandBase<?> createQueryCommand(VdcQueryType query, VdcQueryParametersBase parameters, EngineContext engineContext) {
    Class<?> type = null;
    try {
        type = getQueryClass(query.name());
        QueriesCommandBase<?> result;
        if (engineContext == null) {
            result = (QueriesCommandBase<?>) findCommandConstructor(type, parameters.getClass()).newInstance(parameters);
        } else {
            result = (QueriesCommandBase<?>) findCommandConstructor(type, parameters.getClass(), EngineContext.class).newInstance(parameters, engineContext);
        }
        return result;
    } catch (Exception e) {
        log.error("Command Factory: Failed to create command '{}' using reflection: {}", type, e.getMessage());
        log.error("Exception", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Override
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    StringBuilder sb = new StringBuilder(" ( ");
    boolean firstTime = true;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        value = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    }
    if ("=".equals(relations)) {
        relations = getLikeSyntax(caseSensitive);
    } else if ("!=".equals(relations)) {
        relations = "NOT " + getLikeSyntax(caseSensitive);
    }
    // Sort according to the value (real column name) in order not to rely on random access from map
    SortedSet<Map.Entry<String, String>> sortedEntrySet = new TreeSet<>(new ColNameMapEntryComparator());
    sortedEntrySet.addAll(columnNameDict.entrySet());
    for (Map.Entry<String, String> columnNameEntry : sortedEntrySet) {
        if (typeDict.get(columnNameEntry.getKey()) == String.class && !notFreeTextSearchableFieldsList.contains(columnNameEntry.getKey())) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(" OR ");
            }
            sb.append(StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, columnNameEntry.getValue(), relations, value));
        }
    }
    sb.append(" ) ");
    return sb.toString();
}
#method_after
@Override
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    StringBuilder sb = new StringBuilder(" ( ");
    boolean firstTime = true;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        value = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    }
    if ("=".equals(relations)) {
        relations = getLikeSyntax(caseSensitive);
    } else if ("!=".equals(relations)) {
        relations = "NOT " + getLikeSyntax(caseSensitive);
    }
    // Sort according to the value (real column name) in order not to rely on random access from map
    SortedSet<Map.Entry<String, String>> sortedEntrySet = new TreeSet<>(new ColNameMapEntryComparator());
    for (Map.Entry<String, String> entry : columnNameDict.entrySet()) {
        sortedEntrySet.add(entry);
    }
    for (Map.Entry<String, String> columnNameEntry : sortedEntrySet) {
        if (typeDict.get(columnNameEntry.getKey()) == String.class && !notFreeTextSearchableFieldsList.contains(columnNameEntry.getKey())) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(" OR ");
            }
            sb.append(StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, columnNameEntry.getValue(), relations, value));
        }
    }
    sb.append(" ) ");
    return sb.toString();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue;
    // check if user is not already subscribed to this event with same
    // method and address
    Guid subscriberId = getParameters().getEventSubscriber().getsubscriber_id();
    String eventName = getParameters().getEventSubscriber().getevent_up_name();
    EventNotificationMethod eventNotificationMethod = getParameters().getEventSubscriber().getevent_notification_method();
    List<event_subscriber> subscriptions = DbFacade.getInstance().getEventDao().getAllForSubscriber(subscriberId);
    if (IsAlreadySubscribed(subscriptions, subscriberId, eventName, eventNotificationMethod)) {
        addCanDoActionMessage(VdcBllMessages.EN_ALREADY_SUBSCRIBED);
        retValue = false;
    } else {
        // get notification method
        if (eventNotificationMethod != null) {
            // Validate user
            DbUser user = DbFacade.getInstance().getDbUserDao().get(subscriberId);
            if (user == null) {
                addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
                retValue = false;
            } else {
                retValue = ValidateAdd(eventNotificationMethod, getParameters().getEventSubscriber(), user);
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue;
    // check if user is not already subscribed to this event with same
    // method and address
    Guid subscriberId = getParameters().getEventSubscriber().getsubscriber_id();
    String eventName = getParameters().getEventSubscriber().getevent_up_name();
    EventNotificationMethod eventNotificationMethod = getParameters().getEventSubscriber().getevent_notification_method();
    List<event_subscriber> subscriptions = DbFacade.getInstance().getEventDao().getAllForSubscriber(subscriberId);
    if (IsAlreadySubscribed(subscriptions, subscriberId, eventName, eventNotificationMethod)) {
        addCanDoActionMessage(VdcBllMessages.EN_ALREADY_SUBSCRIBED);
        retValue = false;
    } else if (!eventExists(eventName)) {
        addCanDoActionMessage(VdcBllMessages.EN_UNSUPPORTED_NOTIFICATION_EVENT);
        retValue = false;
    } else {
        // get notification method
        if (eventNotificationMethod != null) {
            // Validate user
            DbUser user = DbFacade.getInstance().getDbUserDao().get(subscriberId);
            if (user == null) {
                addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
                retValue = false;
            } else {
                retValue = ValidateAdd(eventNotificationMethod, getParameters().getEventSubscriber(), user);
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
        }
    }
    return retValue;
}
#end_block

#method_before
private void populateVmWithDisks(List<Disk> disks, VM vm) {
    VmHandler.updateDisksForVm(vm, disks);
    for (Disk disk : disks) {
        VmDevice device = new VmDevice(new VmDeviceId(disk.getId(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, true, false, "", null, disk.getDiskStorageType() == Disk.DiskStorageType.IMAGE ? ((DiskImage) disk).getSnapshotId() : null);
        vm.getManagedVmDeviceMap().put(disk.getId(), device);
    }
}
#method_after
private void populateVmWithDisks(List<Disk> disks, VM vm) {
    VmHandler.updateDisksForVm(vm, disks);
    for (Disk disk : disks) {
        VmDevice device = new VmDevice(new VmDeviceId(disk.getId(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, true, false, "", null, disk.getDiskStorageType() == Disk.DiskStorageType.IMAGE ? ((DiskImage) disk).getSnapshotId() : null, null);
        vm.getManagedVmDeviceMap().put(disk.getId(), device);
    }
}
#end_block

#method_before
private DiskImage createDiskImage(boolean active) {
    DiskImage di = new DiskImage();
    di.setActive(active);
    di.setId(Guid.newGuid());
    di.setImageId(Guid.newGuid());
    di.setParentId(Guid.newGuid());
    di.setImageStatus(ImageStatus.OK);
    return di;
}
#method_after
private static DiskImage createDiskImage(boolean active) {
    DiskImage di = new DiskImage();
    di.setActive(active);
    di.setId(Guid.newGuid());
    di.setImageId(Guid.newGuid());
    di.setParentId(Guid.newGuid());
    di.setImageStatus(ImageStatus.OK);
    return di;
}
#end_block

#method_before
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, String> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVm, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVmStatusField, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#method_after
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, Field> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVm, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
        if (pair.getFirst().isHotsetAllowed()) {
            mUpdateVmsStatic.AddHotsetFields(pair.getSecond().getName());
        }
    }
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#end_block

#method_before
public static boolean isUpdateValid(VmStatic source, VmStatic destination) {
    return mUpdateVmsStatic.IsUpdateValid(source, destination);
}
#method_after
public static boolean isUpdateValid(VmStatic source, VmStatic destination, VMStatus status, boolean hotsetEnabled) {
    return mUpdateVmsStatic.IsUpdateValid(source, destination, status, hotsetEnabled);
}
#end_block

#method_before
public static boolean verifyAddVm(List<String> reasons, int nicsCount, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getAvailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else if (!VmTemplateCommand.isVmPriorityValueLegal(vmPriority, reasons)) {
        returnValue = false;
    }
    return returnValue;
}
#method_after
public static boolean verifyAddVm(List<String> reasons, int nicsCount, int vmPriority, MacPoolManagerStrategy macPool) {
    boolean returnValue = true;
    if (macPool.getAvailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else if (!VmTemplateCommand.isVmPriorityValueLegal(vmPriority, reasons)) {
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
public static List<VmInit> getVmInitByIds(List<Guid> ids) {
    VmInitDAO db = DbFacade.getInstance().getVmInitDao();
    return db.getVmInitByIds(ids);
}
#method_after
// if secure is true we don't return the stored password, only
public static List<VmInit> getVmInitByIds(List<Guid> ids, boolean secure) {
    VmInitDAO db = DbFacade.getInstance().getVmInitDao();
    List<VmInit> all = db.getVmInitByIds(ids);
    for (VmInit vmInit : all) {
        if (secure) {
            vmInit.setPasswordAlreadyStored(!StringUtils.isEmpty(vmInit.getRootPassword()));
            vmInit.setRootPassword(null);
        } else {
            vmInit.setPasswordAlreadyStored(false);
        }
    }
    return all;
}
#end_block

#method_before
private static Version getApplicationVersion(final String part, final String appName) {
    try {
        return new RpmVersion(part, getAppName(part, appName), true);
    } catch (Exception e) {
        log.debugFormat("Failed to create rpm version object, part: {0} appName: {1}, error: {2}", part, appName, e.toString());
        return null;
    }
}
#method_after
private static Version getApplicationVersion(final String part, final String appName) {
    try {
        return new RpmVersion(part, getAppName(part, appName), true);
    } catch (Exception e) {
        log.debug("Failed to create rpm version object, part '{}' appName '{}': {}", part, appName, e.getMessage());
        log.debug("Exception", e);
        return null;
    }
}
#end_block

#method_before
public static boolean isNumOfMonitorsLegal(DisplayType displayType, int numOfMonitors, List<String> reasons) {
    boolean legal = true;
    if (displayType == DisplayType.vnc) {
        legal = (numOfMonitors <= 1);
    } else {
        // Spice
        legal = (numOfMonitors <= getMaxNumberOfMonitors());
    }
    if (!legal) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS.toString());
    }
    return legal;
}
#method_after
public static boolean isNumOfMonitorsLegal(Collection<GraphicsType> graphicsTypes, int numOfMonitors, List<String> reasons) {
    boolean legal = false;
    if (graphicsTypes.contains(GraphicsType.VNC)) {
        legal = (numOfMonitors <= 1);
    } else if (graphicsTypes.contains(GraphicsType.SPICE)) {
        // contains spice and doesn't contain vnc
        legal = (numOfMonitors <= getMaxNumberOfMonitors());
    }
    if (!legal) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS.toString());
    }
    return legal;
}
#end_block

#method_before
public static StorageDomain findStorageDomainForMemory(Guid storagePoolId, long sizeRequested, Map<StorageDomain, Integer> domain2reservedSpaceInDomain) {
    List<StorageDomain> domainsInPool = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(storagePoolId);
    for (StorageDomain currDomain : domainsInPool) {
        long reservedSizeForDisks = domain2reservedSpaceInDomain.containsKey(currDomain) ? domain2reservedSpaceInDomain.get(currDomain) : 0;
        long sizeNeeded = sizeRequested + reservedSizeForDisks;
        if (currDomain.getStorageDomainType().isDataDomain() && currDomain.getStatus() == StorageDomainStatus.Active && doesStorageDomainHaveSpaceForRequest(currDomain, sizeNeeded)) {
            return currDomain;
        }
    }
    return null;
}
#method_after
public static StorageDomain findStorageDomainForMemory(Guid storagePoolId, List<DiskImage> disksList) {
    List<StorageDomain> domainsInPool = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(storagePoolId);
    return findStorageDomainForMemory(domainsInPool, disksList);
}
#end_block

#method_before
public static void updateCurrentCd(Guid vdsId, VM vm, String currentCd) {
    VmDynamic vmDynamic = vm.getDynamicData();
    vmDynamic.setCurrentCd(currentCd);
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(vdsId, vmDynamic));
}
#method_after
public static void updateCurrentCd(Guid vdsId, VM vm, String currentCd) {
    VmDynamic vmDynamic = vm.getDynamicData();
    vmDynamic.setCurrentCd(currentCd);
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(vmDynamic));
}
#end_block

#method_before
private CreateImageTemplateParameters buildChildCommandParameters(DiskImage diskImage, Guid vmSnapshotId) {
    CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
    createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
    createParams.setVmSnapshotId(vmSnapshotId);
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationStorageDomainId(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0));
    createParams.setDiskAlias(diskInfoDestinationMap.get(diskImage.getId()).getDiskAlias());
    createParams.setParentParameters(getParameters());
    createParams.setQuotaId(getQuotaIdForDisk(diskImage));
    return createParams;
}
#method_after
private CreateImageTemplateParameters buildChildCommandParameters(DiskImage diskImage, Guid vmSnapshotId) {
    CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
    createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
    createParams.setVmSnapshotId(vmSnapshotId);
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationStorageDomainId(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0));
    createParams.setDiskAlias(diskInfoDestinationMap.get(diskImage.getId()).getDiskAlias());
    createParams.setParentParameters(getParameters());
    createParams.setQuotaId(getQuotaIdForDisk(diskImage));
    createParams.setDiskProfileId(diskInfoDestinationMap.get(diskImage.getId()).getDiskProfileId());
    return createParams;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (getParameters().getBaseTemplateId() == null) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.infoFormat("Cancelling current running update for vms for base template id {0}", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warnFormat("Failed deleting job {0} at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVm().isBalloonEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), getParameters().getGraphicsDevices().keySet(), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    if (getParameters().getBaseTemplateId() != null) {
        VmTemplate userSelectedBaseTemplate = getVmTemplateDAO().get(getParameters().getBaseTemplateId());
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!getVm().getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (getParameters().getBaseTemplateId() != null) {
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#method_after
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "updateVmVersion", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    if (CommandCoordinatorUtil.getCommandExecutionStatus(getParameters().getCommandId()) == CommandExecutionStatus.EXECUTED) {
        // if template exist in db remove it
        if (getVmTemplate() != null) {
            DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
            removeNetwork();
        }
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        Guid storagePoolId = getVdsGroup() == null ? null : getVdsGroup().getStoragePoolId();
        permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
        // host-specific parameters can be changed by administration role only
        if (getParameters().getMasterVm().getDedicatedVmForVds() != null || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
        }
    }
    return permissionCheckSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
            Guid storagePoolId = getVdsGroup() == null ? null : getVdsGroup().getStoragePoolId();
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
            // host-specific parameters can be changed by administration role only
            if (getParameters().getMasterVm().getDedicatedVmForVds() != null || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
                permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
            }
        } else {
            permissionCheckSubject.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, getActionType().getActionGroup()));
        }
    }
    return permissionCheckSubject;
}
#end_block

#method_before
private void copyVmPermissions(UniquePermissionsSet permissionsToAdd) {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> vmPermissions = dao.getAllForEntity(getVmId(), getCurrentUser().getId(), false);
    for (Permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
    }
}
#method_after
private void copyVmPermissions(UniquePermissionsSet permissionsToAdd) {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> vmPermissions = dao.getAllForEntity(getVmId(), getEngineSessionSeqId(), false);
    for (Permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
    }
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    if (getParameters().getBaseTemplateId() != null) {
        return Collections.singletonMap(getParameters().getBaseTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return super.getSharedLocks();
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    if (isTemplateVersion()) {
        return Collections.singletonMap(getParameters().getBaseTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return super.getSharedLocks();
}
#end_block

#method_before
@Test
public void canDoActionFailedUpdateReadOnly() {
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    // make sure that device is plugged
    assertEquals(true, device.getIsPlugged());
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(true);
    initializeCommand(parameters, Collections.singletonList(createVm(VMStatus.Up)));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
}
#method_after
@Test
public void canDoActionFailedUpdateReadOnly() {
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(true);
    initializeCommand(parameters, Collections.singletonList(createVm(VMStatus.Up)));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
}
#end_block

#method_before
@Test
public void canDoActionFailedROVmAttachedToPool() {
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(true);
    VM vm = createVm(VMStatus.Down);
    vm.setVmPoolId(Guid.newGuid());
    initializeCommand(parameters, Collections.singletonList(vm));
    // Default RO is false
    VmDevice vmDevice = createVmDevice(diskImageGuid, vmId);
    when(command.getVmDeviceForVm()).thenReturn(vmDevice);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    vmDevice.setIsReadOnly(true);
    parameters.getDiskInfo().setReadOnly(false);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
}
#method_after
@Test
public void canDoActionFailedROVmAttachedToPool() {
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(true);
    VM vm = createVm(VMStatus.Down);
    vm.setVmPoolId(Guid.newGuid());
    initializeCommand(parameters, Collections.singletonList(vm));
    // Default RO is false
    VmDevice vmDevice = stubVmDevice(diskImageGuid, vmId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    vmDevice.setIsReadOnly(true);
    parameters.getDiskInfo().setReadOnly(false);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
}
#end_block

#method_before
@Test
public void nullifiedSnapshotOnUpdateDiskToShareable() {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.RAW);
    parameters.setDiskInfo(disk);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.NFS);
    parameters.setDiskInfo(disk);
    DiskImage oldDisk = createDiskImage();
    oldDisk.setVmSnapshotId(Guid.newGuid());
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    when(storageDomainStaticDao.get(storage.getId())).thenReturn(storage.getStorageStaticData());
    initializeCommand(parameters);
    mockInterfaceList();
    assertTrue(command.canDoAction());
    command.executeVmCommand();
    assertTrue(oldDisk.getVmSnapshotId() == null);
}
#method_after
@Test
public void nullifiedSnapshotOnUpdateDiskToShareable() {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.RAW);
    parameters.setDiskInfo(disk);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.NFS);
    parameters.setDiskInfo(disk);
    DiskImage oldDisk = createDiskImage();
    oldDisk.setVmSnapshotId(Guid.newGuid());
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    when(storageDomainStaticDao.get(storage.getId())).thenReturn(storage.getStorageStaticData());
    initializeCommand(parameters);
    mockVdsCommandSetVolumeDescription();
    mockInterfaceList();
    assertTrue(command.canDoAction());
    command.executeVmCommand();
    assertTrue(oldDisk.getVmSnapshotId() == null);
}
#end_block

#method_before
@Test
public void clearAddressOnInterfaceChange() {
    final UpdateVmDiskParameters parameters = createParameters();
    // update new disk interface so it will be different than the old one
    parameters.getDiskInfo().setDiskInterface(DiskInterface.VirtIO_SCSI);
    // creating old disk with interface different than interface of disk from parameters
    // have to return original disk on each request to dao,
    // since the command updates retrieved instance of disk
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    command.executeVmCommand();
    // verify that device address was cleared exactly once
    verify(vmDeviceDAO, times(1)).clearDeviceAddress(device.getDeviceId());
}
#method_after
@Test
public void clearAddressOnInterfaceChange() {
    final UpdateVmDiskParameters parameters = createParameters();
    // update new disk interface so it will be different than the old one
    parameters.getDiskInfo().setDiskInterface(DiskInterface.VirtIO_SCSI);
    // creating old disk with interface different than interface of disk from parameters
    // have to return original disk on each request to dao,
    // since the command updates retrieved instance of disk
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    mockVdsCommandSetVolumeDescription();
    command.executeVmCommand();
    // verify that device address was cleared exactly once
    verify(vmDeviceDAO).clearDeviceAddress(diskImageGuid);
}
#end_block

#method_before
@Test
public void testUpdateReadOnlyPropertyOnChange() {
    // Disk should be updated as Read Only
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(true);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    initializeCommand(parameters);
    command.executeVmCommand();
    device.setIsReadOnly(true);
    verify(vmDeviceDAO, times(1)).update(device);
}
#method_after
@Test
public void testUpdateReadOnlyPropertyOnChange() {
    // Disk should be updated as Read Only
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(true);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    initializeCommand(parameters);
    stubVmDevice(diskImageGuid, vmId);
    mockVdsCommandSetVolumeDescription();
    command.executeVmCommand();
    verify(command, atLeast(1)).updateReadOnlyRequested();
    assertTrue(command.updateReadOnlyRequested());
    verify(vmDeviceDAO).update(any(VmDevice.class));
}
#end_block

#method_before
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(anyList());
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(anyList());
    mockVdsCommandSetVolumeDescription();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(command.getDiskValidator(parameters.getDiskInfo())).thenReturn(diskValidator);
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Test
public void testDoNotUpdateDeviceWhenReadOnlyIsNotChanged() {
    // New disk is a read write
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    // Disk is already attached to VM as a read write
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    // To be sure that readOnly property is not changed
    assertEquals(device.getIsReadOnly(), parameters.getDiskInfo().getReadOnly());
    initializeCommand(parameters);
    command.executeVmCommand();
    assertFalse(command.updateReadOnlyRequested());
    verify(command, atLeast(1)).updateReadOnlyRequested();
    verify(vmDeviceDAO, never()).update(any(VmDevice.class));
}
#method_after
@Test
public void testDoNotUpdateDeviceWhenReadOnlyIsNotChanged() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    initializeCommand(parameters);
    mockVdsCommandSetVolumeDescription();
    command.executeVmCommand();
    verify(command, atLeast(1)).updateReadOnlyRequested();
    assertFalse(command.updateReadOnlyRequested());
    verify(vmDeviceDAO, never()).update(any(VmDevice.class));
}
#end_block

#method_before
@Test
public void testResize() {
    DiskImage oldDisk = createDiskImage();
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(sdId, spId)).thenReturn(sd);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(oldDisk.getSize() * 2);
    initializeCommand(parameters);
    assertTrue(command.validateCanResizeDisk());
}
#method_after
@Test
public void testResize() {
    DiskImage oldDisk = createDiskImage();
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(oldDisk.getSize() * 2);
    initializeCommand(parameters);
    assertTrue(command.validateCanResizeDisk());
}
#end_block

#method_before
@Test
public void testFailedRoDiskResize() {
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(sdId, spId)).thenReturn(sd);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(parameters.getDiskInfo().getSize() * 2);
    initializeCommand(parameters);
    DiskImage oldDisk = createDiskImage();
    doReturn(oldDisk).when(command).getOldDisk();
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    device.setIsReadOnly(true);
    doReturn(device).when(command).getVmDeviceForVm();
    assertFalse(command.validateCanResizeDisk());
    CanDoActionTestUtils.assertCanDoActionMessages("wrong failure", command, VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
}
#method_after
@Test
public void testFailedRoDiskResize() {
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(parameters.getDiskInfo().getSize() * 2);
    initializeCommand(parameters);
    DiskImage oldDisk = createDiskImage();
    doReturn(oldDisk).when(command).getOldDisk();
    VmDevice vmDevice = stubVmDevice(diskImageGuid, vmId);
    vmDevice.setIsReadOnly(true);
    assertFalse(command.validateCanResizeDisk());
    CanDoActionTestUtils.assertCanDoActionMessages("wrong failure", command, VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
}
#end_block

#method_before
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
}
#method_after
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
}
#end_block

#method_before
private StorageDomain addNewStorageDomainToDisk(DiskImage diskImage, StorageType storageType) {
    StorageDomain storage = new StorageDomain();
    storage.setId(Guid.newGuid());
    storage.setStorageType(storageType);
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storage.getId())));
    return storage;
}
#method_after
private StorageDomain addNewStorageDomainToDisk(DiskImage diskImage, StorageType storageType) {
    StorageDomain storage = new StorageDomain();
    storage.setId(Guid.newGuid());
    storage.setStorageType(storageType);
    storage.setStatus(StorageDomainStatus.Active);
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storage.getId())));
    return storage;
}
#end_block

#method_before
@Test
public void nullifiedSnapshotOnUpdateDiskToShareable() {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.RAW);
    parameters.setDiskInfo(disk);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.NFS);
    parameters.setDiskInfo(disk);
    DiskImage oldDisk = createDiskImage();
    oldDisk.setVmSnapshotId(Guid.newGuid());
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    when(storageDomainStaticDao.get(storage.getId())).thenReturn(storage.getStorageStaticData());
    initializeCommand(parameters);
    mockInterfaceList();
    assertTrue(command.canDoAction());
    command.executeVmCommand();
    assertTrue(oldDisk.getVmSnapshotId() == null);
}
#method_after
@Test
public void nullifiedSnapshotOnUpdateDiskToShareable() {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.RAW);
    parameters.setDiskInfo(disk);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.NFS);
    parameters.setDiskInfo(disk);
    DiskImage oldDisk = createDiskImage();
    oldDisk.setVmSnapshotId(Guid.newGuid());
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    when(storageDomainStaticDao.get(storage.getId())).thenReturn(storage.getStorageStaticData());
    initializeCommand(parameters);
    mockVdsCommandSetVolumeDescription();
    mockInterfaceList();
    assertTrue(command.canDoAction());
    command.executeVmCommand();
    assertTrue(oldDisk.getVmSnapshotId() == null);
}
#end_block

#method_before
@Test
public void clearAddressOnInterfaceChange() {
    final UpdateVmDiskParameters parameters = createParameters();
    // update new disk interface so it will be different than the old one
    parameters.getDiskInfo().setDiskInterface(DiskInterface.VirtIO_SCSI);
    // creating old disk with interface different than interface of disk from parameters
    // have to return original disk on each request to dao,
    // since the command updates retrieved instance of disk
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    // verify that device address was cleared exactly once
    verify(vmDeviceDAO, times(1)).clearDeviceAddress(device.getDeviceId());
}
#method_after
@Test
public void clearAddressOnInterfaceChange() {
    final UpdateVmDiskParameters parameters = createParameters();
    // update new disk interface so it will be different than the old one
    parameters.getDiskInfo().setDiskInterface(DiskInterface.VirtIO_SCSI);
    // creating old disk with interface different than interface of disk from parameters
    // have to return original disk on each request to dao,
    // since the command updates retrieved instance of disk
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    mockVdsCommandSetVolumeDescription();
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    // verify that device address was cleared exactly once
    verify(vmDeviceDAO, times(1)).clearDeviceAddress(device.getDeviceId());
}
#end_block

#method_before
@Test
public void testUpdateReadOnlyPropertyOnChange() {
    // Disk should be updated as Read Only
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(true);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    initializeCommand(parameters);
    command.executeVmCommand();
    device.setIsReadOnly(true);
    verify(vmDeviceDAO, times(1)).update(device);
}
#method_after
@Test
public void testUpdateReadOnlyPropertyOnChange() {
    // Disk should be updated as Read Only
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(true);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    initializeCommand(parameters);
    mockVdsCommandSetVolumeDescription();
    command.executeVmCommand();
    device.setIsReadOnly(true);
    verify(vmDeviceDAO, times(1)).update(device);
}
#end_block

#method_before
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(anyList());
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(anyList());
    mockVdsCommandSetVolumeDescription();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(command.getDiskValidator(parameters.getDiskInfo())).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Test
public void testDoNotUpdateDeviceWhenReadOnlyIsNotChanged() {
    // New disk is a read write
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    // Disk is already attached to VM as a read write
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    // To be sure that readOnly property is not changed
    assertEquals(device.getIsReadOnly(), parameters.getDiskInfo().getReadOnly());
    initializeCommand(parameters);
    command.executeVmCommand();
    assertFalse(command.updateReadOnlyRequested());
    verify(command, atLeast(1)).updateReadOnlyRequested();
    verify(vmDeviceDAO, never()).update(any(VmDevice.class));
}
#method_after
@Test
public void testDoNotUpdateDeviceWhenReadOnlyIsNotChanged() {
    // New disk is a read write
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    // Disk is already attached to VM as a read write
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    // To be sure that readOnly property is not changed
    assertEquals(device.getIsReadOnly(), parameters.getDiskInfo().getReadOnly());
    initializeCommand(parameters);
    mockVdsCommandSetVolumeDescription();
    command.executeVmCommand();
    assertFalse(command.updateReadOnlyRequested());
    verify(command, atLeast(1)).updateReadOnlyRequested();
    verify(vmDeviceDAO, never()).update(any(VmDevice.class));
}
#end_block

#method_before
@Test
public void testResize() {
    DiskImage oldDisk = createDiskImage();
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(sdId, spId)).thenReturn(sd);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(oldDisk.getSize() * 2);
    initializeCommand(parameters);
    assertTrue(command.validateCanResizeDisk());
}
#method_after
@Test
public void testResize() {
    DiskImage oldDisk = createDiskImage();
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(oldDisk.getSize() * 2);
    initializeCommand(parameters);
    assertTrue(command.validateCanResizeDisk());
}
#end_block

#method_before
@Test
public void testFailedRoDiskResize() {
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(sdId, spId)).thenReturn(sd);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(parameters.getDiskInfo().getSize() * 2);
    initializeCommand(parameters);
    DiskImage oldDisk = createDiskImage();
    doReturn(oldDisk).when(command).getOldDisk();
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    device.setIsReadOnly(true);
    doReturn(device).when(command).getVmDeviceForVm();
    assertFalse(command.validateCanResizeDisk());
    CanDoActionTestUtils.assertCanDoActionMessages("wrong failure", command, VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
}
#method_after
@Test
public void testFailedRoDiskResize() {
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(parameters.getDiskInfo().getSize() * 2);
    initializeCommand(parameters);
    DiskImage oldDisk = createDiskImage();
    doReturn(oldDisk).when(command).getOldDisk();
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    device.setIsReadOnly(true);
    doReturn(device).when(command).getVmDeviceForVm();
    assertFalse(command.validateCanResizeDisk());
    CanDoActionTestUtils.assertCanDoActionMessages("wrong failure", command, VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
}
#end_block

#method_before
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
}
#method_after
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
}
#end_block

#method_before
private StorageDomain addNewStorageDomainToDisk(DiskImage diskImage, StorageType storageType) {
    StorageDomain storage = new StorageDomain();
    storage.setId(Guid.newGuid());
    storage.setStorageType(storageType);
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storage.getId())));
    return storage;
}
#method_after
private StorageDomain addNewStorageDomainToDisk(DiskImage diskImage, StorageType storageType) {
    StorageDomain storage = new StorageDomain();
    storage.setId(Guid.newGuid());
    storage.setStorageType(storageType);
    storage.setStatus(StorageDomainStatus.Active);
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storage.getId())));
    return storage;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validateVmNotAttachedToPool() && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validateVmPoolProperties() && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#end_block

#method_before
protected boolean validateCanUpdateReadOnly(DiskValidator diskValidator) {
    if (updateReadOnlyRequested()) {
        if (getVm().getStatus() != VMStatus.Down && vmDeviceForVm.getIsPlugged()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        if (!validateVmNotAttachedToPool()) {
            return false;
        }
        return validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface());
    }
    return true;
}
#method_after
protected boolean validateCanUpdateReadOnly(DiskValidator diskValidator) {
    if (updateReadOnlyRequested()) {
        if (getVm().getStatus() != VMStatus.Down && vmDeviceForVm.getIsPlugged()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        return validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface());
    }
    return true;
}
#end_block

#method_before
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getIsReadOnly())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = getDiskImageDao().getDiskSnapshotForVmSnapshot(getParameters().getDiskId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(newDiskImage.getStorageIds().get(0), newDiskImage.getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#method_after
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getIsReadOnly())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = getDiskImageDao().getDiskSnapshotForVmSnapshot(getParameters().getDiskId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#end_block

#method_before
private void performDiskUpdate(final boolean unlockImage) {
    final Disk disk = getDiskDao().get(getParameters().getDiskId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                diskImage.setQuotaId(getQuotaId());
                if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                    diskImage.setImageStatus(ImageStatus.OK);
                }
                getImageDao().update(diskImage.getImage());
                updateQuota(diskImage);
                updateDiskProfile();
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#method_after
private void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk disk = getDiskDao().get(getParameters().getDiskId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                diskImage.setQuotaId(getQuotaId());
                if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                    diskImage.setImageStatus(ImageStatus.OK);
                }
                getImageDao().update(diskImage.getImage());
                updateQuota(diskImage);
                updateDiskProfile();
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#end_block

#method_before
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getIsReadOnly())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = getDiskImageDao().getDiskSnapshotForVmSnapshot(getParameters().getDiskId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(newDiskImage.getStorageIds().get(0), newDiskImage.getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#method_after
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getIsReadOnly())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = getDiskImageDao().getDiskSnapshotForVmSnapshot(getParameters().getDiskId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#end_block

#method_before
private void performDiskUpdate(final boolean unlockImage) {
    final Disk disk = getDiskDao().get(getParameters().getDiskId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                diskImage.setQuotaId(getQuotaId());
                if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                    diskImage.setImageStatus(ImageStatus.OK);
                }
                getImageDao().update(diskImage.getImage());
                updateQuota(diskImage);
                updateDiskProfile();
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#method_after
private void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk disk = getDiskDao().get(getParameters().getDiskId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                diskImage.setQuotaId(getQuotaId());
                if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                    diskImage.setImageStatus(ImageStatus.OK);
                }
                getImageDao().update(diskImage.getImage());
                updateQuota(diskImage);
                updateDiskProfile();
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#end_block

#method_before
@Test
public void nullifiedSnapshotOnUpdateDiskToShareable() {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.RAW);
    parameters.setDiskInfo(disk);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.NFS);
    parameters.setDiskInfo(disk);
    DiskImage oldDisk = createDiskImage();
    oldDisk.setVmSnapshotId(Guid.newGuid());
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    when(storageDomainStaticDao.get(storage.getId())).thenReturn(storage.getStorageStaticData());
    initializeCommand(parameters);
    mockInterfaceList();
    assertTrue(command.canDoAction());
    command.executeVmCommand();
    assertTrue(oldDisk.getVmSnapshotId() == null);
}
#method_after
@Test
public void nullifiedSnapshotOnUpdateDiskToShareable() {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.RAW);
    parameters.setDiskInfo(disk);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.NFS);
    parameters.setDiskInfo(disk);
    DiskImage oldDisk = createDiskImage();
    oldDisk.setVmSnapshotId(Guid.newGuid());
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    when(storageDomainStaticDao.get(storage.getId())).thenReturn(storage.getStorageStaticData());
    initializeCommand(parameters);
    mockVdsCommandSetVolumeDescription();
    mockInterfaceList();
    assertTrue(command.canDoAction());
    command.executeVmCommand();
    assertTrue(oldDisk.getVmSnapshotId() == null);
}
#end_block

#method_before
@Test
public void clearAddressOnInterfaceChange() {
    final UpdateVmDiskParameters parameters = createParameters();
    // update new disk interface so it will be different than the old one
    parameters.getDiskInfo().setDiskInterface(DiskInterface.VirtIO_SCSI);
    // creating old disk with interface different than interface of disk from parameters
    // have to return original disk on each request to dao,
    // since the command updates retrieved instance of disk
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    // verify that device address was cleared exactly once
    verify(vmDeviceDAO, times(1)).clearDeviceAddress(device.getDeviceId());
}
#method_after
@Test
public void clearAddressOnInterfaceChange() {
    final UpdateVmDiskParameters parameters = createParameters();
    // update new disk interface so it will be different than the old one
    parameters.getDiskInfo().setDiskInterface(DiskInterface.VirtIO_SCSI);
    // creating old disk with interface different than interface of disk from parameters
    // have to return original disk on each request to dao,
    // since the command updates retrieved instance of disk
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    mockVdsCommandSetVolumeDescription();
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    // verify that device address was cleared exactly once
    verify(vmDeviceDAO, times(1)).clearDeviceAddress(device.getDeviceId());
}
#end_block

#method_before
@Test
public void testUpdateReadOnlyPropertyOnChange() {
    // Disk should be updated as Read Only
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(true);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    initializeCommand(parameters);
    command.executeVmCommand();
    device.setIsReadOnly(true);
    verify(vmDeviceDAO, times(1)).update(device);
}
#method_after
@Test
public void testUpdateReadOnlyPropertyOnChange() {
    // Disk should be updated as Read Only
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(true);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    initializeCommand(parameters);
    mockVdsCommandSetVolumeDescription();
    command.executeVmCommand();
    device.setIsReadOnly(true);
    verify(vmDeviceDAO, times(1)).update(device);
}
#end_block

#method_before
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(anyList());
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assertNotSame(oldDisk.getDiskInterface(), parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(anyList());
    mockVdsCommandSetVolumeDescription();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(command.getDiskValidator(parameters.getDiskInfo())).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Test
public void testDoNotUpdateDeviceWhenReadOnlyIsNotChanged() {
    // New disk is a read write
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    // Disk is already attached to VM as a read write
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    // To be sure that readOnly property is not changed
    assertEquals(device.getIsReadOnly(), parameters.getDiskInfo().getReadOnly());
    initializeCommand(parameters);
    command.executeVmCommand();
    assertFalse(command.updateReadOnlyRequested());
    verify(command, atLeast(1)).updateReadOnlyRequested();
    verify(vmDeviceDAO, never()).update(any(VmDevice.class));
}
#method_after
@Test
public void testDoNotUpdateDeviceWhenReadOnlyIsNotChanged() {
    // New disk is a read write
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    // Disk is already attached to VM as a read write
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    // To be sure that readOnly property is not changed
    assertEquals(device.getIsReadOnly(), parameters.getDiskInfo().getReadOnly());
    initializeCommand(parameters);
    mockVdsCommandSetVolumeDescription();
    command.executeVmCommand();
    assertFalse(command.updateReadOnlyRequested());
    verify(command, atLeast(1)).updateReadOnlyRequested();
    verify(vmDeviceDAO, never()).update(any(VmDevice.class));
}
#end_block

#method_before
@Test
public void testResize() {
    DiskImage oldDisk = createDiskImage();
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(sdId, spId)).thenReturn(sd);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(oldDisk.getSize() * 2);
    initializeCommand(parameters);
    assertTrue(command.validateCanResizeDisk());
}
#method_after
@Test
public void testResize() {
    DiskImage oldDisk = createDiskImage();
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(oldDisk.getSize() * 2);
    initializeCommand(parameters);
    assertTrue(command.validateCanResizeDisk());
}
#end_block

#method_before
@Test
public void testFailedRoDiskResize() {
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(sdId, spId)).thenReturn(sd);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(parameters.getDiskInfo().getSize() * 2);
    initializeCommand(parameters);
    DiskImage oldDisk = createDiskImage();
    doReturn(oldDisk).when(command).getOldDisk();
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    device.setIsReadOnly(true);
    doReturn(device).when(command).getVmDeviceForVm();
    assertFalse(command.validateCanResizeDisk());
    CanDoActionTestUtils.assertCanDoActionMessages("wrong failure", command, VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
}
#method_after
@Test
public void testFailedRoDiskResize() {
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    UpdateVmDiskParameters parameters = createParameters();
    ((DiskImage) parameters.getDiskInfo()).setSize(parameters.getDiskInfo().getSize() * 2);
    initializeCommand(parameters);
    DiskImage oldDisk = createDiskImage();
    doReturn(oldDisk).when(command).getOldDisk();
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    device.setIsReadOnly(true);
    doReturn(device).when(command).getVmDeviceForVm();
    assertFalse(command.validateCanResizeDisk());
    CanDoActionTestUtils.assertCanDoActionMessages("wrong failure", command, VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
}
#end_block

#method_before
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
}
#method_after
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
}
#end_block

#method_before
private StorageDomain addNewStorageDomainToDisk(DiskImage diskImage, StorageType storageType) {
    StorageDomain storage = new StorageDomain();
    storage.setId(Guid.newGuid());
    storage.setStorageType(storageType);
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storage.getId())));
    return storage;
}
#method_after
private StorageDomain addNewStorageDomainToDisk(DiskImage diskImage, StorageType storageType) {
    StorageDomain storage = new StorageDomain();
    storage.setId(Guid.newGuid());
    storage.setStorageType(storageType);
    storage.setStatus(StorageDomainStatus.Active);
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storage.getId())));
    return storage;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    if (getDbFacade().getStorageDomainDao().get(storageDomainId) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        Map<String, Object> diskDescriptionMap;
        try {
            diskDescriptionMap = JsonHelper.jsonToMap(newDiskImage.getDescription());
            newDiskImage.setDiskAlias((String) diskDescriptionMap.get(ImagesHandler.DISK_ALIAS));
            newDiskImage.setDiskDescription((String) diskDescriptionMap.get(ImagesHandler.DISK_DESCRIPTION));
        } catch (IOException e) {
            log.warnFormat("Exception while generating json for disk. Exception: {0}", e);
        }
    }
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    if (getDbFacade().getStorageDomainDao().get(storageDomainId) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        try {
            Map<String, Object> diskDescriptionMap = JsonHelper.jsonToMap(newDiskImage.getDescription());
            newDiskImage.setDiskAlias((String) diskDescriptionMap.get(ImagesHandler.DISK_ALIAS));
            newDiskImage.setDiskDescription((String) diskDescriptionMap.get(ImagesHandler.DISK_DESCRIPTION));
        } catch (IOException e) {
            log.warn("Exception while parsing JSON for disk. Exception: '{}'", e);
        }
    }
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#end_block

#method_before
public static String getSuggestedDiskAlias(BaseDisk disk, String diskPrefix, int count) {
    String diskAlias;
    if (disk == null) {
        diskAlias = getDefaultDiskAlias(diskPrefix, DefaultDriveName);
        log.warnFormat("Disk object is null, the suggested default disk alias to be used is {0}", diskAlias);
    } else {
        String defaultAlias = getDefaultDiskAlias(diskPrefix, String.valueOf(count));
        diskAlias = getDiskAliasWithDefault(disk, defaultAlias);
    }
    return diskAlias;
}
#method_after
public static String getSuggestedDiskAlias(BaseDisk disk, String diskPrefix, int count) {
    String diskAlias;
    if (disk == null) {
        diskAlias = getDefaultDiskAlias(diskPrefix, DefaultDriveName);
        log.warn("Disk object is null, the suggested default disk alias to be used is '{}'", diskAlias);
    } else {
        String defaultAlias = getDefaultDiskAlias(diskPrefix, String.valueOf(count));
        diskAlias = getDiskAliasWithDefault(disk, defaultAlias);
    }
    return diskAlias;
}
#end_block

#method_before
public static String getDiskAliasWithDefault(BaseDisk disk, String aliasIfNull) {
    String diskAlias = disk.getDiskAlias();
    if (StringUtils.isEmpty(diskAlias)) {
        log.infoFormat("Disk alias retrieved from the client is null or empty, the suggested default disk alias to be used is {0}", aliasIfNull);
        return aliasIfNull;
    }
    return diskAlias;
}
#method_after
public static String getDiskAliasWithDefault(BaseDisk disk, String aliasIfNull) {
    String diskAlias = disk.getDiskAlias();
    if (StringUtils.isEmpty(diskAlias)) {
        log.info("Disk alias retrieved from the client is null or empty, the suggested default disk alias to be" + " used is '{}'", aliasIfNull);
        return aliasIfNull;
    }
    return diskAlias;
}
#end_block

#method_before
public static void addDiskImage(DiskImage image, boolean active, image_storage_domain_map imageStorageDomainMap, Guid vmId) {
    try {
        addImage(image, active, imageStorageDomainMap);
        addDiskToVmIfNotExists(image, vmId);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db", ex);
        throw new VdcBLLException(VdcBllErrors.DB, ex);
    }
}
#method_after
public static void addDiskImage(DiskImage image, boolean active, image_storage_domain_map imageStorageDomainMap, Guid vmId) {
    try {
        addImage(image, active, imageStorageDomainMap);
        addDiskToVmIfNotExists(image, vmId);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new VdcBLLException(VdcBllErrors.DB, ex);
    }
}
#end_block

#method_before
public static void addDiskImageWithNoVmDevice(DiskImage image, boolean active, image_storage_domain_map imageStorageDomainMap) {
    try {
        addImage(image, active, imageStorageDomainMap);
        addDisk(image);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db", ex);
        throw new VdcBLLException(VdcBllErrors.DB, ex);
    }
}
#method_after
public static void addDiskImageWithNoVmDevice(DiskImage image, boolean active, image_storage_domain_map imageStorageDomainMap) {
    try {
        addImage(image, active, imageStorageDomainMap);
        addDisk(image);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new VdcBLLException(VdcBllErrors.DB, ex);
    }
}
#end_block

#method_before
private static DiskImage isImageExist(Guid storagePoolId, DiskImage image) {
    DiskImage fromIrs = null;
    try {
        Guid storageDomainId = image.getStorageIds().get(0);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        fromIrs = (DiskImage) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, image.getImageId())).getReturnValue();
    } catch (Exception e) {
        log.debug("Unable to get image info from from storage.", e);
    }
    return fromIrs;
}
#method_after
private static DiskImage isImageExist(Guid storagePoolId, DiskImage image) {
    DiskImage fromIrs = null;
    try {
        Guid storageDomainId = image.getStorageIds().get(0);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        fromIrs = (DiskImage) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, image.getImageId())).getReturnValue();
    } catch (Exception e) {
        log.debug("Unable to get image info from from storage", e);
    }
    return fromIrs;
}
#end_block

#method_before
public static void removeDiskImage(DiskImage diskImage, Guid vmId) {
    try {
        removeDiskFromVm(vmId, diskImage.getId());
        removeImage(diskImage);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db", ex);
        throw new VdcBLLException(VdcBllErrors.DB, ex);
    }
}
#method_after
public static void removeDiskImage(DiskImage diskImage, Guid vmId) {
    try {
        removeDiskFromVm(vmId, diskImage.getId());
        removeImage(diskImage);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new VdcBLLException(VdcBllErrors.DB, ex);
    }
}
#end_block

#method_before
public static Snapshot prepareSnapshotConfigWithAlternateImage(Snapshot snapshot, Guid oldImageId, DiskImage newImage) {
    try {
        OvfManager ovfManager = new OvfManager();
        String snapConfig = snapshot.getVmConfiguration();
        if (snapshot.isVmConfigurationAvailable() && snapConfig != null) {
            VM vmSnapshot = new VM();
            ArrayList<DiskImage> snapshotImages = new ArrayList<DiskImage>();
            ovfManager.ImportVm(snapConfig, vmSnapshot, snapshotImages, new ArrayList<VmNetworkInterface>());
            // Remove the image from the disk list
            Iterator<DiskImage> diskIter = snapshotImages.iterator();
            while (diskIter.hasNext()) {
                DiskImage imageInList = diskIter.next();
                if (imageInList.getImageId().equals(oldImageId)) {
                    log.debugFormat("Recreating vmSnapshot {0} without the image {1}", snapshot.getId(), oldImageId);
                    diskIter.remove();
                    break;
                }
            }
            if (newImage != null) {
                log.debugFormat("Adding image {0} to vmSnapshot {1}", newImage.getImageId(), snapshot.getId());
                snapshotImages.add(newImage);
            }
            String newOvf = ovfManager.ExportVm(vmSnapshot, snapshotImages, ClusterUtils.getCompatibilityVersion(vmSnapshot));
            snapshot.setVmConfiguration(newOvf);
        }
    } catch (OvfReaderException e) {
        log.errorFormat("Can't remove image {0} from snapshot {1}", oldImageId, snapshot.getId());
    }
    return snapshot;
}
#method_after
public static Snapshot prepareSnapshotConfigWithAlternateImage(Snapshot snapshot, Guid oldImageId, DiskImage newImage) {
    try {
        OvfManager ovfManager = new OvfManager();
        String snapConfig = snapshot.getVmConfiguration();
        if (snapshot.isVmConfigurationAvailable() && snapConfig != null) {
            VM vmSnapshot = new VM();
            ArrayList<DiskImage> snapshotImages = new ArrayList<DiskImage>();
            ovfManager.ImportVm(snapConfig, vmSnapshot, snapshotImages, new ArrayList<VmNetworkInterface>());
            // Remove the image from the disk list
            Iterator<DiskImage> diskIter = snapshotImages.iterator();
            while (diskIter.hasNext()) {
                DiskImage imageInList = diskIter.next();
                if (imageInList.getImageId().equals(oldImageId)) {
                    log.debug("Recreating vmSnapshot '{}' without the image '{}'", snapshot.getId(), oldImageId);
                    diskIter.remove();
                    break;
                }
            }
            if (newImage != null) {
                log.debug("Adding image '{}' to vmSnapshot '{}'", newImage.getImageId(), snapshot.getId());
                snapshotImages.add(newImage);
            }
            String newOvf = ovfManager.ExportVm(vmSnapshot, snapshotImages, ClusterUtils.getCompatibilityVersion(vmSnapshot));
            snapshot.setVmConfiguration(newOvf);
        }
    } catch (OvfReaderException e) {
        log.error("Can't remove image '{}' from snapshot '{}'", oldImageId, snapshot.getId());
    }
    return snapshot;
}
#end_block

#method_before
private String getJsonDiskDescription() {
    Map<String, Object> description = new HashMap<>();
    description.put(ImagesHandler.DISK_ALIAS, getParameters().getDiskInfo().getDiskAlias());
    description.put(ImagesHandler.DISK_DESCRIPTION, getParameters().getDiskInfo().getDiskDescription());
    try {
        return JsonHelper.mapToJson(description, false);
    } catch (IOException e) {
        log.errorFormat("Exception while generating json for disk. ERROR: {0}", e);
        AuditLogableBase auditLogableBase = new AuditLogableBase();
        auditLogableBase.addCustomValue("DataCenterName", getStoragePool().getName());
        auditLogableBase.addCustomValue("StorageDomainName", getStorageDomain().getName());
        auditLogableBase.addCustomValue("DiskName", getParameters().getDiskInfo().getDiskAlias());
        AuditLogDirector.log(auditLogableBase, AuditLogType.UPDATE_DESCRIPTION_FOR_DISK_FAILED);
        return StringUtils.EMPTY;
    }
}
#method_after
private String getJsonDiskDescription() {
    try {
        return ImagesHandler.getJsonDiskDescription(getParameters().getDiskInfo().getDiskAlias(), getParameters().getDiskInfo().getDiskDescription());
    } catch (IOException e) {
        log.error("Exception while generating json for disk. ERROR: '{}'", e);
        return StringUtils.EMPTY;
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (getDestinationDiskImage() != null) {
        if (getParameters().isShouldRemainIllegalOnFailedExecution()) {
            setImageStatus(ImageStatus.ILLEGAL);
        } else {
            DbFacade.getInstance().getDiskImageDynamicDao().remove(getDestinationDiskImage().getImageId());
            super.endWithFailure();
        }
    }
}
#method_after
@Override
protected void endWithFailure() {
    if (getDestinationDiskImage() != null) {
        if (getParameters().isShouldRemainIllegalOnFailedExecution()) {
            setImageStatus(ImageStatus.ILLEGAL, getDestinationDiskImage());
        } else {
            DbFacade.getInstance().getDiskImageDynamicDao().remove(getDestinationDiskImage().getImageId());
            super.endWithFailure();
        }
    }
}
#end_block

#method_before
private void discoverHostName_SelectedItemChanged() {
    if (Boolean.TRUE.equals(getIsDiscoveredHosts().getEntity())) {
        ExternalDiscoveredHost dhost = (ExternalDiscoveredHost) getExternalDiscoveredHosts().getSelectedItem();
        ExternalHostGroup dhg = (ExternalHostGroup) getExternalHostGroups().getSelectedItem();
        VDS vds = new VDS();
        if (dhost != null && dhg != null) {
            vds.setVdsName(dhost.getName());
            vds.setHostName(// $NON-NLS-1$
            dhost.getName() + "." + (dhg.getDomainName() != null ? dhg.getDomainName() : constants.empty()));
        }
        updateModelFromVds(vds, null, false, null);
    }
}
#method_after
private void discoverHostName_SelectedItemChanged() {
    if (Boolean.TRUE.equals(getIsDiscoveredHosts().getEntity())) {
        ExternalDiscoveredHost dhost = (ExternalDiscoveredHost) getExternalDiscoveredHosts().getSelectedItem();
        ExternalHostGroup dhg = (ExternalHostGroup) getExternalHostGroups().getSelectedItem();
        VDS vds = new VDS();
        if (dhost != null && dhg != null) {
            vds.setVdsName(dhost.getName());
            vds.setHostName(// $NON-NLS-1$
            dhost.getName() + "." + // $NON-NLS-1$
            (dhg.getDomainName() != null ? dhg.getDomainName() : ""));
        }
        updateModelFromVds(vds, null, false, null);
    }
}
#end_block

#method_before
private void externalHostGroups_SelectedItemChanged() {
    ExternalHostGroup dhg = (ExternalHostGroup) getExternalHostGroups().getSelectedItem();
    VDS vds = new VDS();
    if (dhg != null) {
        vds.setVdsName(getName().getEntity());
        vds.setHostName(// $NON-NLS-1$
        getName().getEntity() + "." + (dhg.getDomainName() != null ? dhg.getDomainName() : constants.empty()));
    }
    updateModelFromVds(vds, null, false, null);
}
#method_after
private void externalHostGroups_SelectedItemChanged() {
    ExternalHostGroup dhg = (ExternalHostGroup) getExternalHostGroups().getSelectedItem();
    VDS vds = new VDS();
    if (dhg != null) {
        vds.setVdsName(getName().getEntity());
        vds.setHostName(// $NON-NLS-1$
        getName().getEntity() + "." + // $NON-NLS-1$
        (dhg.getDomainName() != null ? dhg.getDomainName() : ""));
    }
    updateModelFromVds(vds, null, false, null);
}
#end_block

#method_before
@Test
public void testQueryExecution() {
    // Prepare the query parameters
    Guid adElementGuid = Guid.newGuid();
    when(getQueryParameters().getId()).thenReturn(adElementGuid);
    // Create expected result
    Permissions expected = new Permissions();
    expected.setad_element_id(adElementGuid);
    // Mock the DAOs
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getAllForAdElement(adElementGuid, getUser().getId(), getQuery().getEngineSessionId(), getQueryParameters().isFiltered())).thenReturn(Collections.singletonList(expected));
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    getQuery().executeQueryCommand();
    // Assert the query's results
    @SuppressWarnings("unchecked")
    List<Permissions> actual = (List<Permissions>) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong number of returned permissions", 1, actual.size());
    assertEquals("Wrong returned permissions", expected, actual.get(0));
}
#method_after
@Test
public void testQueryExecution() {
    // Prepare the query parameters
    Guid adElementGuid = Guid.newGuid();
    when(getQueryParameters().getId()).thenReturn(adElementGuid);
    // Create expected result
    Permissions expected = new Permissions();
    expected.setad_element_id(adElementGuid);
    // Mock the DAOs
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getAllForAdElement(adElementGuid, getQuery().getEngineSessionSeqId(), getQueryParameters().isFiltered())).thenReturn(Collections.singletonList(expected));
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    getQuery().executeQueryCommand();
    // Assert the query's results
    @SuppressWarnings("unchecked")
    List<Permissions> actual = (List<Permissions>) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong number of returned permissions", 1, actual.size());
    assertEquals("Wrong returned permissions", expected, actual.get(0));
}
#end_block

#method_before
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, getExecutionContext());
}
#method_after
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return commandObjectsHandlerProvider.get().runAction(command, getExecutionContext());
}
#end_block

#method_before
protected BackendInternal getBackend() {
    return Backend.getInstance();
}
#method_after
protected BackendInternal getBackend() {
    return Injector.get(BackendInternal.class);
}
#end_block

#method_before
private CompensationContext createCompensationContext(TransactionScopeOption transactionScopeOption, boolean forceCompensation) {
    if (transactionScopeOption == TransactionScopeOption.Suppress && !forceCompensation) {
        return NoOpCompensationContext.getInstance();
    }
    DefaultCompensationContext defaultContext = new DefaultCompensationContext();
    defaultContext.setCommandId(commandId);
    defaultContext.setCommandType(getClass().getName());
    defaultContext.setBusinessEntitySnapshotDAO(getBusinessEntitySnapshotDAO());
    defaultContext.setSnapshotSerializer(SerializationFactory.getSerializer());
    return defaultContext;
}
#method_after
private CompensationContext createCompensationContext(TransactionScopeOption transactionScopeOption, boolean forceCompensation) {
    if (transactionScopeOption == TransactionScopeOption.Suppress && !forceCompensation) {
        return NoOpCompensationContext.getInstance();
    }
    return createDefaultCompensationContext(commandId);
}
#end_block

#method_before
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        ExecutionHandler.startFinalizingStep(getExecutionContext());
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        startFinalizingStep();
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#end_block

#method_before
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                log.info("Command '{}' persisting async task placeholder for child command '{}'", getCommandId(), command.getCommandId());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#method_after
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = commandObjectsHandlerProvider.get().createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                log.info("Command '{}' persisting async task placeholder for child command '{}'", getCommandId(), command.getCommandId());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#end_block

#method_before
@Override
public List<Permissions> getAllForAdElement(Guid id) {
    return getAllForAdElement(id, null, null, false);
}
#method_after
@Override
public List<Permissions> getAllForAdElement(Guid id) {
    return getAllForAdElement(id, -1, false);
}
#end_block

#method_before
@Override
public List<Permissions> getAllForAdElement(Guid id, Guid userID, String engineSessionSeqId, boolean isFiltered) {
    int appMode = Config.<Integer>getValue(ConfigValues.ApplicationMode);
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("ad_element_id", id).addValue("user_id", userID).addValue("engine_session_seq_id", getEngineSessionId(engineSessionSeqId)).addValue("is_filtered", isFiltered).addValue("app_mode", appMode);
    return getCallsHandler().executeReadList("GetPermissionsByAdElementId", PermissionRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<Permissions> getAllForAdElement(Guid id, long engineSessionSeqId, boolean isFiltered) {
    int appMode = Config.<Integer>getValue(ConfigValues.ApplicationMode);
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("ad_element_id", id).addValue("engine_session_seq_id", engineSessionSeqId).addValue("is_filtered", isFiltered).addValue("app_mode", appMode);
    return getCallsHandler().executeReadList("GetPermissionsByAdElementId", PermissionRowMapper.instance, parameterSource);
}
#end_block

#method_before
@Override
public List<Permissions> getAllForEntity(Guid id) {
    return getAllForEntity(id, null, null, false);
}
#method_after
@Override
public List<Permissions> getAllForEntity(Guid id) {
    return getAllForEntity(id, -1, false);
}
#end_block

#method_before
@Override
public List<Permissions> getAllForEntity(Guid id, Guid userID, String engineSessionSeqId, boolean isFiltered, boolean allUsersWithPermission, int appMode) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id).addValue("user_id", userID).addValue("engine_session_seq_id", getEngineSessionId(engineSessionSeqId)).addValue("is_filtered", isFiltered).addValue("app_mode", appMode);
    String functionName = "GetPermissionsByEntityId";
    if (allUsersWithPermission) {
        functionName = "GetAllUsersWithPermissionsOnEntityByEntityId";
    }
    return getCallsHandler().executeReadList(functionName, PermissionRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<Permissions> getAllForEntity(Guid id, long engineSessionId, boolean isFiltered) {
    return getAllForEntity(id, engineSessionId, isFiltered, false);
}
#end_block

#method_before
@Override
public List<Permissions> getTreeForEntity(Guid id, VdcObjectType type) {
    return getTreeForEntity(id, type, null, null, false);
}
#method_after
@Override
public List<Permissions> getTreeForEntity(Guid id, VdcObjectType type) {
    return getTreeForEntity(id, type, -1, false);
}
#end_block

#method_before
@Override
public List<Permissions> getTreeForEntity(Guid id, VdcObjectType type, Guid userID, String engineSessionSeqId, boolean isFiltered, int appMode) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id).addValue("object_type_id", type.getValue()).addValue("user_id", userID).addValue("engine_session_seq_id", getEngineSessionId(engineSessionSeqId)).addValue("is_filtered", isFiltered).addValue("app_mode", appMode);
    return getCallsHandler().executeReadList("GetPermissionsTreeByEntityId", PermissionRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<Permissions> getTreeForEntity(Guid id, VdcObjectType type, long engineSessionSeqId, boolean isFiltered) {
    int appMode = Config.<Integer>getValue(ConfigValues.ApplicationMode);
    return getTreeForEntity(id, type, engineSessionSeqId, isFiltered, appMode);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), getParameters().getGraphicsDevices().keySet(), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVdsGroup().getcompatibility_version(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVdsGroup().getcompatibility_version(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private void copyVmPermissions(UniquePermissionsSet permissionsToAdd) {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> vmPermissions = dao.getAllForEntity(getVmId(), getCurrentUser().getId(), getSessionId(), false);
    for (Permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
    }
}
#method_after
private void copyVmPermissions(UniquePermissionsSet permissionsToAdd) {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> vmPermissions = dao.getAllForEntity(getVmId(), getEngineSessionSeqId(), false);
    for (Permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getDbFacade().getPermissionDao().getAllForAdElement(getParameters().getId(), getUserID(), getEngineSessionId(), getParameters().isFiltered()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getDbFacade().getPermissionDao().getAllForAdElement(getParameters().getId(), getEngineSessionSeqId(), getParameters().isFiltered()));
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    if (!validateCustomProperties(vmStaticFromParams, reasons)) {
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return isDedicatedVdsOnSameCluster(vmStaticFromParams);
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    if (!validateCustomProperties(vmStaticFromParams, reasons)) {
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return VmHandler.validateDedicatedVdsExistOnSameCluster(vmStaticFromParams, getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (vmFromParams.getId() != null && getVmStaticDao().get(vmFromParams.getId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmNumaNodes();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.error("Failed to add vm . The reasons are: {}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmNumaNodes();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    addGraphicsDevice();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.error("Failed to add vm . The reasons are: {}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#end_block

#method_before
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getCurrentUser().getId(), getSessionId(), false);
    for (Permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getad_element_id(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM);
    }
}
#method_after
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getEngineSessionSeqId(), false);
    for (Permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getad_element_id(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM);
    }
}
#end_block

#method_before
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permissions[] permsArray = new Permissions[newDiskImageIds.size()];
    Guid diskOperatorIdFromParams = getParameters().getDiskOperatorAuthzPrincipalDbId();
    Guid diskOperatorId = diskOperatorIdFromParams != null ? diskOperatorIdFromParams : getCurrentUser().getId();
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permissions(diskOperatorId, PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permissions[] permsArray = new Permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permissions(getUserIdOfDiskOperator(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        DisplayType defaultDisplayType = osRepository.getDisplayTypes(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version()).get(0);
        getParameters().getVmStaticData().setDefaultDisplayType(defaultDisplayType);
    }
}
#method_after
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        autoSelectDefaultDisplayType(getVmTemplateId());
    }
}
#end_block

#method_before
protected boolean checkNumberOfMonitors() {
    return VmHandler.isNumOfMonitorsLegal(getParameters().getVmStaticData().getDefaultDisplayType(), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkNumberOfMonitors() {
    Collection<GraphicsType> graphicsTypes = VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices());
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return VmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors, getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private void copyQuotaPermissions() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    List<Permissions> vmPermissions = getDbFacade().getPermissionDao().getAllForEntity(getParameters().getQuotaId(), getCurrentUser().getId(), getSessionId(), false);
    for (Permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getQuotaId(), vmPermission.getObjectType());
    }
    if (!permissionsToAdd.isEmpty()) {
        List<Permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permissions[permissionsList.size()]));
    }
}
#method_after
private void copyQuotaPermissions() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    List<Permissions> vmPermissions = getDbFacade().getPermissionDao().getAllForEntity(getParameters().getQuotaId(), getEngineSessionSeqId(), false);
    for (Permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getQuotaId(), vmPermission.getObjectType());
    }
    if (!permissionsToAdd.isEmpty()) {
        List<Permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permissions[permissionsList.size()]));
    }
}
#end_block

#method_before
@Test
public void testExecuteQueryWithDirectOnly() {
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getAllForEntity(objectID, getUser().getId(), UNPRIVILEGED_USER_SESSION_ID, getQueryParameters().isFiltered(), false)).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(true);
}
#method_after
@Test
public void testExecuteQueryWithDirectOnly() {
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getAllForEntity(objectID, UNPRIVILEGED_USER_SESSION_ID, getQueryParameters().isFiltered(), false)).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(true);
}
#end_block

#method_before
@Test
public void testExecuteQueryWithoutDirectOnly() {
    VdcObjectType type = RandomUtils.instance().pickRandom(VdcObjectType.values());
    when(getQueryParameters().getVdcObjectType()).thenReturn(type);
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getTreeForEntity(objectID, type, getUser().getId(), UNPRIVILEGED_USER_SESSION_ID, getQueryParameters().isFiltered())).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(false);
}
#method_after
@Test
public void testExecuteQueryWithoutDirectOnly() {
    VdcObjectType type = RandomUtils.instance().pickRandom(VdcObjectType.values());
    when(getQueryParameters().getVdcObjectType()).thenReturn(type);
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getTreeForEntity(objectID, type, UNPRIVILEGED_USER_SESSION_ID, getQueryParameters().isFiltered())).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(false);
}
#end_block

#method_before
private void assertQueryDAOCall(boolean isDirectOnly) {
    when(getQueryParameters().getObjectId()).thenReturn(objectID);
    when(getQueryParameters().getDirectOnly()).thenReturn(isDirectOnly);
    when(getQuery().getEngineSessionId()).thenReturn(UNPRIVILEGED_USER_SESSION_ID);
    getQuery().executeQueryCommand();
    @SuppressWarnings("unchecked")
    List<Permissions> result = (List<Permissions>) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong permissions returned from the query", mockedPermissions, result);
}
#method_after
private void assertQueryDAOCall(boolean isDirectOnly) {
    when(getQueryParameters().getObjectId()).thenReturn(objectID);
    when(getQueryParameters().getDirectOnly()).thenReturn(isDirectOnly);
    when(getQuery().getEngineSessionSeqId()).thenReturn(UNPRIVILEGED_USER_SESSION_ID);
    getQuery().executeQueryCommand();
    @SuppressWarnings("unchecked")
    List<Permissions> result = (List<Permissions>) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong permissions returned from the query", mockedPermissions, result);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid objectId = getParameters().getObjectId();
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> perms;
    if (getParameters().getDirectOnly()) {
        perms = dao.getAllForEntity(objectId, getUserID(), getEngineSessionId(), getParameters().isFiltered(), getParameters().getAllUsersWithPermission());
    } else {
        perms = dao.getTreeForEntity(objectId, getParameters().getVdcObjectType(), getUserID(), getEngineSessionId(), getParameters().isFiltered());
    }
    getQueryReturnValue().setReturnValue(perms);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid objectId = getParameters().getObjectId();
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> perms;
    if (getParameters().getDirectOnly()) {
        perms = dao.getAllForEntity(objectId, getEngineSessionSeqId(), getParameters().isFiltered(), getParameters().getAllUsersWithPermission());
    } else {
        perms = dao.getTreeForEntity(objectId, getParameters().getVdcObjectType(), getEngineSessionSeqId(), getParameters().isFiltered());
    }
    getQueryReturnValue().setReturnValue(perms);
}
#end_block

#method_before
@Test
public void testGetAllForAdElementFilteredWithPermissions() {
    List<Permissions> result = dao.getAllForAdElement(AD_ELEMENT_ID, PRIVILEGED_USER_ID, PRIVILEGED_USER_SESSION_ID, true);
    assertValidGetByAdElement(result);
}
#method_after
@Test
public void testGetAllForAdElementFilteredWithPermissions() {
    List<Permissions> result = dao.getAllForAdElement(AD_ELEMENT_ID, PRIVILEGED_USER_SESSION_ID, true);
    assertValidGetByAdElement(result);
}
#end_block

#method_before
@Test
public void testGetAllForAdElementFilteredWithNoPermissions() {
    List<Permissions> result = dao.getAllForAdElement(AD_ELEMENT_ID, UNPRIVILEGED_USER_ID, UNPRIVILEGED_USER_SESSION_ID, true);
    assertInvalidGetPermissionList(result);
}
#method_after
@Test
public void testGetAllForAdElementFilteredWithNoPermissions() {
    List<Permissions> result = dao.getAllForAdElement(AD_ELEMENT_ID, UNPRIVILEGED_USER_SESSION_ID, true);
    assertInvalidGetPermissionList(result);
}
#end_block

#method_before
@Test
public void testGetAllForEntityFilteredWithPermissions() {
    List<Permissions> result = dao.getAllForEntity(VM_ENTITY_ID, PRIVILEGED_USER_ID, PRIVILEGED_USER_SESSION_ID, true);
    assertGetAllForEntityResult(result);
}
#method_after
@Test
public void testGetAllForEntityFilteredWithPermissions() {
    List<Permissions> result = dao.getAllForEntity(VM_ENTITY_ID, PRIVILEGED_USER_SESSION_ID, true);
    assertGetAllForEntityResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForEntityFilteredWithNoPermissionsFilteringDisabled() {
    List<Permissions> result = dao.getAllForEntity(VM_ENTITY_ID, UNPRIVILEGED_USER_ID, UNPRIVILEGED_USER_SESSION_ID, false);
    assertGetAllForEntityResult(result);
}
#method_after
@Test
public void testGetAllForEntityFilteredWithNoPermissionsFilteringDisabled() {
    List<Permissions> result = dao.getAllForEntity(VM_ENTITY_ID, UNPRIVILEGED_USER_SESSION_ID, false);
    assertGetAllForEntityResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForEntityFilteredWithNoPermissions() {
    List<Permissions> result = dao.getAllForEntity(VM_ENTITY_ID, UNPRIVILEGED_USER_ID, UNPRIVILEGED_USER_SESSION_ID, true);
    assertInvalidGetPermissionList(result);
}
#method_after
@Test
public void testGetAllForEntityFilteredWithNoPermissions() {
    List<Permissions> result = dao.getAllForEntity(VM_ENTITY_ID, UNPRIVILEGED_USER_SESSION_ID, true);
    assertInvalidGetPermissionList(result);
}
#end_block

#method_before
@Test
public void testGetAllUsersWithPermissionsOnEntity() {
    List<Permissions> result = dao.getAllForEntity(VM_ENTITY_ID, PRIVILEGED_USER_ID, PRIVILEGED_USER_SESSION_ID, true, true);
    assertNotNull(result);
    assertEquals(2, result.size());
    assertGetAllForEntityResult(result);
}
#method_after
@Test
public void testGetAllUsersWithPermissionsOnEntity() {
    List<Permissions> result = dao.getAllForEntity(VM_ENTITY_ID, PRIVILEGED_USER_SESSION_ID, true, true);
    assertNotNull(result);
    assertEquals(2, result.size());
    assertGetAllForEntityResult(result);
}
#end_block

#method_before
@Test
public void testGetTreeForEntityWithRoleTypeFilteredWithPermissions() {
    baseTestGetTreeForEntityFiltered(STORAGE_ENTITY_ID, VdcObjectType.Storage, PRIVILEGED_USER_ID, PRIVILEGED_USER_SESSION_ID, true);
}
#method_after
@Test
public void testGetTreeForEntityWithRoleTypeFilteredWithPermissions() {
    baseTestGetTreeForEntityFiltered(STORAGE_ENTITY_ID, VdcObjectType.Storage, PRIVILEGED_USER_SESSION_ID, true);
}
#end_block

#method_before
@Test
public void testGetTreeForEntityWithRoleTypeFilteredWithNoPermissionsCheckDisabled() {
    baseTestGetTreeForEntityFiltered(STORAGE_ENTITY_ID, VdcObjectType.Storage, UNPRIVILEGED_USER_ID, UNPRIVILEGED_USER_SESSION_ID, false);
}
#method_after
@Test
public void testGetTreeForEntityWithRoleTypeFilteredWithNoPermissionsCheckDisabled() {
    baseTestGetTreeForEntityFiltered(STORAGE_ENTITY_ID, VdcObjectType.Storage, UNPRIVILEGED_USER_SESSION_ID, false);
}
#end_block

#method_before
@Test
public void testGetTreeForEntityWithRoleTypeFilteredWithNoPermissions() {
    List<Permissions> result = dao.getTreeForEntity(STORAGE_ENTITY_ID, VdcObjectType.Storage, UNPRIVILEGED_USER_ID, UNPRIVILEGED_USER_SESSION_ID, true);
    assertInvalidGetPermissionList(result);
}
#method_after
@Test
public void testGetTreeForEntityWithRoleTypeFilteredWithNoPermissions() {
    List<Permissions> result = dao.getTreeForEntity(STORAGE_ENTITY_ID, VdcObjectType.Storage, UNPRIVILEGED_USER_SESSION_ID, true);
    assertInvalidGetPermissionList(result);
}
#end_block

#method_before
@Test
public void testGetTreeForEntityWithAppMode() {
    List<Permissions> result = dao.getTreeForEntity(STORAGE_ENTITY_ID, VdcObjectType.Storage, PRIVILEGED_USER_ID, PRIVILEGED_USER_SESSION_ID, true, ApplicationMode.AllModes.getValue());
    assertEquals(1, result.size());
    List<Permissions> result2 = dao.getTreeForEntity(STORAGE_ENTITY_ID, VdcObjectType.Storage, PRIVILEGED_USER_ID, PRIVILEGED_USER_SESSION_ID, true, ApplicationMode.VirtOnly.getValue());
    assertEquals(1, result2.size());
    List<Permissions> result3 = dao.getTreeForEntity(STORAGE_ENTITY_ID, VdcObjectType.Storage, PRIVILEGED_USER_ID, PRIVILEGED_USER_SESSION_ID, true, ApplicationMode.GlusterOnly.getValue());
    assertEquals(1, result3.size());
}
#method_after
@Test
public void testGetTreeForEntityWithAppMode() {
    List<Permissions> result = dao.getTreeForEntity(STORAGE_ENTITY_ID, VdcObjectType.Storage, PRIVILEGED_USER_SESSION_ID, true, ApplicationMode.AllModes.getValue());
    assertEquals(1, result.size());
    List<Permissions> result2 = dao.getTreeForEntity(STORAGE_ENTITY_ID, VdcObjectType.Storage, PRIVILEGED_USER_SESSION_ID, true, ApplicationMode.VirtOnly.getValue());
    assertEquals(1, result2.size());
    List<Permissions> result3 = dao.getTreeForEntity(STORAGE_ENTITY_ID, VdcObjectType.Storage, PRIVILEGED_USER_SESSION_ID, true, ApplicationMode.GlusterOnly.getValue());
    assertEquals(1, result3.size());
}
#end_block

#method_before
private void baseTestGetTreeForEntityFiltered(Guid entityID, VdcObjectType objectType, Guid userID, String sessionId, boolean isFiltered, Guid... alternativeObjectIds) {
    List<Permissions> result = dao.getTreeForEntity(entityID, objectType, userID, sessionId, isFiltered);
    assertGetTreeForEntityResult(entityID, result, alternativeObjectIds);
}
#method_after
private void baseTestGetTreeForEntityFiltered(Guid entityID, VdcObjectType objectType, long sessionId, boolean isFiltered, Guid... alternativeObjectIds) {
    List<Permissions> result = dao.getTreeForEntity(entityID, objectType, sessionId, isFiltered);
    assertGetTreeForEntityResult(entityID, result, alternativeObjectIds);
}
#end_block

#method_before
@Test
public void testGetEntityPermissions() {
    // Should not return null since the user has the relevant permission
    assertNotNull(dao.getEntityPermissions(DIRECTORY_ELEMENT_ID_WITH_BASIC_PERMISSIONS, ActionGroup.VM_BASIC_OPERATIONS, VM_TEMPLATE_ENTITY_ID, VdcObjectType.VM));
    // Should return null since the user does not has the relevant permission
    assertNull(dao.getEntityPermissions(DIRECTORY_ELEMENT_ID_WITH_BASIC_PERMISSIONS, ActionGroup.CREATE_TEMPLATE, VM_TEMPLATE_ENTITY_ID, VdcObjectType.VM));
}
#method_after
@Test
public void testGetEntityPermissions() {
    // Should not return null since the user has the relevant permission
    assertNotNull(dao.getEntityPermissions(DIRECTORY_ELEMENT_ID_WITH_BASIC_PERMISSIONS, ActionGroup.RUN_VM, VM_TEMPLATE_ENTITY_ID, VdcObjectType.VM));
    // Should return null since the user does not has the relevant permission
    assertNull(dao.getEntityPermissions(DIRECTORY_ELEMENT_ID_WITH_BASIC_PERMISSIONS, ActionGroup.CREATE_TEMPLATE, VM_TEMPLATE_ENTITY_ID, VdcObjectType.VM));
}
#end_block

#method_before
@Test
public void testGetEntityPermissionsByUserAndGroups() {
    // Should not return null since the user has the relevant permission
    assertNotNull(dao.getEntityPermissionsForUserAndGroups(Guid.newGuid(), DIRECTORY_ELEMENT_ID_WITH_BASIC_PERMISSIONS.toString(), ActionGroup.VM_BASIC_OPERATIONS, VM_TEMPLATE_ENTITY_ID, VdcObjectType.VM, false));
    // Should return null since the user does not has the relevant permission
    assertNull(dao.getEntityPermissionsForUserAndGroups(Guid.newGuid(), DIRECTORY_ELEMENT_ID_WITH_BASIC_PERMISSIONS.toString(), ActionGroup.CREATE_TEMPLATE, VM_TEMPLATE_ENTITY_ID, VdcObjectType.VM, false));
}
#method_after
@Test
public void testGetEntityPermissionsByUserAndGroups() {
    // Should not return null since the user has the relevant permission
    assertNotNull(dao.getEntityPermissionsForUserAndGroups(Guid.newGuid(), DIRECTORY_ELEMENT_ID_WITH_BASIC_PERMISSIONS.toString(), ActionGroup.RUN_VM, VM_TEMPLATE_ENTITY_ID, VdcObjectType.VM, false));
    // Should return null since the user does not has the relevant permission
    assertNull(dao.getEntityPermissionsForUserAndGroups(Guid.newGuid(), DIRECTORY_ELEMENT_ID_WITH_BASIC_PERMISSIONS.toString(), ActionGroup.CREATE_TEMPLATE, VM_TEMPLATE_ENTITY_ID, VdcObjectType.VM, false));
}
#end_block

#method_before
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    // Mock the parameters
    actionGroup = RandomUtils.instance().pickRandom(ActionGroup.values());
    when(getQueryParameters().getActionGroup()).thenReturn(actionGroup);
    sessionID = RandomUtils.instance().nextString(10);
    when(getQueryParameters().getSessionId()).thenReturn(sessionID);
    SessionDataContainer.getInstance().setUser(sessionID, getUser());
    DbFacade dbFacadeMock = mock(DbFacade.class);
    SessionDataContainer.getInstance().setDbFacade(dbFacadeMock);
    EngineSessionDAO engineSessionDAOMock = mock(EngineSessionDAO.class);
    when(engineSessionDAOMock.removeBySessionId(any(String.class))).thenReturn(1);
    when(dbFacadeMock.getEngineSessionDao()).thenReturn(engineSessionDAOMock);
}
#method_after
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    // Mock the parameters
    actionGroup = RandomUtils.instance().pickRandom(ActionGroup.values());
    when(getQueryParameters().getActionGroup()).thenReturn(actionGroup);
    sessionID = RandomUtils.instance().nextString(10);
    when(getQueryParameters().getSessionId()).thenReturn(sessionID);
    DbFacade dbFacadeMock = mock(DbFacade.class);
    EngineSessionDAO engineSessionDAOMock = mock(EngineSessionDAO.class);
    when(engineSessionDAOMock.save(any(EngineSession.class))).thenReturn(RandomUtils.instance().nextLong());
    when(engineSessionDAOMock.remove(any(Long.class))).thenReturn(1);
    when(dbFacadeMock.getEngineSessionDao()).thenReturn(engineSessionDAOMock);
    PermissionDAO permissionsDAOMock = mock(PermissionDAO.class);
    when(permissionsDAOMock.getAllForEntity(any(Guid.class), any(Guid.class), any(Boolean.class))).thenReturn(new ArrayList<Permissions>());
    when(dbFacadeMock.getPermissionDao()).thenReturn(permissionsDAOMock);
    SessionDataContainer.getInstance().setDbFacade(dbFacadeMock);
    SessionDataContainer.getInstance().setUser(sessionID, getUser());
}
#end_block

#method_before
public void persistEngineSession(String sessionId) {
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    if (sessionInfo != null) {
        EngineSession engineSession = new EngineSession();
        engineSession.setEngineSessionId(sessionId);
        DbUser user = getUser(sessionId, false);
        engineSession.setUserId(user.getId());
        engineSession.setUserName(user.getLoginName());
        engineSession.setGroupIds(user.getGroupIds());
        engineSession.setRoleIds(getSystemRolesForUser(user.getId(), user.isAdmin() ? false : true));
        getDbFacade().getEngineSessionDao().save(engineSession);
    }
}
#method_after
private void persistEngineSession(String sessionId) {
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    if (sessionInfo != null) {
        sessionInfo.contentOfSession.put(ENGINE_SESSION_SEQ_ID, getDbFacade().getEngineSessionDao().save(new EngineSession(getUser(sessionId, false), sessionId)));
    }
}
#end_block

#method_before
public final void setUser(String sessionId, DbUser user) {
    setData(sessionId, USER_PARAMETER_NAME, user);
}
#method_after
public final void setUser(String sessionId, DbUser user) {
    setData(sessionId, USER_PARAMETER_NAME, user);
    persistEngineSession(sessionId);
}
#end_block

#method_before
private void removeSessionImpl(String sessionId, int reason, String message, Object... msgArgs) {
    AcctUtils.reportRecords(reason, getPrincipalName(sessionId), (ExtMap) getData(sessionId, AUTH_RECORD_PARAMETER_NAME, false), (ExtMap) getData(sessionId, PRINCIPAL_RECORD_PARAMETER_NAME, false), message, msgArgs);
    sessionInfoMap.remove(sessionId);
    getDbFacade().getEngineSessionDao().removeBySessionId(sessionId);
}
#method_after
private void removeSessionImpl(String sessionId, int reason, String message, Object... msgArgs) {
    AcctUtils.reportRecords(reason, getPrincipalName(sessionId), (ExtMap) getData(sessionId, AUTH_RECORD_PARAMETER_NAME, false), (ExtMap) getData(sessionId, PRINCIPAL_RECORD_PARAMETER_NAME, false), message, msgArgs);
    getDbFacade().getEngineSessionDao().remove(getEngineSessionSeqId(sessionId));
    sessionInfoMap.remove(sessionId);
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
        // Initialize Power Management Health Check
        PmHealthCheckManager.getInstance().initialize();
        // recover from engine failure
        PmHealthCheckManager.getInstance().recover(hosts);
        // Create authentication profiles for all the domains that exist in the database:
        // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
        DbUserCacheManager.getInstance().init();
        CommandCoordinatorUtil.initAsyncTaskManager();
        ResourceManager.getInstance().init();
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        ExternalTrustStoreInitializer.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        SessionDataContainer.getInstance().cleanupAllEngineSessions();
        new DwhHeartBeat().init();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
        // Initialize Power Management Health Check
        PmHealthCheckManager.getInstance().initialize();
        // recover from engine failure
        PmHealthCheckManager.getInstance().recover(hosts);
        CommandCoordinatorUtil.initAsyncTaskManager();
        Injector.get(ResourceManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        SessionDataContainer.getInstance().cleanupEngineSessionsOnStartup();
        new DwhHeartBeat().init();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#end_block

#method_before
@Before
public void setUpContainer() {
    container = spy(SessionDataContainer.getInstance());
    DbFacade dbFacadeMock = mock(DbFacade.class);
    when(container.getDbFacade()).thenReturn(dbFacadeMock);
    EngineSessionDAO engineSessionDAOMock = mock(EngineSessionDAO.class);
    when(engineSessionDAOMock.removeBySessionId(any(String.class))).thenReturn(1);
    when(dbFacadeMock.getEngineSessionDao()).thenReturn(engineSessionDAOMock);
    clearSession();
}
#method_after
@Before
public void setUpContainer() {
    container = spy(SessionDataContainer.getInstance());
    DbFacade dbFacadeMock = mock(DbFacade.class);
    when(container.getDbFacade()).thenReturn(dbFacadeMock);
    EngineSessionDAO engineSessionDAOMock = mock(EngineSessionDAO.class);
    when(engineSessionDAOMock.remove(any(Long.class))).thenReturn(1);
    when(dbFacadeMock.getEngineSessionDao()).thenReturn(engineSessionDAOMock);
    PermissionDAO permissionsDAOMock = mock(PermissionDAO.class);
    when(permissionsDAOMock.getAllForEntity(any(Guid.class), any(Guid.class), any(Boolean.class))).thenReturn(new ArrayList<Permissions>());
    when(dbFacadeMock.getPermissionDao()).thenReturn(permissionsDAOMock);
    DbUser user = mock(DbUser.class);
    container.setUser(TEST_SESSION_ID, user);
}
#end_block

#method_before
@After
public void clearSession() {
    container.removeSessionOnLogout(TEST_SESSION_ID);
}
#method_after
public void clearSession() {
    container.removeSessionOnLogout(TEST_SESSION_ID);
}
#end_block

#method_before
@Test
public void testGetDataAndSetDataWithEmptySession() {
    assertNull("Get should return null with an empty session", container.getData("", TEST_KEY, false));
}
#method_after
@Test
public void testGetDataAndSetDataWithEmptySession() {
    assertNull("Get should return null with an empty session", container.getData("", TEST_KEY, false));
    clearSession();
}
#end_block

#method_before
@Test
public void testGetDataAndSetDataWithFullSession() {
    container.setData(TEST_SESSION_ID, TEST_KEY, TEST_VALUE);
    assertEquals("Get should return the value with a given session", TEST_VALUE, container.getData(TEST_SESSION_ID, TEST_KEY, false));
}
#method_after
@Test
public void testGetDataAndSetDataWithFullSession() {
    container.setData(TEST_SESSION_ID, TEST_KEY, TEST_VALUE);
    assertEquals("Get should return the value with a given session", TEST_VALUE, container.getData(TEST_SESSION_ID, TEST_KEY, false));
    clearSession();
}
#end_block

#method_before
@Test
public void testGetUserAndSetUserWithSessionParam() {
    DbUser user = mock(DbUser.class);
    container.setUser(TEST_SESSION_ID, user);
    assertEquals("Get should return the value with a given session", user, container.getUser(TEST_SESSION_ID, false));
}
#method_after
@Test
public void testGetUserAndSetUserWithSessionParam() {
    DbUser user = mock(DbUser.class);
    container.setUser(TEST_SESSION_ID, user);
    assertEquals("Get should return the value with a given session", user, container.getUser(TEST_SESSION_ID, false));
    clearSession();
}
#end_block

#method_before
@Test
public void testRefreshUserSession() {
    initDataForClearTest(USER);
    // refresh the old session (refresh = true)
    container.getData(TEST_SESSION_ID, USER, true);
    // cleared expired session
    container.cleanExpiredUsersSessions();
    // session should be already refreshed -> not null
    assertNotNull("Get should return null since the session wasn't refresh", container.getData(TEST_SESSION_ID, USER, false));
}
#method_after
@Test
public void testRefreshUserSession() {
    initDataForClearTest(USER);
    // refresh the old session (refresh = true)
    container.getData(TEST_SESSION_ID, USER, true);
    // cleared expired session
    container.cleanExpiredUsersSessions();
    // session should be already refreshed -> not null
    assertNotNull("Get should return null since the session wasn't refresh", container.getData(TEST_SESSION_ID, USER, false));
    clearSession();
}
#end_block

#method_before
public Collection<Guid> getGroupIds() {
    if (groupIds == null) {
        groupIds = Collections.emptyList();
    }
    return new ArrayList<Guid>(groupIds);
}
#method_after
public Collection<Guid> getGroupIds() {
    if (groupIds == null) {
        groupIds = Collections.emptyList();
    }
    return new HashSet<Guid>(groupIds);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((engineSessionId == null) ? 0 : engineSessionId.hashCode());
    result = prime * result + ((userId == null) ? 0 : userId.hashCode());
    result = prime * result + ((userName == null) ? 0 : userName.hashCode());
    result = prime * result + ((authRecord == null) ? 0 : authRecord.hashCode());
    result = prime * result + ((principalRecord == null) ? 0 : principalRecord.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((engineSessionId == null) ? 0 : engineSessionId.hashCode());
    result = prime * result + ((userId == null) ? 0 : userId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    EngineSession other = (EngineSession) obj;
    return ObjectUtils.objectsEqual(engineSessionId, other.engineSessionId) && ObjectUtils.objectsEqual(userId, other.userId) && ObjectUtils.objectsEqual(userName, other.userName) && ObjectUtils.objectsEqual(authRecord, other.authRecord) && ObjectUtils.objectsEqual(principalRecord, other.principalRecord);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    EngineSession other = (EngineSession) obj;
    return ObjectUtils.objectsEqual(engineSessionId, other.engineSessionId) && ObjectUtils.objectsEqual(userId, other.userId);
}
#end_block

#method_before
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getEngineSessionDao();
    // create some test data
    newEngineSession = new EngineSession();
    newEngineSession.setEngineSessionId(Guid.newGuid().toString());
    newEngineSession.setUserId(Guid.newGuid());
    newEngineSession.setSessionExpiration(new Date());
    newEngineSession.setRole("");
    newEngineSession.setPrincipalRecord("");
    newEngineSession.setAuthRecord("");
    newEngineSession.setGroupIds(new LinkedList<Guid>(Arrays.asList(FixturesTool.EXISTING_GROUP_ID)));
    newEngineSession.setUserName("");
    existingEngineSession = dao.get(FixturesTool.EXISTING_SESSION_ID.toString());
}
#method_after
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getEngineSessionDao();
    // create some test data
    newEngineSession = new EngineSession();
    newEngineSession.setEngineSessionId(Guid.newGuid().toString());
    newEngineSession.setUserId(Guid.newGuid());
    newEngineSession.setRoleIds(new HashSet<Guid>(Arrays.asList(FixturesTool.EXISTING_GROUP_ID)));
    newEngineSession.setGroupIds(new HashSet<Guid>(Arrays.asList(FixturesTool.EXISTING_GROUP_ID)));
    newEngineSession.setUserName("");
    existingEngineSession = dao.get(ID);
}
#end_block

#method_before
@Test
public void testGetWithInvalidId() {
    EngineSession result = dao.get(Guid.newGuid().toString());
    assertNull(result);
}
#method_after
@Test
public void testGetWithInvalidId() {
    EngineSession result = dao.getBySessionId(Guid.newGuid().toString());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGet() {
    EngineSession result = dao.get(existingEngineSession.getEngineSessionId());
    assertNotNull(result);
    assertEquals(existingEngineSession, result);
}
#method_after
@Test
public void testGet() {
    EngineSession result = dao.get(existingEngineSession.getId());
    assertNotNull(result);
    assertEquals(existingEngineSession, result);
}
#end_block

#method_before
@Test
public void testRemove() {
    EngineSession result = dao.get(existingEngineSession.getEngineSessionId());
    assertNotNull(result);
    assertEquals(dao.remove(existingEngineSession.getEngineSessionId()), 1);
    result = dao.get(existingEngineSession.getEngineSessionId());
    assertNull(result);
    assertEquals(dao.remove(existingEngineSession.getEngineSessionId()), 0);
}
#method_after
@Test
public void testRemove() {
    EngineSession result = dao.get(existingEngineSession.getId());
    assertNotNull(result);
    assertEquals(dao.remove(existingEngineSession.getId()), 1);
    result = dao.get(existingEngineSession.getId());
    assertNull(result);
    assertEquals(dao.remove(existingEngineSession.getId()), 0);
}
#end_block

#method_before
@Test
public void testSaveOrUpdate() {
    List<EngineSession> sessions = dao.getAll();
    assertNotNull(sessions);
    int sessionsNumber = sessions.size();
    dao.saveOrUpdate(existingEngineSession);
    sessions = dao.getAll();
    assertEquals(sessionsNumber, sessions.size());
    EngineSession sessionFromDb = dao.get(existingEngineSession.getEngineSessionId());
    assertNotNull(sessionFromDb);
    assertEquals(sessionFromDb, existingEngineSession);
    dao.saveOrUpdate(newEngineSession);
    sessions = dao.getAll();
    assertNotNull(sessions);
    assertEquals(sessionsNumber + 1, sessions.size());
    sessionFromDb = dao.get(newEngineSession.getEngineSessionId());
    assertEquals(sessionFromDb, newEngineSession);
}
#method_after
@Test
public void testSaveOrUpdate() {
    EngineSession sessionFromDb = dao.getBySessionId(newEngineSession.getEngineSessionId());
    assertNull(sessionFromDb);
    dao.save(newEngineSession);
    sessionFromDb = dao.getBySessionId(newEngineSession.getEngineSessionId());
    assertNotNull(sessionFromDb);
    assertEquals(sessionFromDb, newEngineSession);
}
#end_block

#method_before
@Override
public EngineSession mapRow(ResultSet rs, int rowNum) throws SQLException {
    EngineSession session = new EngineSession();
    session.setEngineSessionId(rs.getString("id"));
    session.setUserId(getGuidDefaultEmpty(rs, "user_id"));
    session.setUserName(rs.getString("user_name"));
    session.setAuthRecord(rs.getString("auth_record"));
    session.setPrincipalRecord(rs.getString("principal_record"));
    session.setGroupIds(convertToGuidList(rs.getString("group_ids"), ','));
    session.setRole(rs.getString("role"));
    session.setSessionExpiration(DbFacadeUtils.fromDate(rs.getTimestamp("session_expiration")));
    return session;
}
#method_after
@Override
public EngineSession mapRow(ResultSet rs, int rowNum) throws SQLException {
    EngineSession session = new EngineSession();
    session.setId(rs.getLong("id"));
    session.setEngineSessionId(rs.getString("engine_session_id"));
    session.setUserId(getGuidDefaultEmpty(rs, "user_id"));
    session.setUserName(rs.getString("user_name"));
    session.setGroupIds(convertToGuidList(rs.getString("group_ids"), ','));
    session.setRoleIds(convertToGuidList(rs.getString("role_ids"), ','));
    return session;
}
#end_block

#method_before
@Override
public EngineSession get(String id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id);
    return getCallsHandler().executeRead("GetEngineSessionById", EngineSessionRowMapper.instance, parameterSource);
}
#method_after
@Override
public EngineSession get(long id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id);
    return getCallsHandler().executeRead("GetEngineSession", EngineSessionRowMapper.instance, parameterSource);
}
#end_block

#method_before
@Override
public int remove(String id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id);
    return getCallsHandler().executeModificationReturnResult("DeleteEngineSession", parameterSource);
}
#method_after
@Override
public int remove(long id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id);
    return getCallsHandler().executeModificationReturnResult("DeleteEngineSession", parameterSource);
}
#end_block

#method_before
public static Collection<String> replaceWith(String propertyName, List<?> items, String separator, int maxNumberOfPrintedItems) {
    int size = Math.min(maxNumberOfPrintedItems, items.size());
    List<String> printedItems = new ArrayList<String>(size);
    for (int i = 0; i < size; i++) {
        printedItems.add(String.format("\t%s", String.valueOf(items.get(i))));
    }
    if (items.size() > maxNumberOfPrintedItems) {
        printedItems.add("\t...");
    }
    ArrayList<String> replacements = new ArrayList<String>();
    replacements.add(MessageFormat.format("${0} {1}", propertyName, StringUtils.join(printedItems, separator)));
    replacements.add(MessageFormat.format("${0}_COUNTER {1}", propertyName, items.size()));
    return replacements;
}
#method_after
public static Collection<String> replaceWith(String propertyName, List<?> items, String separator, int maxNumberOfPrintedItems) {
    Validate.isTrue(maxNumberOfPrintedItems >= 1);
    Validate.isTrue(StringUtils.isNotEmpty(separator));
    int size = Math.min(maxNumberOfPrintedItems, items.size());
    List<String> printedItems = new ArrayList<String>(size);
    for (int i = 0; i < size; i++) {
        printedItems.add(String.format("\t%s", String.valueOf(items.get(i))));
    }
    if (items.size() > maxNumberOfPrintedItems) {
        printedItems.add("\t...");
    }
    ArrayList<String> replacements = new ArrayList<String>();
    replacements.add(MessageFormat.format("${0} {1}", propertyName, StringUtils.join(printedItems, separator)));
    replacements.add(MessageFormat.format("${0}_COUNTER {1}", propertyName, items.size()));
    return replacements;
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
        // Initialize Power Management Health Check
        PmHealthCheckManager.getInstance().initialize();
        // recover from engine failure
        PmHealthCheckManager.getInstance().recover(hosts);
        CommandCoordinatorUtil.initAsyncTaskManager();
        ResourceManager.getInstance().init();
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        ExternalTrustStoreInitializer.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        SessionDataContainer.getInstance().cleanupEngineSessionsOnStartup();
        new DwhHeartBeat().init();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
        // Initialize Power Management Health Check
        PmHealthCheckManager.getInstance().initialize();
        // recover from engine failure
        PmHealthCheckManager.getInstance().recover(hosts);
        CommandCoordinatorUtil.initAsyncTaskManager();
        Injector.get(ResourceManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        new DwhHeartBeat().init();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#end_block

#method_before
@Override
protected void init(T parameters) {
    super.init(parameters);
    setVmId(parameters.getContainerId());
    setVm(parameters.getVm());
    setVdsGroupId(parameters.getVdsGroupId());
    if (parameters.getVm() != null && getVm().getDiskMap() != null) {
        imageList = new ArrayList<DiskImage>();
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                imageList.add((DiskImage) disk);
            }
        }
    }
    ensureDomainMap(imageList, parameters.getDestDomainId());
    updateGraphicsDevices();
}
#method_after
@Override
protected void init(T parameters) {
    super.init(parameters);
    setVmId(parameters.getContainerId());
    setVm(parameters.getVm());
    setVdsGroupId(parameters.getVdsGroupId());
    if (parameters.getVm() != null && getVm().getDiskMap() != null) {
        imageList = new ArrayList<DiskImage>();
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                imageList.add((DiskImage) disk);
            }
        }
    }
    ensureDomainMap(imageList, parameters.getDestDomainId());
    Version clusterVersion = getVdsGroup() == null ? null : getVdsGroup().getcompatibility_version();
    VmStatic staticData = getVm() == null ? null : getVm().getStaticData();
    ImportUtils.updateGraphicsDevices(staticData, clusterVersion);
}
#end_block

#method_before
private void processImages(final boolean useCopyImages) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmImagesAndSnapshots();
            updateSnapshotsFromExport();
            if (useCopyImages) {
                moveOrCopyAllImageGroups();
            }
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity());
            if (getParameters().isImportAsNewEntity()) {
                getParameters().setVm(getVm());
                setVmId(getVm().getId());
            }
            return null;
        }
    });
}
#method_after
@Override
protected void processImages() {
    processImages(!isImagesAlreadyOnTarget());
    // vm related ops
    if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
        endVmRelatedOps();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    mOldTemplate = DbFacade.getInstance().getVmTemplateDao().get(getVmTemplate().getId());
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!isInstanceType && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isInstanceType && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), getParameters().graphicsTypesToBeSet(), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getcompatibility_version(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.isBalloonEnabled(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return returnValue;
}
#method_after
private boolean doClusterRelatedChecks() {
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getcompatibility_version(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.isBalloonEnabled(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVdsGroup().getcompatibility_version(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getParameters().getVmTemplateData(), getVdsGroup().getcompatibility_version());
    }
    if (getVmTemplate() != null) {
        getVmStaticDAO().incrementDbGeneration(getVmTemplate().getId());
        updateOriginalTemplateNameOnDerivedVms();
        UpdateVmTemplate();
        updateWatchdog(getParameters().getVmTemplateData().getId());
        updateRngDevice(getParameters().getVmTemplateData().getId());
        updateGraphicsDevice();
        checkTrustedService();
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getParameters().getVmTemplateData(), getVdsGroup().getcompatibility_version());
    }
    getVmStaticDAO().incrementDbGeneration(getVmTemplate().getId());
    updateOriginalTemplateNameOnDerivedVms();
    UpdateVmTemplate();
    updateWatchdog(getParameters().getVmTemplateData().getId());
    updateRngDevice(getParameters().getVmTemplateData().getId());
    updateGraphicsDevice();
    checkTrustedService();
    updateVmsOfInstanceType();
    setSucceeded(true);
}
#end_block

#method_before
private void updateGraphicsDevice() {
    for (GraphicsType type : GraphicsType.values()) {
        if (!getParameters().shouldUpdateGraphicsDevice(type)) {
            continue;
        }
        GraphicsDevice vmGraphicsDevice = getGraphicsDevOfType(type);
        if (vmGraphicsDevice == null) {
            if (getParameters().getGraphicsDevice(type) != null) {
                getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(getParameters().getGraphicsDevice(type)));
            }
        } else {
            if (getParameters().getGraphicsDevice(type) == null) {
                getBackend().runInternalAction(VdcActionType.RemoveGraphicsDevice, new GraphicsParameters(vmGraphicsDevice));
            } else {
                getBackend().runInternalAction(VdcActionType.UpdateGraphicsDevice, new GraphicsParameters(getParameters().getGraphicsDevice(type)));
            }
        }
    }
}
#method_after
private void updateGraphicsDevice() {
    for (GraphicsType type : getParameters().getGraphicsDevices().keySet()) {
        GraphicsDevice vmGraphicsDevice = getGraphicsDevOfType(type);
        if (vmGraphicsDevice == null) {
            if (getParameters().getGraphicsDevices().get(type) != null) {
                getParameters().getGraphicsDevices().get(type).setVmId(getVmTemplateId());
                GraphicsParameters parameters = new GraphicsParameters(getParameters().getGraphicsDevices().get(type));
                parameters.setVm(false);
                getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, parameters);
            }
        } else {
            if (getParameters().getGraphicsDevices().get(type) == null) {
                GraphicsParameters parameters = new GraphicsParameters(vmGraphicsDevice);
                parameters.setVm(false);
                getBackend().runInternalAction(VdcActionType.RemoveGraphicsDevice, parameters);
            } else {
                getParameters().getGraphicsDevices().get(type).setVmId(getVmTemplateId());
                GraphicsParameters parameters = new GraphicsParameters(getParameters().getGraphicsDevices().get(type));
                parameters.setVm(false);
                getBackend().runInternalAction(VdcActionType.UpdateGraphicsDevice, parameters);
            }
        }
    }
}
#end_block

#method_before
private GraphicsDevice getGraphicsDevOfType(GraphicsType type) {
    VdcQueryReturnValue query = getBackend().runInternalQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(getParameters().getVmTemplateId()));
    List<GraphicsDevice> graphicsDevices = query.getReturnValue();
    for (GraphicsDevice dev : graphicsDevices) {
        if (dev.getVmDeviceType() == type.getCorrespondingDeviceType()) {
            return dev;
        }
    }
    return null;
}
#method_after
private GraphicsDevice getGraphicsDevOfType(GraphicsType type) {
    List<GraphicsDevice> graphicsDevices = getGraphicsDevices();
    for (GraphicsDevice dev : graphicsDevices) {
        if (dev.getGraphicsType() == type) {
            return dev;
        }
    }
    return null;
}
#end_block

#method_before
private ImportVmCommand<ImportVmParameters> setupDiskSpaceTest(final int diskSpaceRequired) {
    mcr.mockConfigValue(ConfigValues.FreeSpaceCriticalLowInGB, diskSpaceRequired);
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommand<ImportVmParameters>(createParameters()));
    doReturn(true).when(cmd).validateNoDuplicateVm();
    doReturn(true).when(cmd).validateVdsCluster();
    doReturn(true).when(cmd).validateUsbPolicy();
    doReturn(true).when(cmd).canAddVm();
    doReturn(true).when(cmd).checkTemplateInStorageDomain();
    doReturn(true).when(cmd).checkImagesGUIDsLegal();
    doReturn(true).when(cmd).validateNoDuplicateDiskImages(any(Iterable.class));
    doReturn(createSourceDomain()).when(cmd).getSourceDomain();
    doReturn(createStorageDomain()).when(cmd).getStorageDomain(any(Guid.class));
    doReturn(Collections.<VM>singletonList(createVM())).when(cmd).getVmsFromExportDomain();
    doReturn(new VmTemplate()).when(cmd).getVmTemplate();
    doReturn(new StoragePool()).when(cmd).getStoragePool();
    doReturn(new VDSGroup()).when(cmd).getVdsGroup();
    return cmd;
}
#method_after
private ImportVmCommand<ImportVmParameters> setupDiskSpaceTest(ImportVmParameters parameters) {
    final ImportValidator validator = spy(new ImportValidator(parameters));
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommand<ImportVmParameters>(parameters) {

        @Override
        protected ImportValidator getImportValidator() {
            return validator;
        }
    });
    parameters.setCopyCollapse(true);
    doReturn(true).when(cmd).validateNoDuplicateVm();
    doReturn(true).when(cmd).validateVdsCluster();
    doReturn(true).when(cmd).validateUsbPolicy();
    doReturn(true).when(cmd).canAddVm();
    doReturn(true).when(cmd).checkTemplateInStorageDomain();
    doReturn(true).when(cmd).checkImagesGUIDsLegal();
    doReturn(true).when(cmd).setAndValidateDiskProfiles();
    doReturn(true).when(cmd).setAndValidateCpuProfile();
    doReturn(true).when(cmd).validateNoDuplicateDiskImages(any(Iterable.class));
    doReturn(createSourceDomain()).when(cmd).getSourceDomain();
    doReturn(createStorageDomain()).when(cmd).getStorageDomain(any(Guid.class));
    doReturn(Collections.<VM>singletonList(createVM())).when(cmd).getVmsFromExportDomain();
    doReturn(new VmTemplate()).when(cmd).getVmTemplate();
    doReturn(new StoragePool()).when(cmd).getStoragePool();
    doReturn(new VDSGroup()).when(cmd).getVdsGroup();
    doReturn(macPoolManagerStrategy).when(cmd).getMacPool();
    ArrayList<Guid> sdIds = new ArrayList<Guid>(Collections.singletonList(Guid.newGuid()));
    for (DiskImage image : parameters.getVm().getImages()) {
        image.setStorageIds(sdIds);
    }
    doReturn(Collections.<DiskImage>emptyList()).when(cmd).createDiskDummiesForSpaceValidations(anyList());
    return cmd;
}
#end_block

#method_before
@Test
public void testManagedDeviceSyncWithNewDiskId() {
    ImportVmParameters parameters = createParameters();
    ImportVmCommand<ImportVmParameters> command = new ImportVmCommand<>(parameters);
    List<DiskImage> diskList = new ArrayList<>();
    DiskImage diskImage = new DiskImage();
    diskImage.setStorageIds(new ArrayList<Guid>());
    DiskImage diskImage2 = new DiskImage();
    diskImage2.setStorageIds(new ArrayList<Guid>());
    diskList.add(diskImage);
    diskList.add(diskImage2);
    DiskImage disk = command.getActiveVolumeDisk(diskList);
    Map<Guid, VmDevice> managedDevices = new HashMap<>();
    managedDevices.put(disk.getId(), new VmDevice());
    Guid beforeOldDiskId = disk.getId();
    command.generateNewDiskId(diskList, disk);
    command.updateManagedDeviceMap(disk, managedDevices);
    Guid oldDiskId = command.newDiskIdForDisk.get(disk.getId()).getId();
    assertEquals("The old disk id should be similar to the value at the newDiskIdForDisk.", beforeOldDiskId, oldDiskId);
    assertNotNull("The manged deivce should return the disk device by the new key", managedDevices.get(disk.getId()));
    assertNull("The manged deivce should not return the disk device by the old key", managedDevices.get(beforeOldDiskId));
}
#method_after
@Test
public void testManagedDeviceSyncWithNewDiskId() {
    ImportVmParameters parameters = createParameters();
    ImportVmCommand<ImportVmParameters> command = new ImportVmCommand<>(parameters);
    List<DiskImage> diskList = new ArrayList<>();
    DiskImage diskImage = new DiskImage();
    diskImage.setStorageIds(new ArrayList<Guid>());
    DiskImage diskImage2 = new DiskImage();
    diskImage2.setStorageIds(new ArrayList<Guid>());
    diskList.add(diskImage);
    diskList.add(diskImage2);
    DiskImage disk = command.getActiveVolumeDisk(diskList);
    Map<Guid, VmDevice> managedDevices = new HashMap<>();
    managedDevices.put(disk.getId(), new VmDevice());
    Guid beforeOldDiskId = disk.getId();
    command.generateNewDiskId(diskList, disk);
    command.updateManagedDeviceMap(disk, managedDevices);
    Guid oldDiskId = command.newDiskIdForDisk.get(disk.getId()).getId();
    assertEquals("The old disk id should be similar to the value at the newDiskIdForDisk.", beforeOldDiskId, oldDiskId);
    assertNotNull("The manged device should return the disk device by the new key", managedDevices.get(disk.getId()));
    assertNull("The manged device should not return the disk device by the old key", managedDevices.get(beforeOldDiskId));
}
#end_block

#method_before
/* Test import images with empty Guid is failing */
@Test
public void testEmptyGuidFails() {
    ImportVmParameters params = createParameters();
    params.setCopyCollapse(Boolean.TRUE);
    DiskImage diskImage = params.getVm().getImages().get(0);
    diskImage.setVmSnapshotId(Guid.Empty);
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommand<ImportVmParameters>(params));
    doReturn(true).when(cmd).validateNoDuplicateVm();
    doReturn(true).when(cmd).validateVdsCluster();
    doReturn(true).when(cmd).validateUsbPolicy();
    doReturn(true).when(cmd).canAddVm();
    doReturn(true).when(cmd).checkTemplateInStorageDomain();
    doReturn(true).when(cmd).checkImagesGUIDsLegal();
    doReturn(true).when(cmd).validateNoDuplicateDiskImages(any(Iterable.class));
    doReturn(createSourceDomain()).when(cmd).getSourceDomain();
    doReturn(createStorageDomain()).when(cmd).getStorageDomain(any(Guid.class));
    doReturn(Collections.<VM>singletonList(params.getVm())).when(cmd).getVmsFromExportDomain();
    doReturn(new VmTemplate()).when(cmd).getVmTemplate();
    doReturn(new StoragePool()).when(cmd).getStoragePool();
    doReturn(new VDSGroup()).when(cmd).getVdsGroup();
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID.toString()));
}
#method_after
/* Test import images with empty Guid is failing */
@Test
public void testEmptyGuidFails() {
    ImportVmParameters params = createParameters();
    params.setCopyCollapse(Boolean.TRUE);
    DiskImage diskImage = params.getVm().getImages().get(0);
    diskImage.setVmSnapshotId(Guid.Empty);
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommand<ImportVmParameters>(params));
    doReturn(true).when(cmd).validateNoDuplicateVm();
    doReturn(true).when(cmd).validateVdsCluster();
    doReturn(true).when(cmd).validateUsbPolicy();
    doReturn(true).when(cmd).canAddVm();
    doReturn(true).when(cmd).checkTemplateInStorageDomain();
    doReturn(true).when(cmd).checkImagesGUIDsLegal();
    doReturn(true).when(cmd).setAndValidateDiskProfiles();
    doReturn(true).when(cmd).validateNoDuplicateDiskImages(any(Iterable.class));
    doReturn(createSourceDomain()).when(cmd).getSourceDomain();
    doReturn(createStorageDomain()).when(cmd).getStorageDomain(any(Guid.class));
    doReturn(Collections.<VM>singletonList(params.getVm())).when(cmd).getVmsFromExportDomain();
    doReturn(new VmTemplate()).when(cmd).getVmTemplate();
    doReturn(new StoragePool()).when(cmd).getStoragePool();
    doReturn(new VDSGroup()).when(cmd).getVdsGroup();
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID.toString()));
}
#end_block

#method_before
@Test
public void testValidateClusterSupportForVirtioScsi() {
    ImportVmCommand<ImportVmParameters> cmd = setupDiskSpaceTest(0);
    cmd.getParameters().getVm().getDiskMap().values().iterator().next().setDiskInterface(DiskInterface.VirtIO_SCSI);
    cmd.getVdsGroup().setcompatibility_version(Version.v3_2);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
}
#method_after
@Test
public void testValidateClusterSupportForVirtioScsi() {
    ImportVmCommand<ImportVmParameters> cmd = setupDiskSpaceTest(createParameters());
    cmd.getParameters().getVm().getDiskMap().values().iterator().next().setDiskInterface(DiskInterface.VirtIO_SCSI);
    cmd.getVdsGroup().setcompatibility_version(Version.v3_2);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
}
#end_block

#method_before
private CreateImageTemplateParameters buildChildCommandParameters(DiskImage diskImage, Guid vmSnapshotId) {
    CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
    createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
    createParams.setVmSnapshotId(vmSnapshotId);
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationStorageDomainId(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0));
    createParams.setDiskAlias(diskInfoDestinationMap.get(diskImage.getId()).getDiskAlias());
    createParams.setParentParameters(getParameters());
    createParams.setQuotaId(getQuotaIdForDisk(diskImage));
    return createParams;
}
#method_after
private CreateImageTemplateParameters buildChildCommandParameters(DiskImage diskImage, Guid vmSnapshotId) {
    CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
    createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
    createParams.setVmSnapshotId(vmSnapshotId);
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationStorageDomainId(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0));
    createParams.setDiskAlias(diskInfoDestinationMap.get(diskImage.getId()).getDiskAlias());
    createParams.setParentParameters(getParameters());
    createParams.setQuotaId(getQuotaIdForDisk(diskImage));
    createParams.setDiskProfileId(diskInfoDestinationMap.get(diskImage.getId()).getDiskProfileId());
    return createParams;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.infoFormat("Cancelling current running update for vms for base template id {0}", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warnFormat("Failed deleting job {0} at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), getParameters().getGraphicsDevices().keySet(), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), getParameters().graphicsTypesToBeSet(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVdsGroup().getcompatibility_version(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    if (CommandCoordinatorUtil.getCommandExecutionStatus(getParameters().getCommandId()) == CommandExecutionStatus.EXECUTED) {
        // if template exist in db remove it
        if (getVmTemplate() != null) {
            DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
            removeNetwork();
        }
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getParameters().getVm() != null && !StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED));
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > MacPoolManager.getInstance().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > getMacPool().getAvailableMacsCount()) {
            return failCanDoAction(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        }
    }
    if (!validateBallonDevice()) {
        return false;
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!isImagesAlreadyOnTarget() && !validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#method_after
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#end_block

#method_before
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (!setDomainsForMemoryImages(domainMap)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), getGraphicsTypesForVm(vmFromParams), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        if (!handleDestStorageDomains()) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), getGraphicsTypesForVm(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!validate(getImportValidator().validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces())))) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
Set<GraphicsType> getGraphicsTypesForVm(VM vmFromParams) {
    return VmDeviceUtils.getGraphicsTypesForVm(vmFromParams);
}
#method_after
Set<GraphicsType> getGraphicsTypesForVm() {
    Set<GraphicsType> graphicsTypes = new HashSet<>();
    for (VmDevice vmDevice : getVm().getManagedVmDeviceMap().values()) {
        if (VmDeviceGeneralType.GRAPHICS == vmDevice.getType()) {
            graphicsTypes.add(GraphicsType.fromVmDeviceType(VmDeviceType.valueOf(vmDevice.getDevice())));
        }
    }
    return graphicsTypes;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = verifyDisksIfNeeded();
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = validate(getImportValidator().verifyDisks(imageList, imageToDestinationDomainMap));
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.transformToList(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
private void processImages(final boolean useCopyImages) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmImagesAndSnapshots();
            updateSnapshotsFromExport();
            if (useCopyImages) {
                moveOrCopyAllImageGroups();
            }
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity());
            VmHandler.lockVm(getVm().getId());
            if (getParameters().isImportAsNewEntity()) {
                getParameters().setVm(getVm());
                setVmId(getVm().getId());
            }
            return null;
        }
    });
}
#method_after
@Override
protected void processImages() {
    processImages(!isImagesAlreadyOnTarget());
    // vm related ops
    if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
        endVmRelatedOps();
    }
}
#end_block

#method_before
private void processImages(final boolean useCopyImages) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmImagesAndSnapshots();
            updateSnapshotsFromExport();
            if (useCopyImages) {
                moveOrCopyAllImageGroups();
            }
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity());
            VmHandler.lockVm(getVm().getId());
            if (getParameters().isImportAsNewEntity()) {
                getParameters().setVm(getVm());
                setVmId(getVm().getId());
            }
            return null;
        }
    });
}
#method_after
private void processImages(final boolean useCopyImages) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmImagesAndSnapshots();
            updateSnapshotsFromExport();
            if (useCopyImages) {
                moveOrCopyAllImageGroups();
            }
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity());
            if (getParameters().isImportAsNewEntity()) {
                getParameters().setVm(getVm());
                setVmId(getVm().getId());
            }
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups() {
    moveOrCopyAllImageGroups(getVm().getId(), ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false, true));
    copyAllMemoryImages(getVm().getId());
}
#method_after
protected void moveOrCopyAllImageGroups() {
    moveOrCopyAllImageGroups(getVm().getId(), ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false, true));
    copyAllMemoryImages(getVm().getId());
}
#end_block

#method_before
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForMemoryDumpImage(Guid containerID, Guid storageId, Guid imageId, Guid volumeId) {
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, imageId, volumeId, imageId, volumeId, storageId, getMoveOrCopyImageOperation());
    params.setParentCommand(getActionType());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setParentParameters(getParameters());
    StorageDomainStatic storageDomain = getStorageDomainStaticDAO().get(storageId);
    if (storageDomain.getStorageType().isBlockDomain()) {
        params.setUseCopyCollapse(true);
        params.setVolumeType(VolumeType.Preallocated);
        params.setVolumeFormat(VolumeFormat.RAW);
    }
    return params;
}
#method_after
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForMemoryDumpImage(Guid containerID, Guid storageId, Guid imageId, Guid volumeId) {
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, imageId, volumeId, imageId, volumeId, storageId, ImageOperation.Copy);
    params.setParentCommand(getActionType());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setParentParameters(getParameters());
    StorageDomainStatic storageDomain = getStorageDomainStaticDAO().get(storageId);
    if (storageDomain.getStorageType().isBlockDomain()) {
        params.setUseCopyCollapse(true);
        params.setVolumeType(VolumeType.Preallocated);
        params.setVolumeFormat(VolumeFormat.RAW);
    }
    return params;
}
#end_block

#method_before
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForMemoryConfImage(Guid containerID, Guid storageId, Guid imageId, Guid volumeId) {
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, imageId, volumeId, imageId, volumeId, storageId, getMoveOrCopyImageOperation());
    params.setParentCommand(getActionType());
    // This volume is always of type 'sparse' and format 'cow' so no need to convert,
    // and there're no snapshots for it so no reason to use copy collapse
    params.setUseCopyCollapse(false);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setParentParameters(getParameters());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    return params;
}
#method_after
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForMemoryConfImage(Guid containerID, Guid storageId, Guid imageId, Guid volumeId) {
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, imageId, volumeId, imageId, volumeId, storageId, ImageOperation.Copy);
    params.setParentCommand(getActionType());
    // This volume is always of type 'sparse' and format 'cow' so no need to convert,
    // and there're no snapshots for it so no reason to use copy collapse
    params.setUseCopyCollapse(false);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setParentParameters(getParameters());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    return params;
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForDisk(DiskImage disk, Guid containerID) {
    Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
    Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
    params.setParentCommand(getActionType());
    params.setUseCopyCollapse(getParameters().getCopyCollapse());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    params.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getQuotaId());
    if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(originalDiskId)) {
        DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(originalDiskId);
        params.setVolumeType(diskImageBase.getVolumeType());
        params.setVolumeFormat(diskImageBase.getVolumeFormat());
    }
    params.setParentParameters(getParameters());
    return params;
}
#method_after
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForDisk(DiskImage disk, Guid containerID) {
    Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
    Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, ImageOperation.Copy);
    params.setParentCommand(getActionType());
    params.setUseCopyCollapse(getParameters().getCopyCollapse());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    params.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getQuotaId());
    params.setDiskProfileId(disk.getDiskProfileId());
    if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(originalDiskId)) {
        DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(originalDiskId);
        params.setVolumeType(diskImageBase.getVolumeType());
        params.setVolumeFormat(diskImageBase.getVolumeFormat());
    }
    params.setParentParameters(getParameters());
    return params;
}
#end_block

#method_before
private String getMemoryVolumeFromActiveSnapshotInExportDomain() {
    for (Snapshot snapshot : getVm().getSnapshots()) {
        if (snapshot.getType() == SnapshotType.ACTIVE)
            return snapshot.getMemoryVolume();
    }
    log.warnFormat("VM {0} doesn't have active snapshot in export domain", getVmId());
    return StringUtils.EMPTY;
}
#method_after
private String getMemoryVolumeFromActiveSnapshotInExportDomain() {
    Snapshot activeSnapshot = getActiveSnapshot();
    if (activeSnapshot != null) {
        return activeSnapshot.getMemoryVolume();
    }
    return StringUtils.EMPTY;
}
#end_block

#method_before
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#method_after
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
private void removeVmSnapshots() {
    Guid vmId = getVmId();
    Set<String> memoryStates = snapshotsManager.removeSnapshots(vmId);
    for (String memoryState : memoryStates) {
        removeMemoryVolumes(memoryState, vmId);
    }
}
#method_after
@Override
protected void removeVmSnapshots() {
    Guid vmId = getVmId();
    Set<String> memoryStates = snapshotsManager.removeSnapshots(vmId);
    for (String memoryState : memoryStates) {
        removeMemoryVolumes(memoryState, vmId);
    }
}
#end_block

#method_before
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#method_after
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.error("Failed to remove memory volumes '{}'", memoryVolume);
    }
}
#end_block

#method_before
protected void removeVmNetworkInterfaces() {
    new VmInterfaceManager().removeAll(getVmId());
}
#method_after
protected void removeVmNetworkInterfaces() {
    new VmInterfaceManager(getMacPool()).removeAll(getVmId());
}
#end_block

#method_before
@Override
protected List<DiskImage> getImages() {
    return getVm().getImages();
}
#method_after
protected List<DiskImage> getImages() {
    return getVm().getImages();
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_UPDATE_VM : AuditLogType.USER_FAILED_UPDATE_VM;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return isInternalExecution() ? getSucceeded() ? AuditLogType.SYSTEM_UPDATE_VM : AuditLogType.SYSTEM_FAILED_UPDATE_VM : getSucceeded() ? AuditLogType.USER_UPDATE_VM : AuditLogType.USER_FAILED_UPDATE_VM;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void hotSetCpus(int cpuPerSocket) {
    int currentSockets = getVm().getNumOfSockets();
    int newSockets = newVmStatic.getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#method_after
private void hotSetCpus(int cpuPerSocket, int newNumOfSockets) {
    int currentSockets = getVm().getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newNumOfSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#end_block

#method_before
private void updateGraphicsDevice() {
    for (GraphicsType type : GraphicsType.values()) {
        if (!getParameters().shouldUpdateGraphicsDevice(type)) {
            continue;
        }
        GraphicsDevice vmGraphicsDevice = getGraphicsDevOfType(type);
        if (vmGraphicsDevice == null) {
            if (getParameters().getGraphicsDevice(type) != null) {
                getParameters().getGraphicsDevice(type).setVmId(getVmId());
                getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(getParameters().getGraphicsDevice(type)));
            }
        } else {
            if (getParameters().getGraphicsDevice(type) == null) {
                getBackend().runInternalAction(VdcActionType.RemoveGraphicsDevice, new GraphicsParameters(vmGraphicsDevice));
            } else {
                getParameters().getGraphicsDevice(type).setVmId(getVmId());
                getBackend().runInternalAction(VdcActionType.UpdateGraphicsDevice, new GraphicsParameters(getParameters().getGraphicsDevice(type)));
            }
        }
    }
}
#method_after
private void updateGraphicsDevice() {
    for (GraphicsType type : getParameters().getGraphicsDevices().keySet()) {
        GraphicsDevice vmGraphicsDevice = getGraphicsDevOfType(type);
        if (vmGraphicsDevice == null) {
            if (getParameters().getGraphicsDevices().get(type) != null) {
                getParameters().getGraphicsDevices().get(type).setVmId(getVmId());
                getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(getParameters().getGraphicsDevices().get(type)));
            }
        } else {
            if (getParameters().getGraphicsDevices().get(type) == null) {
                getBackend().runInternalAction(VdcActionType.RemoveGraphicsDevice, new GraphicsParameters(vmGraphicsDevice));
            } else {
                getParameters().getGraphicsDevices().get(type).setVmId(getVmId());
                getBackend().runInternalAction(VdcActionType.UpdateGraphicsDevice, new GraphicsParameters(getParameters().getGraphicsDevices().get(type)));
            }
        }
    }
}
#end_block

#method_before
private GraphicsDevice getGraphicsDevOfType(GraphicsType type) {
    VdcQueryReturnValue query = getBackend().runInternalQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(getParameters().getVmId()));
    List<GraphicsDevice> graphicsDevices = query.getReturnValue();
    for (GraphicsDevice dev : graphicsDevices) {
        if (dev.getVmDeviceType() == type.getCorrespondingDeviceType()) {
            return dev;
        }
    }
    return null;
}
#method_after
private GraphicsDevice getGraphicsDevOfType(GraphicsType type) {
    List<GraphicsDevice> graphicsDevices = getGraphicsDevices();
    for (GraphicsDevice dev : graphicsDevices) {
        if (dev.getGraphicsType() == type) {
            return dev;
        }
    }
    return null;
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<VmDeviceId>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getType(), payload.getSpecParams(), true, true, null);
        }
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<VmDeviceId>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null);
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!checkNumberOfMonitors()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), getParameters().graphicsTypesToBeModified(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

#method_before
private boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.isBalloonEnabled(getVmId());
}
#method_after
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.isBalloonEnabled(getVmId());
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.CDROM) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            struct = new HashMap<String, Object>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
}
#method_after
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<String, Object>();
        addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<String, Object>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmFloppy() {
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.FLOPPY) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            Map<String, Object> struct = new HashMap<String, Object>();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#method_after
@Override
protected void buildVmFloppy() {
    // check if we have payload Floppy
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.FLOPPY;
    if (hasPayload) {
        Map<String, Object> struct = new HashMap<String, Object>();
        addFloppyDetails(vm.getVmPayload(), struct);
        addDevice(struct, vm.getVmPayload(), "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, null, true, true, true, "", null, null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            Map<String, Object> struct = new HashMap<String, Object>();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    // map to avoid fetching qos object for same disk profile id
    Map<Guid, Guid> diskProfileStorageQosMap = new HashMap<>();
    Map<Guid, Map<String, Long>> storageQosIoTuneMap = new HashMap<>();
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                handleIoTune(vm, vmDevice, diskImage, diskProfileStorageQosMap, storageQosIoTuneMap);
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(SYSPREP_FILE_NAME, Base64.encodeBase64String(sysPrepContent.getBytes()));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#method_after
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(getOsRepository().getSysprepFileName(vm.getOs(), vm.getVdsGroupCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#end_block

#method_before
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), Base64.encodeBase64String(entry.getValue()));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#method_after
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#end_block

#method_before
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VNIC_PROFILE_PROPERTIES> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debugFormat("VNIC {0} is using profile {1} on network {2}", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion())) {
                unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion(), network)) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.CUSTOM_PROPERTIES);
    }
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#method_after
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VNIC_PROFILE_PROPERTIES> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debug("VNIC '{}' is using profile '{}' on network '{}'", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion())) {
                unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion(), network)) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.CUSTOM_PROPERTIES);
    }
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#end_block

#method_before
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    Guid qosId = vnicProfile.getNetworkQosId();
    if (!FeatureSupported.networkQoS(vdsGroupCompatibilityVersion)) {
        return qosId == null;
    }
    Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
    if (specParams == null) {
        specParams = new HashMap<>();
        struct.put(VdsProperties.SpecParams, specParams);
    }
    NetworkQoS networkQoS = (qosId == null) ? new NetworkQoS() : DbFacade.getInstance().getQosDao().get(qosId);
    NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
    qosMapper.serialize(networkQoS);
    return true;
}
#method_after
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    Guid qosId = vnicProfile.getNetworkQosId();
    if (!FeatureSupported.networkQoS(vdsGroupCompatibilityVersion)) {
        return qosId == null;
    }
    Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
    if (specParams == null) {
        specParams = new HashMap<>();
        struct.put(VdsProperties.SpecParams, specParams);
    }
    NetworkQoS networkQoS = (qosId == null) ? new NetworkQoS() : DbFacade.getInstance().getNetworkQosDao().get(qosId);
    NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
    qosMapper.serialize(networkQoS);
    return true;
}
#end_block

#method_before
@Override
protected void buildVmMemoryBalloon() {
    if (vm.isRunOnce() && vm.isBalloonEnabled()) {
        Map<String, Object> specParams = new HashMap<String, Object>();
        specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.getName(), "", 0, specParams, true, true, true, "", null, null);
        addMemBalloonDevice(vmDevice);
    } else {
        // get vm device for this Balloon from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            addMemBalloonDevice(vmDevice);
            // only one memory balloon should exist
            break;
        }
    }
}
#method_after
@Override
protected void buildVmMemoryBalloon() {
    if (vm.isRunOnce() && vm.isBalloonEnabled()) {
        Map<String, Object> specParams = new HashMap<String, Object>();
        specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.getName(), "", 0, specParams, true, true, true, "", null, null, null);
        addMemBalloonDevice(vmDevice);
    } else {
        // get vm device for this Balloon from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            addMemBalloonDevice(vmDevice);
            // only one memory balloon should exist
            break;
        }
    }
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return isDedicatedVdsOnSameCluster(vmStaticFromParams);
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    if (!validateCustomProperties(vmStaticFromParams, reasons)) {
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return isDedicatedVdsOnSameCluster(vmStaticFromParams);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), getParameters().graphicsTypesToBeModified(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (vmFromParams.getId() != null && getVmStaticDao().get(vmFromParams.getId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    return true;
}
#end_block

#method_before
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.errorFormat("Can not find any default active domain for one of the disks of template with id : {0}", vmDisksSource.getId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#method_after
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.error("Can not find any default active domain for one of the disks of template with id '{}'", vmDisksSource.getId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#end_block

#method_before
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setvolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<Guid>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    return newImage;
}
#method_after
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setvolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<Guid>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    newImage.setDiskProfileId(image.getDiskProfileId());
    return newImage;
}
#end_block

#method_before
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#method_after
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority, getMacPool());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                addGraphicsDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmNumaNodes();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    addGraphicsDevice();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.error("Failed to add vm . The reasons are: {}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
private void addGraphicsDevice() {
    for (GraphicsType type : GraphicsType.values()) {
        GraphicsDevice graphicsDevice = getParameters().getGraphicsDevice(type);
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#method_after
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#end_block

#method_before
private void updateSmartCardDevices() {
    // add or remove the smartcard according to user request
    if (getVm().isSmartcardEnabled() != getVmTemplate().isSmartcardEnabled()) {
        VmDeviceUtils.updateSmartcardDevice(getVm().getId(), getVm().isSmartcardEnabled());
    }
}
#method_after
private void updateSmartCardDevices() {
    // if vm smartcard settings is different from device source's
    // add or remove the smartcard according to user request
    boolean smartcardOnDeviceSource = getInstanceTypeId() != null ? getInstanceType().isSmartcardEnabled() : getVmTemplate().isSmartcardEnabled();
    if (getVm().isSmartcardEnabled() != smartcardOnDeviceSource) {
        VmDeviceUtils.updateSmartcardDevice(getVm().getId(), getVm().isSmartcardEnabled());
    }
}
#end_block

#method_before
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getType(), payload.getSpecParams(), true, true, null);
    }
}
#method_after
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null);
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
    if (instanceTypeId != null) {
        copyDiskDevicesFromTemplate();
    }
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#end_block

#method_before
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        updateProfileOnNic(iface);
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool());
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = getMacPool().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        updateProfileOnNic(iface);
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    tempVar.setLastStopTime(new Date());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic vmDynamic = new VmDynamic();
    vmDynamic.setId(getVmId());
    vmDynamic.setStatus(VMStatus.Down);
    vmDynamic.setVmHost("");
    vmDynamic.setVmIp("");
    vmDynamic.setVmFQDN("");
    vmDynamic.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    vmDynamic.setLastStopTime(new Date());
    getDbFacade().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? (getReturnValue().getVdsmTaskIdList().size() > 0 ? AuditLogType.USER_ADD_VM_STARTED : AuditLogType.USER_ADD_VM) : AuditLogType.USER_FAILED_ADD_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
        default:
            return AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? (!getReturnValue().getVdsmTaskIdList().isEmpty() ? AuditLogType.USER_ADD_VM_STARTED : AuditLogType.USER_ADD_VM) : AuditLogType.USER_FAILED_ADD_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
        default:
            return AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
    }
}
#end_block

#method_before
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (instanceTypeId != null && !checkInstanceTypeImagePermissions(instanceTypeId)) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance on the cluster is enough
        if (permSubject.getObjectType() == VdcObjectType.VdsGroups && instanceTypeId != null) {
            permSubject.setActionGroup(ActionGroup.CREATE_INSTANCE);
            if (checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
                continue;
            }
            // create_vm is overriding in case no create_instance, try again with it
            permSubject.setActionGroup(getActionType().getActionGroup());
        }
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (getInstanceTypeId() != null && !checkInstanceTypeImagePermissions(getInstanceTypeId())) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance on the cluster is enough
        if (permSubject.getObjectType() == VdcObjectType.VdsGroups && getInstanceTypeId() != null) {
            permSubject.setActionGroup(ActionGroup.CREATE_INSTANCE);
            if (checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
                continue;
            }
            // create_vm is overriding in case no create_instance, try again with it
            permSubject.setActionGroup(getActionType().getActionGroup());
        }
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permissions[] permsArray = new Permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permissions(getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permissions[] permsArray = new Permissions[newDiskImageIds.size()];
    Guid diskOperatorIdFromParams = getParameters().getDiskOperatorAuthzPrincipalDbId();
    Guid diskOperatorId = diskOperatorIdFromParams != null ? diskOperatorIdFromParams : getCurrentUser().getId();
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permissions(diskOperatorId, PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        DisplayType defaultDisplayType = osRepository.getGraphicsAndDisplays(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version()).get(0).getSecond();
        getParameters().getVmStaticData().setDefaultDisplayType(defaultDisplayType);
    }
}
#method_after
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        autoSelectDefaultDisplayType(getVmTemplateId());
    }
}
#end_block

#method_before
protected boolean isTemplateInValidDc() {
    return getVmTemplate().getStoragePoolId().equals(getStoragePoolId());
}
#method_after
protected boolean isTemplateInValidDc() {
    return VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplateId()) || getVmTemplate().getStoragePoolId().equals(getStoragePoolId());
}
#end_block

#method_before
protected boolean checkNumberOfMonitors() {
    Set<GraphicsType> graphicsTypesToBeSet = getParameters().graphicsTypesToBeModified();
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return VmHandler.isNumOfMonitorsLegal(graphicsTypesToBeSet, numOfMonitors, getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkNumberOfMonitors() {
    Collection<GraphicsType> graphicsTypes = VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices());
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return VmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors, getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Set parameters for messaging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        if (ObjectIdentityChecker.CanUpdateField(vm, "vdsGroupId", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
            Version clusterCompatibilityVersion = targetCluster.getcompatibility_version();
            if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNics(interfaces, clusterCompatibilityVersion)) {
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.checkCpuSockets(vm.getStaticData().getNumOfSockets(), vm.getStaticData().getCpuPerSocket(), clusterCompatibilityVersion.getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
            // Check if the display type is supported
            if (!VmHandler.isGraphicsAndDisplaySupported(vm.getOs(), VmDeviceUtils.getGraphicsTypesForVm(vm), vm.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), clusterCompatibilityVersion)) {
                return false;
            }
            if (VmDeviceUtils.isVirtioScsiControllerAttached(vm.getId())) {
                // Verify cluster compatibility
                if (!FeatureSupported.virtIoScsi(targetCluster.getcompatibility_version())) {
                    return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
                }
                // Verify OS compatibility
                if (!VmHandler.isOsTypeSupportedForVirtioScsi(vm.getOs(), targetCluster.getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
                    return false;
                }
            }
            // A existing VM cannot be changed into a cluster without a defined architecture
            if (targetCluster.getArchitecture() == ArchitectureType.undefined) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
            } else if (targetCluster.getArchitecture() != vm.getClusterArch()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_CLUSTER_DIFFERENT_ARCHITECTURES);
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isInternalExecution() && !ObjectIdentityChecker.CanUpdateField(getVm(), "vdsGroupId", getVm().getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    ChangeVmClusterValidator validator = new ChangeVmClusterValidator(this, getParameters().getClusterId());
    return validator.validate();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // check that the cluster are not the same
    VM vm = getVm();
    if (vm.getVdsGroupId().equals(getParameters().getClusterId())) {
        setSucceeded(true);
        return;
    }
    // update vm interfaces
    List<Network> networks = getNetworkDAO().getAllForCluster(getParameters().getClusterId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    for (final VmNic iface : interfaces) {
        if (iface.getVnicProfileId() != null) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return ObjectUtils.equals(n.getId(), network.getId());
                }
            });
            // interface connection
            if (net == null) {
                iface.setVnicProfileId(null);
                getVmNicDao().update(iface);
            }
        }
    }
    if (vm.getDedicatedVmForVds() != null) {
        vm.setDedicatedVmForVds(null);
        dedicatedHostWasCleared = true;
    }
    vm.setVdsGroupId(getParameters().getClusterId());
    DbFacade.getInstance().getVmStaticDao().update(vm.getStaticData());
    // change vm cluster should remove the vm from all associated affinity groups
    List<AffinityGroup> allAffinityGroupsByVmId = DbFacade.getInstance().getAffinityGroupDao().getAllAffinityGroupsByVmId(vm.getId());
    if (!allAffinityGroupsByVmId.isEmpty()) {
        StringBuilder sb = new StringBuilder();
        for (AffinityGroup affinityGroup : allAffinityGroupsByVmId) {
            sb.append(affinityGroup.getName() + " ");
        }
        log.infoFormat("Due to cluster change, removing VM from associated affinity group(s): {0}", sb.toString());
        DbFacade.getInstance().getAffinityGroupDao().removeVmFromAffinityGroups(vm.getId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // check that the cluster are not the same
    VM vm = getVm();
    if (vm.getVdsGroupId().equals(getParameters().getClusterId())) {
        setSucceeded(true);
        return;
    }
    // update vm interfaces
    List<Network> networks = getNetworkDAO().getAllForCluster(getParameters().getClusterId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    for (final VmNic iface : interfaces) {
        if (iface.getVnicProfileId() != null) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return ObjectUtils.equals(n.getId(), network.getId());
                }
            });
            // interface connection
            if (net == null) {
                iface.setVnicProfileId(null);
                getVmNicDao().update(iface);
            }
        }
    }
    if (vm.getDedicatedVmForVds() != null) {
        vm.setDedicatedVmForVds(null);
        dedicatedHostWasCleared = true;
    }
    // Since CPU profile is coupled to cluster, when changing a cluster
    // the 'old' CPU profile is invalid. The update VM command is called straight after
    // will validate a right profile for VM and its cluster
    vm.setCpuProfileId(null);
    vm.setVdsGroupId(getParameters().getClusterId());
    DbFacade.getInstance().getVmStaticDao().update(vm.getStaticData());
    // change vm cluster should remove the vm from all associated affinity groups
    List<AffinityGroup> allAffinityGroupsByVmId = DbFacade.getInstance().getAffinityGroupDao().getAllAffinityGroupsByVmId(vm.getId());
    if (!allAffinityGroupsByVmId.isEmpty()) {
        StringBuilder sb = new StringBuilder();
        for (AffinityGroup affinityGroup : allAffinityGroupsByVmId) {
            sb.append(affinityGroup.getName() + " ");
        }
        log.info("Due to cluster change, removing VM from associated affinity group(s): {}", sb);
        DbFacade.getInstance().getAffinityGroupDao().removeVmFromAffinityGroups(vm.getId());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    // In addition to having EDIT_VM_PROPERTIES on the VM, you must have CREATE_VM on the cluster
    permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getParameters().getClusterId(), VdcObjectType.VdsGroups, ActionGroup.CREATE_VM));
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return VmHandler.getPermissionsNeededToChangeCluster(getParameters().getVmId(), getParameters().getClusterId());
}
#end_block

#method_before
public VmDevice readVmDevice(XmlNode node, VmBase vmBase, Guid deviceId, boolean isManaged) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).innerText)) {
        vmDevice.setAddress(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).innerText));
    } else {
        vmDevice.setAddress("");
    }
    if (node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).innerText)) {
        vmDevice.setAlias(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).innerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = node.SelectSingleNode(OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.innerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText)) {
        vmDevice.setType(VmDeviceGeneralType.forValue(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText)));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceGeneralType.forValue(VmDeviceType.getoVirtDevice(resourceType)));
    }
    if (node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).innerText)) {
        vmDevice.setDevice(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).innerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).innerText)) {
        vmDevice.setBootOrder(Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).innerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).innerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).innerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)) {
        vmDevice.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    } else {
        vmDevice.setCustomProperties(null);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS).innerText)) {
        vmDevice.setSnapshotId(new Guid(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    }
    if (isManaged) {
        vmDevice.setIsManaged(true);
        vmBase.getManagedDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    } else {
        vmBase.getUnmanagedDeviceList().add(vmDevice);
    }
    return vmDevice;
}
#method_after
private VmDevice readVmDevice(XmlNode node, Guid deviceId) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).innerText)) {
        vmDevice.setAddress(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).innerText));
    } else {
        vmDevice.setAddress("");
    }
    if (node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).innerText)) {
        vmDevice.setAlias(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).innerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = node.SelectSingleNode(OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.innerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText)) {
        vmDevice.setType(VmDeviceGeneralType.forValue(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText)));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceGeneralType.forValue(VmDeviceType.getoVirtDevice(resourceType)));
    }
    if (node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).innerText)) {
        vmDevice.setDevice(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).innerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).innerText)) {
        vmDevice.setBootOrder(Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).innerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).innerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).innerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)) {
        vmDevice.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    } else {
        vmDevice.setCustomProperties(null);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS).innerText)) {
        vmDevice.setSnapshotId(new Guid(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    }
    return vmDevice;
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = content.SelectSingleNode(OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = content.SelectSingleNode(OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = content.SelectSingleNode(OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = content.SelectSingleNode(OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode(OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = content.SelectSingleNode(OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(new Version(getVersion())) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    node = content.SelectSingleNode(OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    readGeneralData(content);
    readVmInit(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = content.SelectSingleNode(OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = content.SelectSingleNode(OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    node = content.SelectSingleNode(OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = content.SelectSingleNode(OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = content.SelectSingleNode(OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode(OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(new Version(getVersion())) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // due to depndency on vmBase.getOsId() must be read AFTER readOsSection
    node = content.SelectSingleNode(OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = content.SelectSingleNode(OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    readGeneralData(content);
    readVmInit(content);
}
#end_block

#method_before
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    iface.setName(node.SelectSingleNode(OvfProperties.VMD_NAME, _xmlNS).innerText);
    iface.setMacAddress((node.SelectSingleNode("rasd:MACAddress", _xmlNS) != null) ? node.SelectSingleNode("rasd:MACAddress", _xmlNS).innerText : "");
    String networkName = node.SelectSingleNode(OvfProperties.VMD_CONNECTION, _xmlNS).innerText;
    iface.setNetworkName(StringUtils.defaultIfEmpty(networkName, null));
    XmlNode vnicProfileNameNode = node.SelectSingleNode(OvfProperties.VMD_VNIC_PROFILE_NAME, _xmlNS);
    iface.setVnicProfileName(vnicProfileNameNode == null ? null : StringUtils.defaultIfEmpty(vnicProfileNameNode.innerText, null));
    XmlNode linkedNode = node.SelectSingleNode(OvfProperties.VMD_LINKED, _xmlNS);
    iface.setLinked(linkedNode == null ? true : Boolean.valueOf(linkedNode.innerText));
    String resourceSubType = node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).innerText;
    if (StringUtils.isNotEmpty(resourceSubType)) {
        iface.setType(Integer.parseInt(resourceSubType));
    }
    XmlNode speed = node.SelectSingleNode("rasd:speed", _xmlNS);
    iface.setSpeed((speed != null) ? Integer.parseInt(speed.innerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#method_after
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    String networkName = node.SelectSingleNode(OvfProperties.VMD_CONNECTION, _xmlNS).innerText;
    iface.setNetworkName(StringUtils.defaultIfEmpty(networkName, null));
    XmlNode vnicProfileNameNode = node.SelectSingleNode(OvfProperties.VMD_VNIC_PROFILE_NAME, _xmlNS);
    iface.setVnicProfileName(vnicProfileNameNode == null ? null : StringUtils.defaultIfEmpty(vnicProfileNameNode.innerText, null));
    XmlNode linkedNode = node.SelectSingleNode(OvfProperties.VMD_LINKED, _xmlNS);
    iface.setLinked(linkedNode == null ? true : Boolean.valueOf(linkedNode.innerText));
    iface.setName(node.SelectSingleNode(OvfProperties.VMD_NAME, _xmlNS).innerText);
    String resourceSubType = node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).innerText;
    if (StringUtils.isNotEmpty(resourceSubType)) {
        iface.setType(Integer.parseInt(resourceSubType));
    }
    XmlNode speed = node.SelectSingleNode("rasd:speed", _xmlNS);
    iface.setSpeed((speed != null) ? Integer.parseInt(speed.innerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, boolean copySnapshotDevices) {
    VM vm = DbFacade.getInstance().getVmDao().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDao().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, vm, vmBase, isVm, devices, srcDeviceIdToTargetDeviceIdMapping, soundDeviceEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, copySnapshotDevices);
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    Guid id;
    if (graphicsToSkip == null) {
        graphicsToSkip = new HashSet<>();
    }
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
                hasAlreadyCD = true;
                addCD = false;
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(vmBase, isBalloonEnabled);
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasVmRngDevice(dstId)) {
                    // don't copy rng device if we already have it
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasVmGraphicsDeviceOfType(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            VDSGroup cluster = vmBase.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId()) : null;
            addSoundCard(vmBase, cluster != null ? cluster.getcompatibility_version() : null);
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = getNumOfMonitors(vm);
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#end_block

#method_before
private static int getNumOfMonitors(VM vm) {
    int maxMonitorsSpice = vm.getSingleQxlPci() ? 1 : vm.getNumOfMonitors();
    int maxMonitorsVnc = Math.max(1, vm.getNumOfMonitors());
    return Math.min(maxMonitorsSpice, maxMonitorsVnc);
}
#method_after
private static int getNumOfMonitors(VM vm) {
    int maxMonitorsSpice = vm.getSingleQxlPci() ? SINGLE_QXL_MONITORS : vm.getNumOfMonitors();
    int maxMonitorsVnc = Math.max(VNC_MIN_MONITORS, vm.getNumOfMonitors());
    return Math.min(maxMonitorsSpice, maxMonitorsVnc);
}
#end_block

#method_before
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, Boolean isReadOnly, Map<String, String> customProp) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp, null);
    dao.save(managedDevice);
    // If we add Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (type == VmDeviceGeneralType.DISK || type == VmDeviceGeneralType.INTERFACE) {
        // recalculate boot sequence
        VmBase vmBase = DbFacade.getInstance().getVmStaticDao().get(id.getVmId());
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
    }
    return managedDevice;
}
#method_after
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, Boolean isReadOnly, Map<String, String> customProp) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp, null, null);
    dao.save(managedDevice);
    // If we add Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (type == VmDeviceGeneralType.DISK || type == VmDeviceGeneralType.INTERFACE) {
        // recalculate boot sequence
        VmBase vmBase = DbFacade.getInstance().getVmStaticDao().get(id.getVmId());
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
    }
    return managedDevice;
}
#end_block

#method_before
private static boolean isBalloonEnabled(VmManagementParametersBase params) {
    Boolean balloonEnabled = params.isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : osRepository.isBalloonEnabled(params.getVmStaticData().getOsId(), ClusterUtils.getCompatibilityVersion(params.getVmStaticData()));
}
#method_after
private static boolean isBalloonEnabled(VmManagementParametersBase params) {
    Boolean balloonEnabled = params.isBalloonEnabled();
    return (balloonEnabled != null) ? balloonEnabled : isBalloonEnabled(params.getVmStaticData().getId());
}
#end_block

#method_before
public static Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    VmDeviceUtils.setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<Pair<EditableDeviceOnVmStatusField, Boolean>> fieldList = VmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (Pair<EditableDeviceOnVmStatusField, Boolean> pair : fieldList) {
        final EditableDeviceOnVmStatusField field = pair.getFirst();
        Boolean isEnabled = pair.getSecond();
        if (Boolean.TRUE.equals(isEnabled)) {
            VmDevice device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), field.generalType(), field.type().getName(), "", 0, new HashMap<String, Object>(), true, true, field.isReadOnly(), "", null, null);
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            vmManagedDeviceMap.remove(getVmDeviceIdByName(vmManagedDeviceMap, field.type().getName()));
        }
    }
    return vmManagedDeviceMap;
}
#method_after
public static Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    VmDeviceUtils.setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<Pair<EditableDeviceOnVmStatusField, Boolean>> fieldList = VmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (Pair<EditableDeviceOnVmStatusField, Boolean> pair : fieldList) {
        final EditableDeviceOnVmStatusField field = pair.getFirst();
        Boolean isEnabled = pair.getSecond();
        if (Boolean.TRUE.equals(isEnabled)) {
            VmDevice device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), field.generalType(), field.type().getName(), "", 0, new HashMap<String, Object>(), true, true, field.isReadOnly(), "", null, null, null);
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            vmManagedDeviceMap.remove(getVmDeviceIdByName(vmManagedDeviceMap, field.generalType(), field.type().getName()));
        }
    }
    return vmManagedDeviceMap;
}
#end_block

#method_before
private static Guid getVmDeviceIdByName(Map<Guid, VmDevice> vmManagedDeviceMap, String name) {
    for (Map.Entry<Guid, VmDevice> entry : vmManagedDeviceMap.entrySet()) {
        if (entry.getValue().getDevice().equals(name)) {
            return entry.getKey();
        }
    }
    return null;
}
#method_after
private static Guid getVmDeviceIdByName(Map<Guid, VmDevice> vmManagedDeviceMap, VmDeviceGeneralType generalType, String name) {
    for (Map.Entry<Guid, VmDevice> entry : vmManagedDeviceMap.entrySet()) {
        // if no match, and specific name is unknown, look by general type
        if (entry.getValue().getDevice().equals(name) || (VmDeviceType.UNKNOWN.getName().equals(name) && entry.getValue().getType() == generalType)) {
            return entry.getKey();
        }
    }
    return null;
}
#end_block

#method_before
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVds, VDSGroup vdsGroup) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    }
    return validateVmProperties(vm, runVmParam.getCustomProperties(), messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(validateDisplayType(), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, getVmDisks(), runVmParam.getRunAsStateless()), messages) && validate(validateStorageDomains(vm, isInternalExecution, getVmImageDisks()), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && validate(validateMemorySize(vm), messages) && SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVds, messages);
}
#method_after
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVds, VDSGroup vdsGroup) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    }
    return validateVmProperties(vm, runVmParam.getCustomProperties(), messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(validateDisplayType(), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, runVmParam.getRunAsStateless()), messages) && validate(validateStorageDomains(vm, isInternalExecution, getVmImageDisks()), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && validate(validateMemorySize(vm), messages) && SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVds, messages);
}
#end_block

#method_before
protected ValidationResult validateDisplayType() {
    if (!VmValidationUtils.isGraphicsAndDisplaySupported(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), getVmActiveGraphics(), vm.getDefaultDisplayType())) {
        // todo handle runonce
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS);
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateDisplayType() {
    if (!VmValidationUtils.isGraphicsAndDisplaySupported(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), getVmActiveGraphics(), vm.getDefaultDisplayType())) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private Set<GraphicsType> getVmActiveGraphics() {
    Set<GraphicsType> graphicsTypes = new HashSet<>();
    for (Entry<GraphicsType, GraphicsInfo> graphics : vm.getGraphicsInfos().entrySet()) {
        if (graphics.getValue().isSet()) {
            graphicsTypes.add(graphics.getKey());
        }
    }
    return graphicsTypes;
}
#method_after
private Set<GraphicsType> getVmActiveGraphics() {
    if (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty()) {
        // graphics overriden in runonce
        return vm.getGraphicsInfos().keySet();
    } else {
        List<VmDevice> graphicDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceGeneralType.GRAPHICS);
        Set<GraphicsType> graphicsTypes = new HashSet<>();
        for (VmDevice graphicDevice : graphicDevices) {
            GraphicsType type = GraphicsType.fromString(graphicDevice.getDevice());
            graphicsTypes.add(type);
        }
        return graphicsTypes;
    }
}
#end_block

#method_before
protected boolean validateVmProperties(VM vm, String runOnceCustomProperties, List<String> messages) {
    String customProperties = runOnceCustomProperties != null ? runOnceCustomProperties : vm.getCustomProperties();
    List<ValidationError> validationErrors = getVmPropertiesUtils().validateVmProperties(vm.getVdsGroupCompatibilityVersion(), customProperties);
    if (!validationErrors.isEmpty()) {
        getVmPropertiesUtils().handleCustomPropertiesError(validationErrors, messages);
        return false;
    }
    return true;
}
#method_after
protected boolean validateVmProperties(VM vm, String runOnceCustomProperties, List<String> messages) {
    String customProperties = runOnceCustomProperties != null ? runOnceCustomProperties : vm.getCustomProperties();
    return getVmPropertiesUtils().validateVmProperties(vm.getVdsGroupCompatibilityVersion(), customProperties, messages);
}
#end_block

#method_before
protected ValidationResult validateStatelessVm(VM vm, List<Disk> plugDisks, Boolean stateless) {
    // if the VM is not stateless, there is nothing to check
    if (stateless != null ? !stateless : !vm.isStateless()) {
        return ValidationResult.VALID;
    }
    ValidationResult previewValidation = getSnapshotValidator().vmNotInPreview(vm.getId());
    if (!previewValidation.isValid()) {
        return previewValidation;
    }
    // if the VM itself is stateless or run once as stateless
    if (vm.isAutoStartup()) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA);
    }
    ValidationResult hasSpaceValidation = hasSpaceForSnapshots(vm, plugDisks);
    if (!hasSpaceValidation.isValid()) {
        return hasSpaceValidation;
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateStatelessVm(VM vm, Boolean stateless) {
    // if the VM is not stateless, there is nothing to check
    if (stateless != null ? !stateless : !vm.isStateless()) {
        return ValidationResult.VALID;
    }
    ValidationResult previewValidation = getSnapshotValidator().vmNotInPreview(vm.getId());
    if (!previewValidation.isValid()) {
        return previewValidation;
    }
    // if the VM itself is stateless or run once as stateless
    if (vm.isAutoStartup()) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA);
    }
    ValidationResult hasSpaceValidation = hasSpaceForSnapshots();
    if (!hasSpaceValidation.isValid()) {
        return hasSpaceValidation;
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected ValidationResult hasSpaceForSnapshots(VM vm, List<Disk> plugDisks) {
    Integer minSnapshotSize = Config.<Integer>getValue(ConfigValues.InitStorageSparseSizeInGB);
    Map<StorageDomain, Integer> mapStorageDomainsToNumOfDisks = mapStorageDomainsToNumOfDisks(vm, plugDisks);
    for (Entry<StorageDomain, Integer> e : mapStorageDomainsToNumOfDisks.entrySet()) {
        ValidationResult validationResult = new StorageDomainValidator(e.getKey()).isDomainHasSpaceForRequest(minSnapshotSize * e.getValue());
        if (!validationResult.isValid()) {
            return validationResult;
        }
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult hasSpaceForSnapshots() {
    Set<Guid> sdIds = ImagesHandler.getAllStorageIdsForImageIds(getVmImageDisks());
    MultipleStorageDomainsValidator msdValidator = getStorageDomainsValidator(sdIds);
    ValidationResult retVal = msdValidator.allDomainsWithinThresholds();
    if (retVal == ValidationResult.VALID) {
        return msdValidator.allDomainsHaveSpaceForNewDisks(getVmImageDisks());
    }
    return retVal;
}
#end_block

#method_before
protected ValidationResult validateInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<String>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion())) {
        result.remove(null);
    }
    // aren't attached to the cluster
    return result.isEmpty() ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
}
#method_after
protected ValidationResult validateInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion())) {
        result.remove(null);
    }
    // aren't attached to the cluster
    return result.isEmpty() ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
}
#end_block

#method_before
// /////////////////////
// / Utility methods ///
// /////////////////////
protected boolean validate(ValidationResult validationResult, List<String> message) {
    if (!validationResult.isValid()) {
        message.add(validationResult.getMessage().name());
        if (validationResult.getVariableReplacements() != null) {
            for (String variableReplacement : validationResult.getVariableReplacements()) {
                message.add(variableReplacement);
            }
        }
    }
    return validationResult.isValid();
}
#method_after
// /////////////////////
// / Utility methods ///
// /////////////////////
protected boolean validate(ValidationResult validationResult, List<String> message) {
    if (!validationResult.isValid()) {
        message.add(validationResult.getMessage().name());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            message.add(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/devices/watchdog/models").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/devices/maxPciDevices").put("value", MAX_PCI_DEVICES);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/devices/display/protocols").put("value", "VNC/cirrus,SPICE/qxl");
    preferences.node("/os/rhel7/devices/balloon/enabled").put("value", "true");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    preferences.node("/os/windows_7/devices/hyperv/enabled").put("value", "true");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/devices/watchdog/models").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/devices/maxPciDevices").put("value", MAX_PCI_DEVICES);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/devices/display/protocols").put("value", "VNC/cirrus,SPICE/qxl");
    preferences.node("/os/rhel7/devices/balloon/enabled").put("value", "true");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    preferences.node("/os/windows_7/id").put("value", "11");
    preferences.node("/os/windows_7/sysprepFileName").put("value", UNATTEND_XML);
    preferences.node("/os/windows_7/devices/hyperv/enabled").put("value", "true");
    preferences.node("/os/windows_8/cpu/unsupported").put("value", "conroe, opteron_g1");
    preferences.node("/os/windows_8/sysprepFileName").put("value", UNATTEND_XML);
    preferences.node("/os/windows_xp/id").put("value", "1");
    preferences.node("/os/windows_xp/sysprepFileName").put("value", SYSPREP_INF);
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#end_block

#method_before
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDAOGetForStoragePool();
    mockVdsGroupDAOReturnVdsGroup();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    assertFalse("If the disk is too big, canDoAction should fail", cmd.canDoAction());
    assertTrue("canDoAction failed for the wrong reason", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDAOGetForStoragePool();
    mockVdsGroupDAOReturnVdsGroup();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockOsRepository();
    mockOsRepositoryGraphics(0, Version.v3_3, new Pair<GraphicsType, DisplayType>(GraphicsType.SPICE, DisplayType.qxl));
    mockGraphicsDevices(vm.getId());
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    assertFalse("If the disk is too big, canDoAction should fail", cmd.canDoAction());
    assertTrue("canDoAction failed for the wrong reason", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
protected void mockOsRepository() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    VmHandler.init();
    when(osRepository.isWindows(0)).thenReturn(true);
}
#method_after
protected void mockOsRepository() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    VmHandler.init();
    when(osRepository.isWindows(0)).thenReturn(true);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
}
#end_block

#method_before
@Test
public void canAddVm() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 5;
    AddVmCommand<VmManagementParametersBase> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(Collections.emptyList()).when(cmd).validateCustomProperties(any(VmStatic.class));
    doReturn(true).when(cmd).validateSpaceRequirements();
    assertTrue("vm could not be added", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
}
#method_after
@Test
public void canAddVm() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 5;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(true).when(cmd).validateCustomProperties(any(VmStatic.class), any(ArrayList.class));
    doReturn(true).when(cmd).validateSpaceRequirements();
    assertTrue("vm could not be added", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
}
#end_block

#method_before
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    VDSGroup vdsGroup = createVdsGroup();
    mockStorageDomainDAOGetForStoragePool();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    mockDisplayTypes(vm.getOs(), vdsGroup.getcompatibility_version());
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    mockGetAllSnapshots(cmd);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    VDSGroup vdsGroup = createVdsGroup();
    mockStorageDomainDAOGetForStoragePool();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    mockDisplayTypes(vm.getOs(), vdsGroup.getcompatibility_version());
    mockGraphicsDevices(vm.getId());
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    mockGetAllSnapshots(cmd);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
@Test
public void isVirtioScsiEnabledDefaultedToTrue() {
    AddVmCommand<VmManagementParametersBase> cmd = setupCanAddVmTests(0, 0);
    doReturn(createVdsGroup()).when(cmd).getVdsGroup();
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO_SCSI")));
    assertTrue("isVirtioScsiEnabled hasn't been defaulted to true on cluster >= 3.3.", cmd.isVirtioScsiEnabled());
}
#method_after
@Test
public void isVirtioScsiEnabledDefaultedToTrue() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(0, 0);
    doReturn(createVdsGroup()).when(cmd).getVdsGroup();
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO_SCSI")));
    assertTrue("isVirtioScsiEnabled hasn't been defaulted to true on cluster >= 3.3.", cmd.isVirtioScsiEnabled());
}
#end_block

#method_before
@Test
public void validateSpaceAndThreshold() {
    AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#method_after
@Test
public void validateSpaceAndThreshold() {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#end_block

#method_before
@Test
public void validateSpaceNotEnough() throws Exception {
    AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
    verify(storageDomainValidator).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#method_after
@Test
public void validateSpaceNotEnough() throws Exception {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
    verify(storageDomainValidator).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#end_block

#method_before
@Test
public void validateSpaceNotWithinThreshold() throws Exception {
    AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0);
    doReturn((new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN))).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
}
#method_after
@Test
public void validateSpaceNotWithinThreshold() throws Exception {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0, 0);
    doReturn((new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN))).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
}
#end_block

#method_before
private void mockDisplayTypes(int osId, Version clusterVersion) {
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
}
#method_after
private void mockDisplayTypes(int osId, Version clusterVersion) {
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
}
#end_block

#method_before
protected AddVmFromTemplateCommand<AddVmFromTemplateParameters> createVmFromTemplateCommand(VM vm) {
    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> concrete = new AddVmFromTemplateCommand<AddVmFromTemplateParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(Collections.emptyList()).when(result).validateCustomProperties(any(VmStatic.class));
    mockDAOs(result);
    mockBackend(result);
    initCommandMethods(result);
    return result;
}
#method_after
protected AddVmFromTemplateCommand<AddVmParameters> createVmFromTemplateCommand(VM vm) {
    AddVmParameters param = new AddVmParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmParameters> concrete = new AddVmFromTemplateCommand<AddVmParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    AddVmFromTemplateCommand<AddVmParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(true).when(result).validateCustomProperties(any(VmStatic.class), any(ArrayList.class));
    mockDAOs(result);
    mockBackend(result);
    initCommandMethods(result);
    return result;
}
#end_block

#method_before
private AddVmCommand<VmManagementParametersBase> setupCanAddVmTests(final int domainSizeGB, final int sizeRequired) {
    VM vm = initializeMock(domainSizeGB, sizeRequired);
    AddVmCommand<VmManagementParametersBase> cmd = createCommand(vm);
    initCommandMethods(cmd);
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    return cmd;
}
#method_after
private AddVmCommand<AddVmParameters> setupCanAddVmTests(final int domainSizeGB, final int sizeRequired) {
    VM vm = initializeMock(domainSizeGB, sizeRequired);
    AddVmCommand<AddVmParameters> cmd = createCommand(vm);
    initCommandMethods(cmd);
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    return cmd;
}
#end_block

#method_before
private static <T extends VmManagementParametersBase> void initCommandMethods(AddVmCommand<T> cmd) {
    doReturn(Guid.newGuid()).when(cmd).getStoragePoolId();
    doReturn(true).when(cmd).canAddVm(anyListOf(String.class), anyString(), any(Guid.class), anyInt());
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
}
#method_after
private static <T extends AddVmParameters> void initCommandMethods(AddVmCommand<T> cmd) {
    doReturn(Guid.newGuid()).when(cmd).getStoragePoolId();
    doReturn(true).when(cmd).canAddVm(anyListOf(String.class), anyString(), any(Guid.class), anyInt());
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
}
#end_block

#method_before
private void mockDAOs(AddVmCommand<?> cmd) {
    doReturn(vmDAO).when(cmd).getVmDAO();
    doReturn(sdDAO).when(cmd).getStorageDomainDAO();
    doReturn(vmTemplateDAO).when(cmd).getVmTemplateDAO();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDAO();
}
#method_after
private void mockDAOs(AddVmCommand<?> cmd) {
    doReturn(vmDAO).when(cmd).getVmDAO();
    doReturn(sdDAO).when(cmd).getStorageDomainDAO();
    doReturn(vmTemplateDAO).when(cmd).getVmTemplateDAO();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDAO();
    doReturn(deviceDao).when(cmd).getVmDeviceDao();
}
#end_block

#method_before
private AddVmCommand<VmManagementParametersBase> createCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase(vm);
    AddVmCommand<VmManagementParametersBase> cmd = new AddVmCommand<VmManagementParametersBase>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    mockDAOs(cmd);
    mockBackend(cmd);
    doReturn(new VDSGroup()).when(cmd).getVdsGroup();
    generateStorageToDisksMap(cmd);
    initDestSDs(cmd);
    storageDomainValidator = mock(StorageDomainValidator.class);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainHasSpaceForRequest(any(int.class));
    doReturn(storageDomainValidator).when(cmd).createStorageDomainValidator(any(StorageDomain.class));
    return cmd;
}
#method_after
private AddVmCommand<AddVmParameters> createCommand(VM vm) {
    AddVmParameters param = new AddVmParameters(vm);
    AddVmCommand<AddVmParameters> cmd = new AddVmCommand<AddVmParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    mockDAOs(cmd);
    mockBackend(cmd);
    doReturn(new VDSGroup()).when(cmd).getVdsGroup();
    generateStorageToDisksMap(cmd);
    initDestSDs(cmd);
    storageDomainValidator = mock(StorageDomainValidator.class);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(storageDomainValidator).when(cmd).createStorageDomainValidator(any(StorageDomain.class));
    return cmd;
}
#end_block

#method_before
protected void generateStorageToDisksMap(AddVmCommand<? extends VmManagementParametersBase> command) {
    command.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_1, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_1));
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_2, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_2));
}
#method_after
protected void generateStorageToDisksMap(AddVmCommand<? extends AddVmParameters> command) {
    command.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_1, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_1));
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_2, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_2));
}
#end_block

#method_before
protected void initDestSDs(AddVmCommand<? extends VmManagementParametersBase> command) {
    StorageDomain sd1 = new StorageDomain();
    StorageDomain sd2 = new StorageDomain();
    sd1.setId(STORAGE_DOMAIN_ID_1);
    sd2.setId(STORAGE_DOMAIN_ID_2);
    command.destStorages.put(STORAGE_DOMAIN_ID_1, sd1);
    command.destStorages.put(STORAGE_DOMAIN_ID_2, sd2);
}
#method_after
protected void initDestSDs(AddVmCommand<? extends AddVmParameters> command) {
    StorageDomain sd1 = new StorageDomain();
    StorageDomain sd2 = new StorageDomain();
    sd1.setId(STORAGE_DOMAIN_ID_1);
    sd2.setId(STORAGE_DOMAIN_ID_2);
    command.destStorages.put(STORAGE_DOMAIN_ID_1, sd1);
    command.destStorages.put(STORAGE_DOMAIN_ID_2, sd2);
}
#end_block

#method_before
private void mockGetAllSnapshots(AddVmFromTemplateCommand<AddVmFromTemplateParameters> command) {
    doAnswer(new Answer<List<DiskImage>>() {

        @Override
        public List<DiskImage> answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            DiskImage arg = (DiskImage) args[0];
            List<DiskImage> list = createDiskSnapshot(arg.getId(), 3);
            return list;
        }
    }).when(command).getAllImageSnapshots(any(DiskImage.class));
}
#method_after
private void mockGetAllSnapshots(AddVmFromTemplateCommand<AddVmParameters> command) {
    doAnswer(new Answer<List<DiskImage>>() {

        @Override
        public List<DiskImage> answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            DiskImage arg = (DiskImage) args[0];
            List<DiskImage> list = createDiskSnapshot(arg.getId(), 3);
            return list;
        }
    }).when(command).getAllImageSnapshots(any(DiskImage.class));
}
#end_block

#method_before
private <T extends VmManagementParametersBase> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString());
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(createVdsGroup()).when(spy).getVdsGroup();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    doReturn(false).when(spy).isVirtioScsiControllerAttached(any(Guid.class));
    spy.setVmTemplateId(Guid.newGuid());
}
#method_after
private <T extends AddVmParameters> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString());
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(createVdsGroup()).when(spy).getVdsGroup();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    doReturn(false).when(spy).isVirtioScsiControllerAttached(any(Guid.class));
    spy.setVmTemplateId(Guid.newGuid());
}
#end_block

#method_before
@Test
public void testPatternBasedNameFails() {
    AddVmCommand<VmManagementParametersBase> cmd = createCommand(initializeMock(1, 1));
    cmd.getParameters().getVm().setName("aa-??bb");
    assertFalse("Pattern-based name should not be supported for VM", cmd.validateInputs());
}
#method_after
@Test
public void testPatternBasedNameFails() {
    AddVmCommand<AddVmParameters> cmd = createCommand(initializeMock(1, 1));
    cmd.getParameters().getVm().setName("aa-??bb");
    assertFalse("Pattern-based name should not be supported for VM", cmd.validateInputs());
}
#end_block

#method_before
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, Field> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVm, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#method_after
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, Field> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVm, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
        if (pair.getFirst().isHotsetAllowed()) {
            mUpdateVmsStatic.AddHotsetFields(pair.getSecond().getName());
        }
    }
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#end_block

#method_before
public static boolean isUpdateValid(VmStatic source, VmStatic destination) {
    return mUpdateVmsStatic.IsUpdateValid(source, destination);
}
#method_after
public static boolean isUpdateValid(VmStatic source, VmStatic destination, VMStatus status, boolean hotsetEnabled) {
    return mUpdateVmsStatic.IsUpdateValid(source, destination, status, hotsetEnabled);
}
#end_block

#method_before
public static boolean copyNonEditableFieldsToDestination(VmStatic source, VmStatic destination) {
    return mUpdateVmsStatic.copyNonEditableFieldsToDestination(source, destination);
}
#method_after
public static boolean copyNonEditableFieldsToDestination(VmStatic source, VmStatic destination, boolean hotSetEnabled) {
    return mUpdateVmsStatic.copyNonEditableFieldsToDestination(source, destination, hotSetEnabled);
}
#end_block

#method_before
public static boolean verifyAddVm(List<String> reasons, int nicsCount, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getAvailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else if (!VmTemplateCommand.isVmPriorityValueLegal(vmPriority, reasons)) {
        returnValue = false;
    }
    return returnValue;
}
#method_after
public static boolean verifyAddVm(List<String> reasons, int nicsCount, int vmPriority, MacPoolManagerStrategy macPool) {
    boolean returnValue = true;
    if (macPool.getAvailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else if (!VmTemplateCommand.isVmPriorityValueLegal(vmPriority, reasons)) {
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
private static Version getApplicationVersion(final String part, final String appName) {
    try {
        return new RpmVersion(part, getAppName(part, appName), true);
    } catch (Exception e) {
        log.debugFormat("Failed to create rpm version object, part: {0} appName: {1}, error: {2}", part, appName, e.toString());
        return null;
    }
}
#method_after
private static Version getApplicationVersion(final String part, final String appName) {
    try {
        return new RpmVersion(part, getAppName(part, appName), true);
    } catch (Exception e) {
        log.debug("Failed to create rpm version object, part '{}' appName '{}': {}", part, appName, e.getMessage());
        log.debug("Exception", e);
        return null;
    }
}
#end_block

#method_before
public static StorageDomain findStorageDomainForMemory(Guid storagePoolId, long sizeRequested, Map<StorageDomain, Integer> domain2reservedSpaceInDomain) {
    List<StorageDomain> domainsInPool = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(storagePoolId);
    for (StorageDomain currDomain : domainsInPool) {
        long reservedSizeForDisks = domain2reservedSpaceInDomain.containsKey(currDomain) ? domain2reservedSpaceInDomain.get(currDomain) : 0;
        long sizeNeeded = sizeRequested + reservedSizeForDisks;
        if (currDomain.getStorageDomainType().isDataDomain() && currDomain.getStatus() == StorageDomainStatus.Active && doesStorageDomainHaveSpaceForRequest(currDomain, sizeNeeded)) {
            return currDomain;
        }
    }
    return null;
}
#method_after
public static StorageDomain findStorageDomainForMemory(Guid storagePoolId, List<DiskImage> disksList) {
    List<StorageDomain> domainsInPool = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(storagePoolId);
    return findStorageDomainForMemory(domainsInPool, disksList);
}
#end_block

#method_before
public static void updateCurrentCd(Guid vdsId, VM vm, String currentCd) {
    VmDynamic vmDynamic = vm.getDynamicData();
    vmDynamic.setCurrentCd(currentCd);
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(vdsId, vmDynamic));
}
#method_after
public static void updateCurrentCd(Guid vdsId, VM vm, String currentCd) {
    VmDynamic vmDynamic = vm.getDynamicData();
    vmDynamic.setCurrentCd(currentCd);
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(vmDynamic));
}
#end_block

#method_before
public static List<Pair<EditableDeviceOnVmStatusField, Boolean>> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<Pair<EditableDeviceOnVmStatusField, Boolean>> fieldList = new ArrayList<>();
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        Boolean isEnabled = null;
        try {
            isEnabled = (Boolean) field.get(objectWithEditableDeviceFields);
        } catch (IllegalAccessException | ClassCastException e) {
            e.printStackTrace();
            log.warn("VmHandler:: isUpdateValidForVmDevices: Reflection error");
        }
        if (isEnabled == null || !VmDeviceUtils.vmDeviceChanged(vmId, annotation.generalType(), annotation.type().getName(), isEnabled)) {
            continue;
        }
        if (!VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            fieldList.add(new Pair<>(annotation, isEnabled));
        }
    }
    return fieldList;
}
#method_after
public static List<Pair<EditableDeviceOnVmStatusField, Boolean>> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<Pair<EditableDeviceOnVmStatusField, Boolean>> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        Boolean isEnabled = null;
        try {
            isEnabled = (Boolean) field.get(objectWithEditableDeviceFields);
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("VmHandler:: isUpdateValidForVmDevices: Reflection error");
            log.debug("Original exception was:", e);
        }
        // if device type is set to unknown, search by general type only
        // because some devices has more than one type, like sound can be ac97/ich6
        String device = null;
        if (annotation.type() != VmDeviceType.UNKNOWN) {
            device = annotation.type().getName();
        }
        if (isEnabled == null || !VmDeviceUtils.vmDeviceChanged(vmId, annotation.generalType(), device, isEnabled)) {
            continue;
        }
        if (!VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            fieldList.add(new Pair<>(annotation, isEnabled));
        }
    }
    return fieldList;
}
#end_block

#method_before
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getcompatibility_version());
}
#end_block

#method_before
private void mockGraphicsDevice() {
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    VmDevice graphicsDevice = new GraphicsDevice(VmDeviceType.SPICE);
    graphicsDevice.setVmId(vm.getId());
    when(vmDeviceDAO.getVmDeviceByVmIdAndType(vm.getId(), VmDeviceGeneralType.GRAPHICS)).thenReturn(Arrays.asList(graphicsDevice));
}
#method_after
private void mockGraphicsDevice() {
    VmDevice graphicsDevice = new GraphicsDevice(VmDeviceType.SPICE);
    graphicsDevice.setDeviceId(Guid.Empty);
    graphicsDevice.setVmId(vm.getId());
    when(vmDeviceDAO.getVmDeviceByVmIdAndType(vm.getId(), VmDeviceGeneralType.GRAPHICS)).thenReturn(Arrays.asList(graphicsDevice));
    doReturn(vmDeviceDAO).when(dbFacade).getVmDeviceDao();
    DbFacadeLocator.setDbFacade(dbFacade);
}
#end_block

#method_before
@Test
public void testCannotDisableVirtioScsi() {
    prepareVmToPassCanDoAction();
    command.getParameters().setVirtioScsiEnabled(false);
    Disk disk = new DiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO_SCSI);
    disk.setPlugged(true);
    mockDiskDaoGetAllForVm(Collections.singletonList(disk), true);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
}
#method_after
@Test
public void testCannotDisableVirtioScsi() {
    prepareVmToPassCanDoAction();
    command.getParameters().setVirtioScsiEnabled(false);
    Disk disk = new DiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO_SCSI);
    disk.setPlugged(true);
    mockDiskDaoGetAllForVm(Collections.singletonList(disk), true);
    VmValidator vmValidator = spy(new VmValidator(vm));
    doReturn(vmValidator).when(command).createVmValidator(vm);
    doReturn(diskDAO).when(vmValidator).getDiskDao();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
}
#end_block

#method_before
private void prepareVmToPassCanDoAction() {
    vmStatic.setName("vm1");
    vmStatic.setMemSizeMb(256);
    vmStatic.setSingleQxlPci(false);
    mockVmDaoGetVm();
    mockSameNameQuery(false);
    mockValidateCustomProperties();
    mockValidatePciAndIdeLimit();
    mockGraphicsDevice();
}
#method_after
private void prepareVmToPassCanDoAction() {
    vmStatic.setName("vm1");
    vmStatic.setMemSizeMb(256);
    vmStatic.setSingleQxlPci(false);
    mockVmDaoGetVm();
    mockSameNameQuery(false);
    mockValidateCustomProperties();
    mockValidatePciAndIdeLimit();
    doReturn(true).when(command).setAndValidateCpuProfile();
    mockGraphicsDevice();
}
#end_block

#method_before
private void mockValidateCustomProperties() {
    doReturn(Collections.<ValidationError>emptyList()).when(command).validateCustomProperties(any(VmStatic.class));
}
#method_after
private void mockValidateCustomProperties() {
    doReturn(true).when(command).validateCustomProperties(any(VmStatic.class), any(ArrayList.class));
}
#end_block

#method_before
@Override
public InstanceType get() {
    InstanceType instanceType = performGet(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(guid));
    parent.adjustDisplayData(instanceType);
    return instanceType;
}
#method_after
@Override
public InstanceType get() {
    InstanceType instanceType = performGet(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(guid));
    DisplayHelper.adjustDisplayData(this, instanceType);
    return instanceType;
}
#end_block

#method_before
@Override
protected InstanceType doPopulate(InstanceType model, org.ovirt.engine.core.common.businessentities.InstanceType entity) {
    if (!model.isSetConsole()) {
        model.setConsole(new Console());
    }
    model.getConsole().setEnabled(!getConsoleDevicesForEntity(entity.getId()).isEmpty());
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtIOSCSI());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getInstance().getVirtioScsiControllersForEntity(entity.getId()).isEmpty());
    setRngDevice(model);
    return model;
}
#method_after
@Override
protected InstanceType doPopulate(InstanceType model, org.ovirt.engine.core.common.businessentities.InstanceType entity) {
    if (!model.isSetConsole()) {
        model.setConsole(new Console());
    }
    model.getConsole().setEnabled(!getConsoleDevicesForEntity(entity.getId()).isEmpty());
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtIOSCSI());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getVirtioScsiControllersForEntity(this, entity.getId()).isEmpty());
    model.setSoundcardEnabled(!VmHelper.getSoundDevicesForEntity(this, entity.getId()).isEmpty());
    setRngDevice(model);
    return model;
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(InstanceType incoming, org.ovirt.engine.core.common.businessentities.InstanceType entity) {
    org.ovirt.engine.core.common.businessentities.InstanceType updated = getMapper(modelType, org.ovirt.engine.core.common.businessentities.InstanceType.class).map(incoming, entity);
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), Version.getLast()));
    UpdateVmTemplateParameters updateParams = new UpdateVmTemplateParameters((VmTemplate) updated);
    if (incoming.isSetRngDevice()) {
        updateParams.setUpdateRngDevice(true);
        updateParams.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    BackendTemplatesResource.setGraphicsToParams(incoming, updateParams);
    return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, updateParams);
}
#method_after
@Override
public VdcActionParametersBase getParameters(InstanceType incoming, org.ovirt.engine.core.common.businessentities.InstanceType entity) {
    org.ovirt.engine.core.common.businessentities.InstanceType updated = getMapper(modelType, org.ovirt.engine.core.common.businessentities.InstanceType.class).map(incoming, entity);
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), Version.getLast()));
    UpdateVmTemplateParameters updateParams = new UpdateVmTemplateParameters((VmTemplate) updated);
    if (incoming.isSetRngDevice()) {
        updateParams.setUpdateRngDevice(true);
        updateParams.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    if (incoming.isSetSoundcardEnabled()) {
        updateParams.setSoundDeviceEnabled(incoming.isSoundcardEnabled());
    }
    DisplayHelper.setGraphicsToParams(incoming.getDisplay(), updateParams);
    return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, updateParams);
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetBios()) {
        if (model.getBios().isSetBootMenu()) {
            entity.setBootMenuEnabled(model.getBios().getBootMenu().isEnabled());
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
        if (model.getDisplay().isSetFileTransferEnabled()) {
            entity.setSpiceFileTransferEnabled(model.getDisplay().isFileTransferEnabled());
        }
        if (model.getDisplay().isSetCopyPasteEnabled()) {
            entity.setSpiceCopyPasteEnabled(model.getDisplay().isCopyPasteEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (entity.getVmInit() == null) {
            entity.setVmInit(new VmInit());
        }
        entity.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        entity.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.getVersion() != null) {
        if (model.getVersion().getBaseTemplate() != null && StringUtils.isNotEmpty(model.getVersion().getBaseTemplate().getId())) {
            entity.setBaseTemplateId(Guid.createGuidFromString(model.getVersion().getBaseTemplate().getId()));
        }
        if (model.getVersion().isSetVersionName()) {
            entity.setTemplateVersionName(model.getVersion().getVersionName());
        }
    // numbering is generated in the backend, hence even if user specified version number, we ignore it.
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetStartPaused()) {
        entity.setRunAndPause(model.isStartPaused());
    }
    return entity;
}
#method_after
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    mapVmBaseModelToEntity(entity, model);
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (entity.getVmInit() == null) {
            entity.setVmInit(new VmInit());
        }
        entity.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.getVersion() != null) {
        if (model.getVersion().getBaseTemplate() != null && StringUtils.isNotEmpty(model.getVersion().getBaseTemplate().getId())) {
            entity.setBaseTemplateId(Guid.createGuidFromString(model.getVersion().getBaseTemplate().getId()));
        }
        if (model.getVersion().isSetVersionName()) {
            entity.setTemplateVersionName(model.getVersion().getVersionName());
        }
    // numbering is generated in the backend, hence even if user specified version number, we ignore it.
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setName(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        staticVm.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpuShares()) {
        staticVm.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            staticVm.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
        if (model.getDisplay().isSetFileTransferEnabled()) {
            staticVm.setSpiceFileTransferEnabled(model.getDisplay().isFileTransferEnabled());
        }
        if (model.getDisplay().isSetCopyPasteEnabled()) {
            staticVm.setSpiceCopyPasteEnabled(model.getDisplay().isCopyPasteEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        staticVm.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.setTimeZone(model.getTimezone());
    }
    if (model.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), staticVm);
    }
    if (model.isSetStartPaused()) {
        staticVm.setRunAndPause(model.isStartPaused());
    }
    return staticVm;
}
#method_after
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    mapVmBaseModelToEntity(staticVm, model);
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        staticVm.getVmInit().setDomain(model.getDomain().getName());
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    if (entity.getVmType() != null) {
        model.setType(VmMapper.map(entity.getVmType(), null));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(VmMapper.map(entity.getOrigin(), null));
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
    }
    if (entity.getDefaultBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getOsId()));
        if (entity.getDefaultBootSequence() != null) {
            for (Boot boot : VmMapper.map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    model.setBios(new Bios());
    model.getBios().setBootMenu(new BootMenu());
    model.getBios().getBootMenu().setEnabled(entity.isBootMenuEnabled());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    model.setDisplay(new Display());
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.isAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    if (entity.getClusterArch() != null) {
        model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    }
    if (entity.getCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getVmInit() != null && StringUtils.isNotBlank(entity.getVmInit().getDomain())) {
        Domain domain = new Domain();
        domain.setName(entity.getVmInit().getDomain());
        model.setDomain(domain);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    model.setTimezone(entity.getTimeZone());
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    // so need to populate template version properties
    if (!entity.isBaseTemplate()) {
        TemplateVersion version = new TemplateVersion();
        version.setVersionName(entity.getTemplateVersionName());
        version.setVersionNumber(entity.getTemplateVersionNumber());
        Template baseTemplate = new Template();
        baseTemplate.setId(entity.getBaseTemplateId().toString());
        version.setBaseTemplate(baseTemplate);
        model.setVersion(version);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    model.setStartPaused(entity.isRunAndPause());
    return model;
}
#method_after
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    mapVmBaseEntityToModel(model, entity);
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
    }
    if (entity.getDefaultBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getOsId()));
        if (entity.getDefaultBootSequence() != null) {
            for (Boot boot : VmMapper.map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getClusterArch() != null) {
        model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    }
    model.setDisplay(DisplayMapper.map(entity, null));
    // so need to populate template version properties
    if (!entity.isBaseTemplate()) {
        TemplateVersion version = new TemplateVersion();
        version.setVersionName(entity.getTemplateVersionName());
        version.setVersionNumber(entity.getTemplateVersionNumber());
        Template baseTemplate = new Template();
        baseTemplate.setId(entity.getBaseTemplateId().toString());
        version.setBaseTemplate(baseTemplate);
        model.setVersion(version);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    staticVm.setSpiceFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    staticVm.setSpiceCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    staticVm.setRunAndPause(entity.isRunAndPause());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setVmType(entity.getVmType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    staticVm.setSpiceFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    staticVm.setSpiceCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    staticVm.setRunAndPause(entity.isRunAndPause());
    staticVm.setCpuProfileId(entity.getCpuProfileId());
    staticVm.setAutoConverge(entity.getAutoConverge());
    staticVm.setMigrateCompressed(entity.getMigrateCompressed());
    staticVm.setCustomProperties(entity.getCustomProperties());
    staticVm.setCustomEmulatedMachine(entity.getCustomEmulatedMachine());
    staticVm.setCustomCpuName(entity.getCustomCpuName());
    return doMapVmBaseHwPartToVmStatic(entity, staticVm);
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.NumaTuneMode.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.NumaTuneMode mode, String incoming) {
    if (mode == null) {
        return null;
    }
    switch(mode) {
        case STRICT:
            return NumaTuneMode.STRICT.value();
        case INTERLEAVE:
            return NumaTuneMode.INTERLEAVE.value();
        case PREFERRED:
            return NumaTuneMode.PREFERRED.value();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.InstanceType.class, to = VmStatic.class)
public static VmStatic map(org.ovirt.engine.core.common.businessentities.InstanceType entity, VmStatic vmStatic) {
    return doMapVmBaseHwPartToVmStatic((VmBase) entity, vmStatic != null ? vmStatic : new VmStatic());
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetBios()) {
        if (vm.getBios().isSetBootMenu()) {
            staticVm.setBootMenuEnabled(vm.getBios().getBootMenu().isEnabled());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
        if (vm.getDisplay().isSetFileTransferEnabled()) {
            staticVm.setSpiceFileTransferEnabled(vm.getDisplay().isSetFileTransferEnabled());
        }
        if (vm.getDisplay().isSetCopyPasteEnabled()) {
            staticVm.setSpiceCopyPasteEnabled(vm.getDisplay().isSetCopyPasteEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(vm.getSerialNumber(), staticVm);
    }
    if (vm.isSetNumaTuneMode()) {
        NumaTuneMode mode = NumaTuneMode.fromValue(vm.getNumaTuneMode());
        if (mode != null) {
            staticVm.setNumaTuneMode(map(mode, null));
        }
    }
    if (vm.isSetStartPaused()) {
        staticVm.setRunAndPause(vm.isStartPaused());
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    mapVmBaseModelToEntity(staticVm, vm);
    if (!vm.isSetMemory() && staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetNumaTuneMode()) {
        NumaTuneMode mode = NumaTuneMode.fromValue(vm.getNumaTuneMode());
        if (mode != null) {
            staticVm.setNumaTuneMode(map(mode, null));
        }
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    model.setBios(new Bios());
    model.getBios().setBootMenu(new BootMenu());
    model.getBios().getBootMenu().setEnabled(entity.isBootMenuEnabled());
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    model.setDisplay(new Display());
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos());
        if (graphicsType != null) {
            model.getDisplay().setType(DisplayType.fromGraphicsType(graphicsType).value());
            GraphicsInfo graphicsInfo = entity.getGraphicsInfos().get(graphicsType);
            model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
            Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
            model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
            Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        }
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (StringUtils.isNotBlank(entity.getVmInit().getDomain())) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity.getStaticData(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    model.setStartPaused(entity.isRunAndPause());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    return map(entity, template, true);
}
#end_block

#method_before
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String vncKeyboardLayout = vm.getDisplay().getKeyboardLayout();
            params.setVncKeyboardLayout(vncKeyboardLayout);
        }
        setGraphicsFromLegacyDisplay(vm, params);
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetBios()) {
        if (vm.getBios().isSetBootMenu()) {
            params.setBootMenuEnabled(vm.getBios().getBootMenu().isEnabled());
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    return params;
}
#method_after
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String vncKeyboardLayout = vm.getDisplay().getKeyboardLayout();
            params.setVncKeyboardLayout(vncKeyboardLayout);
        }
        DisplayMapper.fillDisplayInParams(vm, params);
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetBios()) {
        if (vm.getBios().isSetBootMenu()) {
            params.setBootMenuEnabled(vm.getBios().getBootMenu().isEnabled());
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetCustomCpuModel()) {
        params.setCustomCpuName(vm.getCustomCpuModel());
    }
    if (vm.isSetCustomEmulatedMachine()) {
        params.setCustomEmulatedMachine(vm.getCustomEmulatedMachine());
    }
    return params;
}
#end_block

#method_before
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    if (entity.getType() != null || entity.getFiles().isEmpty()) {
        Payload model = template != null ? template : new Payload();
        if (entity.getType() != null) {
            org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getType(), null);
            if (deviceType != null) {
                model.setType(deviceType.value());
            }
        }
        model.setVolumeId(entity.getVolumeId());
        if (entity.getFiles().size() > 0) {
            model.setFiles(new Files());
            for (Map.Entry<String, String> entry : entity.getFiles().entrySet()) {
                File file = new File();
                file.setName(entry.getKey());
                file.setContent(entry.getValue());
                model.getFiles().getFiles().add(file);
            }
        }
        return model;
    }
    return null;
}
#method_after
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    if (entity.getDeviceType() != null || entity.getFiles().isEmpty()) {
        Payload model = template != null ? template : new Payload();
        if (entity.getDeviceType() != null) {
            org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getDeviceType(), null);
            if (deviceType != null) {
                model.setType(deviceType.value());
            }
        }
        model.setVolumeId(entity.getVolumeId());
        if (entity.getFiles().size() > 0) {
            model.setFiles(new Files());
            for (Map.Entry<String, String> entry : entity.getFiles().entrySet()) {
                File file = new File();
                file.setName(entry.getKey());
                file.setContent(entry.getValue());
                model.getFiles().getFiles().add(file);
            }
        }
        return model;
    }
    return null;
}
#end_block

#method_before
@Mapping(from = Payload.class, to = VmPayload.class)
public static VmPayload map(Payload model, VmPayload template) {
    VmPayload entity = template != null ? template : new VmPayload();
    if (model.getType() != null) {
        org.ovirt.engine.api.model.VmDeviceType deviceType = org.ovirt.engine.api.model.VmDeviceType.fromValue(model.getType());
        if (deviceType != null) {
            entity.setType(map(deviceType, null));
        }
    }
    if (model.isSetVolumeId()) {
        entity.setVolumeId(model.getVolumeId());
    }
    if (model.isSetFiles()) {
        for (File file : model.getFiles().getFiles()) {
            entity.getFiles().put(file.getName(), file.getContent());
        }
    }
    return entity;
}
#method_after
@Mapping(from = Payload.class, to = VmPayload.class)
public static VmPayload map(Payload model, VmPayload template) {
    VmPayload entity = template != null ? template : new VmPayload();
    if (model.getType() != null) {
        org.ovirt.engine.api.model.VmDeviceType deviceType = org.ovirt.engine.api.model.VmDeviceType.fromValue(model.getType());
        if (deviceType != null) {
            entity.setDeviceType(map(deviceType, null));
        }
    }
    if (model.isSetVolumeId()) {
        entity.setVolumeId(model.getVolumeId());
    }
    if (model.isSetFiles()) {
        for (File file : model.getFiles().getFiles()) {
            entity.getFiles().put(file.getName(), file.getContent());
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VmInitNetwork.class, to = GuestNicConfiguration.class)
public static GuestNicConfiguration map(VmInitNetwork entity, GuestNicConfiguration template) {
    GuestNicConfiguration model = template != null ? template : new GuestNicConfiguration();
    model.setName(entity.getName());
    model.setOnBoot(entity.getStartOnBoot());
    model.setBootProtocol(entity.getBootProtocol().name());
    IP ip = new IP();
    model.setIp(ip);
    ip.setAddress(entity.getIp());
    ip.setNetmask(entity.getNetmask());
    ip.setGateway(entity.getGateway());
    return model;
}
#method_after
@Mapping(from = VmInitNetwork.class, to = GuestNicConfiguration.class)
public static GuestNicConfiguration map(VmInitNetwork entity, GuestNicConfiguration template) {
    GuestNicConfiguration model = template != null ? template : new GuestNicConfiguration();
    model.setName(entity.getName());
    model.setOnBoot(entity.getStartOnBoot());
    if (entity.getBootProtocol() != null) {
        model.setBootProtocol(BootProtocolMapper.map(entity.getBootProtocol(), null).value());
    }
    IP ip = new IP();
    model.setIp(ip);
    ip.setAddress(entity.getIp());
    ip.setNetmask(entity.getNetmask());
    ip.setGateway(entity.getGateway());
    return model;
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                if (iface.isSetName()) {
                    vmInitInterface.setName(iface.getName());
                }
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            entity.setRootPassword(user.getPassword());
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#method_after
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                if (iface.isSetName()) {
                    vmInitInterface.setName(iface.getName());
                }
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            String userName = user.getUserName();
            if (StringUtils.equals(userName, "root")) {
                entity.setUserName(userName);
                String userPassword = user.getPassword();
                if (userPassword != null) {
                    entity.setRootPassword(userPassword);
                }
            }
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#end_block

#method_before
@Override
protected Template postPopulate(Template from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    from.setTimezone("Australia/Darwin");
    from.getSerialNumber().setPolicy(SerialNumberPolicy.CUSTOM.value());
    return from;
}
#method_after
@Override
protected Template postPopulate(Template from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    from.setTimezone("Australia/Darwin");
    from.getSerialNumber().setPolicy(SerialNumberPolicy.CUSTOM.value());
    from.getMigration().setAutoConverge(InheritableBoolean.TRUE.value());
    from.getMigration().setCompressed(InheritableBoolean.TRUE.value());
    return from;
}
#end_block

#method_before
@Override
protected void verify(Template model, Template transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.isSetOs());
    assertEquals(model.getBios().getBootMenu().isEnabled(), transform.getBios().getBootMenu().isEnabled());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertNotNull(model.getDisplay());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isSingleQxlPci(), transform.getDisplay().isSingleQxlPci());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getDisplay().getKeyboardLayout(), transform.getDisplay().getKeyboardLayout());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.getMigrationDowntime(), transform.getMigrationDowntime());
    assertEquals(model.getVersion().getVersionName(), transform.getVersion().getVersionName());
    assertEquals(model.getVersion().getBaseTemplate().getId(), transform.getVersion().getBaseTemplate().getId());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
    assertEquals(model.getDisplay().isFileTransferEnabled(), transform.getDisplay().isFileTransferEnabled());
    assertEquals(model.getDisplay().isCopyPasteEnabled(), transform.getDisplay().isCopyPasteEnabled());
    assertEquals(model.isStartPaused(), transform.isStartPaused());
}
#method_after
@Override
protected void verify(Template model, Template transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.isSetOs());
    assertEquals(model.getBios().getBootMenu().isEnabled(), transform.getBios().getBootMenu().isEnabled());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertNotNull(model.getDisplay());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isSingleQxlPci(), transform.getDisplay().isSingleQxlPci());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getDisplay().getKeyboardLayout(), transform.getDisplay().getKeyboardLayout());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.getMigrationDowntime(), transform.getMigrationDowntime());
    assertEquals(model.getVersion().getVersionName(), transform.getVersion().getVersionName());
    assertEquals(model.getVersion().getBaseTemplate().getId(), transform.getVersion().getBaseTemplate().getId());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
    assertEquals(model.getDisplay().isFileTransferEnabled(), transform.getDisplay().isFileTransferEnabled());
    assertEquals(model.getDisplay().isCopyPasteEnabled(), transform.getDisplay().isCopyPasteEnabled());
    assertEquals(model.isStartPaused(), transform.isStartPaused());
    assertEquals(model.getMigration().getAutoConverge(), transform.getMigration().getAutoConverge());
    assertEquals(model.getMigration().getCompressed(), transform.getMigration().getCompressed());
}
#end_block

#method_before
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetEntityExpectations(0);
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = doAdd(getRestModel(0));
    assertEquals(201, response.getStatus());
    verifyModel((R) response.getEntity(), 0);
    assertNull(((R) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetEntityExpectations(0);
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = doAdd(getRestModel(0));
    assertEquals(201, response.getStatus());
    verifyModel((R) response.getEntity(), 0);
    assertNull(((R) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
protected void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
        setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
        setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
    }
    setUpGetGraphicsExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
protected void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
        setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
        setUpGetSoundcardExpectations(new int[] { 0, 1, 2 });
        setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
    }
    setUpGetGraphicsExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
@Override
public Response add(InstanceType instanceType) {
    validateParameters(instanceType, "name");
    VmStatic vmStatic = getMapper(InstanceType.class, VmStatic.class).map(instanceType, new VmStatic());
    VM vm = new VM();
    vm.setStaticData(vmStatic);
    String name = instanceType.getName();
    String description = "";
    if (instanceType.isSetDescription()) {
        description = instanceType.getDescription();
    }
    vm.setVmDescription(description);
    AddVmTemplateParameters addInstanceTypeParameters = new AddVmTemplateParameters(vm, name, description);
    addInstanceTypeParameters.setTemplateType(VmEntityType.INSTANCE_TYPE);
    addInstanceTypeParameters.setVmTemplateId(null);
    addInstanceTypeParameters.setPublicUse(true);
    addInstanceTypeParameters.setConsoleEnabled(instanceType.getConsole() != null && instanceType.getConsole().isSetEnabled() ? instanceType.getConsole().isEnabled() : false);
    addInstanceTypeParameters.setVirtioScsiEnabled(instanceType.isSetVirtioScsi() && instanceType.getVirtioScsi().isSetEnabled() ? instanceType.getVirtioScsi().isEnabled() : null);
    return performCreate(VdcActionType.AddVmTemplate, addInstanceTypeParameters, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#method_after
@Override
public Response add(InstanceType instanceType) {
    validateParameters(instanceType, "name");
    VmStatic vmStatic = getMapper(InstanceType.class, VmStatic.class).map(instanceType, new VmStatic());
    VM vm = new VM();
    vm.setStaticData(vmStatic);
    String name = instanceType.getName();
    String description = "";
    if (instanceType.isSetDescription()) {
        description = instanceType.getDescription();
    }
    vm.setVmDescription(description);
    AddVmTemplateParameters addInstanceTypeParameters = new AddVmTemplateParameters(vm, name, description);
    addInstanceTypeParameters.setTemplateType(VmEntityType.INSTANCE_TYPE);
    addInstanceTypeParameters.setVmTemplateId(null);
    addInstanceTypeParameters.setPublicUse(true);
    addInstanceTypeParameters.setConsoleEnabled(instanceType.getConsole() != null && instanceType.getConsole().isSetEnabled() ? instanceType.getConsole().isEnabled() : false);
    addInstanceTypeParameters.setVirtioScsiEnabled(instanceType.isSetVirtioScsi() && instanceType.getVirtioScsi().isSetEnabled() ? instanceType.getVirtioScsi().isEnabled() : null);
    if (instanceType.isSetSoundcardEnabled()) {
        addInstanceTypeParameters.setSoundDeviceEnabled(instanceType.isSoundcardEnabled());
    }
    return performCreate(VdcActionType.AddVmTemplate, addInstanceTypeParameters, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#end_block

#method_before
@Override
@SingleEntityResource
public InstanceTypeResource getInstanceTypeSubResource(String id) {
    return inject(new BackendInstanceTypeResource(id, this));
}
#method_after
@Override
@SingleEntityResource
public InstanceTypeResource getInstanceTypeSubResource(String id) {
    return inject(new BackendInstanceTypeResource(id));
}
#end_block

#method_before
protected InstanceTypes mapCollection(List<org.ovirt.engine.core.common.businessentities.InstanceType> entities) {
    InstanceTypes collection = new InstanceTypes();
    for (org.ovirt.engine.core.common.businessentities.InstanceType entity : entities) {
        InstanceType instanceType = map(entity);
        adjustDisplayData(instanceType);
        collection.getInstanceTypes().add(addLinks(populate(instanceType, entity)));
    }
    return collection;
}
#method_after
protected InstanceTypes mapCollection(List<org.ovirt.engine.core.common.businessentities.InstanceType> entities) {
    InstanceTypes collection = new InstanceTypes();
    for (org.ovirt.engine.core.common.businessentities.InstanceType entity : entities) {
        InstanceType instanceType = map(entity);
        DisplayHelper.adjustDisplayData(this, instanceType);
        collection.getInstanceTypes().add(addLinks(populate(instanceType, entity)));
    }
    return collection;
}
#end_block

#method_before
@Override
protected InstanceType doPopulate(InstanceType model, org.ovirt.engine.core.common.businessentities.InstanceType entity) {
    if (!model.isSetConsole()) {
        model.setConsole(new Console());
    }
    model.getConsole().setEnabled(!getConsoleDevicesForEntity(entity.getId()).isEmpty());
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtIOSCSI());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getInstance().getVirtioScsiControllersForEntity(entity.getId()).isEmpty());
    List<VmRngDevice> rngDevices = getRngDevices(entity.getId());
    if (rngDevices != null && !rngDevices.isEmpty()) {
        model.setRngDevice(RngDeviceMapper.map(rngDevices.get(0), null));
    }
    return model;
}
#method_after
@Override
protected InstanceType doPopulate(InstanceType model, org.ovirt.engine.core.common.businessentities.InstanceType entity) {
    if (!model.isSetConsole()) {
        model.setConsole(new Console());
    }
    model.getConsole().setEnabled(!getConsoleDevicesForEntity(entity.getId()).isEmpty());
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtIOSCSI());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getVirtioScsiControllersForEntity(this, entity.getId()).isEmpty());
    model.setSoundcardEnabled(!VmHelper.getSoundDevicesForEntity(this, entity.getId()).isEmpty());
    List<VmRngDevice> rngDevices = getRngDevices(entity.getId());
    if (rngDevices != null && !rngDevices.isEmpty()) {
        model.setRngDevice(RngDeviceMapper.map(rngDevices.get(0), null));
    }
    return model;
}
#end_block

#method_before
@Override
public void init() {
    super.init();
    OsTypeMockUtils.mockOsTypes();
    initBackendResource(vmHelper);
}
#method_after
@Override
public void init() {
    super.init();
    OsTypeMockUtils.mockOsTypes();
    osRepository = control.createMock(OsRepository.class);
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
}
#end_block

#method_before
@Test
public void testRemove() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpGetGraphicsExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#method_after
@Test
public void testRemove() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    mockUniqueOsNames();
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpGetGraphicsExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#end_block

#method_before
@Test
public void testRemoveForced() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpGetGraphicsExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.TRUE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString(), new Action() {

        {
            setForce(true);
        }
    }));
}
#method_after
@Test
public void testRemoveForced() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    mockUniqueOsNames();
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpGetGraphicsExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.TRUE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString(), new Action() {

        {
            setForce(true);
        }
    }));
}
#end_block

#method_before
@Test
public void testRemoveDetachOnly() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpGetGraphicsExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "RemoveDisks" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    Action action = new Action();
    action.setVm(new VM());
    action.getVm().setDisks(new Disks());
    action.getVm().getDisks().setDetachOnly(true);
    verifyRemove(collection.remove(GUIDS[0].toString(), action));
}
#method_after
@Test
public void testRemoveDetachOnly() throws Exception {
    mockUniqueOsNames();
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpGetGraphicsExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "RemoveDisks" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    Action action = new Action();
    action.setVm(new VM());
    action.getVm().setDisks(new Disks());
    action.getVm().getDisks().setDetachOnly(true);
    verifyRemove(collection.remove(GUIDS[0].toString(), action));
}
#end_block

#method_before
@Test
public void testRemoveForcedIncomplete() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpGetGraphicsExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString(), new Action() {

        {
        }
    }));
}
#method_after
@Test
public void testRemoveForcedIncomplete() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    mockUniqueOsNames();
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpGetGraphicsExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString(), new Action() {

        {
        }
    }));
}
#end_block

#method_before
protected void doTestBadRemove(boolean canDo, boolean success, String detail) throws Exception {
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpGetGraphicsExpectations(1);
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, canDo, success));
    try {
        collection.remove(GUIDS[0].toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
protected void doTestBadRemove(boolean canDo, boolean success, String detail) throws Exception {
    setUpGetEntityExpectations();
    mockUniqueOsNames();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpGetGraphicsExpectations(1);
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, canDo, success));
    try {
        collection.remove(GUIDS[0].toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1, 0);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetCertuficateExpectations(1, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    VM created = (VM) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#method_after
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1, 0);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetCertuficateExpectations(1, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    VM created = (VM) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#end_block

#method_before
@Test
public void testAddFromScratch() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetBallooningExpectations(2, 0);
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    Disks disks = new Disks();
    disks.getDisks().add(new Disk());
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId", "DiskInfoList" }, new Object[] { Guid.Empty, mapDisks(disks) }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    model.setDisks(disks);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddFromScratch() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetBallooningExpectations(2, 0);
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    Disks disks = new Disks();
    disks.getDisks().add(new Disk());
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId", "DiskInfoList" }, new Object[] { Guid.Empty, mapDisks(disks) }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    model.setDisks(disks);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddFromScratchWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    addStorageDomainToModel(model);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddFromScratchWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    addStorageDomainToModel(model);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddFromScratchNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
}
#method_after
@Test
public void testAddFromScratchNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
}
#end_block

#method_before
private void doTestBadAddFromScratch(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, canDo, success));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
private void doTestBadAddFromScratch(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    expect(osRepository.isBalloonEnabled(anyInt(), anyObject(Version.class))).andReturn(false).anyTimes();
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, canDo, success));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[0]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testCloneVmFromSnapshot() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(0);
    Map<Guid, org.ovirt.engine.core.common.businessentities.Disk> diskImageMap = new HashMap<Guid, org.ovirt.engine.core.common.businessentities.Disk>();
    diskImageMap.put(Guid.newGuid(), new DiskImage());
    expect(vmConfiguration.getDiskMap()).andReturn(diskImageMap).anyTimes();
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(GUIDS[0]);
    vmStatic.setName(NAMES[0]);
    expect(vmConfiguration.getStaticData()).andReturn(vmStatic).anyTimes();
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 0, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmConfigurationBySnapshot, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, vmConfiguration);
    setUpCreationExpectations(VdcActionType.AddVmFromSnapshot, AddVmFromSnapshotParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(createDisksCollection(), createSnapshotsCollection(1));
    model.setTemplate(null);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneVmFromSnapshot() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(0);
    Map<Guid, org.ovirt.engine.core.common.businessentities.Disk> diskImageMap = new HashMap<Guid, org.ovirt.engine.core.common.businessentities.Disk>();
    diskImageMap.put(Guid.newGuid(), new DiskImage());
    vmConfiguration.setDiskMap(diskImageMap);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(2, 2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(2);
    setUpGetRngDeviceExpectations(2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmConfigurationBySnapshot, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, vmConfiguration);
    setUpCreationExpectations(VdcActionType.AddVmFromSnapshot, AddVmFromSnapshotParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(createDisksCollection(), createSnapshotsCollection(1));
    model.setTemplate(null);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(0, 2);
    setUpGetRngDeviceExpectations(0, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    expect(vm.getVmtGuid()).andReturn(GUIDS[1]).anyTimes();
    expect(vm.isStateless()).andReturn(true).anyTimes();
    expect(vm.isUseLatestVersion()).andReturn(true).anyTimes();
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM returnValueVM = (VM) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#method_after
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 2, 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    vm.setVmtGuid(GUIDS[1]);
    vm.setStateless(true);
    vm.setUseLatestVersion(true);
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM returnValueVM = (VM) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#end_block

#method_before
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfigurationWithRegenerateTrue() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 3);
    setUpGetBallooningExpectations(1, 3);
    setUpGetCertuficateExpectations(1, 3);
    setUpGetConsoleExpectations(new int[] { 3 });
    setUpGetVmOvfExpectations(new int[] { 3 });
    setUpGetVirtioScsiExpectations(new int[] { 3 });
    setUpGetRngDeviceExpectations(new int[] { 3 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setRegenerateIds(Boolean.TRUE);
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    Guid newId = GUIDS[3];
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), true }, true, true, newId, VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { newId }, getEntityWithProvidedId(2, newId));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM queriedVm = (VM) response.getEntity();
    assertEquals(newId.toString(), queriedVm.getId());
    queriedVm.setId(GUIDS[2].toString());
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfigurationWithRegenerateTrue() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 3);
    setUpGetBallooningExpectations(1, 3);
    setUpGetCertuficateExpectations(1, 3);
    setUpGetConsoleExpectations(new int[] { 3 });
    setUpGetVmOvfExpectations(new int[] { 3 });
    setUpGetVirtioScsiExpectations(new int[] { 3 });
    setUpGetSoundcardExpectations(new int[] { 3 });
    setUpGetRngDeviceExpectations(new int[] { 3 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setRegenerateIds(Boolean.TRUE);
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    Guid newId = GUIDS[3];
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), true }, true, true, newId, VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { newId }, getEntityWithProvidedId(2, newId));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM queriedVm = (VM) response.getEntity();
    assertEquals(newId.toString(), queriedVm.getId());
    queriedVm.setId(GUIDS[2].toString());
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfiguration() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), false }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfiguration() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), false }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfigurationNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId" }, new Object[] { returnedVM, GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfigurationNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId" }, new Object[] { returnedVM, GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[0]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    setUpGetGraphicsExpectations(3);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetPayloadExpectations(3);
        setUpGetBallooningExpectations(3);
        setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
        setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
        setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
        setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
        setUpGetCertuficateExpectations(3);
    }
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
private void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    setUpGetGraphicsExpectations(3);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetPayloadExpectations(3);
        setUpGetBallooningExpectations(3);
        setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
        setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
        setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
        setUpGetSoundcardExpectations(new int[] { 0, 1, 2 });
        setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
        setUpGetCertuficateExpectations(3);
    }
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
@Test
public void testListAllContent() throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    List<String> populates = new ArrayList<String>();
    populates.add("true");
    expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
    setUpGetPayloadExpectations(3);
    setUpGetBallooningExpectations(3);
    setUpGetGraphicsExpectations(3);
    setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
    setUpGetCertuficateExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
@Test
public void testListAllContent() throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    List<String> populates = new ArrayList<String>();
    populates.add("true");
    expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
    setUpGetPayloadExpectations(3);
    setUpGetBallooningExpectations(3);
    setUpGetGraphicsExpectations(3);
    setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
    setUpGetCertuficateExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
private VmPayload getPayloadModel() {
    VmPayload payload = new VmPayload();
    payload.setType(VmDeviceType.CDROM);
    payload.getFiles().put("payloadFile", new String(Base64.decodeBase64(PAYLOAD_COMTENT)));
    return payload;
}
#method_after
private VmPayload getPayloadModel() {
    VmPayload payload = new VmPayload();
    payload.setDeviceType(VmDeviceType.CDROM);
    payload.getFiles().put("payloadFile", new String(Base64.decodeBase64(PAYLOAD_COMTENT)));
    return payload;
}
#end_block

#method_before
private void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
private void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VM setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics, int index, Guid vmId) {
    expect(entity.getId()).andReturn(vmId).anyTimes();
    expect(entity.getVdsGroupId()).andReturn(GUIDS[2]).anyTimes();
    expect(entity.getName()).andReturn(NAMES[index]).anyTimes();
    expect(entity.getVmDescription()).andReturn(DESCRIPTIONS[index]).anyTimes();
    expect(entity.getNumOfCpus()).andReturn(8).anyTimes();
    expect(entity.getNumOfSockets()).andReturn(2).anyTimes();
    expect(entity.getUsageMemPercent()).andReturn(Integer.valueOf(20)).anyTimes();
    Map<GraphicsType, GraphicsInfo> graphics = new HashMap<>();
    graphics.put(GraphicsType.VNC, new GraphicsInfo());
    expect(entity.getGraphicsInfos()).andReturn(graphics).anyTimes();
    expect(entity.getDisplaySecurePort()).andReturn(5900).anyTimes();
    expect(entity.getNumOfMonitors()).andReturn(2).anyTimes();
    expect(entity.getVmType()).andReturn(VmType.Server).anyTimes();
    expect(entity.getRunOnVdsName()).andReturn(NAMES[NAMES.length - 1]).anyTimes();
    expect(entity.isHostedEngine()).andReturn(index == 0).anyTimes();
    setUpStatisticalEntityExpectations(entity, statistics);
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VM setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics, int index, Guid vmId) {
    entity.setId(vmId);
    entity.setVdsGroupId(GUIDS[2]);
    entity.setName(NAMES[index]);
    entity.setVmDescription(DESCRIPTIONS[index]);
    entity.setCpuPerSocket(4);
    entity.setNumOfSockets(2);
    entity.setUsageMemPercent(20);
    entity.getGraphicsInfos().put(GraphicsType.VNC, new GraphicsInfo());
    entity.setNumOfMonitors(2);
    entity.setVmType(VmType.Server);
    entity.setRunOnVdsName(NAMES[NAMES.length - 1]);
    entity.setOrigin(index == 0 ? OriginType.HOSTED_ENGINE : OriginType.OVIRT);
    entity.setBootSequence(null);
    setUpStatisticalEntityExpectations(entity, statistics);
    return entity;
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VmTemplate setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VmTemplate entity, int index) {
    expect(entity.getId()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getVdsGroupId()).andReturn(GUIDS[2]).anyTimes();
    expect(entity.getName()).andReturn(NAMES[index]).anyTimes();
    expect(entity.getDescription()).andReturn(DESCRIPTIONS[index]).anyTimes();
    expect(entity.getNumOfCpus()).andReturn(8).anyTimes();
    expect(entity.getNumOfSockets()).andReturn(2).anyTimes();
    expect(entity.getDefaultDisplayType()).andReturn(DisplayType.vga).anyTimes();
    expect(entity.getNumOfMonitors()).andReturn(2).anyTimes();
    expect(entity.getVmType()).andReturn(VmType.Server).anyTimes();
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VmTemplate setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VmTemplate entity, int index) {
    entity.setId(GUIDS[index]);
    entity.setVdsGroupId(GUIDS[2]);
    entity.setName(NAMES[index]);
    entity.setDescription(DESCRIPTIONS[index]);
    entity.setCpuPerSocket(4);
    entity.setNumOfSockets(2);
    entity.setDefaultDisplayType(DisplayType.cirrus);
    entity.setNumOfMonitors(2);
    entity.setVmType(VmType.Server);
    return entity;
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VM setUpStatisticalEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics) {
    expect(entity.getMemSizeMb()).andReturn(10).anyTimes();
    expect(entity.getStatisticsData()).andReturn(statistics).anyTimes();
    expect(statistics.getusage_mem_percent()).andReturn(20).anyTimes();
    expect(statistics.getcpu_user()).andReturn(Double.valueOf(30L)).anyTimes();
    expect(statistics.getcpu_sys()).andReturn(Double.valueOf(40L)).anyTimes();
    expect(statistics.getusage_cpu_percent()).andReturn(50).anyTimes();
    expect(entity.getMigrationProgressPercent()).andReturn(50).anyTimes();
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VM setUpStatisticalEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics) {
    entity.setVmMemSizeMb(10);
    entity.setStatisticsData(statistics);
    statistics.setusage_mem_percent(20);
    statistics.setcpu_user(30.0);
    statistics.setcpu_sys(40.0);
    statistics.setusage_cpu_percent(50);
    entity.setMigrationProgressPercent(50);
    return entity;
}
#end_block

#method_before
static VM getModel(int index) {
    VM model = new VM();
    model.setName(NAMES[index]);
    model.setDescription(DESCRIPTIONS[index]);
    model.setId(GUIDS[0].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    return model;
}
#method_after
static VM getModel(int index) {
    VM model = new VM();
    model.setName(NAMES[index]);
    model.setDescription(DESCRIPTIONS[index]);
    model.setId(GUIDS[index].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    return model;
}
#end_block

#method_before
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VM.class), control.createMock(VmStatistics.class), index);
}
#method_after
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    return setUpEntityExpectations(vm, vm.getStatisticsData(), index);
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VM getEntityWithProvidedId(int index, Guid vmId) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VM.class), control.createMock(VmStatistics.class), index, vmId);
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VM getEntityWithProvidedId(int index, Guid vmId) {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    return setUpEntityExpectations(vm, vm.getStatisticsData(), index, vmId);
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VmTemplate getTemplateEntity(int index) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VmTemplate.class), index);
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VmTemplate getTemplateEntity(int index) {
    org.ovirt.engine.core.common.businessentities.VmTemplate template = new org.ovirt.engine.core.common.businessentities.VmTemplate();
    return setUpEntityExpectations(template, index);
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm.getTemplate());
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(getClusterId(vm));
            }
            VDSGroup cluster = lookupCluster(staticVm.getVdsGroupId());
            if (Guid.Empty.equals(templateId) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            // let backend decide based on osinfo
            staticVm.setDefaultDisplayType(null);
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster.getcompatibility_version()));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                staticVm.setInstanceTypeId(getTemplateId(vm.getInstanceType()));
            }
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateId);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, storageDomainId);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateId);
            }
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm.getTemplate());
            VmTemplate templateEntity = lookupTemplate(templateId);
            VmStatic builtFromTemplate = getMapper(VmTemplate.class, VmStatic.class).map(templateEntity, null);
            VmStatic builtFromInstanceType = null;
            org.ovirt.engine.core.common.businessentities.InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                Mapper<org.ovirt.engine.core.common.businessentities.InstanceType, VmStatic> instanceTypeMapper = getMapper(org.ovirt.engine.core.common.businessentities.InstanceType.class, VmStatic.class);
                instanceTypeEntity = lookupInstanceType(getTemplateId(vm.getInstanceType()));
                builtFromInstanceType = instanceTypeMapper.map(instanceTypeEntity, builtFromTemplate);
                builtFromInstanceType.setInstanceTypeId(getTemplateId(vm.getInstanceType()));
            }
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(getClusterId(vm));
            }
            VDSGroup cluster = lookupCluster(staticVm.getVdsGroupId());
            if (Guid.Empty.equals(templateId) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster.getcompatibility_version()));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && templateId.equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateEntity, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, storageDomainId, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateEntity, instanceTypeEntity, cluster);
            }
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#end_block

#method_before
private Response createVmFromSnapshot(VM vm) {
    // If Vm has snapshots collection - this is a clone vm from snapshot operation
    String snapshotId = getSnapshotId(vm.getSnapshots());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getVmConfiguration(snapshotId);
    getMapper(VM.class, VmStatic.class).map(vm, vmConfiguration.getStaticData());
    // If vm passed in the call has disks attached on them,
    // merge their data with the data of the disks on the configuration
    // The parameters to AddVmFromSnapshot hold an array list of Disks
    // and not List of Disks, as this is a GWT serialization limitation,
    // and this parameter class serves GWT clients as well.
    HashMap<Guid, DiskImage> diskImagesByImageId = getDiskImagesByIdMap(vmConfiguration.getDiskMap().values());
    if (vm.isSetDisks()) {
        prepareImagesForCloneFromSnapshotParams(vm.getDisks(), diskImagesByImageId);
    }
    return cloneVmFromSnapshot(vmConfiguration.getStaticData(), vm, snapshotId, diskImagesByImageId);
}
#method_after
private Response createVmFromSnapshot(VM vm) {
    // If Vm has snapshots collection - this is a clone vm from snapshot operation
    String snapshotId = getSnapshotId(vm.getSnapshots());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getVmConfiguration(snapshotId);
    getMapper(VM.class, VmStatic.class).map(vm, vmConfiguration.getStaticData());
    // If vm passed in the call has disks attached on them,
    // merge their data with the data of the disks on the configuration
    // The parameters to AddVmFromSnapshot hold an array list of Disks
    // and not List of Disks, as this is a GWT serialization limitation,
    // and this parameter class serves GWT clients as well.
    HashMap<Guid, DiskImage> diskImagesByImageId = getDiskImagesByIdMap(vmConfiguration.getDiskMap().values());
    if (vm.isSetDisks()) {
        prepareImagesForCloneFromSnapshotParams(vm.getDisks(), diskImagesByImageId);
    }
    return cloneVmFromSnapshot(vmConfiguration, vm, snapshotId, diskImagesByImageId);
}
#end_block

#method_before
private Response cloneVmFromSnapshot(VmStatic staticVm, VM vm, String snapshotId, HashMap<Guid, DiskImage> images) {
    Guid sourceSnapshotId = asGuid(snapshotId);
    AddVmFromSnapshotParameters params = new AddVmFromSnapshotParameters(staticVm, sourceSnapshotId);
    params.setDiskInfoDestinationMap(images);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    setGraphicsToParams(vm, params);
    return performCreate(VdcActionType.AddVmFromSnapshot, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
private Response cloneVmFromSnapshot(org.ovirt.engine.core.common.businessentities.VM configVm, VM vm, String snapshotId, HashMap<Guid, DiskImage> images) {
    VmStatic staticVm = configVm.getStaticData();
    Guid sourceSnapshotId = asGuid(snapshotId);
    AddVmFromSnapshotParameters params = new AddVmFromSnapshotParameters(staticVm, sourceSnapshotId);
    params.setDiskInfoDestinationMap(images);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else {
        params.setSoundDeviceEnabled(isVMDeviceTypeExist(configVm.getManagedVmDeviceMap(), VmDeviceGeneralType.SOUND));
    }
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    DisplayHelper.setGraphicsToParams(vm.getDisplay(), params);
    return performCreate(VdcActionType.AddVmFromSnapshot, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
private Response cloneVmFromTemplate(VmStatic staticVm, VM vm, Guid templateId) {
    AddVmFromTemplateParameters params = new AddVmFromTemplateParameters(staticVm, getDisksToClone(vm.getDisks(), templateId), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    params.setBalloonEnabled(vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning() ? vm.getMemoryPolicy().isBallooning() : null);
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(templateId).isEmpty());
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    setGraphicsToParams(vm, params);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(vm, params);
    return performCreate(VdcActionType.AddVmFromTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
private Response cloneVmFromTemplate(VmStatic staticVm, VM vm, VmTemplate template, InstanceType instanceType, VDSGroup cluster) {
    AddVmParameters params = new AddVmParameters(staticVm);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), template.getId()));
    params.setVmPayload(getPayload(vm));
    addDevicesToParams(params, vm, template, instanceType, staticVm.getOsId(), cluster);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(vm, params);
    DisplayHelper.setGraphicsToParams(vm.getDisplay(), params);
    return performCreate(VdcActionType.AddVmFromTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
protected Response addVm(VmStatic staticVm, VM vm, Guid storageDomainId, Guid templateId) {
    VmManagementParametersBase params = new VmManagementParametersBase(staticVm);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), templateId));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(vm, params);
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(templateId).isEmpty());
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    setGraphicsToParams(vm, params);
    return performCreate(VdcActionType.AddVm, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
protected Response addVm(VmStatic staticVm, VM vm, Guid storageDomainId, VmTemplate template, InstanceType instanceType, VDSGroup cluster) {
    AddVmParameters params = new AddVmParameters(staticVm);
    params.setVmPayload(getPayload(vm));
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), template.getId()));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(vm, params);
    addDevicesToParams(params, vm, template, instanceType, staticVm.getOsId(), cluster);
    DisplayHelper.setGraphicsToParams(vm.getDisplay(), params);
    return performCreate(VdcActionType.AddVm, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
protected Response addVmFromScratch(VmStatic staticVm, VM vm, Guid storageDomainId) {
    AddVmFromScratchParameters params = new AddVmFromScratchParameters(staticVm, mapDisks(vm.getDisks()), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setStorageDomainId(storageDomainId);
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    if (vm.isSetConsole() && vm.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    setGraphicsToParams(vm, params);
    return performCreate(VdcActionType.AddVmFromScratch, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
protected Response addVmFromScratch(VmStatic staticVm, VM vm, Guid storageDomainId, InstanceType instanceType, VDSGroup cluster) {
    AddVmParameters params = new AddVmParameters(staticVm);
    params.setDiskInfoList(mapDisks(vm.getDisks()));
    params.setVmPayload(getPayload(vm));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setStorageDomainId(storageDomainId);
    addDevicesToParams(params, vm, null, instanceType, staticVm.getOsId(), cluster);
    DisplayHelper.setGraphicsToParams(vm.getDisplay(), params);
    return performCreate(VdcActionType.AddVmFromScratch, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
protected VM addInlineDetails(Set<Detail> details, VM vm) {
    if (details.contains(Detail.DISKS)) {
        addInlineDisks(vm);
    }
    if (details.contains(Detail.NICS)) {
        addInlineNics(vm);
    }
    if (details.contains(Detail.TAGS)) {
        addInlineTags(vm);
    }
    return vm;
}
#method_after
protected VM addInlineDetails(Set<String> details, VM vm) {
    if (details.contains("disks")) {
        addInlineDisks(vm);
    }
    if (details.contains("nics")) {
        addInlineNics(vm);
    }
    if (details.contains("tags")) {
        addInlineTags(vm);
    }
    return vm;
}
#end_block

#method_before
protected VMs mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities, boolean isFiltered) {
    // Fill VmInit for entities - the search query no join the VmInit to Vm
    IdsQueryParameters params = new IdsQueryParameters();
    List<Guid> ids = Entities.getIds(entities);
    params.setId(ids);
    VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
    if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
        List<VmInit> vmInits = queryReturnValue.getReturnValue();
        Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
        for (org.ovirt.engine.core.common.businessentities.VM vm : entities) {
            vm.setVmInit(initMap.get(vm.getId()));
        }
    }
    VMs collection = new VMs();
    for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
        VM vm = map(entity);
        adjustDisplayData(vm);
        // Filtered users are not allowed to view host related information
        if (isFiltered) {
            removeRestrictedInfoFromVM(vm);
        }
        collection.getVMs().add(addLinks(populate(vm, entity)));
    }
    return collection;
}
#method_after
protected VMs mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities, boolean isFiltered) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    boolean includeData = details.contains(DetailHelper.MAIN);
    boolean includeSize = details.contains("size");
    if (includeData) {
        // Fill VmInit for entities - the search query no join the VmInit to Vm
        IdsQueryParameters params = new IdsQueryParameters();
        List<Guid> ids = Entities.getIds(entities);
        params.setId(ids);
        VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
        if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
            List<VmInit> vmInits = queryReturnValue.getReturnValue();
            Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
            for (org.ovirt.engine.core.common.businessentities.VM vm : entities) {
                vm.setVmInit(initMap.get(vm.getId()));
            }
        }
    }
    VMs collection = new VMs();
    if (includeData) {
        for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
            VM vm = map(entity);
            DisplayHelper.adjustDisplayData(this, vm);
            // Filtered users are not allowed to view host related information
            if (isFiltered) {
                removeRestrictedInfoFromVM(vm);
            }
            collection.getVMs().add(addLinks(populate(vm, entity)));
        }
    }
    if (includeSize) {
        collection.setSize((long) entities.size());
    }
    return collection;
}
#end_block

#method_before
protected void setVirtioScsiController(VM model) {
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtIOSCSI());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getInstance().getVirtioScsiControllersForEntity(new Guid(model.getId())).isEmpty());
}
#method_after
protected void setVirtioScsiController(VM model) {
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtIOSCSI());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getVirtioScsiControllersForEntity(this, new Guid(model.getId())).isEmpty());
}
#end_block

#method_before
@Override
protected VM deprecatedPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<Detail> details = DetailHelper.getDetails(getHttpHeaders());
    model = addInlineDetails(details, model);
    if (details.contains(Detail.STATISTICS)) {
        addInlineStatistics(model);
    }
    return model;
}
#method_after
@Override
protected VM deprecatedPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    model = addInlineDetails(details, model);
    if (details.contains("statistics")) {
        addInlineStatistics(model);
    }
    return model;
}
#end_block

#method_before
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    setPayload(model);
    setBallooning(model);
    setConsoleDevice(model);
    setVirtioScsiController(model);
    setCertificateInfo(model);
    setVmOvfConfiguration(model, entity);
    setRngDevice(model);
    return model;
}
#method_after
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    setPayload(model);
    setBallooning(model);
    setConsoleDevice(model);
    setVirtioScsiController(model);
    setSoundcard(model);
    setCertificateInfo(model);
    setVmOvfConfiguration(model, entity);
    setRngDevice(model);
    return model;
}
#end_block

#method_before
private void doTestAddWithClonePermissions(Template model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description", "CopyVmPermissions" }, new Object[] { NAMES[0], DESCRIPTIONS[0], copy }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#method_after
private void doTestAddWithClonePermissions(Template model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description", "CopyVmPermissions" }, new Object[] { NAMES[0], DESCRIPTIONS[0], copy }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(getModel(0));
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    Template created = (Template) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#method_after
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(getModel(0));
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    Template created = (Template) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#end_block

#method_before
public void testAdd() throws Exception {
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    super.testAdd();
}
#method_after
public void testAdd() throws Exception {
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    super.testAdd();
}
#end_block

#method_before
@Test
public void testAddVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetConsoleExpectations(new int[] { 2, 0, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2, 2 });
    setUpGetRngDeviceExpectations(new int[] { 2, 2 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[2], DESCRIPTIONS[2] }, true, true, GUIDS[2], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(getModel(2));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    assertEquals(((Template) response.getEntity()).getVersion().getVersionName(), VERSION_NAME);
    assertEquals(((Template) response.getEntity()).getVersion().getBaseTemplate().getId(), GUIDS[1].toString());
    verifyModel((Template) response.getEntity(), 2);
}
#method_after
@Test
public void testAddVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetConsoleExpectations(new int[] { 2, 0, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2, 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 2, 0 });
    setUpGetRngDeviceExpectations(new int[] { 2, 2 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[2], DESCRIPTIONS[2] }, true, true, GUIDS[2], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(getModel(2));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    assertEquals(((Template) response.getEntity()).getVersion().getVersionName(), VERSION_NAME);
    assertEquals(((Template) response.getEntity()).getVersion().getBaseTemplate().getId(), GUIDS[1].toString());
    verifyModel((Template) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddNamedVm() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmNameForDataCenter, GetVmByVmNameForDataCenterParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.getVm().setId(null);
    model.getVm().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddNamedVm() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmNameForDataCenter, GetVmByVmNameForDataCenterParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.getVm().setId(null);
    model.getVm().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddNamedVmFiltered() throws Exception {
    setUpFilteredQueryExpectations();
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmNameForDataCenter, GetVmByVmNameForDataCenterParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.getVm().setId(null);
    model.getVm().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddNamedVmFiltered() throws Exception {
    setUpFilteredQueryExpectations();
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmNameForDataCenter, GetVmByVmNameForDataCenterParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.getVm().setId(null);
    model.getVm().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddWithCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddWithCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddWithClusterName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddWithClusterName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
protected void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetConsoleExpectations(new int[] { 0 });
    super.doTestBadAdd(canDo, success, detail);
}
#method_after
protected void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    super.doTestBadAdd(canDo, success, detail);
}
#end_block

#method_before
@Override
public VM get() {
    VM vm;
    if (isNextRunRequested()) {
        vm = performGet(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(guid));
    } else {
        vm = performGet(VdcQueryType.GetVmByVmId, new IdQueryParameters(guid));
    }
    parent.adjustDisplayData(vm);
    return removeRestrictedInfo(vm);
}
#method_after
@Override
public VM get() {
    VM vm;
    if (isNextRunRequested()) {
        org.ovirt.engine.core.common.businessentities.VM entity = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(guid), id, true);
        vm = addLinks(populate(VmMapper.map(entity, null, false), entity));
    } else {
        vm = performGet(VdcQueryType.GetVmByVmId, new IdQueryParameters(guid));
    }
    DisplayHelper.adjustDisplayData(this, vm);
    return removeRestrictedInfo(vm);
}
#end_block

#method_before
@Override
public Response migrate(Action action) {
    boolean forceMigration = action.isSetForce() ? action.isForce() : false;
    if (!action.isSetHost()) {
        return doAction(VdcActionType.MigrateVm, new MigrateVmParameters(forceMigration, guid), action);
    } else {
        return doAction(VdcActionType.MigrateVmToServer, new MigrateVmToServerParameters(forceMigration, guid, getHostId(action)), action);
    }
}
#method_after
@Override
public Response migrate(Action action) {
    boolean forceMigration = action.isSetForce() ? action.isForce() : false;
    if (!action.isSetHost()) {
        return doAction(VdcActionType.MigrateVm, new MigrateVmParameters(forceMigration, guid, getTargetClusterId(action)), action);
    } else {
        return doAction(VdcActionType.MigrateVmToServer, new MigrateVmToServerParameters(forceMigration, guid, getHostId(action), getTargetClusterId(action)), action);
    }
}
#end_block

#method_before
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    parent.setConsoleDevice(model);
    parent.setVirtioScsiController(model);
    parent.setVmOvfConfiguration(model, entity);
    parent.setRngDevice(model);
    return model;
}
#method_after
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    parent.setConsoleDevice(model);
    parent.setVirtioScsiController(model);
    parent.setSoundcard(model);
    parent.setVmOvfConfiguration(model, entity);
    parent.setRngDevice(model);
    return model;
}
#end_block

#method_before
@Override
protected VM deprecatedPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<Detail> details = DetailHelper.getDetails(getHttpHeaders());
    parent.addInlineDetails(details, model);
    addStatistics(model, entity, uriInfo, httpHeaders);
    parent.setPayload(model);
    parent.setBallooning(model);
    parent.setCertificateInfo(model);
    return model;
}
#method_after
@Override
protected VM deprecatedPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    parent.addInlineDetails(details, model);
    if (details.contains("statistics")) {
        addStatistics(model, entity, uriInfo);
    }
    parent.setPayload(model);
    parent.setBallooning(model);
    parent.setCertificateInfo(model);
    return model;
}
#end_block

#method_before
VM addStatistics(VM model, org.ovirt.engine.core.common.businessentities.VM entity, UriInfo ui, HttpHeaders httpHeaders) {
    if (DetailHelper.include(httpHeaders, "statistics")) {
        model.setStatistics(new Statistics());
        VmStatisticalQuery query = new VmStatisticalQuery(newModel(model.getId()));
        List<Statistic> statistics = query.getStatistics(entity);
        for (Statistic statistic : statistics) {
            LinkHelper.addLinks(ui, statistic, query.getParentType());
        }
        model.getStatistics().getStatistics().addAll(statistics);
    }
    return model;
}
#method_after
private void addStatistics(VM model, org.ovirt.engine.core.common.businessentities.VM entity, UriInfo ui) {
    model.setStatistics(new Statistics());
    VmStatisticalQuery query = new VmStatisticalQuery(newModel(model.getId()));
    List<Statistic> statistics = query.getStatistics(entity);
    for (Statistic statistic : statistics) {
        LinkHelper.addLinks(ui, statistic, query.getParentType());
    }
    model.getStatistics().getStatistics().addAll(statistics);
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getVdsGroupId()).getcompatibility_version()));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    params.setApplyChangesLater(isNextRunRequested());
    if (incoming.isSetPayloads()) {
        if (incoming.isSetPayloads() && incoming.getPayloads().isSetPayload()) {
            params.setVmPayload(parent.getPayload(incoming));
        } else {
            params.setClearPayload(true);
        }
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    if (incoming.isSetConsole() && incoming.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(incoming.getConsole().isEnabled());
    }
    if (incoming.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(incoming.getVirtioScsi().isEnabled());
    }
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    BackendVmsResource.setGraphicsToParams(incoming, params);
    if (incoming.isSetInstanceType() && (incoming.getInstanceType().isSetId() || incoming.getInstanceType().isSetName())) {
        updated.setInstanceTypeId(lookupInstanceTypeId(incoming.getInstanceType()));
    } else if (incoming.isSetInstanceType()) {
        // this means that the instance type should be unset
        updated.setInstanceTypeId(null);
    }
    return params;
}
#method_after
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getVdsGroupId()).getcompatibility_version()));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    params.setApplyChangesLater(isNextRunRequested());
    if (incoming.isSetPayloads()) {
        if (incoming.isSetPayloads() && incoming.getPayloads().isSetPayload()) {
            params.setVmPayload(parent.getPayload(incoming));
        } else {
            params.setClearPayload(true);
        }
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    if (incoming.isSetConsole() && incoming.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(incoming.getConsole().isEnabled());
    }
    if (incoming.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(incoming.getVirtioScsi().isEnabled());
    }
    if (incoming.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(incoming.isSoundcardEnabled());
    }
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    DisplayHelper.setGraphicsToParams(incoming.getDisplay(), params);
    if (incoming.isSetInstanceType() && (incoming.getInstanceType().isSetId() || incoming.getInstanceType().isSetName())) {
        updated.setInstanceTypeId(lookupInstanceTypeId(incoming.getInstanceType()));
    } else if (incoming.isSetInstanceType()) {
        // this means that the instance type should be unset
        updated.setInstanceTypeId(null);
    }
    return params;
}
#end_block

#method_before
@Override
public Template get() {
    Template template = performGet(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(guid));
    parent.adjustDisplayData(template);
    return template;
}
#method_after
@Override
public Template get() {
    Template template = performGet(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(guid));
    DisplayHelper.adjustDisplayData(this, template);
    return template;
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getVdsGroupId()).getcompatibility_version()));
    UpdateVmTemplateParameters params = new UpdateVmTemplateParameters(updated);
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    BackendTemplatesResource.setGraphicsToParams(incoming, params);
    return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, params);
}
#method_after
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getVdsGroupId()).getcompatibility_version()));
    UpdateVmTemplateParameters params = new UpdateVmTemplateParameters(updated);
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    if (incoming.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(incoming.isSoundcardEnabled());
    }
    DisplayHelper.setGraphicsToParams(incoming.getDisplay(), params);
    return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, params);
}
#end_block

#method_before
@Override
protected Template doPopulate(Template model, VmTemplate entity) {
    if (!model.isSetConsole()) {
        model.setConsole(new Console());
    }
    model.getConsole().setEnabled(!getConsoleDevicesForEntity(entity.getId()).isEmpty());
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtIOSCSI());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getInstance().getVirtioScsiControllersForEntity(entity.getId()).isEmpty());
    setRngDevice(model);
    return model;
}
#method_after
@Override
protected Template doPopulate(Template model, VmTemplate entity) {
    if (!model.isSetConsole()) {
        model.setConsole(new Console());
    }
    model.getConsole().setEnabled(!getConsoleDevicesForEntity(entity.getId()).isEmpty());
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtIOSCSI());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getVirtioScsiControllersForEntity(this, entity.getId()).isEmpty());
    model.setSoundcardEnabled(VmHelper.getSoundDevicesForEntity(this, entity.getId()).isEmpty());
    setRngDevice(model);
    return model;
}
#end_block

#method_before
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getPayloads().getPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    CpuTune cpuTune = new CpuTune();
    VCpuPin pin = new VCpuPin();
    pin.setVcpu(33);
    pin.setCpuSet("1-4,6");
    cpuTune.getVCpuPin().add(pin);
    from.getCpu().setCpuTune(cpuTune);
    from.setTimezone("Australia/Darwin");
    from.setPlacementPolicy(new VmPlacementPolicy());
    from.getPlacementPolicy().setHost(new Host());
    from.getPlacementPolicy().getHost().setId(Guid.Empty.toString());
    for (GuestNicConfiguration guestNic : from.getInitialization().getNicConfigurations().getNicConfigurations()) {
        guestNic.setBootProtocol(MappingTestHelper.shuffle(BootProtocol.class).value());
    }
    from.getDisplay().setType("spice");
    from.getSerialNumber().setPolicy(SerialNumberPolicy.CUSTOM.value());
    from.getDisplay().setFileTransferEnabled(true);
    from.getDisplay().setCopyPasteEnabled(true);
    return from;
}
#method_after
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getPayloads().getPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    CpuTune cpuTune = new CpuTune();
    VCpuPin pin = new VCpuPin();
    pin.setVcpu(33);
    pin.setCpuSet("1-4,6");
    cpuTune.getVCpuPin().add(pin);
    from.getCpu().setCpuTune(cpuTune);
    from.setTimezone("Australia/Darwin");
    from.setPlacementPolicy(new VmPlacementPolicy());
    from.getPlacementPolicy().setHost(new Host());
    from.getPlacementPolicy().getHost().setId(Guid.Empty.toString());
    for (GuestNicConfiguration guestNic : from.getInitialization().getNicConfigurations().getNicConfigurations()) {
        guestNic.setBootProtocol(MappingTestHelper.shuffle(BootProtocol.class).value());
    }
    from.getDisplay().setType("spice");
    from.getSerialNumber().setPolicy(SerialNumberPolicy.CUSTOM.value());
    from.getDisplay().setFileTransferEnabled(true);
    from.getDisplay().setCopyPasteEnabled(true);
    from.getMigration().setAutoConverge(InheritableBoolean.TRUE.value());
    from.getMigration().setCompressed(InheritableBoolean.TRUE.value());
    return from;
}
#end_block

#method_before
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertEquals(model.getBios().getBootMenu().isEnabled(), transform.getBios().getBootMenu().isEnabled());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isSingleQxlPci(), transform.getDisplay().isSingleQxlPci());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.getDisplay().getKeyboardLayout(), transform.getDisplay().getKeyboardLayout());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.getMigrationDowntime(), transform.getMigrationDowntime());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
    assertEquals(model.getDisplay().isFileTransferEnabled(), transform.getDisplay().isFileTransferEnabled());
    assertEquals(model.getDisplay().isCopyPasteEnabled(), transform.getDisplay().isCopyPasteEnabled());
    assertEquals(model.isStartPaused(), transform.isStartPaused());
}
#method_after
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertEquals(model.getBios().getBootMenu().isEnabled(), transform.getBios().getBootMenu().isEnabled());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isSingleQxlPci(), transform.getDisplay().isSingleQxlPci());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.getDisplay().getKeyboardLayout(), transform.getDisplay().getKeyboardLayout());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.getMigrationDowntime(), transform.getMigrationDowntime());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
    assertEquals(model.getDisplay().isFileTransferEnabled(), transform.getDisplay().isFileTransferEnabled());
    assertEquals(model.getDisplay().isCopyPasteEnabled(), transform.getDisplay().isCopyPasteEnabled());
    assertEquals(model.isStartPaused(), transform.isStartPaused());
    assertEquals(model.getMigration().getAutoConverge(), transform.getMigration().getAutoConverge());
    assertEquals(model.getMigration().getCompressed(), transform.getMigration().getCompressed());
}
#end_block

#method_before
@Test
public void testVmPayloadMapToPaylod() {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setType(org.ovirt.engine.core.common.utils.VmDeviceType.CDROM);
    vmPayload.setVolumeId("CD-VOL");
    Payload payload = VmMapper.map(vmPayload, null);
    assertEquals(vmPayload.getType().name().toLowerCase(), payload.getType());
    assertEquals(vmPayload.getVolumeId(), payload.getVolumeId());
}
#method_after
@Test
public void testVmPayloadMapToPaylod() {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(org.ovirt.engine.core.common.utils.VmDeviceType.CDROM);
    vmPayload.setVolumeId("CD-VOL");
    Payload payload = VmMapper.map(vmPayload, null);
    assertEquals(vmPayload.getDeviceType().name().toLowerCase(), payload.getType());
    assertEquals(vmPayload.getVolumeId(), payload.getVolumeId());
}
#end_block

#method_before
@Test
public void testPayloadMapToVmPaylod() {
    Payload payload = new Payload();
    payload.setType("CDROM");
    payload.setVolumeId("CD-VOL");
    VmPayload vmPayload = VmMapper.map(payload, null);
    assertEquals(payload.getType(), vmPayload.getType().name());
    assertEquals(payload.getVolumeId(), vmPayload.getVolumeId());
}
#method_after
@Test
public void testPayloadMapToVmPaylod() {
    Payload payload = new Payload();
    payload.setType("CDROM");
    payload.setVolumeId("CD-VOL");
    VmPayload vmPayload = VmMapper.map(payload, null);
    assertEquals(payload.getType(), vmPayload.getDeviceType().name());
    assertEquals(payload.getVolumeId(), vmPayload.getVolumeId());
}
#end_block

#method_before
@Test
public void testDisplayPort() {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    entity.setStatus(VMStatus.Up);
    entity.getGraphicsInfos().put(GraphicsType.SPICE, new GraphicsInfo());
    entity.getGraphicsInfos().get(GraphicsType.SPICE).setPort(5900).setTlsPort(9999);
    VM model = VmMapper.map(entity, (VM) null);
    assertTrue(model.getDisplay().getPort() == 5900);
    assertTrue(model.getDisplay().getSecurePort() == 9999);
    entity.getGraphicsInfos().put(GraphicsType.SPICE, new GraphicsInfo());
    entity.getGraphicsInfos().get(GraphicsType.SPICE).setPort(null).setTlsPort(null);
    model = VmMapper.map(entity, (VM) null);
    assertNull(model.getDisplay().getPort());
    assertNull(model.getDisplay().getSecurePort());
}
#method_after
@Test
public void testDisplayPort() {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    entity.setStatus(VMStatus.Up);
    entity.getGraphicsInfos().put(GraphicsType.SPICE, new GraphicsInfo());
    entity.getGraphicsInfos().get(GraphicsType.SPICE).setPort(5900).setTlsPort(9999);
    VM model = VmMapper.map(entity, (VM) null);
    entity.getGraphicsInfos().put(GraphicsType.SPICE, new GraphicsInfo());
    entity.getGraphicsInfos().get(GraphicsType.SPICE).setPort(null).setTlsPort(null);
    model = VmMapper.map(entity, (VM) null);
    assertNull(model.getDisplay().getPort());
    assertNull(model.getDisplay().getSecurePort());
}
#end_block

#method_before
@Override
@SingleEntityResource
public TemplateResource getTemplateSubResource(String id) {
    return inject(new BackendTemplateResource(id, this));
}
#method_after
@Override
@SingleEntityResource
public TemplateResource getTemplateSubResource(String id) {
    return inject(new BackendTemplateResource(id));
}
#end_block

#method_before
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    Guid clusterId = null;
    VDSGroup cluster = null;
    if (namedCluster(template)) {
        clusterId = getClusterId(template);
        cluster = lookupCluster(clusterId);
    }
    if (template.getVersion() != null) {
        validateParameters(template.getVersion(), "baseTemplate");
    }
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(cluster, template));
    if (namedCluster(template)) {
        staticVm.setVdsGroupId(clusterId);
    }
    staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(template.getUsb(), cluster != null ? cluster.getcompatibility_version() : lookupCluster(staticVm.getVdsGroupId()).getcompatibility_version()));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    if (template.getVersion() != null) {
        params.setBaseTemplateId(Guid.createGuidFromString(template.getVersion().getBaseTemplate().getId()));
        params.setTemplateVersionName(template.getVersion().getVersionName());
    }
    params.setConsoleEnabled(template.getConsole() != null && template.getConsole().isSetEnabled() ? template.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    params.setVirtioScsiEnabled(template.isSetVirtioScsi() && template.getVirtioScsi().isSetEnabled() ? template.getVirtioScsi().isEnabled() : null);
    if (template.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(template.getRngDevice(), null));
    }
    setGraphicsToParams(template, params);
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    setupCloneVmPermissions(template, params);
    return performCreate(VdcActionType.AddVmTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#method_after
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    Guid clusterId = null;
    VDSGroup cluster = null;
    if (namedCluster(template)) {
        clusterId = getClusterId(template);
        cluster = lookupCluster(clusterId);
    }
    if (template.getVersion() != null) {
        validateParameters(template.getVersion(), "baseTemplate");
    }
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(cluster, template));
    if (namedCluster(template)) {
        staticVm.setVdsGroupId(clusterId);
    }
    staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(template.getUsb(), cluster != null ? cluster.getcompatibility_version() : lookupCluster(staticVm.getVdsGroupId()).getcompatibility_version()));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    if (template.getVersion() != null) {
        params.setBaseTemplateId(Guid.createGuidFromString(template.getVersion().getBaseTemplate().getId()));
        params.setTemplateVersionName(template.getVersion().getVersionName());
    }
    params.setConsoleEnabled(template.getConsole() != null && template.getConsole().isSetEnabled() ? template.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    params.setVirtioScsiEnabled(template.isSetVirtioScsi() && template.getVirtioScsi().isSetEnabled() ? template.getVirtioScsi().isEnabled() : null);
    if (template.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(template.isSoundcardEnabled());
    } else {
        params.setSoundDeviceEnabled(!VmHelper.getSoundDevicesForEntity(this, staticVm.getId()).isEmpty());
    }
    if (template.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(template.getRngDevice(), null));
    }
    DisplayHelper.setGraphicsToParams(template.getDisplay(), params);
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    setupCloneVmPermissions(template, params);
    return performCreate(VdcActionType.AddVmTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#end_block

#method_before
protected Templates mapCollection(List<VmTemplate> entities) {
    // Fill VmInit for entities - the search query no join the VmInit to Templates
    IdsQueryParameters params = new IdsQueryParameters();
    List<Guid> ids = Entities.getIds(entities);
    params.setId(ids);
    VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
    if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
        List<VmInit> vmInits = queryReturnValue.getReturnValue();
        Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
        for (VmTemplate template : entities) {
            template.setVmInit(initMap.get(template.getId()));
        }
    }
    Templates collection = new Templates();
    for (VmTemplate entity : entities) {
        Template template = map(entity);
        adjustDisplayData(template);
        collection.getTemplates().add(addLinks(populate(template, entity)));
    }
    return collection;
}
#method_after
protected Templates mapCollection(List<VmTemplate> entities) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    boolean includeData = details.contains(DetailHelper.MAIN);
    boolean includeSize = details.contains("size");
    if (includeData) {
        // Fill VmInit for entities - the search query no join the VmInit to Templates
        IdsQueryParameters params = new IdsQueryParameters();
        List<Guid> ids = Entities.getIds(entities);
        params.setId(ids);
        VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
        if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
            List<VmInit> vmInits = queryReturnValue.getReturnValue();
            Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
            for (VmTemplate template : entities) {
                template.setVmInit(initMap.get(template.getId()));
            }
        }
    }
    Templates collection = new Templates();
    if (includeData) {
        for (VmTemplate entity : entities) {
            Template template = map(entity);
            collection.getTemplates().add(addLinks(populate(template, entity)));
            DisplayHelper.adjustDisplayData(this, template);
        }
    }
    if (includeSize) {
        collection.setSize((long) entities.size());
    }
    return collection;
}
#end_block

#method_before
@Override
protected Template doPopulate(Template model, VmTemplate entity) {
    if (!model.isSetConsole()) {
        model.setConsole(new Console());
    }
    model.getConsole().setEnabled(!getConsoleDevicesForEntity(entity.getId()).isEmpty());
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtIOSCSI());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getInstance().getVirtioScsiControllersForEntity(entity.getId()).isEmpty());
    List<VmRngDevice> rngDevices = getRngDevices(entity.getId());
    if (rngDevices != null && !rngDevices.isEmpty()) {
        model.setRngDevice(RngDeviceMapper.map(rngDevices.get(0), null));
    }
    return model;
}
#method_after
@Override
protected Template doPopulate(Template model, VmTemplate entity) {
    if (!model.isSetConsole()) {
        model.setConsole(new Console());
    }
    model.getConsole().setEnabled(!getConsoleDevicesForEntity(entity.getId()).isEmpty());
    if (!model.isSetVirtioScsi()) {
        model.setVirtioScsi(new VirtIOSCSI());
    }
    model.getVirtioScsi().setEnabled(!VmHelper.getVirtioScsiControllersForEntity(this, entity.getId()).isEmpty());
    model.setSoundcardEnabled(!VmHelper.getSoundDevicesForEntity(this, entity.getId()).isEmpty());
    List<VmRngDevice> rngDevices = getRngDevices(entity.getId());
    if (rngDevices != null && !rngDevices.isEmpty()) {
        model.setRngDevice(RngDeviceMapper.map(rngDevices.get(0), null));
    }
    return model;
}
#end_block

#method_before
@Test
public void add() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity());
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetEntityExpectations(VdcQueryType.GetVirtioScsiControllers, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpCreationExpectations(VdcActionType.AddVmPoolWithVms, VmPoolParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[0], VdcQueryType.GetVmPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(getModel(0));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VmPool);
    verifyModelTemplate((VmPool) response.getEntity());
}
#method_after
@Test
public void add() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity());
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetEntityExpectations(VdcQueryType.GetVirtioScsiControllers, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpGetEntityExpectations(VdcQueryType.GetSoundDevices, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpCreationExpectations(VdcActionType.AddVmPoolWithVms, VmPoolParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[0], VdcQueryType.GetVmPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(getModel(0));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VmPool);
    verifyModelTemplate((VmPool) response.getEntity());
}
#end_block

#method_before
@Test
public void addWithName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getTemplateEntity());
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVirtioScsiControllers, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpCreationExpectations(VdcActionType.AddVmPoolWithVms, VmPoolParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[0], VdcQueryType.GetVmPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VmPool pool = getModel(0);
    pool.setId(null);
    pool.getTemplate().setId(null);
    pool.getTemplate().setName(NAMES[1]);
    Response response = collection.add(pool);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VmPool);
    verifyModelTemplate((VmPool) response.getEntity());
}
#method_after
@Test
public void addWithName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getTemplateEntity());
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVirtioScsiControllers, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpGetEntityExpectations(VdcQueryType.GetSoundDevices, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpCreationExpectations(VdcActionType.AddVmPoolWithVms, VmPoolParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[0], VdcQueryType.GetVmPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VmPool pool = getModel(0);
    pool.setId(null);
    pool.getTemplate().setId(null);
    pool.getTemplate().setName(NAMES[1]);
    Response response = collection.add(pool);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VmPool);
    verifyModelTemplate((VmPool) response.getEntity());
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    resource.getParent().backend = backend;
    resource.getParent().sessionHelper = sessionHelper;
    resource.getParent().mappingLocator = resource.mappingLocator;
    resource.getParent().httpHeaders = httpHeaders;
    resource.getParent().messageBundle = messageBundle;
    OsTypeMockUtils.mockOsTypes();
    initBackendResource(vmHelper);
}
#method_after
@Override
protected void init() {
    super.init();
    resource.getParent().backend = backend;
    resource.getParent().sessionHelper = sessionHelper;
    resource.getParent().mappingLocator = resource.mappingLocator;
    resource.getParent().httpHeaders = httpHeaders;
    resource.getParent().messageBundle = messageBundle;
    OsTypeMockUtils.mockOsTypes();
}
#end_block

#method_before
public void testGetConsoleAware(boolean allContent) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetConsoleExpectations(new int[] { 0 });
        setUpGetVirtioScsiExpectations(new int[] { 0 });
        setUpGetRngDeviceExpectations(new int[] { 0 });
        setUpGetVmOvfExpectations(new int[] { 0 });
    }
    setUpGetEntityExpectations(1);
    setUpGetPayloadExpectations(0, 1);
    setUpGetBallooningExpectations();
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations();
    control.replay();
    VM response = resource.get();
    verifyModel(response, 0);
    verifyCertificate(response);
    List<String> populateHeader = httpHeaders.getRequestHeader(BackendResource.POPULATE);
    boolean populated = populateHeader != null ? populateHeader.contains("true") : false;
    assertTrue(populated ? response.isSetConsole() : !response.isSetConsole());
}
#method_after
public void testGetConsoleAware(boolean allContent) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetConsoleExpectations(new int[] { 0 });
        setUpGetVirtioScsiExpectations(new int[] { 0 });
        setUpGetSoundcardExpectations(new int[] { 0 });
        setUpGetRngDeviceExpectations(new int[] { 0 });
        setUpGetVmOvfExpectations(new int[] { 0 });
    }
    setUpGetEntityExpectations(1);
    setUpGetPayloadExpectations(0, 1);
    setUpGetBallooningExpectations();
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations();
    control.replay();
    VM response = resource.get();
    verifyModel(response, 0);
    verifyCertificate(response);
    List<String> populateHeader = httpHeaders.getRequestHeader(BackendResource.POPULATE);
    boolean populated = populateHeader != null ? populateHeader.contains("true") : false;
    assertTrue(populated ? response.isSetConsole() : !response.isSetConsole());
}
#end_block

#method_before
@Test
public void testUpdate() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    verifyModel(resource.update(getModel(0)), 0);
}
#method_after
@Test
public void testUpdate() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    verifyModel(resource.update(getModel(0)), 0);
}
#end_block

#method_before
@Test
public void testUpdateRemovingPayloads() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 1);
    setUpGetNoPayloadExpectations(0, 1);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    verifyModelClearingPayloads(resource.update(getModelClearingPayloads(0)), 0);
}
#method_after
@Test
public void testUpdateRemovingPayloads() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 1);
    setUpGetNoPayloadExpectations(0, 1);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    verifyModelClearingPayloads(resource.update(getModelClearingPayloads(0)), 0);
}
#end_block

#method_before
@Test
public void testUpdateVmPolicy() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    VM model = getModel(0);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    verifyModel(resource.update(model), 0);
}
#method_after
@Test
public void testUpdateVmPolicy() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    VM model = getModel(0);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    verifyModel(resource.update(model), 0);
}
#end_block

#method_before
@Test
public void testUpdateMovingCluster() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.ChangeVMCluster, ChangeVMClusterParameters.class, new String[] { "ClusterId", "VmId" }, new Object[] { GUIDS[1], GUIDS[0] }, true, true, false));
    setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true);
    VM model = getModel(0);
    model.setId(GUIDS[0].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    verifyModelOnNewCluster(resource.update(model), 0);
}
#method_after
@Test
public void testUpdateMovingCluster() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(0);
    setUpGetVmOvfExpectations(0);
    setUpGetVirtioScsiExpectations(0);
    setUpGetSoundcardExpectations(0);
    setUpGetRngDeviceExpectations(0);
    setUpGetGraphicsExpectations(1);
    setUriInfo(setUpActionExpectations(VdcActionType.ChangeVMCluster, ChangeVMClusterParameters.class, new String[] { "ClusterId", "VmId" }, new Object[] { GUIDS[1], GUIDS[0] }, true, true, false));
    setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true);
    VM model = getModel(0);
    model.setId(GUIDS[0].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    verifyModelOnNewCluster(resource.update(model), 0);
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VM setUpStatisticalExpectations() throws Exception {
    VmStatistics stats = control.createMock(VmStatistics.class);
    org.ovirt.engine.core.common.businessentities.VM entity = control.createMock(org.ovirt.engine.core.common.businessentities.VM.class);
    setUpStatisticalEntityExpectations(entity, stats);
    setUpGetEntityExpectations(1, false, entity);
    control.replay();
    return entity;
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VM setUpStatisticalExpectations() throws Exception {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    setUpStatisticalEntityExpectations(entity, entity.getStatisticsData());
    setUpGetEntityExpectations(1, false, entity);
    control.replay();
    return entity;
}
#end_block

#method_before
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VM.class), control.createMock(VmStatistics.class), index);
}
#method_after
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    return setUpEntityExpectations(vm, vm.getStatisticsData(), index);
}
#end_block

#method_before
protected void verifyModelOnNewCluster(VM model, int index) {
    assertNotNull(model.getCluster().getId());
    assertEquals(GUIDS[2].toString(), model.getCluster().getId());
    verifyModel(model, index);
}
#method_after
protected void verifyModelOnNewCluster(VM model, int index) {
    assertNotNull(model.getCluster().getId());
    assertEquals(GUIDS[1].toString(), model.getCluster().getId());
    verifyModel(model, index);
}
#end_block

#method_before
private VmPayload getPayloadModel() {
    VmPayload payload = new VmPayload();
    payload.setType(VmDeviceType.CDROM);
    payload.getFiles().put("payloadFile", new String(Base64.decodeBase64(PAYLOAD_COMTENT)));
    return payload;
}
#method_after
private VmPayload getPayloadModel() {
    VmPayload payload = new VmPayload();
    payload.setDeviceType(VmDeviceType.CDROM);
    payload.getFiles().put("payloadFile", new String(Base64.decodeBase64(PAYLOAD_COMTENT)));
    return payload;
}
#end_block

#method_before
@Test
public void testBadGuid() throws Exception {
    control.replay();
    try {
        new BackendTemplateResource("foo", new BackendTemplatesResource());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyNotFoundException(wae);
    }
}
#method_after
@Test
public void testBadGuid() throws Exception {
    control.replay();
    try {
        new BackendTemplateResource("foo");
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyNotFoundException(wae);
    }
}
#end_block

#method_before
public void testGetConsoleAware(boolean allContent) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations(1);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetConsoleExpectations(new int[] { 0 });
        setUpGetVirtioScsiExpectations(new int[] { 0 });
        setUpGetRngDeviceExpectations(new int[] { 0 });
    }
    setUpGetGraphicsExpectations(1);
    control.replay();
    R response = resource.get();
    verifyModel(response, 0);
    List<String> populateHeader = httpHeaders.getRequestHeader(BackendResource.POPULATE);
    boolean populated = populateHeader != null ? populateHeader.contains("true") : false;
    assertTrue(populated ? response.isSetConsole() : !response.isSetConsole());
}
#method_after
public void testGetConsoleAware(boolean allContent) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations(1);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetConsoleExpectations(new int[] { 0 });
        setUpGetVirtioScsiExpectations(new int[] { 0 });
        setUpGetSoundcardExpectations(new int[] { 0 });
        setUpGetRngDeviceExpectations(new int[] { 0 });
    }
    setUpGetGraphicsExpectations(1);
    control.replay();
    R response = resource.get();
    verifyModel(response, 0);
    List<String> populateHeader = httpHeaders.getRequestHeader(BackendResource.POPULATE);
    boolean populated = populateHeader != null ? populateHeader.contains("true") : false;
    assertTrue(populated ? response.isSetConsole() : !response.isSetConsole());
}
#end_block

#method_before
@Test
public void testUpdate() throws Exception {
    setUpGetEntityExpectations(2);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVmTemplate, UpdateVmTemplateParameters.class, new String[] {}, new Object[] {}, true, true));
    verifyModel(resource.update(getRestModel(0)), 0);
}
#method_after
@Test
public void testUpdate() throws Exception {
    setUpGetEntityExpectations(2);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVmTemplate, UpdateVmTemplateParameters.class, new String[] {}, new Object[] {}, true, true));
    verifyModel(resource.update(getRestModel(0)), 0);
}
#end_block

#method_before
private void loadPayload() {
    VmDeviceDAO dao = getDbFacade().getVmDeviceDao();
    List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getVmId(), VmDeviceGeneralType.DISK);
    for (VmDevice disk : disks) {
        if (VmPayload.isPayload(disk.getSpecParams())) {
            VmPayload payload = new VmPayload(VmDeviceType.valueOf(disk.getType().name()), disk.getSpecParams());
            payload.setType(VmDeviceType.valueOf(disk.getDevice().toUpperCase()));
            getVm().setVmPayload(payload);
            break;
        }
    }
}
#method_after
private void loadPayload() {
    VmDeviceDAO dao = getDbFacade().getVmDeviceDao();
    List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getVmId(), VmDeviceGeneralType.DISK);
    for (VmDevice disk : disks) {
        if (VmPayload.isPayload(disk.getSpecParams())) {
            VmPayload payload = new VmPayload(disk);
            getVm().setVmPayload(payload);
            break;
        }
    }
}
#end_block

#method_before
@Override
protected CreateVmVDSCommandParameters buildCreateVmParameters() {
    CreateVmVDSCommandParameters createVmParams = super.buildCreateVmParameters();
    RunVmOnceParams runOnceParams = getParameters();
    SysPrepParams sysPrepParams = new SysPrepParams();
    sysPrepParams.setSysPrepDomainName(runOnceParams.getSysPrepDomainName());
    sysPrepParams.setSysPrepUserName(runOnceParams.getSysPrepUserName());
    sysPrepParams.setSysPrepPassword(runOnceParams.getSysPrepPassword());
    createVmParams.setSysPrepParams(sysPrepParams);
    createVmParams.getVm().setVmInit(getParameters().getVmInit());
    for (GraphicsType graphicsType : getParameters().getRunOnceGraphics()) {
        getVm().getGraphicsInfos().put(graphicsType, new GraphicsInfo());
    }
    return createVmParams;
}
#method_after
@Override
protected CreateVmVDSCommandParameters buildCreateVmParameters() {
    CreateVmVDSCommandParameters createVmParams = super.buildCreateVmParameters();
    RunVmOnceParams runOnceParams = getParameters();
    SysPrepParams sysPrepParams = new SysPrepParams();
    sysPrepParams.setSysPrepDomainName(runOnceParams.getSysPrepDomainName());
    sysPrepParams.setSysPrepUserName(runOnceParams.getSysPrepUserName());
    sysPrepParams.setSysPrepPassword(runOnceParams.getSysPrepPassword());
    createVmParams.setSysPrepParams(sysPrepParams);
    createVmParams.getVm().setVmInit(getParameters().getVmInit());
    fillRunOnceGraphics();
    return createVmParams;
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    staticVm.setSpiceFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    staticVm.setSpiceCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    staticVm.setRunAndPause(entity.isRunAndPause());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setVmType(entity.getVmType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    staticVm.setSpiceFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    staticVm.setSpiceCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    staticVm.setRunAndPause(entity.isRunAndPause());
    staticVm.setCpuProfileId(entity.getCpuProfileId());
    staticVm.setAutoConverge(entity.getAutoConverge());
    staticVm.setMigrateCompressed(entity.getMigrateCompressed());
    staticVm.setCustomProperties(entity.getCustomProperties());
    staticVm.setCustomEmulatedMachine(entity.getCustomEmulatedMachine());
    staticVm.setCustomCpuName(entity.getCustomCpuName());
    return doMapVmBaseHwPartToVmStatic(entity, staticVm);
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.NumaTuneMode.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.NumaTuneMode mode, String incoming) {
    if (mode == null) {
        return null;
    }
    switch(mode) {
        case STRICT:
            return NumaTuneMode.STRICT.value();
        case INTERLEAVE:
            return NumaTuneMode.INTERLEAVE.value();
        case PREFERRED:
            return NumaTuneMode.PREFERRED.value();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.InstanceType.class, to = VmStatic.class)
public static VmStatic map(org.ovirt.engine.core.common.businessentities.InstanceType entity, VmStatic vmStatic) {
    return doMapVmBaseHwPartToVmStatic((VmBase) entity, vmStatic != null ? vmStatic : new VmStatic());
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetBios()) {
        if (vm.getBios().isSetBootMenu()) {
            staticVm.setBootMenuEnabled(vm.getBios().getBootMenu().isEnabled());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
        if (vm.getDisplay().isSetFileTransferEnabled()) {
            staticVm.setSpiceFileTransferEnabled(vm.getDisplay().isSetFileTransferEnabled());
        }
        if (vm.getDisplay().isSetCopyPasteEnabled()) {
            staticVm.setSpiceCopyPasteEnabled(vm.getDisplay().isSetCopyPasteEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(vm.getSerialNumber(), staticVm);
    }
    if (vm.isSetNumaTuneMode()) {
        NumaTuneMode mode = NumaTuneMode.fromValue(vm.getNumaTuneMode());
        if (mode != null) {
            staticVm.setNumaTuneMode(map(mode, null));
        }
    }
    if (vm.isSetStartPaused()) {
        staticVm.setRunAndPause(vm.isStartPaused());
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    mapVmBaseModelToEntity(staticVm, vm);
    if (!vm.isSetMemory() && staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetNumaTuneMode()) {
        NumaTuneMode mode = NumaTuneMode.fromValue(vm.getNumaTuneMode());
        if (mode != null) {
            staticVm.setNumaTuneMode(map(mode, null));
        }
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    model.setBios(new Bios());
    model.getBios().setBootMenu(new BootMenu());
    model.getBios().getBootMenu().setEnabled(entity.isBootMenuEnabled());
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos(), null);
        String graphicsTypeString = graphicsType == null ? null : graphicsType.name().toLowerCase();
        GraphicsInfo graphicsInfo = graphicsType == null ? null : entity.getGraphicsInfos().get(graphicsType);
        model.setDisplay(new Display());
        model.getDisplay().setType(graphicsTypeString);
        model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
        Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
        model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
        Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos(), null);
            model.getDisplay().setType(graphicsType == null ? null : graphicsType.name().toLowerCase());
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
        model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
        model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (StringUtils.isNotBlank(entity.getVmInit().getDomain())) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity.getStaticData(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    model.setStartPaused(entity.isRunAndPause());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    return map(entity, template, true);
}
#end_block

#method_before
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String vncKeyboardLayout = vm.getDisplay().getKeyboardLayout();
            params.setVncKeyboardLayout(vncKeyboardLayout);
        }
        setGraphicsFromLegacyDisplay(vm, params);
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetBios()) {
        if (vm.getBios().isSetBootMenu()) {
            params.setBootMenuEnabled(vm.getBios().getBootMenu().isEnabled());
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    return params;
}
#method_after
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay()) {
        // todo rest api follow up
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String vncKeyboardLayout = vm.getDisplay().getKeyboardLayout();
            params.setVncKeyboardLayout(vncKeyboardLayout);
        }
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetBios()) {
        if (vm.getBios().isSetBootMenu()) {
            params.setBootMenuEnabled(vm.getBios().getBootMenu().isEnabled());
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetCustomCpuModel()) {
        params.setCustomCpuName(vm.getCustomCpuModel());
    }
    if (vm.isSetCustomEmulatedMachine()) {
        params.setCustomEmulatedMachine(vm.getCustomEmulatedMachine());
    }
    return params;
}
#end_block

#method_before
@Mapping(from = DisplayType.class, to = org.ovirt.engine.core.common.businessentities.DisplayType.class)
public static org.ovirt.engine.core.common.businessentities.DisplayType map(DisplayType type, org.ovirt.engine.core.common.businessentities.DisplayType incoming) {
    switch(type) {
        case VNC:
            return org.ovirt.engine.core.common.businessentities.DisplayType.vga;
        case SPICE:
            return org.ovirt.engine.core.common.businessentities.DisplayType.qxl;
        default:
            return null;
    }
}
#method_after
@Mapping(from = DisplayType.class, to = org.ovirt.engine.core.common.businessentities.DisplayType.class)
public static org.ovirt.engine.core.common.businessentities.DisplayType map(DisplayType type, org.ovirt.engine.core.common.businessentities.DisplayType incoming) {
    switch(type) {
        case VNC:
            // todo restapi follow up
            return org.ovirt.engine.core.common.businessentities.DisplayType.cirrus;
        case SPICE:
            return org.ovirt.engine.core.common.businessentities.DisplayType.qxl;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.DisplayType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.DisplayType type, String incoming) {
    switch(type) {
        case vga:
            return DisplayType.VNC.value();
        case qxl:
            return DisplayType.SPICE.value();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.DisplayType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.DisplayType type, String incoming) {
    switch(type) {
        case // todo restapi follow up
        cirrus:
            return DisplayType.VNC.value();
        case qxl:
            return DisplayType.SPICE.value();
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    if (entity.getType() != null || entity.getFiles().isEmpty()) {
        Payload model = template != null ? template : new Payload();
        if (entity.getType() != null) {
            org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getType(), null);
            if (deviceType != null) {
                model.setType(deviceType.value());
            }
        }
        model.setVolumeId(entity.getVolumeId());
        if (entity.getFiles().size() > 0) {
            model.setFiles(new Files());
            for (Map.Entry<String, String> entry : entity.getFiles().entrySet()) {
                File file = new File();
                file.setName(entry.getKey());
                file.setContent(entry.getValue());
                model.getFiles().getFiles().add(file);
            }
        }
        return model;
    }
    return null;
}
#method_after
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    if (entity.getDeviceType() != null || entity.getFiles().isEmpty()) {
        Payload model = template != null ? template : new Payload();
        if (entity.getDeviceType() != null) {
            org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getDeviceType(), null);
            if (deviceType != null) {
                model.setType(deviceType.value());
            }
        }
        model.setVolumeId(entity.getVolumeId());
        if (entity.getFiles().size() > 0) {
            model.setFiles(new Files());
            for (Map.Entry<String, String> entry : entity.getFiles().entrySet()) {
                File file = new File();
                file.setName(entry.getKey());
                file.setContent(entry.getValue());
                model.getFiles().getFiles().add(file);
            }
        }
        return model;
    }
    return null;
}
#end_block

#method_before
@Mapping(from = Payload.class, to = VmPayload.class)
public static VmPayload map(Payload model, VmPayload template) {
    VmPayload entity = template != null ? template : new VmPayload();
    if (model.getType() != null) {
        org.ovirt.engine.api.model.VmDeviceType deviceType = org.ovirt.engine.api.model.VmDeviceType.fromValue(model.getType());
        if (deviceType != null) {
            entity.setType(map(deviceType, null));
        }
    }
    if (model.isSetVolumeId()) {
        entity.setVolumeId(model.getVolumeId());
    }
    if (model.isSetFiles()) {
        for (File file : model.getFiles().getFiles()) {
            entity.getFiles().put(file.getName(), file.getContent());
        }
    }
    return entity;
}
#method_after
@Mapping(from = Payload.class, to = VmPayload.class)
public static VmPayload map(Payload model, VmPayload template) {
    VmPayload entity = template != null ? template : new VmPayload();
    if (model.getType() != null) {
        org.ovirt.engine.api.model.VmDeviceType deviceType = org.ovirt.engine.api.model.VmDeviceType.fromValue(model.getType());
        if (deviceType != null) {
            entity.setDeviceType(map(deviceType, null));
        }
    }
    if (model.isSetVolumeId()) {
        entity.setVolumeId(model.getVolumeId());
    }
    if (model.isSetFiles()) {
        for (File file : model.getFiles().getFiles()) {
            entity.getFiles().put(file.getName(), file.getContent());
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VmInitNetwork.class, to = GuestNicConfiguration.class)
public static GuestNicConfiguration map(VmInitNetwork entity, GuestNicConfiguration template) {
    GuestNicConfiguration model = template != null ? template : new GuestNicConfiguration();
    model.setName(entity.getName());
    model.setOnBoot(entity.getStartOnBoot());
    model.setBootProtocol(entity.getBootProtocol().name());
    IP ip = new IP();
    model.setIp(ip);
    ip.setAddress(entity.getIp());
    ip.setNetmask(entity.getNetmask());
    ip.setGateway(entity.getGateway());
    return model;
}
#method_after
@Mapping(from = VmInitNetwork.class, to = GuestNicConfiguration.class)
public static GuestNicConfiguration map(VmInitNetwork entity, GuestNicConfiguration template) {
    GuestNicConfiguration model = template != null ? template : new GuestNicConfiguration();
    model.setName(entity.getName());
    model.setOnBoot(entity.getStartOnBoot());
    if (entity.getBootProtocol() != null) {
        model.setBootProtocol(BootProtocolMapper.map(entity.getBootProtocol(), null).value());
    }
    IP ip = new IP();
    model.setIp(ip);
    ip.setAddress(entity.getIp());
    ip.setNetmask(entity.getNetmask());
    ip.setGateway(entity.getGateway());
    return model;
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                if (iface.isSetName()) {
                    vmInitInterface.setName(iface.getName());
                }
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            entity.setRootPassword(user.getPassword());
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#method_after
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                if (iface.isSetName()) {
                    vmInitInterface.setName(iface.getName());
                }
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            String userName = user.getUserName();
            if (StringUtils.equals(userName, "root")) {
                entity.setUserName(userName);
                String userPassword = user.getPassword();
                if (userPassword != null) {
                    entity.setRootPassword(userPassword);
                }
            }
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#end_block

#method_before
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    // needs to be called before iso list is updated
    setIsoImagePath(vm.getIsoPath());
    getAttachFloppy().setEntity(false);
    getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel<DisplayType> vncProtocol = new EntityModel<DisplayType>(DisplayType.vga).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel<DisplayType> qxlProtocol = new EntityModel<DisplayType>(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    boolean hasSpiceSupport = AsyncDataProvider.getInstance().hasSpiceSupport(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if (hasSpiceSupport) {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    } else {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol));
        getDisplayConsole_Spice_IsSelected().setIsAvailable(false);
    }
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vga ? vncProtocol : qxlProtocol);
    getSpiceFileTransferEnabled().setEntity(vm.isSpiceFileTransferEnabled());
    getSpiceCopyPasteEnabled().setEntity(vm.isSpiceCopyPasteEnabled());
}
#method_after
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    // needs to be called before iso list is updated
    setIsoImagePath(vm.getIsoPath());
    getAttachFloppy().setEntity(false);
    getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    updateDomainList();
    updateSystemTabLists();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel<DisplayType> vncProtocol = new EntityModel<DisplayType>(DisplayType.vga).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel<DisplayType> qxlProtocol = new EntityModel<DisplayType>(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    boolean hasSpiceSupport = AsyncDataProvider.getInstance().hasSpiceSupport(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if (hasSpiceSupport) {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    } else {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol));
        getDisplayConsole_Spice_IsSelected().setIsAvailable(false);
    }
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vga ? vncProtocol : qxlProtocol);
    getSpiceFileTransferEnabled().setEntity(vm.isSpiceFileTransferEnabled());
    getSpiceCopyPasteEnabled().setEntity(vm.isSpiceCopyPasteEnabled());
}
#end_block

#method_before
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setBootMenuEnabled(getBootMenuEnabled().getEntity());
    params.setRunAndPause(getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless(getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties(getCustomPropertySheet().serialize());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl(getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams(getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl(getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName(getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword(getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && getIsCloudInitEnabled().getEntity() || getIsSysprepEnabled() != null && getIsSysprepEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    params.setSpiceFileTransferEnabled(getSpiceFileTransferEnabled().getEntity());
    params.setSpiceCopyPasteEnabled(getSpiceCopyPasteEnabled().getEntity());
    return params;
}
#method_after
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setBootMenuEnabled(getBootMenuEnabled().getEntity());
    params.setRunAndPause(getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless(getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties(getCustomPropertySheet().serialize());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl(getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams(getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl(getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName(getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword(getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && getIsCloudInitEnabled().getEntity() || getIsSysprepEnabled() != null && getIsSysprepEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    String selectedEmulatedMachine = getEmulatedMachine().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(selectedEmulatedMachine)) {
        params.setCustomEmulatedMachine(selectedEmulatedMachine);
    }
    String selectedCustomCpu = getCustomCpu().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(selectedCustomCpu)) {
        params.setCustomCpuName(selectedCustomCpu);
    }
    params.setSpiceFileTransferEnabled(getSpiceFileTransferEnabled().getEntity());
    params.setSpiceCopyPasteEnabled(getSpiceCopyPasteEnabled().getEntity());
    return params;
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
            getSpiceFileTransferEnabled().setIsChangable(false);
            getSpiceCopyPasteEnabled().setIsChangable(false);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
            getSpiceFileTransferEnabled().setIsChangable(true);
            getSpiceCopyPasteEnabled().setIsChangable(true);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
            getSpiceFileTransferEnabled().setIsChangable(false);
            getSpiceCopyPasteEnabled().setIsChangable(false);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
            getSpiceFileTransferEnabled().setIsChangable(true);
            getSpiceCopyPasteEnabled().setIsChangable(true);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#end_block

#method_before
public boolean validate() {
    getIsoImage().setIsValid(true);
    if (getAttachIso().getEntity()) {
        getIsoImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if (getAttachFloppy().getEntity()) {
        getFloppyImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    boolean cloudInitIsValid = getVmInit().validate();
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation && cloudInitIsValid;
}
#method_after
public boolean validate() {
    getIsoImage().setIsValid(true);
    if (getAttachIso().getEntity()) {
        getIsoImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if (getAttachFloppy().getEntity()) {
        getFloppyImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    boolean cloudInitIsValid = getVmInit().validate();
    getEmulatedMachine().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_EMULATED_MACHINE_SIZE) });
    getCustomCpu().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_CPU_NAME_SIZE) });
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation && cloudInitIsValid && getEmulatedMachine().getIsValid() && getCustomCpu().getIsValid();
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VmTemplate getTemplateEntity() {
    VmTemplate entity = control.createMock(VmTemplate.class);
    expect(entity.getId()).andReturn(GUIDS[1]).anyTimes();
    expect(entity.getVdsGroupId()).andReturn(GUIDS[2]).anyTimes();
    expect(entity.getName()).andReturn(NAMES[1]).anyTimes();
    expect(entity.getDescription()).andReturn(DESCRIPTIONS[1]).anyTimes();
    expect(entity.getNumOfCpus()).andReturn(8).anyTimes();
    expect(entity.getNumOfSockets()).andReturn(2).anyTimes();
    expect(entity.getDefaultDisplayType()).andReturn(DisplayType.vga).anyTimes();
    expect(entity.getNumOfMonitors()).andReturn(2).anyTimes();
    expect(entity.getVmType()).andReturn(VmType.Server).anyTimes();
    return entity;
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VmTemplate getTemplateEntity() {
    VmTemplate entity = control.createMock(VmTemplate.class);
    expect(entity.getId()).andReturn(GUIDS[1]).anyTimes();
    expect(entity.getVdsGroupId()).andReturn(GUIDS[2]).anyTimes();
    expect(entity.getName()).andReturn(NAMES[1]).anyTimes();
    expect(entity.getDescription()).andReturn(DESCRIPTIONS[1]).anyTimes();
    expect(entity.getNumOfCpus()).andReturn(8).anyTimes();
    expect(entity.getNumOfSockets()).andReturn(2).anyTimes();
    // todo restapi follow up
    expect(entity.getDefaultDisplayType()).andReturn(DisplayType.cirrus).anyTimes();
    expect(entity.getNumOfMonitors()).andReturn(2).anyTimes();
    expect(entity.getVmType()).andReturn(VmType.Server).anyTimes();
    return entity;
}
#end_block

#method_before
@Test
public void add() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity());
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetEntityExpectations(VdcQueryType.GetVirtioScsiControllers, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpCreationExpectations(VdcActionType.AddVmPoolWithVms, VmPoolParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[0], VdcQueryType.GetVmPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(getModel(0));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VmPool);
    verifyModelTemplate((VmPool) response.getEntity());
}
#method_after
@Test
public void add() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity());
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetEntityExpectations(VdcQueryType.GetVirtioScsiControllers, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpGetEntityExpectations(VdcQueryType.GetSoundDevices, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpCreationExpectations(VdcActionType.AddVmPoolWithVms, VmPoolParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[0], VdcQueryType.GetVmPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(getModel(0));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VmPool);
    verifyModelTemplate((VmPool) response.getEntity());
}
#end_block

#method_before
@Test
public void addWithName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getTemplateEntity());
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVirtioScsiControllers, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpCreationExpectations(VdcActionType.AddVmPoolWithVms, VmPoolParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[0], VdcQueryType.GetVmPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VmPool pool = getModel(0);
    pool.setId(null);
    pool.getTemplate().setId(null);
    pool.getTemplate().setName(NAMES[1]);
    Response response = collection.add(pool);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VmPool);
    verifyModelTemplate((VmPool) response.getEntity());
}
#method_after
@Test
public void addWithName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getTemplateEntity());
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVirtioScsiControllers, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpGetEntityExpectations(VdcQueryType.GetSoundDevices, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpCreationExpectations(VdcActionType.AddVmPoolWithVms, VmPoolParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[0], VdcQueryType.GetVmPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VmPool pool = getModel(0);
    pool.setId(null);
    pool.getTemplate().setId(null);
    pool.getTemplate().setName(NAMES[1]);
    Response response = collection.add(pool);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VmPool);
    verifyModelTemplate((VmPool) response.getEntity());
}
#end_block

#method_before
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVds, VDSGroup vdsGroup) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    }
    return validateVmProperties(vm, runVmParam.getCustomProperties(), messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(validateDisplayType(), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, getVmDisks(), runVmParam.getRunAsStateless()), messages) && validate(validateStorageDomains(vm, isInternalExecution, getVmImageDisks()), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && validate(validateMemorySize(vm), messages) && SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVds, messages);
}
#method_after
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVds, VDSGroup vdsGroup) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    }
    return validateVmProperties(vm, runVmParam.getCustomProperties(), messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(validateDisplayType(), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, runVmParam.getRunAsStateless()), messages) && validate(validateStorageDomains(vm, isInternalExecution, getVmImageDisks()), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && validate(validateMemorySize(vm), messages) && SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVds, messages);
}
#end_block

#method_before
protected boolean validateVmProperties(VM vm, String runOnceCustomProperties, List<String> messages) {
    String customProperties = runOnceCustomProperties != null ? runOnceCustomProperties : vm.getCustomProperties();
    List<ValidationError> validationErrors = getVmPropertiesUtils().validateVmProperties(vm.getVdsGroupCompatibilityVersion(), customProperties);
    if (!validationErrors.isEmpty()) {
        getVmPropertiesUtils().handleCustomPropertiesError(validationErrors, messages);
        return false;
    }
    return true;
}
#method_after
protected boolean validateVmProperties(VM vm, String runOnceCustomProperties, List<String> messages) {
    String customProperties = runOnceCustomProperties != null ? runOnceCustomProperties : vm.getCustomProperties();
    return getVmPropertiesUtils().validateVmProperties(vm.getVdsGroupCompatibilityVersion(), customProperties, messages);
}
#end_block

#method_before
protected ValidationResult validateStatelessVm(VM vm, List<Disk> plugDisks, Boolean stateless) {
    // if the VM is not stateless, there is nothing to check
    if (stateless != null ? !stateless : !vm.isStateless()) {
        return ValidationResult.VALID;
    }
    ValidationResult previewValidation = getSnapshotValidator().vmNotInPreview(vm.getId());
    if (!previewValidation.isValid()) {
        return previewValidation;
    }
    // if the VM itself is stateless or run once as stateless
    if (vm.isAutoStartup()) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA);
    }
    ValidationResult hasSpaceValidation = hasSpaceForSnapshots(vm, plugDisks);
    if (!hasSpaceValidation.isValid()) {
        return hasSpaceValidation;
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateStatelessVm(VM vm, Boolean stateless) {
    // if the VM is not stateless, there is nothing to check
    if (stateless != null ? !stateless : !vm.isStateless()) {
        return ValidationResult.VALID;
    }
    ValidationResult previewValidation = getSnapshotValidator().vmNotInPreview(vm.getId());
    if (!previewValidation.isValid()) {
        return previewValidation;
    }
    // if the VM itself is stateless or run once as stateless
    if (vm.isAutoStartup()) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA);
    }
    ValidationResult hasSpaceValidation = hasSpaceForSnapshots();
    if (!hasSpaceValidation.isValid()) {
        return hasSpaceValidation;
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected ValidationResult hasSpaceForSnapshots(VM vm, List<Disk> plugDisks) {
    Integer minSnapshotSize = Config.<Integer>getValue(ConfigValues.InitStorageSparseSizeInGB);
    Map<StorageDomain, Integer> mapStorageDomainsToNumOfDisks = mapStorageDomainsToNumOfDisks(vm, plugDisks);
    for (Entry<StorageDomain, Integer> e : mapStorageDomainsToNumOfDisks.entrySet()) {
        ValidationResult validationResult = new StorageDomainValidator(e.getKey()).isDomainHasSpaceForRequest(minSnapshotSize * e.getValue());
        if (!validationResult.isValid()) {
            return validationResult;
        }
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult hasSpaceForSnapshots() {
    Set<Guid> sdIds = ImagesHandler.getAllStorageIdsForImageIds(getVmImageDisks());
    MultipleStorageDomainsValidator msdValidator = getStorageDomainsValidator(sdIds);
    ValidationResult retVal = msdValidator.allDomainsWithinThresholds();
    if (retVal == ValidationResult.VALID) {
        return msdValidator.allDomainsHaveSpaceForNewDisks(getVmImageDisks());
    }
    return retVal;
}
#end_block

#method_before
protected ValidationResult validateInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<String>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion())) {
        result.remove(null);
    }
    // aren't attached to the cluster
    return result.isEmpty() ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
}
#method_after
protected ValidationResult validateInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion())) {
        result.remove(null);
    }
    // aren't attached to the cluster
    return result.isEmpty() ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
}
#end_block

#method_before
// /////////////////////
// / Utility methods ///
// /////////////////////
protected boolean validate(ValidationResult validationResult, List<String> message) {
    if (!validationResult.isValid()) {
        message.add(validationResult.getMessage().name());
        if (validationResult.getVariableReplacements() != null) {
            for (String variableReplacement : validationResult.getVariableReplacements()) {
                message.add(variableReplacement);
            }
        }
    }
    return validationResult.isValid();
}
#method_after
// /////////////////////
// / Utility methods ///
// /////////////////////
protected boolean validate(ValidationResult validationResult, List<String> message) {
    if (!validationResult.isValid()) {
        message.add(validationResult.getMessage().name());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            message.add(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#end_block

#method_before
@Override
public void init() {
    super.init();
    OsTypeMockUtils.mockOsTypes();
    initBackendResource(vmHelper);
}
#method_after
@Override
public void init() {
    super.init();
    OsTypeMockUtils.mockOsTypes();
    osRepository = control.createMock(OsRepository.class);
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
}
#end_block

#method_before
@Test
public void testRemove() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#method_after
@Test
public void testRemove() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    mockUniqueOsNames();
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#end_block

#method_before
@Test
public void testRemoveForced() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.TRUE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString(), new Action() {

        {
            setForce(true);
        }
    }));
}
#method_after
@Test
public void testRemoveForced() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    mockUniqueOsNames();
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.TRUE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString(), new Action() {

        {
            setForce(true);
        }
    }));
}
#end_block

#method_before
@Test
public void testRemoveDetachOnly() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "RemoveDisks" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    Action action = new Action();
    action.setVm(new VM());
    action.getVm().setDisks(new Disks());
    action.getVm().getDisks().setDetachOnly(true);
    verifyRemove(collection.remove(GUIDS[0].toString(), action));
}
#method_after
@Test
public void testRemoveDetachOnly() throws Exception {
    mockUniqueOsNames();
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "RemoveDisks" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    Action action = new Action();
    action.setVm(new VM());
    action.getVm().setDisks(new Disks());
    action.getVm().getDisks().setDetachOnly(true);
    verifyRemove(collection.remove(GUIDS[0].toString(), action));
}
#end_block

#method_before
@Test
public void testRemoveForcedIncomplete() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString(), new Action() {

        {
        }
    }));
}
#method_after
@Test
public void testRemoveForcedIncomplete() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    mockUniqueOsNames();
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, true, true);
    verifyRemove(collection.remove(GUIDS[0].toString(), new Action() {

        {
        }
    }));
}
#end_block

#method_before
protected void doTestBadRemove(boolean canDo, boolean success, String detail) throws Exception {
    setUpGetEntityExpectations();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, canDo, success));
    try {
        collection.remove(GUIDS[0].toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
protected void doTestBadRemove(boolean canDo, boolean success, String detail) throws Exception {
    setUpGetEntityExpectations();
    mockUniqueOsNames();
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1);
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveVm, RemoveVmParameters.class, new String[] { "VmId", "Force" }, new Object[] { GUIDS[0], Boolean.FALSE }, canDo, success));
    try {
        collection.remove(GUIDS[0].toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1, 0);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetCertuficateExpectations(1, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    VM created = (VM) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#method_after
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1, 0);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetCertuficateExpectations(1, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    VM created = (VM) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#end_block

#method_before
@Test
public void testAddFromScratch() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetBallooningExpectations(2, 0);
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    Disks disks = new Disks();
    disks.getDisks().add(new Disk());
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId", "DiskInfoList" }, new Object[] { Guid.Empty, mapDisks(disks) }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    model.setDisks(disks);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddFromScratch() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetBallooningExpectations(2, 0);
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    Disks disks = new Disks();
    disks.getDisks().add(new Disk());
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId", "DiskInfoList" }, new Object[] { Guid.Empty, mapDisks(disks) }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    model.setDisks(disks);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddFromScratchWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    addStorageDomainToModel(model);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddFromScratchWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    addStorageDomainToModel(model);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddFromScratchNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
}
#method_after
@Test
public void testAddFromScratchNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
}
#end_block

#method_before
private void doTestBadAddFromScratch(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, canDo, success));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
private void doTestBadAddFromScratch(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    expect(osRepository.isBalloonEnabled(anyInt(), anyObject(Version.class))).andReturn(false).anyTimes();
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVmFromScratch, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, canDo, success));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[0]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testCloneVmFromSnapshot() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(0);
    Map<Guid, org.ovirt.engine.core.common.businessentities.Disk> diskImageMap = new HashMap<Guid, org.ovirt.engine.core.common.businessentities.Disk>();
    diskImageMap.put(Guid.newGuid(), new DiskImage());
    expect(vmConfiguration.getDiskMap()).andReturn(diskImageMap).anyTimes();
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(GUIDS[0]);
    vmStatic.setName(NAMES[0]);
    expect(vmConfiguration.getStaticData()).andReturn(vmStatic).anyTimes();
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 0, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmConfigurationBySnapshot, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, vmConfiguration);
    setUpCreationExpectations(VdcActionType.AddVmFromSnapshot, AddVmFromSnapshotParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(createDisksCollection(), createSnapshotsCollection(1));
    model.setTemplate(null);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneVmFromSnapshot() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(0);
    Map<Guid, org.ovirt.engine.core.common.businessentities.Disk> diskImageMap = new HashMap<Guid, org.ovirt.engine.core.common.businessentities.Disk>();
    diskImageMap.put(Guid.newGuid(), new DiskImage());
    vmConfiguration.setDiskMap(diskImageMap);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(2, 2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(2);
    setUpGetRngDeviceExpectations(2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmConfigurationBySnapshot, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, vmConfiguration);
    setUpCreationExpectations(VdcActionType.AddVmFromSnapshot, AddVmFromSnapshotParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(createDisksCollection(), createSnapshotsCollection(1));
    model.setTemplate(null);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(0, 2);
    setUpGetRngDeviceExpectations(0, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    expect(vm.getVmtGuid()).andReturn(GUIDS[1]).anyTimes();
    expect(vm.isStateless()).andReturn(true).anyTimes();
    expect(vm.isUseLatestVersion()).andReturn(true).anyTimes();
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM returnValueVM = (VM) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#method_after
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 2, 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    vm.setVmtGuid(GUIDS[1]);
    vm.setStateless(true);
    vm.setUseLatestVersion(true);
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM returnValueVM = (VM) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#end_block

#method_before
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfigurationWithRegenerateTrue() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 3);
    setUpGetBallooningExpectations(1, 3);
    setUpGetCertuficateExpectations(1, 3);
    setUpGetConsoleExpectations(new int[] { 3 });
    setUpGetVmOvfExpectations(new int[] { 3 });
    setUpGetVirtioScsiExpectations(new int[] { 3 });
    setUpGetRngDeviceExpectations(new int[] { 3 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setRegenerateIds(Boolean.TRUE);
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    Guid newId = GUIDS[3];
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), true }, true, true, newId, VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { newId }, getEntityWithProvidedId(2, newId));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM queriedVm = (VM) response.getEntity();
    assertEquals(newId.toString(), queriedVm.getId());
    queriedVm.setId(GUIDS[2].toString());
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfigurationWithRegenerateTrue() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 3);
    setUpGetBallooningExpectations(1, 3);
    setUpGetCertuficateExpectations(1, 3);
    setUpGetConsoleExpectations(new int[] { 3 });
    setUpGetVmOvfExpectations(new int[] { 3 });
    setUpGetVirtioScsiExpectations(new int[] { 3 });
    setUpGetSoundcardExpectations(new int[] { 3 });
    setUpGetRngDeviceExpectations(new int[] { 3 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setRegenerateIds(Boolean.TRUE);
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    Guid newId = GUIDS[3];
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), true }, true, true, newId, VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { newId }, getEntityWithProvidedId(2, newId));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM queriedVm = (VM) response.getEntity();
    assertEquals(newId.toString(), queriedVm.getId());
    queriedVm.setId(GUIDS[2].toString());
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfiguration() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), false }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfiguration() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), false }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfigurationNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId" }, new Object[] { returnedVM, GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfigurationNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId" }, new Object[] { returnedVM, GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[0]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetPayloadExpectations(3);
        setUpGetBallooningExpectations(3);
        setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
        setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
        setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
        setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
        setUpGetCertuficateExpectations(3);
    }
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
private void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetPayloadExpectations(3);
        setUpGetBallooningExpectations(3);
        setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
        setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
        setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
        setUpGetSoundcardExpectations(new int[] { 0, 1, 2 });
        setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
        setUpGetCertuficateExpectations(3);
    }
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
@Test
public void testListAllContent() throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    List<String> populates = new ArrayList<String>();
    populates.add("true");
    expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
    setUpGetPayloadExpectations(3);
    setUpGetBallooningExpectations(3);
    setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
    setUpGetCertuficateExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
@Test
public void testListAllContent() throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    List<String> populates = new ArrayList<String>();
    populates.add("true");
    expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
    setUpGetPayloadExpectations(3);
    setUpGetBallooningExpectations(3);
    setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 1, 2 });
    setUpGetCertuficateExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
private VmPayload getPayloadModel() {
    VmPayload payload = new VmPayload();
    payload.setType(VmDeviceType.CDROM);
    payload.getFiles().put("payloadFile", new String(Base64.decodeBase64(PAYLOAD_COMTENT)));
    return payload;
}
#method_after
private VmPayload getPayloadModel() {
    VmPayload payload = new VmPayload();
    payload.setDeviceType(VmDeviceType.CDROM);
    payload.getFiles().put("payloadFile", new String(Base64.decodeBase64(PAYLOAD_COMTENT)));
    return payload;
}
#end_block

#method_before
private void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
private void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VM setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics, int index, Guid vmId) {
    expect(entity.getId()).andReturn(vmId).anyTimes();
    expect(entity.getVdsGroupId()).andReturn(GUIDS[2]).anyTimes();
    expect(entity.getName()).andReturn(NAMES[index]).anyTimes();
    expect(entity.getVmDescription()).andReturn(DESCRIPTIONS[index]).anyTimes();
    expect(entity.getNumOfCpus()).andReturn(8).anyTimes();
    expect(entity.getNumOfSockets()).andReturn(2).anyTimes();
    expect(entity.getUsageMemPercent()).andReturn(Integer.valueOf(20)).anyTimes();
    Map<GraphicsType, GraphicsInfo> graphics = new HashMap<>();
    graphics.put(GraphicsType.VNC, new GraphicsInfo());
    expect(entity.getGraphicsInfos()).andReturn(graphics).anyTimes();
    expect(entity.getDisplaySecurePort()).andReturn(5900).anyTimes();
    expect(entity.getNumOfMonitors()).andReturn(2).anyTimes();
    expect(entity.getVmType()).andReturn(VmType.Server).anyTimes();
    expect(entity.getRunOnVdsName()).andReturn(NAMES[NAMES.length - 1]).anyTimes();
    expect(entity.isHostedEngine()).andReturn(index == 0).anyTimes();
    setUpStatisticalEntityExpectations(entity, statistics);
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VM setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics, int index, Guid vmId) {
    entity.setId(vmId);
    entity.setVdsGroupId(GUIDS[2]);
    entity.setName(NAMES[index]);
    entity.setVmDescription(DESCRIPTIONS[index]);
    entity.setCpuPerSocket(4);
    entity.setNumOfSockets(2);
    entity.setUsageMemPercent(20);
    // todo restapi follow up
    entity.setDisplayType(DisplayType.cirrus);
    entity.setDisplaySecurePort(5900);
    entity.setNumOfMonitors(2);
    entity.setVmType(VmType.Server);
    entity.setRunOnVdsName(NAMES[NAMES.length - 1]);
    entity.setOrigin(index == 0 ? OriginType.HOSTED_ENGINE : OriginType.OVIRT);
    entity.setBootSequence(null);
    setUpStatisticalEntityExpectations(entity, statistics);
    return entity;
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VmTemplate setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VmTemplate entity, int index) {
    expect(entity.getId()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getVdsGroupId()).andReturn(GUIDS[2]).anyTimes();
    expect(entity.getName()).andReturn(NAMES[index]).anyTimes();
    expect(entity.getDescription()).andReturn(DESCRIPTIONS[index]).anyTimes();
    expect(entity.getNumOfCpus()).andReturn(8).anyTimes();
    expect(entity.getNumOfSockets()).andReturn(2).anyTimes();
    expect(entity.getDefaultDisplayType()).andReturn(DisplayType.vga).anyTimes();
    expect(entity.getNumOfMonitors()).andReturn(2).anyTimes();
    expect(entity.getVmType()).andReturn(VmType.Server).anyTimes();
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VmTemplate setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VmTemplate entity, int index) {
    entity.setId(GUIDS[index]);
    entity.setVdsGroupId(GUIDS[2]);
    entity.setName(NAMES[index]);
    entity.setDescription(DESCRIPTIONS[index]);
    entity.setCpuPerSocket(4);
    entity.setNumOfSockets(2);
    // todo restapi follow up
    entity.setDefaultDisplayType(DisplayType.cirrus);
    entity.setNumOfMonitors(2);
    entity.setVmType(VmType.Server);
    return entity;
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VM setUpStatisticalEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics) {
    expect(entity.getMemSizeMb()).andReturn(10).anyTimes();
    expect(entity.getStatisticsData()).andReturn(statistics).anyTimes();
    expect(statistics.getusage_mem_percent()).andReturn(20).anyTimes();
    expect(statistics.getcpu_user()).andReturn(Double.valueOf(30L)).anyTimes();
    expect(statistics.getcpu_sys()).andReturn(Double.valueOf(40L)).anyTimes();
    expect(statistics.getusage_cpu_percent()).andReturn(50).anyTimes();
    expect(entity.getMigrationProgressPercent()).andReturn(50).anyTimes();
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VM setUpStatisticalEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics) {
    entity.setVmMemSizeMb(10);
    entity.setStatisticsData(statistics);
    statistics.setusage_mem_percent(20);
    statistics.setcpu_user(30.0);
    statistics.setcpu_sys(40.0);
    statistics.setusage_cpu_percent(50);
    entity.setMigrationProgressPercent(50);
    return entity;
}
#end_block

#method_before
static VM getModel(int index) {
    VM model = new VM();
    model.setName(NAMES[index]);
    model.setDescription(DESCRIPTIONS[index]);
    model.setId(GUIDS[0].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    return model;
}
#method_after
static VM getModel(int index) {
    VM model = new VM();
    model.setName(NAMES[index]);
    model.setDescription(DESCRIPTIONS[index]);
    model.setId(GUIDS[index].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    return model;
}
#end_block

#method_before
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VM.class), control.createMock(VmStatistics.class), index);
}
#method_after
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    return setUpEntityExpectations(vm, vm.getStatisticsData(), index);
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VM getEntityWithProvidedId(int index, Guid vmId) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VM.class), control.createMock(VmStatistics.class), index, vmId);
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VM getEntityWithProvidedId(int index, Guid vmId) {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    return setUpEntityExpectations(vm, vm.getStatisticsData(), index, vmId);
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VmTemplate getTemplateEntity(int index) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VmTemplate.class), index);
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VmTemplate getTemplateEntity(int index) {
    org.ovirt.engine.core.common.businessentities.VmTemplate template = new org.ovirt.engine.core.common.businessentities.VmTemplate();
    return setUpEntityExpectations(template, index);
}
#end_block

#method_before
protected void readHardwareSection(XmlNode section) {
    for (XmlNode node : section.SelectNodes("Item")) {
        switch(node.SelectSingleNode("rasd:ResourceType", _xmlNS).innerText) {
            case OvfHardware.CPU:
                readCpuItem(node);
                break;
            case OvfHardware.Memory:
                readMemoryItem(node);
                break;
            case OvfHardware.DiskImage:
                readDiskImageItem(node);
                break;
            case OvfHardware.Network:
                readNetworkItem(node);
                break;
            case OvfHardware.USB:
                readUsbItem(node);
                break;
            case OvfHardware.Monitor:
                readMonitorItem(node);
                break;
            case OvfHardware.CD:
                readCdItem(node);
                break;
            case OvfHardware.OTHER:
                readOtherHardwareItem(node);
                break;
        }
    }
}
#method_after
protected void readHardwareSection(XmlNode section) {
    boolean readVirtioSerial = false;
    for (XmlNode node : section.SelectNodes("Item")) {
        switch(node.SelectSingleNode("rasd:ResourceType", _xmlNS).innerText) {
            case OvfHardware.CPU:
                readCpuItem(node);
                break;
            case OvfHardware.Memory:
                readMemoryItem(node);
                break;
            case OvfHardware.DiskImage:
                readDiskImageItem(node);
                break;
            case OvfHardware.Network:
                readNetworkItem(node);
                break;
            case OvfHardware.USB:
                readUsbItem(node);
                break;
            case OvfHardware.Monitor:
                readMonitorItem(node);
                break;
            case OvfHardware.CD:
                readCdItem(node);
                break;
            case OvfHardware.OTHER:
                VmDevice vmDevice = readOtherHardwareItem(node);
                readVirtioSerial = readVirtioSerial || VmDeviceType.VIRTIOSERIAL.getName().equals(vmDevice.getDevice());
                break;
        }
    }
    if (!readVirtioSerial) {
        addManagedVmDevice(VmDeviceCommonUtils.createVirtioSerialDeviceForVm(vmBase.getId()));
    }
}
#end_block

#method_before
protected void readMonitorItem(XmlNode node) {
    vmBase.setNumOfMonitors(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).innerText));
    if (node.SelectSingleNode("rasd:SinglePciQxl", _xmlNS) != null) {
        vmBase.setSingleQxlPci(Boolean.parseBoolean(node.SelectSingleNode("rasd:SinglePciQxl", _xmlNS).innerText));
    }
}
#method_after
protected void readMonitorItem(XmlNode node) {
    vmBase.setNumOfMonitors(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).innerText));
    if (node.SelectSingleNode("rasd:SinglePciQxl", _xmlNS) != null) {
        vmBase.setSingleQxlPci(Boolean.parseBoolean(node.SelectSingleNode("rasd:SinglePciQxl", _xmlNS).innerText));
    }
    if (new Version(getVersion()).compareTo(Version.v3_1) >= 0) {
        readManagedVmDevice(node, Guid.newGuid());
    } else {
        // case we need to add monitor devices according to the numOfMonitors field
        for (int i = 0; i < vmBase.getNumOfMonitors(); ++i) {
            readManagedVmDevice(node, Guid.newGuid());
        }
    }
}
#end_block

#method_before
private void readOtherHardwareItem(XmlNode node) {
    boolean managed = false;
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText)) {
        VmDeviceGeneralType type = VmDeviceGeneralType.forValue(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText));
        String device = node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).innerText;
        // special devices are treated as managed devices but still have the OTHER OVF ResourceType
        managed = VmDeviceCommonUtils.isSpecialDevice(device, type);
    }
    if (managed) {
        readManagedVmDevice(node, Guid.newGuid());
    } else {
        readUnmanagedVmDevice(node, Guid.newGuid());
    }
}
#method_after
private VmDevice readOtherHardwareItem(XmlNode node) {
    boolean managed = false;
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText)) {
        VmDeviceGeneralType type = VmDeviceGeneralType.forValue(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).innerText));
        String device = node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).innerText;
        // special devices are treated as managed devices but still have the OTHER OVF ResourceType
        managed = VmDeviceCommonUtils.isSpecialDevice(device, type);
    }
    return managed ? readManagedVmDevice(node, Guid.newGuid()) : readUnmanagedVmDevice(node, Guid.newGuid());
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = content.SelectSingleNode(OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = content.SelectSingleNode(OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = content.SelectSingleNode(OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = content.SelectSingleNode(OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode(OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = content.SelectSingleNode(OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(new Version(getVersion())) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    node = content.SelectSingleNode(OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    readGeneralData(content);
    readVmInit(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = content.SelectSingleNode(OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = content.SelectSingleNode(OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    node = content.SelectSingleNode(OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = content.SelectSingleNode(OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = content.SelectSingleNode(OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode(OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(new Version(getVersion())) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // due to depndency on vmBase.getOsId() must be read AFTER readOsSection
    node = content.SelectSingleNode(OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = content.SelectSingleNode(OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode(OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    node = content.SelectSingleNode(OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    readGeneralData(content);
    readVmInit(content);
}
#end_block

#method_before
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    String networkName = node.SelectSingleNode(OvfProperties.VMD_CONNECTION, _xmlNS).innerText;
    iface.setNetworkName(StringUtils.defaultIfEmpty(networkName, null));
    XmlNode vnicProfileNameNode = node.SelectSingleNode(OvfProperties.VMD_VNIC_PROFILE_NAME, _xmlNS);
    iface.setVnicProfileName(vnicProfileNameNode == null ? null : StringUtils.defaultIfEmpty(vnicProfileNameNode.innerText, null));
    XmlNode linkedNode = node.SelectSingleNode(OvfProperties.VMD_LINKED, _xmlNS);
    iface.setLinked(linkedNode == null ? true : Boolean.valueOf(linkedNode.innerText));
    String resourceSubType = node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).innerText;
    if (StringUtils.isNotEmpty(resourceSubType)) {
        iface.setType(Integer.parseInt(resourceSubType));
    }
    XmlNode speed = node.SelectSingleNode("rasd:speed", _xmlNS);
    iface.setSpeed((speed != null) ? Integer.parseInt(speed.innerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#method_after
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    String networkName = node.SelectSingleNode(OvfProperties.VMD_CONNECTION, _xmlNS).innerText;
    iface.setNetworkName(StringUtils.defaultIfEmpty(networkName, null));
    XmlNode vnicProfileNameNode = node.SelectSingleNode(OvfProperties.VMD_VNIC_PROFILE_NAME, _xmlNS);
    iface.setVnicProfileName(vnicProfileNameNode == null ? null : StringUtils.defaultIfEmpty(vnicProfileNameNode.innerText, null));
    XmlNode linkedNode = node.SelectSingleNode(OvfProperties.VMD_LINKED, _xmlNS);
    iface.setLinked(linkedNode == null ? true : Boolean.valueOf(linkedNode.innerText));
    iface.setName(node.SelectSingleNode(OvfProperties.VMD_NAME, _xmlNS).innerText);
    String resourceSubType = node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).innerText;
    if (StringUtils.isNotEmpty(resourceSubType)) {
        iface.setType(Integer.parseInt(resourceSubType));
    }
    XmlNode speed = node.SelectSingleNode("rasd:speed", _xmlNS);
    iface.setSpeed((speed != null) ? Integer.parseInt(speed.innerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#end_block

#method_before
private void setDeviceByResource(XmlNode node, VmDevice vmDevice) {
    int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
    int resourceSubType = getResourceType(node, OvfProperties.VMD_SUB_RESOURCE_TYPE);
    if (resourceSubType == -1) {
        // we need special handling for Monitor to define it as vnc or spice
        if (Integer.valueOf(OvfHardware.Monitor) == resourceType) {
            // if default display type is defined in the ovf, set the video device that is suitable for it
            if (defaultDisplayType != null) {
                VmDeviceType vmDeviceType = getDisplayDevice(defaultDisplayType);
                vmDevice.setDevice(vmDeviceType.getName());
            } else {
                // get number of monitors from VirtualQuantity in OVF
                if (node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).innerText)) {
                    int virtualQuantity = Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).innerText);
                    if (virtualQuantity > 1) {
                        vmDevice.setDevice(VmDeviceType.QXL.getName());
                    } else {
                        VmDeviceType vmDeviceType = getDisplayDevice(DisplayType.vga);
                        vmDevice.setDevice(vmDeviceType.getName());
                    }
                } else {
                    // default to spice if quantity not found
                    vmDevice.setDevice(VmDeviceType.QXL.getName());
                }
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    } else if (Integer.valueOf(OvfHardware.Network) == resourceType) {
        // handle interfaces with different sub types : we have 0-3 as the VmInterfaceType enum
        boolean isKnownType = false;
        for (VmInterfaceType vmInterfaceType : VmInterfaceType.values()) {
            if (Integer.valueOf(vmInterfaceType.getValue()) == resourceSubType) {
                vmDevice.setDevice(VmDeviceType.BRIDGE.getName());
                isKnownType = true;
                break;
            }
        }
        if (!isKnownType) {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    }
}
#method_after
private void setDeviceByResource(XmlNode node, VmDevice vmDevice) {
    int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
    int resourceSubType = getResourceType(node, OvfProperties.VMD_SUB_RESOURCE_TYPE);
    if (resourceSubType == -1) {
        // we need special handling for Monitor to define it as vnc or spice
        if (Integer.valueOf(OvfHardware.Monitor) == resourceType) {
            // if default display type is defined in the ovf, set the video device that is suitable for it
            if (defaultDisplayType != null) {
                VmDeviceType vmDeviceType = getDisplayDevice(defaultDisplayType);
                vmDevice.setDevice(vmDeviceType.getName());
            } else {
                // get number of monitors from VirtualQuantity in OVF
                if (node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).innerText)) {
                    int virtualQuantity = Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).innerText);
                    if (virtualQuantity > 1) {
                        vmDevice.setDevice(VmDeviceType.QXL.getName());
                    } else {
                        // todo - this is only workaround until OsInfo patchset
                        // get display types compatible with OS
                        List<DisplayType> displayTypes = osRepository.getDisplayTypes(vmBase.getOsId(), new Version(getVersion()));
                        if (displayTypes.contains(DisplayType.qxl)) {
                            // preserve behavior of previous code - qxl was never set in this branch
                            displayTypes.remove(DisplayType.qxl);
                        }
                        DisplayType displayType = (!displayTypes.isEmpty()) ? // select first compatible device
                        displayTypes.get(0) : DisplayType.cirrus;
                        vmDevice.setDevice(displayType.getDefaultVmDeviceType().getName());
                    }
                } else {
                    // default to spice if quantity not found
                    vmDevice.setDevice(VmDeviceType.QXL.getName());
                }
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    } else if (Integer.valueOf(OvfHardware.Network) == resourceType) {
        // handle interfaces with different sub types : we have 0-3 as the VmInterfaceType enum
        boolean isKnownType = false;
        for (VmInterfaceType vmInterfaceType : VmInterfaceType.values()) {
            if (Integer.valueOf(vmInterfaceType.getValue()) == resourceSubType) {
                vmDevice.setDevice(VmDeviceType.BRIDGE.getName());
                isKnownType = true;
                break;
            }
        }
        if (!isKnownType) {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    }
}
#end_block

#method_before
private CreateImageTemplateParameters buildChildCommandParameters(DiskImage diskImage, Guid vmSnapshotId) {
    CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
    createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
    createParams.setVmSnapshotId(vmSnapshotId);
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationStorageDomainId(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0));
    createParams.setDiskAlias(diskInfoDestinationMap.get(diskImage.getId()).getDiskAlias());
    createParams.setParentParameters(getParameters());
    createParams.setQuotaId(getQuotaIdForDisk(diskImage));
    return createParams;
}
#method_after
private CreateImageTemplateParameters buildChildCommandParameters(DiskImage diskImage, Guid vmSnapshotId) {
    CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
    createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
    createParams.setVmSnapshotId(vmSnapshotId);
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationStorageDomainId(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0));
    createParams.setDiskAlias(diskInfoDestinationMap.get(diskImage.getId()).getDiskAlias());
    createParams.setParentParameters(getParameters());
    createParams.setQuotaId(getQuotaIdForDisk(diskImage));
    createParams.setDiskProfileId(diskInfoDestinationMap.get(diskImage.getId()).getDiskProfileId());
    return createParams;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.infoFormat("Cancelling current running update for vms for base template id {0}", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warnFormat("Failed deleting job {0} at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), getParameters().getGraphicsDevices().keySet(), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // todo osinfo followup
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // todo osinfo followup
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVdsGroup().getcompatibility_version(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    if (CommandCoordinatorUtil.getCommandExecutionStatus(getParameters().getCommandId()) == CommandExecutionStatus.EXECUTED) {
        // if template exist in db remove it
        if (getVmTemplate() != null) {
            DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
            removeNetwork();
        }
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warnFormat("Failed to run VM {0}: {1}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Trying to rerun VM {0}", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(e.getErrorCode()) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    reportCompleted();
                    throw e;
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    runningFailed();
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#end_block

#method_before
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.errorFormat("VM {0} ({1}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
        removeVmStatlessImages();
    } else {
        log.infoFormat("Creating stateless snapshot for VM {0} ({1})", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("Failed to create stateless snapshot for VM {0} ({1})", getVm().getName(), getVm().getId());
        }
    }
}
#method_after
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.error("VM '{}' ({}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
        removeVmStatlessImages();
    } else {
        log.info("Creating stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.error("Failed to create stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
        }
    }
}
#end_block

#method_before
protected VMStatus createVm() {
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.infoFormat("Running VM with attached cd {0}", cdPath);
    }
    updateCurrentCd(cdPath);
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    initParametersForExternalNetworks();
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#method_after
protected VMStatus createVm() {
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.info("Running VM with attached cd '{}'", cdPath);
    }
    updateCurrentCd(cdPath);
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    initParametersForExternalNetworks();
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    boolean isVdsKnown = getVds() != null;
                    if (isStateless && isVdsKnown) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : (isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM) : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : (isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM) : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                getVm().setInitializationType(InitializationType.Sysprep);
            } else if (getVm().getVmInit() != null) {
                getVm().setInitializationType(InitializationType.CloudInit);
            } else {
                getVm().setInitializationType(InitializationType.None);
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
    VmHandler.updateVmGuestAgentVersion(getVm());
    getVm().setCpuName(getVdsGroup().getcpu_name());
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(CpuFlagsManagerHandler.getCpuId(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine((getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getVdsGroup().getEmulatedMachine()));
    }
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    if (isRunAsStateless()) {
        return validateSpaceRequirements();
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.errorFormat("Could not run VM {0} ({1}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/devices/watchdog/models").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/devices/maxPciDevices").put("value", MAX_PCI_DEVICES);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    // will be adjusted in next patch
    preferences.node("/os/rhel7/devices/display/protocols").put("value", "vga/cirrus,qxl/qxl");
    preferences.node("/os/rhel7/devices/balloon/enabled").put("value", "true");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    preferences.node("/os/windows_7/devices/hyperv/enabled").put("value", "true");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/devices/watchdog/models").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/devices/maxPciDevices").put("value", MAX_PCI_DEVICES);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    // todo os info follow up
    preferences.node("/os/rhel7/devices/display/protocols").put("value", "vga/cirrus,qxl/qxl");
    preferences.node("/os/rhel7/devices/balloon/enabled").put("value", "true");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    preferences.node("/os/windows_7/id").put("value", "11");
    preferences.node("/os/windows_7/sysprepFileName").put("value", UNATTEND_XML);
    preferences.node("/os/windows_7/devices/hyperv/enabled").put("value", "true");
    preferences.node("/os/windows_8/cpu/unsupported").put("value", "conroe, opteron_g1");
    preferences.node("/os/windows_8/sysprepFileName").put("value", UNATTEND_XML);
    preferences.node("/os/windows_xp/id").put("value", "1");
    preferences.node("/os/windows_xp/sysprepFileName").put("value", SYSPREP_INF);
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    result = prime * result + (stopReason == null ? 0 : stopReason.hashCode());
    result = prime * result + exitReason.hashCode();
    result = prime * result + graphicsInfos.hashCode();
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    result = prime * result + (stopReason == null ? 0 : stopReason.hashCode());
    result = prime * result + exitReason.hashCode();
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + graphicsInfos.hashCode();
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd) && ObjectUtils.objectsEqual(stopReason, other.stopReason) && exitReason == other.exitReason) && ObjectUtils.objectsEqual(graphicsInfos, other.getGraphicsInfos());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd) && ObjectUtils.objectsEqual(stopReason, other.stopReason) && exitReason == other.exitReason && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine)) && ObjectUtils.objectsEqual(graphicsInfos, other.getGraphicsInfos());
}
#end_block

#method_before
@Override
public int compareTo(VmDynamic o) {
    return BusinessEntityGuidComparator.<VmDynamic>newInstance().compare(this, o);
}
#method_after
@Override
public int compareTo(VmDynamic o) {
    return BusinessEntityComparator.<VmDynamic, Guid>newInstance().compare(this, o);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    resource.getParent().backend = backend;
    resource.getParent().sessionHelper = sessionHelper;
    resource.getParent().mappingLocator = resource.mappingLocator;
    resource.getParent().httpHeaders = httpHeaders;
    resource.getParent().messageBundle = messageBundle;
    OsTypeMockUtils.mockOsTypes();
    initBackendResource(vmHelper);
}
#method_after
@Override
protected void init() {
    super.init();
    resource.getParent().backend = backend;
    resource.getParent().sessionHelper = sessionHelper;
    resource.getParent().mappingLocator = resource.mappingLocator;
    resource.getParent().httpHeaders = httpHeaders;
    resource.getParent().messageBundle = messageBundle;
    OsTypeMockUtils.mockOsTypes();
}
#end_block

#method_before
public void testGetConsoleAware(boolean allContent) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetConsoleExpectations(new int[] { 0 });
        setUpGetVirtioScsiExpectations(new int[] { 0 });
        setUpGetRngDeviceExpectations(new int[] { 0 });
        setUpGetVmOvfExpectations(new int[] { 0 });
    }
    setUpGetEntityExpectations(1);
    setUpGetPayloadExpectations(0, 1);
    setUpGetBallooningExpectations();
    setUpGetCertuficateExpectations();
    control.replay();
    VM response = resource.get();
    verifyModel(response, 0);
    verifyCertificate(response);
    List<String> populateHeader = httpHeaders.getRequestHeader(BackendResource.POPULATE);
    boolean populated = populateHeader != null ? populateHeader.contains("true") : false;
    assertTrue(populated ? response.isSetConsole() : !response.isSetConsole());
}
#method_after
public void testGetConsoleAware(boolean allContent) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetConsoleExpectations(new int[] { 0 });
        setUpGetVirtioScsiExpectations(new int[] { 0 });
        setUpGetSoundcardExpectations(new int[] { 0 });
        setUpGetRngDeviceExpectations(new int[] { 0 });
        setUpGetVmOvfExpectations(new int[] { 0 });
    }
    setUpGetEntityExpectations(1);
    setUpGetPayloadExpectations(0, 1);
    setUpGetBallooningExpectations();
    setUpGetCertuficateExpectations();
    control.replay();
    VM response = resource.get();
    verifyModel(response, 0);
    verifyCertificate(response);
    List<String> populateHeader = httpHeaders.getRequestHeader(BackendResource.POPULATE);
    boolean populated = populateHeader != null ? populateHeader.contains("true") : false;
    assertTrue(populated ? response.isSetConsole() : !response.isSetConsole());
}
#end_block

#method_before
@Test
public void testUpdate() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    verifyModel(resource.update(getModel(0)), 0);
}
#method_after
@Test
public void testUpdate() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    verifyModel(resource.update(getModel(0)), 0);
}
#end_block

#method_before
@Test
public void testUpdateRemovingPayloads() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 1);
    setUpGetNoPayloadExpectations(0, 1);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    verifyModelClearingPayloads(resource.update(getModelClearingPayloads(0)), 0);
}
#method_after
@Test
public void testUpdateRemovingPayloads() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 1);
    setUpGetNoPayloadExpectations(0, 1);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    verifyModelClearingPayloads(resource.update(getModelClearingPayloads(0)), 0);
}
#end_block

#method_before
@Test
public void testUpdateVmPolicy() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    VM model = getModel(0);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    verifyModel(resource.update(model), 0);
}
#method_after
@Test
public void testUpdateVmPolicy() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    VM model = getModel(0);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    verifyModel(resource.update(model), 0);
}
#end_block

#method_before
@Test
public void testUpdateMovingCluster() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.ChangeVMCluster, ChangeVMClusterParameters.class, new String[] { "ClusterId", "VmId" }, new Object[] { GUIDS[1], GUIDS[0] }, true, true, false));
    setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true);
    VM model = getModel(0);
    model.setId(GUIDS[0].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    verifyModelOnNewCluster(resource.update(model), 0);
}
#method_after
@Test
public void testUpdateMovingCluster() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(0);
    setUpGetVmOvfExpectations(0);
    setUpGetVirtioScsiExpectations(0);
    setUpGetSoundcardExpectations(0);
    setUpGetRngDeviceExpectations(0);
    setUriInfo(setUpActionExpectations(VdcActionType.ChangeVMCluster, ChangeVMClusterParameters.class, new String[] { "ClusterId", "VmId" }, new Object[] { GUIDS[1], GUIDS[0] }, true, true, false));
    setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true);
    VM model = getModel(0);
    model.setId(GUIDS[0].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    verifyModelOnNewCluster(resource.update(model), 0);
}
#end_block

#method_before
@Test
public void testStartWithBootDev() throws Exception {
    setUpWindowsGetEntityExpectations(1, false);
    setUriInfo(setUpActionExpectations(VdcActionType.RunVmOnce, RunVmOnceParams.class, new String[] { "VmId", "BootSequence" }, new Object[] { GUIDS[0], BootSequence.N }));
    Action action = new Action();
    action.setVm(new VM());
    action.getVm().setOs(new OperatingSystem());
    action.getVm().getOs().getBoot().add(new Boot());
    action.getVm().getOs().getBoot().get(0).setDev(BootDevice.NETWORK.value());
    verifyActionResponse(resource.start(action));
}
#method_after
// todo  restapi follow up
// @Test
// public void testStartWithVnc() throws Exception {
// setUpWindowsGetEntityExpectations(1, false);
// setUriInfo(setUpActionExpectations(VdcActionType.RunVmOnce,
// RunVmOnceParams.class,
// new String[] { "VmId", "UseVnc" },
// new Object[] { GUIDS[0], Boolean.TRUE }));
// 
// Action action = new Action();
// action.setVm(new VM());
// action.getVm().setDisplay(new Display());
// action.getVm().getDisplay().setType(DisplayType.VNC.value());
// 
// verifyActionResponse(resource.start(action));
// }
@Test
public void testStartWithBootDev() throws Exception {
    setUpWindowsGetEntityExpectations(1, false);
    setUriInfo(setUpActionExpectations(VdcActionType.RunVmOnce, RunVmOnceParams.class, new String[] { "VmId", "BootSequence" }, new Object[] { GUIDS[0], BootSequence.N }));
    Action action = new Action();
    action.setVm(new VM());
    action.getVm().setOs(new OperatingSystem());
    action.getVm().getOs().getBoot().add(new Boot());
    action.getVm().getOs().getBoot().get(0).setDev(BootDevice.NETWORK.value());
    verifyActionResponse(resource.start(action));
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VM setUpStatisticalExpectations() throws Exception {
    VmStatistics stats = control.createMock(VmStatistics.class);
    org.ovirt.engine.core.common.businessentities.VM entity = control.createMock(org.ovirt.engine.core.common.businessentities.VM.class);
    setUpStatisticalEntityExpectations(entity, stats);
    setUpGetEntityExpectations(1, false, entity);
    control.replay();
    return entity;
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VM setUpStatisticalExpectations() throws Exception {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    setUpStatisticalEntityExpectations(entity, entity.getStatisticsData());
    setUpGetEntityExpectations(1, false, entity);
    control.replay();
    return entity;
}
#end_block

#method_before
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VM.class), control.createMock(VmStatistics.class), index);
}
#method_after
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    return setUpEntityExpectations(vm, vm.getStatisticsData(), index);
}
#end_block

#method_before
protected void verifyModelOnNewCluster(VM model, int index) {
    assertNotNull(model.getCluster().getId());
    assertEquals(GUIDS[2].toString(), model.getCluster().getId());
    verifyModel(model, index);
}
#method_after
protected void verifyModelOnNewCluster(VM model, int index) {
    assertNotNull(model.getCluster().getId());
    assertEquals(GUIDS[1].toString(), model.getCluster().getId());
    verifyModel(model, index);
}
#end_block

#method_before
private VmPayload getPayloadModel() {
    VmPayload payload = new VmPayload();
    payload.setType(VmDeviceType.CDROM);
    payload.getFiles().put("payloadFile", new String(Base64.decodeBase64(PAYLOAD_COMTENT)));
    return payload;
}
#method_after
private VmPayload getPayloadModel() {
    VmPayload payload = new VmPayload();
    payload.setDeviceType(VmDeviceType.CDROM);
    payload.getFiles().put("payloadFile", new String(Base64.decodeBase64(PAYLOAD_COMTENT)));
    return payload;
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            Integer maxSockets = Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, vm.getVdsGroupCompatibilityVersion().getValue());
            Integer maxVCpus = Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, vm.getVdsGroupCompatibilityVersion().getValue());
            maxVCpus = Math.min(maxVCpus, (vm.getCpuPerSocket() * maxSockets));
            createInfo.put(VdsProperties.max_number_of_cpus, maxVCpus.toString());
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.put(VdsProperties.emulatedMachine, getVdsGroup().getEmulatedMachine());
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.put(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    addNumaSetting(compatibilityVersion);
    if (vm.getGraphicsInfos().containsKey(GraphicsType.SPICE)) {
        createInfo.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        createInfo.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
    }
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getVdsGroupCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#method_after
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (vm.getGraphicsInfos().containsKey(GraphicsType.SPICE)) {
        createInfo.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        createInfo.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
    }
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getVdsGroupCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        getCustomPropertySheet().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getCpuProfiles().setIsChangable(false);
        getVmId().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCustomCpu().setIsChangable(false);
        getEmulatedMachine().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        getMigrationDowntime().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        getCustomPropertySheet().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangable(true);
            }
        }
    }
}
#end_block

#method_before
private void WatchdogModel_EntityChanged(Object sender, EventArgs args) {
    if ("".equals(getWatchdogModel().getEntity())) {
        getWatchdogAction().setIsChangable(false);
        // $NON-NLS-1$
        getWatchdogAction().setSelectedItem("");
    } else {
        getWatchdogAction().setIsChangable(true);
    }
}
#method_after
private void WatchdogModel_EntityChanged(Object sender, EventArgs args) {
    if (getWatchdogModel().getEntity() == null) {
        getWatchdogAction().setIsChangable(false);
        // $NON-NLS-1$
        getWatchdogAction().setSelectedItem(null);
    } else {
        getWatchdogAction().setIsChangable(true);
    }
}
#end_block

#method_before
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayProtocol().getSelectedItem() != null ? getDisplayProtocol().getSelectedItem().getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    UsbPolicy prevSelectedUsbPolicy = getUsbPolicy().getSelectedItem();
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.getInstance().isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.getInstance().isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    Collection<UsbPolicy> policies = getUsbPolicy().getItems();
    if (policies.contains(prevSelectedUsbPolicy)) {
        getUsbPolicy().setSelectedItem(prevSelectedUsbPolicy);
    } else if (policies.size() > 0) {
        getUsbPolicy().setSelectedItem(policies.iterator().next());
    }
}
#method_after
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayProtocol().getSelectedItem() != null ? getDisplayProtocol().getSelectedItem().getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    UsbPolicy prevSelectedUsbPolicy = getUsbPolicy().getSelectedItem();
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.getInstance().isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.getInstance().isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    if (getBehavior().basedOnCustomInstanceType()) {
        Collection<UsbPolicy> policies = getUsbPolicy().getItems();
        if (policies.contains(prevSelectedUsbPolicy)) {
            getUsbPolicy().setSelectedItem(prevSelectedUsbPolicy);
        } else if (policies.size() > 0) {
            getUsbPolicy().setSelectedItem(policies.iterator().next());
        }
    }
}
#end_block

#method_before
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    VDSGroup cluster = dataCenterWithCluster.getCluster();
    Boolean isMigrationSupported = AsyncDataProvider.getInstance().isMigrationSupported(cluster.getArchitecture(), cluster.getcompatibility_version());
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
}
#method_after
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    VDSGroup cluster = dataCenterWithCluster.getCluster();
    Version version = cluster.getcompatibility_version();
    Boolean isMigrationSupported = AsyncDataProvider.getInstance().isMigrationSupported(cluster.getArchitecture(), version);
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
    autoConverge.updateChangeability(ConfigurationValues.AutoConvergenceSupported, version);
    migrateCompressed.updateChangeability(ConfigurationValues.MigrationCompressionSupported, version);
}
#end_block

#method_before
private void updateDisplayProtocol() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<DisplayType> displayTypes = AsyncDataProvider.getInstance().getDisplayTypes(osType, cluster.getcompatibility_version());
    initDisplayProtocolWithTypes(displayTypes);
}
#method_after
private void updateDisplayProtocol() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<DisplayType> displayTypes = AsyncDataProvider.getInstance().getDisplayTypes(osType, cluster.getcompatibility_version());
    if (displayTypes == null) {
        Integer defaultOs = AsyncDataProvider.getInstance().getDefaultOs(cluster.getArchitecture());
        displayTypes = AsyncDataProvider.getInstance().getDisplayTypes(defaultOs, cluster.getcompatibility_version());
    }
    initDisplayProtocolWithTypes(displayTypes);
}
#end_block

#method_before
private void updateMemoryBalloonDevice() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    boolean isBalloonEnabled = AsyncDataProvider.getInstance().isBalloonEnabled(osType, cluster.getcompatibility_version());
    getMemoryBalloonDeviceEnabled().setIsChangable(isBalloonEnabled);
    getMemoryBalloonDeviceEnabled().setEntity(isBalloonEnabled);
    if (!isBalloonEnabled) {
        getBehavior().deactivateInstanceTypeManager();
        getMemoryBalloonDeviceEnabled().setEntity(isBalloonEnabled);
        getBehavior().activateInstanceTypeManager();
    }
}
#method_after
private void updateMemoryBalloonDevice() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    boolean isBalloonEnabled = AsyncDataProvider.getInstance().isBalloonEnabled(osType, cluster.getcompatibility_version());
    getMemoryBalloonDeviceEnabled().setIsChangable(isBalloonEnabled);
    if (getBehavior().basedOnCustomInstanceType()) {
        getMemoryBalloonDeviceEnabled().setEntity(isBalloonEnabled);
    }
}
#end_block

#method_before
private void updateWatchdogModels() {
    updateWatchdogModels((Integer) getOSType().getSelectedItem());
}
#method_after
private void updateWatchdogModels() {
    updateWatchdogModels(getOSType().getSelectedItem());
}
#end_block

#method_before
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.getInstance().get(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = (String) getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#method_after
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<VmWatchdogType> watchDogModels = new ArrayList<VmWatchdogType>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(vmWatchdogType);
    }
    watchDogModels.add(0, null);
    VmWatchdogType oldWatchdogSelected = getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#end_block

#method_before
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.getInstance().isWindowsOsType(osType) ? AsyncDataProvider.getInstance().getMaxVmNameLengthWin() : AsyncDataProvider.getInstance().getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setIsGeneralTabValid(getIsGeneralTabValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsHostTabValid(getIsHostTabValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getIsAllocationTabValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setIsFirstRunTabValid(vmInitIsValid);
    boolean isValid = hwPartValid && vmInitIsValid && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && getQuota().getIsValid();
    getValid().setEntity(isValid);
    return isValid;
}
#method_after
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.getInstance().isWindowsOsType(osType) ? AsyncDataProvider.getInstance().getMaxVmNameLengthWin() : AsyncDataProvider.getInstance().getMaxVmNameLengthNonWin()), isValidTab(TabName.POOL_TAB) ? new PoolNameValidation() : new I18NNameValidation() });
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getName().getIsValid() && getVmId().getIsValid() && getDescription().getIsValid() && getComment().getIsValid());
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.FIRST_RUN, vmInitIsValid);
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#end_block

#method_before
public boolean validateHwPart() {
    resetTabsValidity();
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getMinAllocatedMemory().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setRngTabValid(getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    boolean isValid = behaviorValid && customPropertySheetValid && getName().getIsValid() && getDescription().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getMigrationDowntime().getIsValid() && getRngBytes().getIsValid() && getRngPeriod().getIsValid() && getTotalCPUCores().getIsValid();
    getValid().setEntity(isValid);
    return isValid;
}
#method_after
public boolean validateHwPart() {
    resetTabsValidity();
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    getEmulatedMachine().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_EMULATED_MACHINE_SIZE) });
    getCustomCpu().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_CPU_NAME_SIZE) });
    boolean behaviorValid = behavior.validate();
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid());
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.CONSOLE_TAB, getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setValidTab(TabName.HOST_TAB, getMigrationDowntime().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setValidTab(TabName.TAB_RNG, getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, getMinAllocatedMemory().getIsValid());
    setValidTab(TabName.SYSTEM_TAB, getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && getEmulatedMachine().getIsValid() && getCustomCpu().getIsValid());
    boolean isValid = behaviorValid && allTabsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#end_block

#method_before
private void resetTabsValidity() {
    setIsGeneralTabValid(true);
    setIsSystemTabValid(true);
    setIsFirstRunTabValid(true);
    setIsDisplayTabValid(true);
    setIsHostTabValid(true);
    setIsAllocationTabValid(true);
    setIsBootSequenceTabValid(true);
    setRngTabValid(true);
    setIsCustomPropertiesTabValid(true);
    getValid().setEntity(true);
}
#method_after
private void resetTabsValidity() {
    setValidTab(TabName.HOST_TAB, true);
    setIsCustomPropertiesTabAvailable(true);
    setValidTab(TabName.TAB_RNG, true);
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, true);
    setValidTab(TabName.BOOT_OPTIONS_TAB, true);
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, true);
    setValidTab(TabName.CONSOLE_TAB, true);
    setValidTab(TabName.INITIAL_RUN_TAB, true);
    setValidTab(TabName.GENERAL_TAB, true);
    getValid().setEntity(true);
}
#end_block

#method_before
public ListModel<String> getWatchdogModel() {
    return watchdogModel;
}
#method_after
public ListModel<VmWatchdogType> getWatchdogModel() {
    return watchdogModel;
}
#end_block

#method_before
public void setWatchdogModel(ListModel<String> watchdogModel) {
    this.watchdogModel = watchdogModel;
}
#method_after
public void setWatchdogModel(ListModel<VmWatchdogType> watchdogModel) {
    this.watchdogModel = watchdogModel;
}
#end_block

#method_before
public ListModel<String> getWatchdogAction() {
    return watchdogAction;
}
#method_after
public ListModel<VmWatchdogAction> getWatchdogAction() {
    return watchdogAction;
}
#end_block

#method_before
public void setWatchdogAction(ListModel<String> watchdogAction) {
    this.watchdogAction = watchdogAction;
}
#method_after
public void setWatchdogAction(ListModel<VmWatchdogAction> watchdogAction) {
    this.watchdogAction = watchdogAction;
}
#end_block

#method_before
private void addBricks(GlusterVolumeEntity volumeEntity) {
    final VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(volumeEntity.getReplicaCount());
    volumeBrickModel.getReplicaCount().setIsChangable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(volumeEntity.getVolumeType().isReplicatedType());
    volumeBrickModel.getStripeCount().setEntity(volumeEntity.getStripeCount());
    volumeBrickModel.getStripeCount().setIsChangable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(volumeEntity.getVolumeType().isStripedType());
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
    volumeBrickModel.setHelpTag(HelpTag.add_bricks);
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    volumeBrickModel.getVolumeType().setEntity(volumeEntity.getVolumeType());
    setWindow(volumeBrickModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(volumeBrickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VDSGroup cluster = (VDSGroup) result;
            volumeBrickModel.getForce().setIsAvailable(GlusterFeaturesUtil.isGlusterForceAddBricksSupported(cluster.getcompatibility_version()));
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    Iterator<VDS> iterator = hostList.iterator();
                    while (iterator.hasNext()) {
                        if (iterator.next().getStatus() != VDSStatus.Up) {
                            iterator.remove();
                        }
                    }
                    final LexoNumericComparator lexoNumeric = new LexoNumericComparator();
                    Collections.sort(hostList, new Comparator<VDS>() {

                        @Override
                        public int compare(VDS host0, VDS host1) {
                            return lexoNumeric.compare(host0.getHostName(), host1.getHostName());
                        }
                    });
                    volumeBrickModel.getServers().setItems(hostList);
                }
            };
            AsyncDataProvider.getInstance().getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getInstance().getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel<GlusterBrickEntity>>());
    // $NON-NLS-1$
    UICommand command = new UICommand("OnAddBricks", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    volumeBrickModel.getCommands().add(command);
}
#method_after
private void addBricks(GlusterVolumeEntity volumeEntity) {
    final VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(volumeEntity.getReplicaCount());
    volumeBrickModel.getReplicaCount().setIsChangable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(volumeEntity.getVolumeType().isReplicatedType());
    volumeBrickModel.getStripeCount().setEntity(volumeEntity.getStripeCount());
    volumeBrickModel.getStripeCount().setIsChangable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(volumeEntity.getVolumeType().isStripedType());
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
    volumeBrickModel.setHelpTag(HelpTag.add_bricks);
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    volumeBrickModel.getVolumeType().setEntity(volumeEntity.getVolumeType());
    setWindow(volumeBrickModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(volumeBrickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VDSGroup cluster = (VDSGroup) result;
            volumeBrickModel.getForce().setIsAvailable(GlusterFeaturesUtil.isGlusterForceAddBricksSupported(cluster.getcompatibility_version()));
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    Iterator<VDS> iterator = hostList.iterator();
                    while (iterator.hasNext()) {
                        if (iterator.next().getStatus() != VDSStatus.Up) {
                            iterator.remove();
                        }
                    }
                    volumeBrickModel.setHostList(hostList);
                }
            };
            AsyncDataProvider.getInstance().getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getInstance().getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel<GlusterBrickEntity>>());
    // $NON-NLS-1$
    UICommand command = new UICommand("OnAddBricks", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    volumeBrickModel.getCommands().add(command);
}
#end_block

#method_before
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit) {
    switch(policyUnit.getName()) {
        case "Migration":
            return new MigrationPolicyUnit(policyUnit);
        case "NUMA":
            return new NumaFilterPolicyUnit(policyUnit);
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit);
        case "CPU":
            return new CPUPolicyUnit(policyUnit);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit);
        case "Network":
            return new NetworkPolicyUnit(policyUnit);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new HostedEngineHAClusterWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.FILTER) {
                return new HostedEngineHAClusterFilterPolicyUnit(policyUnit);
            }
            break;
        case "OptimalForHaReservation":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new HaReservationWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new HaReservationBalancePolicyUnit(policyUnit);
            }
            break;
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new NoneWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new NoneBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new PowerSavingWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new PowerSavingBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new EvenDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new EvenDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenGuestDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new EvenGuestDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new EvenGuestDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        case "VmAffinityGroups":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.FILTER) {
                return new VmAffinityFilterPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new VmAffinityWeightPolicyUnit(policyUnit);
            }
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#method_after
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit) {
    switch(policyUnit.getName()) {
        case "Migration":
            return new MigrationPolicyUnit(policyUnit);
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit);
        case "CPU":
            return new CPUPolicyUnit(policyUnit);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit);
        case "Network":
            return new NetworkPolicyUnit(policyUnit);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new HostedEngineHAClusterWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.FILTER) {
                return new HostedEngineHAClusterFilterPolicyUnit(policyUnit);
            }
            break;
        case "OptimalForHaReservation":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new HaReservationWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new HaReservationBalancePolicyUnit(policyUnit);
            }
            break;
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new NoneWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new NoneBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new PowerSavingWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new PowerSavingBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new EvenDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new EvenDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenGuestDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new EvenGuestDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new EvenGuestDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        case "VmAffinityGroups":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.FILTER) {
                return new VmAffinityFilterPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new VmAffinityWeightPolicyUnit(policyUnit);
            }
        case "Emulated-Machine":
            return new EmulatedMachineFilterPolicyUnit(policyUnit);
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction() || !checkStorageDomain() || !checkStorageDomainStatus(StorageDomainStatus.Active) || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    // Only after validating the existing of the storage domain in DB, we set the field lastTimeUsedAsMaster in the
    // storage domain which is about to be updated.
    oldDomain = getStorageDomainStaticDAO().get(getStorageDomain().getId());
    getStorageDomain().setLastTimeUsedAsMaster(oldDomain.getLastTimeUsedAsMaster());
    // Collect changed fields to update in a list.
    List<String> props = ObjectIdentityChecker.GetChangedFields(oldDomain, getStorageDomain().getStorageStaticData());
    // Allow change only to name & description field
    props.remove("storageName");
    props.remove("description");
    props.remove("comment");
    props.remove("wipeAfterDelete");
    if (!props.isEmpty()) {
        log.warn("There was an attempt to update the following fields although they are not allowed to be updated: {}", StringUtils.join(props, ","));
        return failCanDoAction(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_DOMAIN_FIELDS);
    }
    _storageDomainNameChanged = !StringUtils.equals(oldDomain.getStorageName(), getStorageDomain().getStorageName());
    // order to change description in spm
    if (_storageDomainNameChanged && !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (_storageDomainNameChanged && isStorageWithSameNameExists()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction() || !checkStorageDomain() || !checkStorageDomainStatus(StorageDomainStatus.Active) || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    // Only after validating the existing of the storage domain in DB, we set the field lastTimeUsedAsMaster in the
    // storage domain which is about to be updated.
    oldDomain = getStorageDomainStaticDAO().get(getStorageDomain().getId());
    getStorageDomain().setLastTimeUsedAsMaster(oldDomain.getLastTimeUsedAsMaster());
    // Collect changed fields to update in a list.
    List<String> props = ObjectIdentityChecker.GetChangedFields(oldDomain, getStorageDomain().getStorageStaticData());
    // Allow change only to name, description, comment and wipe after delete fields.
    props.remove("storageName");
    props.remove("description");
    props.remove("comment");
    props.remove("wipeAfterDelete");
    if (!props.isEmpty()) {
        log.warn("There was an attempt to update the following fields although they are not allowed to be updated: {}", StringUtils.join(props, ","));
        return failCanDoAction(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_DOMAIN_FIELDS);
    }
    _storageDomainNameChanged = !StringUtils.equals(oldDomain.getStorageName(), getStorageDomain().getStorageName());
    // order to change description in spm
    if (_storageDomainNameChanged && !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (_storageDomainNameChanged && isStorageWithSameNameExists()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    return true;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StorageDomainStatic other = (StorageDomainStatic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoRecoverable == other.autoRecoverable && containsUnregisteredEntities == other.containsUnregisteredEntities && ObjectUtils.objectsEqual(connection, other.connection) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storage, other.storage) && storageFormat == other.storageFormat && storagePoolType == other.storagePoolType && storageType == other.storageType && sanState == other.sanState && wipeAfterDelete == other.wipeAfterDelete && ObjectUtils.objectsEqual(description, other.description));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StorageDomainStatic other = (StorageDomainStatic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoRecoverable == other.autoRecoverable && containsUnregisteredEntities == other.containsUnregisteredEntities && ObjectUtils.objectsEqual(connection, other.connection) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storage, other.storage) && storageFormat == other.storageFormat && storagePoolType == other.storagePoolType && storageType == other.storageType && sanState == other.sanState && ObjectUtils.objectsEqual(wipeAfterDelete, other.wipeAfterDelete) && ObjectUtils.objectsEqual(description, other.description));
}
#end_block

#method_before
RequestBuilder createRequest() {
    RequestBuilder builder = new RequestBuilder(RequestBuilder.GET, restApiBaseUrl);
    // Control REST API session timeout
    // $NON-NLS-1$
    builder.setHeader("Session-TTL", restApiSessionTimeout);
    // Express additional preferences for serving this request
    // $NON-NLS-1$
    builder.setHeader(PREFER_HEADER, "persistent-auth, csrf-protection");
    // Add CSRF token, this is needed due to Prefer:csrf-protection
    String sessionId = getSessionId();
    if (sessionId != null) {
        builder.setHeader(CSRF_HEADER, sessionId);
    }
    return builder;
}
#method_after
RequestBuilder createRequest() {
    RequestBuilder builder = new RequestBuilder(RequestBuilder.GET, restApiBaseUrl);
    // Control REST API session timeout
    // $NON-NLS-1$
    builder.setHeader("Session-TTL", restApiSessionTimeout);
    // Express additional preferences for serving this request
    // $NON-NLS-1$
    builder.setHeader(PREFER_HEADER, "persistent-auth, csrf-protection");
    // Add CSRF token, this is needed due to Prefer:csrf-protection
    if (restApiSessionId != null) {
        builder.setHeader(CSRF_HEADER, restApiSessionId);
    }
    return builder;
}
#end_block

#method_before
void scheduleKeepAliveHeartbeat() {
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String sessionId = getSessionId();
            if (sessionId != null) {
                // The browser takes care of sending JSESSIONID cookie for this request automatically
                sendRequest(createRequest(), new RestApiRequestCallback());
                // The session is still in use, proceed with the heartbeat
                return true;
            } else {
                // The session has been released, cancel the heartbeat
                return false;
            }
        }
    }, SESSION_HEARTBEAT_MS);
}
#method_after
void scheduleKeepAliveHeartbeat() {
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            if (restApiSessionId != null) {
                // The browser takes care of sending JSESSIONID cookie for this request automatically
                sendRequest(createRequest(), new RestApiRequestCallback());
                // The session is still in use, proceed with the heartbeat
                return true;
            } else {
                // The session has been released, cancel the heartbeat
                return false;
            }
        }
    }, SESSION_HEARTBEAT_MS);
}
#end_block

#method_before
public void acquireSession(String engineAuthToken) {
    sendRequest(createRequest(engineAuthToken), new RestApiRequestCallback() {

        @Override
        protected void processResponse(Response response) {
            // Obtain session ID from response header, as we're unable to access the
            // JSESSIONID cookie directly (cookie is set for REST API specific path)
            String sessionIdFromHeader = HttpUtils.getHeader(response, SESSION_ID_HEADER);
            if (sessionIdFromHeader != null) {
                setSessionId(sessionIdFromHeader);
            }
            reuseSession();
        }
    });
}
#method_after
public void acquireSession(String engineAuthToken) {
    sendRequest(createRequest(engineAuthToken), new RestApiRequestCallback() {

        @Override
        protected void processResponse(Response response) {
            // Obtain session ID from response header, as we're unable to access the
            // JSESSIONID cookie directly (cookie is set for REST API specific path)
            String sessionIdFromHeader = HttpUtils.getHeader(response, SESSION_ID_HEADER);
            if (sessionIdFromHeader != null) {
                setSessionId(sessionIdFromHeader, true);
            }
            reuseSession();
        }
    });
}
#end_block

#method_before
public void reuseSession() {
    // can we can utilize the async call to retrieve it from the backend.
    if (getSessionId() != null) {
        processSessionId(getSessionId());
    } else {
        getSessionId(new StorageCallback() {

            @Override
            public void onSuccess(String result) {
                if (result != null) {
                    restApiSessionId = result;
                    processSessionId(result);
                } else {
                    processSessionIdException();
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                processSessionIdException();
            }
        });
    }
}
#method_after
public void reuseSession() {
    // can we can utilize the async call to retrieve it from the backend.
    if (restApiSessionId != null) {
        processSessionId(restApiSessionId);
    } else {
        getSessionIdFromHttpSession(new StorageCallback() {

            @Override
            public void onSuccess(String result) {
                if (result != null) {
                    setSessionId(result, false);
                    processSessionId(result);
                } else {
                    processSessionIdException();
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                processSessionIdException();
            }
        });
    }
}
#end_block

#method_before
public void releaseSession() {
    setSessionId(null);
}
#method_after
public void releaseSession() {
    setSessionId(null, true);
}
#end_block

#method_before
void setSessionId(String sessionId) {
    Frontend.getInstance().storeInHttpSession(SESSION_ID_KEY, sessionId);
    restApiSessionId = sessionId;
}
#method_after
void setSessionId(String sessionId, boolean storeInHttpSession) {
    if (storeInHttpSession) {
        Frontend.getInstance().storeInHttpSession(SESSION_ID_KEY, sessionId);
    }
    this.restApiSessionId = sessionId;
}
#end_block

#method_before
public static AgentsIterator getAgentsIterator(List<FencingAgent> fencingAgents) {
    orderAgents(fencingAgents);
    return new AgentsIterator(fencingAgents);
}
#method_after
public static AgentsIterator getAgentsIterator(List<FenceAgent> fenceAgents) {
    orderAgents(fenceAgents);
    return new AgentsIterator(fenceAgents);
}
#end_block

#method_before
public static void orderAgents(List<FencingAgent> fencingAgents) {
    synchronized (fencingAgents) {
        Collections.sort(fencingAgents, new FencingAgent.FencingAgentOrderComparator());
    }
}
#method_after
public static void orderAgents(List<FenceAgent> fenceAgents) {
    synchronized (fenceAgents) {
        Collections.sort(fenceAgents, new FenceAgent.FenceAgentOrderComparator());
    }
}
#end_block

#method_before
@Override
public List<FencingAgent> next() {
    List<FencingAgent> agentsWithSameOrder = new LinkedList<FencingAgent>();
    FencingAgent agent = agents.get(pos);
    agentsWithSameOrder.add(agent);
    pos += 1;
    int order = agent.getOrder();
    while (true) {
        agent = agents.get(pos);
        if (agent.getOrder() == order) {
            agentsWithSameOrder.add(agent);
            pos += 1;
        } else {
            break;
        }
    }
    return agentsWithSameOrder;
}
#method_after
@Override
public List<FenceAgent> next() {
    List<FenceAgent> agentsWithSameOrder = new LinkedList<FenceAgent>();
    FenceAgent agent = agents.get(pos);
    agentsWithSameOrder.add(agent);
    pos += 1;
    int order = agent.getOrder();
    while (pos < agents.size()) {
        agent = agents.get(pos);
        if (agent.getOrder() == order) {
            agentsWithSameOrder.add(agent);
            pos += 1;
        } else {
            break;
        }
    }
    return agentsWithSameOrder;
}
#end_block

#method_before
public void initVdsActionParametersForProvision(Guid pid, ExternalHostGroup hg, ExternalComputeResource cr, String mac, String discover_name) {
    privateAddProvisioned = true;
    hostMac = mac;
    hostGroup = hg;
    providerId = pid;
    discoverName = discover_name;
    computeResource = cr;
}
#method_after
public void initVdsActionParametersForProvision(Guid pid, ExternalHostGroup hg, ExternalComputeResource cr, String mac, String discover_name, String discover_ip) {
    privateAddProvisioned = true;
    hostMac = mac;
    hostGroup = hg;
    providerId = pid;
    discoverName = discover_name;
    computeResource = cr;
    discoverIp = discover_ip;
}
#end_block

#method_before
public FencingAgent getAgent() {
    return agent;
}
#method_after
public FenceAgent getAgent() {
    return agent;
}
#end_block

#method_before
public void setAgent(FencingAgent agent) {
    this.agent = agent;
}
#method_after
public void setAgent(FenceAgent agent) {
    this.agent = agent;
}
#end_block

#method_before
private void updateOptionsNonLocalFSData() {
    AsyncDataProvider.getClusterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            dataCenterGuideModel.clusters = clusters;
            dataCenterGuideModel.updateOptionsNonLocalFS();
        }
    }), getEntity().getId());
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            dataCenterGuideModel.allStorageDomains = storageDomains;
            dataCenterGuideModel.updateOptionsNonLocalFS();
        }
    }));
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            dataCenterGuideModel.attachedStorageDomains = storageDomains;
            dataCenterGuideModel.updateOptionsNonLocalFS();
        }
    }), getEntity().getId());
    AsyncDataProvider.getISOStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            dataCenterGuideModel.isoStorageDomains = storageDomains;
            dataCenterGuideModel.updateOptionsNonLocalFS();
        }
    }));
    AsyncDataProvider.getHostList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            dataCenterGuideModel.allHosts = hosts;
            dataCenterGuideModel.updateOptionsNonLocalFS();
        }
    }));
}
#method_after
private void updateOptionsNonLocalFSData() {
    AsyncDataProvider.getInstance().getClusterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            dataCenterGuideModel.clusters = clusters;
            dataCenterGuideModel.updateOptionsNonLocalFS();
        }
    }), getEntity().getId());
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            dataCenterGuideModel.allStorageDomains = storageDomains;
            dataCenterGuideModel.updateOptionsNonLocalFS();
        }
    }));
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            dataCenterGuideModel.attachedStorageDomains = storageDomains;
            dataCenterGuideModel.updateOptionsNonLocalFS();
        }
    }), getEntity().getId());
    AsyncDataProvider.getInstance().getISOStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            dataCenterGuideModel.isoStorageDomains = storageDomains;
            dataCenterGuideModel.updateOptionsNonLocalFS();
        }
    }));
    AsyncDataProvider.getInstance().getHostList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            dataCenterGuideModel.allHosts = hosts;
            dataCenterGuideModel.updateOptionsNonLocalFS();
        }
    }));
}
#end_block

#method_before
private void updateOptionsLocalFSData() {
    AsyncDataProvider.getClusterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            dataCenterGuideModel.clusters = clusters;
            dataCenterGuideModel.updateOptionsLocalFS();
        }
    }), getEntity().getId());
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
    "Hosts: datacenter!= " + getEntity().getName() + " status=maintenance or status=pendingapproval ", SearchType.VDS), new // $NON-NLS-1$
    AsyncQuery(// $NON-NLS-1$
    this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (hosts == null) {
                hosts = new ArrayList<VDS>();
            }
            dataCenterGuideModel.allHosts = hosts;
            AsyncDataProvider.getLocalStorageHost(new AsyncQuery(dataCenterGuideModel, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
                    if (returnValue != null) {
                        VDS localStorageHost = (VDS) returnValue;
                        dataCenterGuideModel.localStorageHost = localStorageHost;
                    } else {
                        noLocalStorageHost = true;
                    }
                    dataCenterGuideModel.updateOptionsLocalFS();
                }
            }), dataCenterGuideModel.getEntity().getName());
        }
    }));
}
#method_after
private void updateOptionsLocalFSData() {
    AsyncDataProvider.getInstance().getClusterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            dataCenterGuideModel.clusters = clusters;
            dataCenterGuideModel.updateOptionsLocalFS();
        }
    }), getEntity().getId());
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
    "Hosts: datacenter!= " + getEntity().getName() + " status=maintenance or status=pendingapproval ", SearchType.VDS), new // $NON-NLS-1$
    AsyncQuery(// $NON-NLS-1$
    this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (hosts == null) {
                hosts = new ArrayList<VDS>();
            }
            dataCenterGuideModel.allHosts = hosts;
            AsyncDataProvider.getInstance().getLocalStorageHost(new AsyncQuery(dataCenterGuideModel, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
                    if (returnValue != null) {
                        VDS localStorageHost = (VDS) returnValue;
                        dataCenterGuideModel.localStorageHost = localStorageHost;
                    } else {
                        noLocalStorageHost = true;
                    }
                    dataCenterGuideModel.updateOptionsLocalFS();
                }
            }), dataCenterGuideModel.getEntity().getName());
        }
    }));
}
#end_block

#method_before
private void addLocalStorage() {
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newLocalDomainTitle());
    model.setHelpTag(HelpTag.new_local_domain);
    // $NON-NLS-1$
    model.setHashName("new_local_domain");
    LocalStorageModel localStorageModel = new LocalStorageModel();
    localStorageModel.setRole(StorageDomainType.Data);
    ArrayList<IStorageModel> list = new ArrayList<IStorageModel>();
    list.add(localStorageModel);
    model.setItems(list);
    model.setSelectedItem(list.get(0));
    AsyncDataProvider.getLocalStorageHost(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            DataCenterGuideModel listModel = (DataCenterGuideModel) array[0];
            StorageModel model = (StorageModel) array[1];
            VDS localHost = (VDS) returnValue;
            model.getHost().setItems(new ArrayList<VDS>(Arrays.asList(new VDS[] { localHost })));
            model.getHost().setSelectedItem(localHost);
            model.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { getEntity() })));
            model.getDataCenter().setSelectedItem(getEntity());
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnAddStorage", listModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            model.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", listModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            model.getCommands().add(tempVar2);
        }
    }), getEntity().getName());
}
#method_after
private void addLocalStorage() {
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newLocalDomainTitle());
    model.setHelpTag(HelpTag.new_local_domain);
    // $NON-NLS-1$
    model.setHashName("new_local_domain");
    LocalStorageModel localStorageModel = new LocalStorageModel();
    localStorageModel.setRole(StorageDomainType.Data);
    ArrayList<IStorageModel> list = new ArrayList<IStorageModel>();
    list.add(localStorageModel);
    model.setItems(list);
    model.setSelectedItem(list.get(0));
    AsyncDataProvider.getInstance().getLocalStorageHost(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            DataCenterGuideModel listModel = (DataCenterGuideModel) array[0];
            StorageModel model = (StorageModel) array[1];
            VDS localHost = (VDS) returnValue;
            model.getHost().setItems(new ArrayList<VDS>(Arrays.asList(new VDS[] { localHost })));
            model.getHost().setSelectedItem(localHost);
            model.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { getEntity() })));
            model.getDataCenter().setSelectedItem(getEntity());
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnAddStorage", listModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            model.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", listModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            model.getCommands().add(tempVar2);
        }
    }), getEntity().getName());
}
#end_block

#method_before
private void addStorageInternal(String title, StorageDomainType type) {
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(title);
    model.setHelpTag(HelpTag.new_domain);
    // $NON-NLS-1$
    model.setHashName("new_domain");
    ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
    dataCenters.add(getEntity());
    model.getDataCenter().setItems(dataCenters);
    model.getDataCenter().setSelectedItem(getEntity());
    model.getDataCenter().setIsChangable(false);
    List<IStorageModel> items = null;
    if (type == StorageDomainType.Data) {
        items = AsyncDataProvider.getDataStorageModels();
    } else if (type == StorageDomainType.ISO) {
        items = AsyncDataProvider.getIsoStorageModels();
    }
    model.setItems(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand tempVar6 = new UICommand("OnAddStorage", this);
    tempVar6.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar6.setIsDefault(true);
    model.getCommands().add(tempVar6);
    // $NON-NLS-1$
    UICommand tempVar7 = new UICommand("Cancel", this);
    tempVar7.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar7.setIsCancel(true);
    model.getCommands().add(tempVar7);
}
#method_after
private void addStorageInternal(String title, StorageDomainType type) {
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(title);
    model.setHelpTag(HelpTag.new_domain);
    // $NON-NLS-1$
    model.setHashName("new_domain");
    ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
    dataCenters.add(getEntity());
    model.getDataCenter().setItems(dataCenters);
    model.getDataCenter().setSelectedItem(getEntity());
    model.getDataCenter().setIsChangable(false);
    List<IStorageModel> items = null;
    if (type == StorageDomainType.Data) {
        items = AsyncDataProvider.getInstance().getDataStorageModels();
    } else if (type == StorageDomainType.ISO) {
        items = AsyncDataProvider.getInstance().getIsoStorageModels();
    }
    model.setItems(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand tempVar6 = new UICommand("OnAddStorage", this);
    tempVar6.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar6.setIsDefault(true);
    model.getCommands().add(tempVar6);
    // $NON-NLS-1$
    UICommand tempVar7 = new UICommand("Cancel", this);
    tempVar7.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar7.setIsCancel(true);
    model.getCommands().add(tempVar7);
}
#end_block

#method_before
public void onAddStorage() {
    StorageModel model = (StorageModel) getWindow();
    String storageName = model.getName().getEntity();
    AsyncDataProvider.isStorageDomainNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            StorageModel storageModel = (StorageModel) dataCenterGuideModel.getWindow();
            String name = storageModel.getName().getEntity();
            String tempVar = storageModel.getOriginalName();
            // $NON-NLS-1$
            String originalName = (tempVar != null) ? tempVar : "";
            boolean isNameUnique = (Boolean) returnValue;
            if (!isNameUnique && name.compareToIgnoreCase(originalName) != 0) {
                storageModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                storageModel.getName().setIsValid(false);
            }
            AsyncDataProvider.getStorageDomainMaxNameLength(new AsyncQuery(dataCenterGuideModel, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target1, Object returnValue1) {
                    DataCenterGuideModel dataCenterGuideModel1 = (DataCenterGuideModel) target1;
                    StorageModel storageModel1 = (StorageModel) dataCenterGuideModel1.getWindow();
                    int nameMaxLength = (Integer) returnValue1;
                    RegexValidation tempVar2 = new RegexValidation();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    tempVar2.setExpression("^[A-Za-z0-9_-]{1," + nameMaxLength + "}$");
                    tempVar2.setMessage(ConstantsManager.getInstance().getMessages().nameCanContainOnlyMsg(nameMaxLength));
                    storageModel1.getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar2 });
                    dataCenterGuideModel1.postOnAddStorage();
                }
            }));
        }
    }), storageName);
}
#method_after
public void onAddStorage() {
    StorageModel model = (StorageModel) getWindow();
    String storageName = model.getName().getEntity();
    AsyncDataProvider.getInstance().isStorageDomainNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            StorageModel storageModel = (StorageModel) dataCenterGuideModel.getWindow();
            String name = storageModel.getName().getEntity();
            String tempVar = storageModel.getOriginalName();
            // $NON-NLS-1$
            String originalName = (tempVar != null) ? tempVar : "";
            boolean isNameUnique = (Boolean) returnValue;
            if (!isNameUnique && name.compareToIgnoreCase(originalName) != 0) {
                storageModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                storageModel.getName().setIsValid(false);
            }
            AsyncDataProvider.getInstance().getStorageDomainMaxNameLength(new AsyncQuery(dataCenterGuideModel, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target1, Object returnValue1) {
                    DataCenterGuideModel dataCenterGuideModel1 = (DataCenterGuideModel) target1;
                    StorageModel storageModel1 = (StorageModel) dataCenterGuideModel1.getWindow();
                    int nameMaxLength = (Integer) returnValue1;
                    RegexValidation tempVar2 = new RegexValidation();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    tempVar2.setExpression("^[A-Za-z0-9_-]{1," + nameMaxLength + "}$");
                    tempVar2.setMessage(ConstantsManager.getInstance().getMessages().nameCanContainOnlyMsg(nameMaxLength));
                    storageModel1.getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar2 });
                    dataCenterGuideModel1.postOnAddStorage();
                }
            }));
        }
    }), storageName);
}
#end_block

#method_before
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = (String) localModel.getPath().getEntity();
    storageDomain = new StorageDomainStatic();
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel, ConstantsManager.getInstance().getMessages().createOperationFailedDcGuideMsg(storageName));
            } else {
                dataCenterGuideModel.saveNewLocalStorage();
            }
        }
    }), host.getStoragePoolId(), path);
}
#method_after
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = (String) localModel.getPath().getEntity();
    storageDomain = new StorageDomainStatic();
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel, ConstantsManager.getInstance().getMessages().createOperationFailedDcGuideMsg(storageName));
            } else {
                dataCenterGuideModel.saveNewLocalStorage();
            }
        }
    }), host.getStoragePoolId(), path);
}
#end_block

#method_before
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = new StorageDomainStatic();
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel, ConstantsManager.getInstance().getMessages().createOperationFailedDcGuideMsg(storageName));
            } else {
                dataCenterGuideModel.saveNewNfsStorage();
            }
        }
    }), null, path);
}
#method_after
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = new StorageDomainStatic();
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel, ConstantsManager.getInstance().getMessages().createOperationFailedDcGuideMsg(storageName));
            } else {
                dataCenterGuideModel.saveNewNfsStorage();
            }
        }
    }), null, path);
}
#end_block

#method_before
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getSelectedItem();
    storageDomain = new StorageDomainStatic();
    storageDomain.setStorageType(sanModel.getType());
    storageDomain.setStorageDomainType(sanModel.getRole());
    storageDomain.setStorageFormat(sanModel.getContainer().getFormat().getSelectedItem());
    storageDomain.setStorageName(model.getName().getEntity());
    AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel, ConstantsManager.getInstance().getMessages().createOperationFailedDcGuideMsg(storageName));
            } else {
                dataCenterGuideModel.saveNewSanStorage();
            }
            dataCenterGuideModel.getWindow().stopProgress();
        }
    }), null, path);
}
#method_after
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getSelectedItem();
    storageDomain = new StorageDomainStatic();
    storageDomain.setStorageType(sanModel.getType());
    storageDomain.setStorageDomainType(sanModel.getRole());
    storageDomain.setStorageFormat(sanModel.getContainer().getFormat().getSelectedItem());
    storageDomain.setStorageName(model.getName().getEntity());
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel, ConstantsManager.getInstance().getMessages().createOperationFailedDcGuideMsg(storageName));
            } else {
                dataCenterGuideModel.saveNewSanStorage();
            }
            dataCenterGuideModel.getWindow().stopProgress();
        }
    }), null, path);
}
#end_block

#method_before
public void attachIsoStorage() {
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> attachedStorage = new ArrayList<StorageDomain>();
            AsyncDataProvider.getISOStorageDomainList(new AsyncQuery(new Object[] { dataCenterGuideModel, attachedStorage }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) array[0];
                    ArrayList<StorageDomain> attachedStorage = (ArrayList<StorageDomain>) array[1];
                    ArrayList<StorageDomain> isoStorageDomains = (ArrayList<StorageDomain>) returnValue;
                    ArrayList<StorageDomain> sdl = new ArrayList<StorageDomain>();
                    for (StorageDomain a : isoStorageDomains) {
                        boolean isContains = false;
                        for (StorageDomain b : attachedStorage) {
                            if (b.getId().equals(a.getId())) {
                                isContains = true;
                                break;
                            }
                        }
                        if (!isContains) {
                            sdl.add(a);
                        }
                    }
                    dataCenterGuideModel.attachStorageInternal(sdl, ConstantsManager.getInstance().getConstants().attachISOLibraryTitle());
                }
            }));
        }
    }), getEntity().getId());
}
#method_after
public void attachIsoStorage() {
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> attachedStorage = new ArrayList<StorageDomain>();
            AsyncDataProvider.getInstance().getISOStorageDomainList(new AsyncQuery(new Object[] { dataCenterGuideModel, attachedStorage }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) array[0];
                    ArrayList<StorageDomain> attachedStorage = (ArrayList<StorageDomain>) array[1];
                    ArrayList<StorageDomain> isoStorageDomains = (ArrayList<StorageDomain>) returnValue;
                    ArrayList<StorageDomain> sdl = new ArrayList<StorageDomain>();
                    for (StorageDomain a : isoStorageDomains) {
                        boolean isContains = false;
                        for (StorageDomain b : attachedStorage) {
                            if (b.getId().equals(a.getId())) {
                                isContains = true;
                                break;
                            }
                        }
                        if (!isContains) {
                            sdl.add(a);
                        }
                    }
                    dataCenterGuideModel.attachStorageInternal(sdl, ConstantsManager.getInstance().getConstants().attachISOLibraryTitle());
                }
            }));
        }
    }), getEntity().getId());
}
#end_block

#method_before
public void attachDataStorage() {
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> unattachedStorage = new ArrayList<StorageDomain>();
            boolean addToList;
            Version version3_0 = new Version(3, 0);
            for (StorageDomain item : storageDomains) {
                addToList = false;
                if (item.getStorageDomainType() == StorageDomainType.Data && (item.getStorageType() == StorageType.LOCALFS) == dataCenterGuideModel.getEntity().isLocal() && item.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
                    if (getEntity().getStoragePoolFormatType() == null) {
                        // compat logic: in case its not v1 and the version is less than 3.0 continue.
                        if (item.getStorageStaticData().getStorageFormat() != StorageFormatType.V1 && dataCenterGuideModel.getEntity().getcompatibility_version().compareTo(version3_0) < 0) {
                            continue;
                        }
                        addToList = true;
                    } else if (getEntity().getStoragePoolFormatType() == item.getStorageStaticData().getStorageFormat()) {
                        addToList = true;
                    }
                }
                if (addToList) {
                    unattachedStorage.add(item);
                }
            }
            dataCenterGuideModel.attachStorageInternal(unattachedStorage, ConstantsManager.getInstance().getConstants().attachStorageTitle());
        }
    }));
}
#method_after
public void attachDataStorage() {
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> unattachedStorage = new ArrayList<StorageDomain>();
            boolean addToList;
            Version version3_0 = new Version(3, 0);
            for (StorageDomain item : storageDomains) {
                addToList = false;
                if (item.getStorageDomainType() == StorageDomainType.Data && (item.getStorageType() == StorageType.LOCALFS) == dataCenterGuideModel.getEntity().isLocal() && item.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
                    if (getEntity().getStoragePoolFormatType() == null) {
                        // compat logic: in case its not v1 and the version is less than 3.0 continue.
                        if (item.getStorageStaticData().getStorageFormat() != StorageFormatType.V1 && dataCenterGuideModel.getEntity().getcompatibility_version().compareTo(version3_0) < 0) {
                            continue;
                        }
                        addToList = true;
                    } else if (getEntity().getStoragePoolFormatType() == item.getStorageStaticData().getStorageFormat()) {
                        addToList = true;
                    }
                }
                if (addToList) {
                    unattachedStorage.add(item);
                }
            }
            dataCenterGuideModel.attachStorageInternal(unattachedStorage, ConstantsManager.getInstance().getConstants().attachStorageTitle());
        }
    }));
}
#end_block

#method_before
public void onAddCluster() {
    ClusterModel model = (ClusterModel) getWindow();
    VDSGroup cluster = new VDSGroup();
    if (model.getProgress() != null) {
        return;
    }
    if (// CPU is mandatory only if the
    !model.validate(model.getEnableOvirtService().getEntity())) // cluster is virt enabled
    {
        return;
    }
    // Save changes.
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    if (model.getClusterPolicy().getSelectedItem() != null) {
        ClusterPolicy selectedPolicy = model.getClusterPolicy().getSelectedItem();
        cluster.setClusterPolicyId(selectedPolicy.getId());
        cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
            localModel.postOnAddCluster(result.getReturnValue());
        }
    }, this);
}
#method_after
public void onAddCluster() {
    ClusterModel model = (ClusterModel) getWindow();
    VDSGroup cluster = new VDSGroup();
    if (model.getProgress() != null) {
        return;
    }
    if (// CPU is mandatory only if the
    !model.validate(model.getEnableOvirtService().getEntity())) // cluster is virt enabled
    {
        return;
    }
    // Save changes.
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    if (model.getClusterPolicy().getSelectedItem() != null) {
        ClusterPolicy selectedPolicy = model.getClusterPolicy().getSelectedItem();
        cluster.setClusterPolicyId(selectedPolicy.getId());
        cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
            localModel.postOnAddCluster(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
public void selectHost() {
    MoveHost model = new MoveHost();
    model.setTitle(ConstantsManager.getInstance().getConstants().selectHostTitle());
    model.setHelpTag(HelpTag.select_host);
    // $NON-NLS-1$
    model.setHashName("select_host");
    // In case of local storage, do not show the cluster selection in host select menu as there can be only one cluster in that case
    // also only one host is allowed in the cluster so we should disable multi selection
    boolean isMultiHostDC = getEntity().isLocal();
    if (isMultiHostDC) {
        model.getCluster().setIsAvailable(false);
        model.setMultiSelection(false);
    }
    setWindow(model);
    AsyncDataProvider.getClusterList(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) array[0];
            MoveHost moveHostModel = (MoveHost) array[1];
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            moveHostModel.getCluster().setItems(clusters);
            moveHostModel.getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnSelectHost", dataCenterGuideModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            moveHostModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", dataCenterGuideModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            moveHostModel.getCommands().add(tempVar2);
        }
    }), getEntity().getId());
}
#method_after
public void selectHost() {
    MoveHost model = new MoveHost();
    model.setTitle(ConstantsManager.getInstance().getConstants().selectHostTitle());
    model.setHelpTag(HelpTag.select_host);
    // $NON-NLS-1$
    model.setHashName("select_host");
    // In case of local storage, do not show the cluster selection in host select menu as there can be only one cluster in that case
    // also only one host is allowed in the cluster so we should disable multi selection
    boolean isMultiHostDC = getEntity().isLocal();
    if (isMultiHostDC) {
        model.getCluster().setIsAvailable(false);
        model.setMultiSelection(false);
    }
    setWindow(model);
    AsyncDataProvider.getInstance().getClusterList(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) array[0];
            MoveHost moveHostModel = (MoveHost) array[1];
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            moveHostModel.getCluster().setItems(clusters);
            moveHostModel.getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnSelectHost", dataCenterGuideModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            moveHostModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", dataCenterGuideModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            moveHostModel.getCommands().add(tempVar2);
        }
    }), getEntity().getId());
}
#end_block

#method_before
public void addHost() {
    HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host_guide_me);
    // $NON-NLS-1$
    model.setHashName("new_host_guide_me");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { getEntity() })));
    model.getDataCenter().setSelectedItem(getEntity());
    model.getDataCenter().setIsChangable(false);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnConfirmPMHost", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void addHost() {
    final HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host_guide_me);
    // $NON-NLS-1$
    model.setHashName("new_host_guide_me");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { getEntity() })));
    model.getDataCenter().setSelectedItem(getEntity());
    model.getDataCenter().setIsChangable(false);
    model.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel<VDSGroup> clusterModel = model.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                VDSGroup cluster = clusterModel.getSelectedItem();
                Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getcompatibility_version().toString());
                if (jsonSupported) {
                    model.getProtocol().setEntity(true);
                } else {
                    model.getProtocol().setEntity(false);
                    model.getProtocol().setIsChangable(false);
                }
            }
        }
    });
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnConfirmPMHost", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName(model.getName().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(model.getPort().getEntity());
    host.setSshPort(model.getAuthSshPort().getEntity());
    host.setSshUsername(model.getUserName().getEntity());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity());
    host.setVdsGroupId(model.getCluster().getSelectedItem().getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    AddVdsActionParameters addVdsParams = new AddVdsActionParameters();
    addVdsParams.setVdsId(host.getId());
    addVdsParams.setvds(host);
    if (model.getUserPassword().getEntity() != null) {
        addVdsParams.setPassword(model.getUserPassword().getEntity());
    }
    addVdsParams.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    addVdsParams.setRebootAfterInstallation(model.getCluster().getSelectedItem().supportsVirtService());
    addVdsParams.setFencingAgents(getFencingAgents(model));
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, addVdsParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#method_after
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName(model.getName().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(model.getPort().getEntity());
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(model.getAuthSshPort().getEntity());
    host.setSshUsername(model.getUserName().getEntity());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity());
    host.setVdsGroupId(model.getCluster().getSelectedItem().getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    AddVdsActionParameters addVdsParams = new AddVdsActionParameters();
    addVdsParams.setVdsId(host.getId());
    addVdsParams.setvds(host);
    if (model.getUserPassword().getEntity() != null) {
        addVdsParams.setPassword(model.getUserPassword().getEntity());
    }
    addVdsParams.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    addVdsParams.setRebootAfterInstallation(model.getCluster().getSelectedItem().supportsVirtService());
    addVdsParams.setFenceAgents(getFenceAgents(model));
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, addVdsParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    FenceExecutor executor = new FenceExecutor(getHost());
    VDSFenceReturnValue result = executor.checkStatus();
    if (result.isSucceeded()) {
        getQueryReturnValue().setReturnValue(result.getFenceResult());
    } else {
        handleError(result);
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    FenceExecutor executor = new FenceExecutor(getHost());
    VDSFenceReturnValue result = executor.checkStatus();
    if (result.getSucceeded()) {
        getQueryReturnValue().setReturnValue(result.getReturnValue());
    } else {
        handleError(result);
    }
}
#end_block

#method_before
private VDS getHost() {
    Guid id = getParameters().getVdsId();
    VDS vds = new VDS();
    vds.setId((Guid) ((id != null) ? id : Guid.Empty));
    vds.setStoragePoolId(getParameters().getStoragePoolId());
    vds.getFencingAgents().add(getParameters().getAgent());
    return vds;
}
#method_after
private VDS getHost() {
    Guid id = getParameters().getVdsId();
    VDS vds = new VDS();
    vds.setId((Guid) ((id != null) ? id : Guid.Empty));
    vds.setStoragePoolId(getParameters().getStoragePoolId());
    vds.getFenceAgents().add(getParameters().getAgent());
    vds.setPmProxyPreferences(getParameters().getPmProxyPreferences());
    return vds;
}
#end_block

#method_before
private void handleError(VDSFenceReturnValue result) {
    if (!result.isProxyHostFound()) {
        getQueryReturnValue().setSucceeded(false);
        getQueryReturnValue().setReturnValue(new FenceStatusReturnValue("unknown", AuditLogDirector.getMessage(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST)));
    } else {
        getQueryReturnValue().setSucceeded(false);
        getQueryReturnValue().setReturnValue(new FenceStatusReturnValue("unknown", AuditLogDirector.getMessage(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED)));
    }
}
#method_after
private void handleError(VDSFenceReturnValue result) {
    if (!result.isProxyHostFound()) {
        getQueryReturnValue().setSucceeded(false);
        getQueryReturnValue().setReturnValue(new FenceStatusReturnValue(UNKNOWN, AuditLogDirector.getMessage(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST)));
    } else {
        getQueryReturnValue().setSucceeded(false);
        getQueryReturnValue().setReturnValue(new FenceStatusReturnValue(UNKNOWN, AuditLogDirector.getMessage(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED)));
    }
}
#end_block

#method_before
public void fetchPublicKey() {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String pk = (String) result;
            if (pk != null && pk.length() > 0) {
                getPublicKey().setEntity(pk);
            }
        }
    };
    AsyncDataProvider.getHostPublicKey(aQuery);
}
#method_after
public void fetchPublicKey() {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String pk = (String) result;
            if (pk != null && pk.length() > 0) {
                getPublicKey().setEntity(pk);
            }
        }
    };
    AsyncDataProvider.getInstance().getHostPublicKey(aQuery);
}
#end_block

#method_before
private void fetchSSHFingerprint() {
    // Cleaning up fields for initialization
    getFetchSshFingerprint().setEntity(ConstantsManager.getInstance().getConstants().empty());
    getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().empty());
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String fingerprint = (String) result;
            if (fingerprint != null && fingerprint.length() > 0) {
                getFetchSshFingerprint().setEntity(fingerprint);
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().successLoadingFingerprint());
            } else {
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().errorLoadingFingerprint());
            }
        }
    };
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (!getHost().getIsValid()) {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().fingerprintAddressError() + getHost().getInvalidityReasons().get(0));
    } else {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().loadingFingerprint());
        AsyncDataProvider.getHostFingerprint(aQuery, getHost().getEntity());
    }
}
#method_after
private void fetchSSHFingerprint() {
    // Cleaning up fields for initialization
    // $NON-NLS-1$
    getFetchSshFingerprint().setEntity("");
    // $NON-NLS-1$
    getFetchResult().setEntity("");
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String fingerprint = (String) result;
            if (fingerprint != null && fingerprint.length() > 0) {
                getFetchSshFingerprint().setEntity(fingerprint);
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().successLoadingFingerprint());
            } else {
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().errorLoadingFingerprint());
            }
        }
    };
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (!getHost().getIsValid()) {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().fingerprintAddressError() + getHost().getInvalidityReasons().get(0));
    } else {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().loadingFingerprint());
        AsyncDataProvider.getInstance().getHostFingerprint(aQuery, getHost().getEntity());
    }
}
#end_block

#method_before
private void initSpmPriorities() {
    AsyncDataProvider.getMaxSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.maxSpmPriority = (Integer) returnValue;
            initSpmPriorities1();
        }
    }));
}
#method_after
private void initSpmPriorities() {
    AsyncDataProvider.getInstance().getMaxSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.maxSpmPriority = (Integer) returnValue;
            initSpmPriorities1();
        }
    }));
}
#end_block

#method_before
private void initSpmPriorities1() {
    AsyncDataProvider.getDefaultSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.defaultSpmPriority = (Integer) returnValue;
            if (postponedSpmPriority != null) {
                updateSpmPriority(postponedSpmPriority);
            }
            spmInitialized = true;
        }
    }));
}
#method_after
private void initSpmPriorities1() {
    AsyncDataProvider.getInstance().getDefaultSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.defaultSpmPriority = (Integer) returnValue;
            if (postponedSpmPriority != null) {
                updateSpmPriority(postponedSpmPriority);
            }
            spmInitialized = true;
        }
    }));
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        dataCenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getCluster()) {
        cluster_SelectedItemChanged();
    } else if (sender == getConsoleAddressEnabled()) {
        consoleAddressChanged();
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        dataCenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getCluster()) {
        cluster_SelectedItemChanged();
    } else if (sender == getConsoleAddressEnabled()) {
        consoleAddressChanged();
    }
}
#end_block

#method_before
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    if (hostModel.getIsNew()) {
                        updateClusterList(hostModel, clusters);
                    } else {
                        AsyncQuery architectureQuery = new AsyncQuery();
                        architectureQuery.setModel(new Object[] { hostModel, clusters });
                        architectureQuery.asyncCallback = new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                Object[] objArray = (Object[]) model;
                                HostModel hostModel = (HostModel) objArray[0];
                                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                                ArchitectureType architecture = (ArchitectureType) returnValue;
                                ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                                for (VDSGroup cluster : clusters) {
                                    if (architecture == ArchitectureType.undefined || cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                        filteredClusters.add(cluster);
                                    }
                                }
                                updateClusterList(hostModel, filteredClusters);
                            }
                        };
                        AsyncDataProvider.getHostArchitecture(architectureQuery, hostModel.getHostId());
                    }
                }
            }
        };
        AsyncDataProvider.getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#method_after
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    if (hostModel.getIsNew()) {
                        updateClusterList(hostModel, clusters);
                    } else {
                        AsyncQuery architectureQuery = new AsyncQuery();
                        architectureQuery.setModel(new Object[] { hostModel, clusters });
                        architectureQuery.asyncCallback = new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                Object[] objArray = (Object[]) model;
                                HostModel hostModel = (HostModel) objArray[0];
                                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                                ArchitectureType architecture = (ArchitectureType) returnValue;
                                ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                                for (VDSGroup cluster : clusters) {
                                    if (architecture == ArchitectureType.undefined || cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                        filteredClusters.add(cluster);
                                    }
                                }
                                updateClusterList(hostModel, filteredClusters);
                            }
                        };
                        AsyncDataProvider.getInstance().getHostArchitecture(architectureQuery, hostModel.getHostId());
                    }
                }
            }
        };
        AsyncDataProvider.getInstance().getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#end_block

#method_before
private void cluster_SelectedItemChanged() {
    VDSGroup cluster = getCluster().getSelectedItem();
    if (cluster != null) {
        AsyncDataProvider.getPmTypeList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ArrayList<String> pmTypes = (ArrayList<String>) returnValue;
                updatePmTypeList(pmTypes, getPmType());
                updatePmTypeList(pmTypes, getPmSecondaryType());
            }
        }), cluster.getcompatibility_version());
    }
}
#method_after
private void cluster_SelectedItemChanged() {
    VDSGroup cluster = getCluster().getSelectedItem();
    if (cluster != null) {
        AsyncDataProvider.getInstance().getPmTypeList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ArrayList<String> pmTypes = (ArrayList<String>) returnValue;
                updatePmTypeList(pmTypes, getPmType());
                updatePmTypeList(pmTypes, getPmSecondaryType());
            }
        }), cluster.getcompatibility_version());
    }
}
#end_block

#method_before
private HashMap<String, String> getPmOptionsMapInternal(EntityModel<String> port, EntityModel<String> slot, EntityModel<Boolean> secure, EntityModel<String> options) {
    HashMap<String, String> dict = new HashMap<String, String>();
    if (getIsPm().getEntity()) {
        // Add well known pm options.
        if (port.getIsAvailable() && port.getEntity() != null) {
            dict.put(PmPortKey, port.getEntity());
        }
        if (slot.getIsAvailable() && slot.getEntity() != null) {
            dict.put(PmSlotKey, slot.getEntity());
        }
        if (secure.getIsAvailable()) {
            dict.put(PmSecureKey, secure.getEntity().toString());
        }
        // Add unknown pm options.
        // Assume Validate method was called before this getter.
        String pmOptions = options.getEntity();
        if (!StringHelper.isNullOrEmpty(pmOptions)) {
            for (// $NON-NLS-1$
            String pair : // $NON-NLS-1$
            pmOptions.split("[,]", -1)) {
                // $NON-NLS-1$
                String[] array = pair.split("[=]", -1);
                if (array.length == 2) {
                    dict.put(array[0], array[1]);
                } else if (array.length == 1) {
                    // $NON-NLS-1$
                    dict.put(array[0], "");
                }
            }
        }
    }
    return dict;
}
#method_after
private HashMap<String, String> getPmOptionsMapInternal(EntityModel<String> port, EntityModel<String> slot, EntityModel<Boolean> secure, EntityModel<String> options) {
    HashMap<String, String> dict = new HashMap<String, String>();
    if (port.getIsAvailable() && port.getEntity() != null) {
        dict.put(PmPortKey, port.getEntity());
    }
    // Add well known pm options.
    if (slot.getIsAvailable() && slot.getEntity() != null) {
        dict.put(PmSlotKey, slot.getEntity());
    }
    if (secure.getIsAvailable()) {
        dict.put(PmSecureKey, secure.getEntity().toString());
    }
    // Add unknown pm options.
    // Assume Validate method was called before this getter.
    String pmOptions = options.getEntity();
    if (!StringHelper.isNullOrEmpty(pmOptions)) {
        for (// $NON-NLS-1$
        String pair : // $NON-NLS-1$
        pmOptions.split("[,]", -1)) {
            // $NON-NLS-1$
            String[] array = pair.split("[=]", -1);
            if (array.length == 2) {
                dict.put(array[0], array[1]);
            } else if (array.length == 1) {
                // $NON-NLS-1$
                dict.put(array[0], "");
            }
        }
    }
    return dict;
}
#end_block

#method_before
private void updatePmModels() {
    boolean isPm = getIsPm().getEntity();
    // $NON-NLS-1$
    final String ciscoUcsValue = "cisco_ucs";
    // Update primary PM fields.
    getManagementIp().setIsChangable(isPm);
    getManagementIp().setIsValid(true);
    getPmUserName().setIsChangable(isPm);
    getPmUserName().setIsValid(true);
    getPmPassword().setIsChangable(isPm);
    getPmPassword().setIsValid(true);
    getPmType().setIsChangable(isPm);
    getPmType().setIsValid(true);
    getPmPort().setIsChangable(isPm);
    getPmPort().setIsValid(true);
    getPmProxyPreferencesList().setIsChangable(getIsPm().getEntity());
    String proxySelectedItem = getPmProxyPreferencesList().getSelectedItem();
    getTestCommand().setIsExecutionAllowed(isPm);
    getProxyUpCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getProxyDownCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getPmSlot().setIsChangable(isPm);
    getPmOptions().setIsChangable(isPm);
    getPmOptions().setIsValid(true);
    getPmSecure().setIsChangable(isPm);
    VDSGroup cluster = getCluster().getSelectedItem();
    String version = AsyncDataProvider.getDefaultConfigurationVersion();
    if (cluster != null) {
        version = cluster.getcompatibility_version().toString();
    }
    String pmType = getPmType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmType, version);
        setCiscoUcsPrimaryPmTypeSelected(pmType.equals(ciscoUcsValue));
    } else {
        getPmPort().setIsAvailable(false);
        getPmSlot().setIsAvailable(false);
        getPmSecure().setIsAvailable(false);
    }
    // Update secondary PM fields.
    getPmSecondaryIp().setIsChangable(isPm);
    getPmSecondaryIp().setIsValid(true);
    getPmSecondaryUserName().setIsChangable(isPm);
    getPmSecondaryUserName().setIsValid(true);
    getPmSecondaryPassword().setIsChangable(isPm);
    getPmSecondaryPassword().setIsValid(true);
    getPmSecondaryType().setIsChangable(isPm);
    getPmSecondaryType().setIsValid(true);
    getPmSecondaryPort().setIsChangable(isPm);
    getPmSecondaryPort().setIsValid(true);
    getPmSecondarySlot().setIsChangable(isPm);
    getPmSecondaryOptions().setIsChangable(isPm);
    getPmSecondaryOptions().setIsValid(true);
    getPmSecondarySecure().setIsChangable(isPm);
    getDisableAutomaticPowerManagement().setIsValid(true);
    getDisableAutomaticPowerManagement().setIsChangable(isPm);
    String pmSecondaryType = getPmSecondaryType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmSecondaryType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmSecondaryPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSecondarySlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecondarySecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmSecondaryType, version);
        setCiscoUcsSecondaryPmTypeSelected(pmSecondaryType.equals(ciscoUcsValue));
    } else {
        getPmSecondaryPort().setIsAvailable(false);
        getPmSecondarySlot().setIsAvailable(false);
        getPmSecondarySecure().setIsAvailable(false);
    }
    // Update other PM fields.
    getPmVariants().setIsChangable(isPm);
    getPmSecondaryConcurrent().setIsChangable(isPm);
    getPmKdumpDetection().setIsChangable(isPm);
    getTestCommand().setIsExecutionAllowed(isPm);
}
#method_after
private void updatePmModels() {
    boolean isPm = getIsPm().getEntity();
    // $NON-NLS-1$
    final String ciscoUcsValue = "cisco_ucs";
    // Update primary PM fields.
    getManagementIp().setIsChangable(isPm);
    getManagementIp().setIsValid(true);
    getPmUserName().setIsChangable(isPm);
    getPmUserName().setIsValid(true);
    getPmPassword().setIsChangable(isPm);
    getPmPassword().setIsValid(true);
    getPmType().setIsChangable(isPm);
    getPmType().setIsValid(true);
    getPmPort().setIsChangable(isPm);
    getPmPort().setIsValid(true);
    getPmProxyPreferencesList().setIsChangable(getIsPm().getEntity());
    String proxySelectedItem = getPmProxyPreferencesList().getSelectedItem();
    getTestCommand().setIsExecutionAllowed(isPm);
    getProxyUpCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getProxyDownCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getPmSlot().setIsChangable(isPm);
    getPmOptions().setIsChangable(isPm);
    getPmOptions().setIsValid(true);
    getPmSecure().setIsChangable(isPm);
    VDSGroup cluster = getCluster().getSelectedItem();
    String version = AsyncDataProvider.getInstance().getDefaultConfigurationVersion();
    if (cluster != null) {
        version = cluster.getcompatibility_version().toString();
    }
    String pmType = getPmType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmType)) {
        AsyncDataProvider.getInstance().getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmType, version);
        setCiscoUcsPrimaryPmTypeSelected(pmType.equals(ciscoUcsValue));
    } else {
        getPmPort().setIsAvailable(false);
        getPmSlot().setIsAvailable(false);
        getPmSecure().setIsAvailable(false);
    }
    // Update secondary PM fields.
    getPmSecondaryIp().setIsChangable(isPm);
    getPmSecondaryIp().setIsValid(true);
    getPmSecondaryUserName().setIsChangable(isPm);
    getPmSecondaryUserName().setIsValid(true);
    getPmSecondaryPassword().setIsChangable(isPm);
    getPmSecondaryPassword().setIsValid(true);
    getPmSecondaryType().setIsChangable(isPm);
    getPmSecondaryType().setIsValid(true);
    getPmSecondaryPort().setIsChangable(isPm);
    getPmSecondaryPort().setIsValid(true);
    getPmSecondarySlot().setIsChangable(isPm);
    getPmSecondaryOptions().setIsChangable(isPm);
    getPmSecondaryOptions().setIsValid(true);
    getPmSecondarySecure().setIsChangable(isPm);
    getDisableAutomaticPowerManagement().setIsValid(true);
    getDisableAutomaticPowerManagement().setIsChangable(isPm);
    String pmSecondaryType = getPmSecondaryType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmSecondaryType)) {
        AsyncDataProvider.getInstance().getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmSecondaryPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSecondarySlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecondarySecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmSecondaryType, version);
        setCiscoUcsSecondaryPmTypeSelected(pmSecondaryType.equals(ciscoUcsValue));
    } else {
        getPmSecondaryPort().setIsAvailable(false);
        getPmSecondarySlot().setIsAvailable(false);
        getPmSecondarySecure().setIsAvailable(false);
    }
    // Update other PM fields.
    getPmVariants().setIsChangable(isPm);
    getPmSecondaryConcurrent().setIsChangable(isPm);
    getPmKdumpDetection().setIsChangable(isPm);
    getTestCommand().setIsExecutionAllowed(isPm);
}
#end_block

#method_before
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    FencingAgent agent = new FencingAgent();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    agent.setOrder(isPrimary ? 1 : 2);
    agent.setIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    agent.setType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    agent.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    agent.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    agent.setOptionsMap(getPmOptionsMap());
    param.setAgent(agent);
    Frontend.getInstance().runQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#method_after
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    FenceAgent agent = new FenceAgent();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    agent.setOrder(isPrimary ? 1 : 2);
    agent.setIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    agent.setType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    agent.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    agent.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    agent.setPort(isPrimary ? getPmPrimaryPortAsInteger() : getPmSecondaryPortAsIngeter());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setPmProxyPreferences(getPmProxyPreferences());
    agent.setOptionsMap(isPrimary ? getPmOptionsMap() : getPmSecondaryOptionsMap());
    param.setAgent(agent);
    Frontend.getInstance().runQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            String message;
            if (returnValue == null) {
                message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
            } else {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response.getReturnValue() == null) {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                } else {
                    FenceStatusReturnValue fenceStatusReturnValue = (FenceStatusReturnValue) response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                }
            }
            setMessage(message);
            getTestCommand().setIsExecutionAllowed(true);
        }
    }, true));
}
#end_block

#method_before
private void validatePmModels(boolean primary) {
    EntityModel<String> ip = primary ? getManagementIp() : getPmSecondaryIp();
    EntityModel<String> userName = primary ? getPmUserName() : getPmSecondaryUserName();
    EntityModel<String> password = primary ? getPmPassword() : getPmSecondaryPassword();
    ListModel<String> type = primary ? getPmType() : getPmSecondaryType();
    EntityModel<String> port = primary ? getPmPort() : getPmSecondaryPort();
    EntityModel<String> options = primary ? getPmOptions() : getPmSecondaryOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation() });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true) });
}
#method_after
private void validatePmModels(boolean primary) {
    EntityModel<String> ip = primary ? getManagementIp() : getPmSecondaryIp();
    EntityModel<String> userName = primary ? getPmUserName() : getPmSecondaryUserName();
    EntityModel<String> password = primary ? getPmPassword() : getPmSecondaryPassword();
    ListModel<String> type = primary ? getPmType() : getPmSecondaryType();
    EntityModel<String> port = primary ? getPmPort() : getPmSecondaryPort();
    EntityModel<String> options = primary ? getPmOptions() : getPmSecondaryOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(50) });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true) });
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if (getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setIsGeneralTabValid(getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid());
    setIsPowerManagementTabValid(getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    getNetworkProviderModel().validate();
    return getIsGeneralTabValid() && getIsPowerManagementTabValid() && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (Boolean.TRUE.equals(getIsDiscoveredHosts().getEntity())) {
        getUserPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255) });
        getExternalComputeResource().setIsValid(getExternalComputeResource().getSelectedItem() != null);
        getExternalHostGroups().setIsValid(getExternalHostGroups().getSelectedItem() != null);
    } else {
        getExternalComputeResource().setIsValid(true);
        getExternalHostGroups().setIsValid(true);
    }
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getConsoleAddress().getIsValid());
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if (getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid() && getExternalHostGroups().getIsValid() && getExternalComputeResource().getIsValid() && getUserPassword().getIsValid());
    setValidTab(TabName.POWER_MANAGEMENT_TAB, getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    getNetworkProviderModel().validate();
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValidTab(TabName.GENERAL_TAB) && isValidTab(TabName.POWER_MANAGEMENT_TAB) && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#end_block

#method_before
private boolean isEntityModelEmpty(EntityModel<String> model) {
    return !(model.getEntity() != null && !model.getEntity().equals(""));
}
#method_after
private boolean isEntityModelEmpty(EntityModel<String> model) {
    // $NON-NLS-1$
    return !(model.getEntity() != null && !model.getEntity().equals(""));
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setIsAvailable(showTransportProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFencingAgentsExist()) {
        orderAgents(vds.getFencingAgents());
        FencingAgent primaryAgent = vds.getFencingAgents().get(0);
        // Set primary PM parameters.
        getManagementIp().setEntity(primaryAgent.getIp());
        getPmUserName().setEntity(primaryAgent.getUser());
        getPmPassword().setEntity(primaryAgent.getPassword());
        getPmType().setSelectedItem(primaryAgent.getType());
        setPmOptionsMap(VdsStatic.pmOptionsStringToMap(primaryAgent.getOptions()));
        if (vds.getFencingAgents().size() > 1) {
            FencingAgent secondaryAgent = vds.getFencingAgents().get(1);
            // Set secondary PM parameters.
            getPmSecondaryIp().setEntity(secondaryAgent.getIp());
            getPmSecondaryUserName().setEntity(secondaryAgent.getUser());
            getPmSecondaryPassword().setEntity(secondaryAgent.getPassword());
            getPmSecondaryType().setSelectedItem(secondaryAgent.getType());
            setPmSecondaryOptionsMap(secondaryAgent.getOptionsMap());
            getPmSecondaryConcurrent().setEntity(secondaryAgent.getOrder() == primaryAgent.getOrder());
        }
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    getProtocol().setIsChangable(editTransportProperties(vds));
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFenceAgentsExist()) {
        orderAgents(vds.getFenceAgents());
        FenceAgent primaryAgent = vds.getFenceAgents().get(0);
        // Set primary PM parameters.
        getManagementIp().setEntity(primaryAgent.getIp());
        getPmUserName().setEntity(primaryAgent.getUser());
        getPmPassword().setEntity(primaryAgent.getPassword());
        getPmType().setSelectedItem(primaryAgent.getType());
        if (primaryAgent.getPort() != null) {
            getPmPort().setEntity(primaryAgent.getPort().toString());
        }
        setPmOptionsMap(VdsStatic.pmOptionsStringToMap(primaryAgent.getOptions()));
        if (vds.getFenceAgents().size() > 1) {
            FenceAgent secondaryAgent = vds.getFenceAgents().get(1);
            // Set secondary PM parameters.
            getPmSecondaryIp().setEntity(secondaryAgent.getIp());
            getPmSecondaryUserName().setEntity(secondaryAgent.getUser());
            getPmSecondaryPassword().setEntity(secondaryAgent.getPassword());
            getPmSecondaryType().setSelectedItem(secondaryAgent.getType());
            if (secondaryAgent.getPort() != null) {
                getPmSecondaryPort().setEntity(secondaryAgent.getPort().toString());
            }
            setPmSecondaryOptionsMap(secondaryAgent.getOptionsMap());
            getPmSecondaryConcurrent().setEntity(secondaryAgent.getOrder() == primaryAgent.getOrder());
        }
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void cleanHostParametersFields() {
    getName().setEntity(constants.empty());
    getComment().setEntity(constants.empty());
    getAuthSshPort().setEntity(Integer.parseInt(constants.defaultHostSSHPort()));
    getHost().setEntity(constants.empty());
    getUserPassword().setEntity(constants.empty());
    getFetchSshFingerprint().setEntity(constants.empty());
}
#method_after
public void cleanHostParametersFields() {
    // $NON-NLS-1$
    getName().setEntity("");
    // $NON-NLS-1$
    getComment().setEntity("");
    getAuthSshPort().setEntity(Integer.parseInt(constants.defaultHostSSHPort()));
    // $NON-NLS-1$
    getHost().setEntity("");
    // $NON-NLS-1$
    getUserPassword().setEntity("");
    // $NON-NLS-1$
    getFetchSshFingerprint().setEntity("");
}
#end_block

#method_before
public static void orderAgents(List<FencingAgent> fencingAgents) {
    synchronized (fencingAgents) {
        Collections.sort(fencingAgents, new FencingAgent.FencingAgentOrderComparator());
    }
}
#method_after
public static void orderAgents(List<FenceAgent> fenceAgents) {
    synchronized (fenceAgents) {
        Collections.sort(fenceAgents, new FenceAgent.FenceAgentOrderComparator());
    }
}
#end_block

#method_before
protected EngineLock acquireMonitorLock() {
    final VDS vds = getVds();
    EngineLock monitoringLock = new EngineLock(Collections.singletonMap(getParameters().getVdsId().toString(), new Pair<String, String>(LockingGroup.VDS_INIT.name(), "")), null);
    log.infoFormat("Before acquiring lock in order to prevent monitoring for host {0} from data-center {1}", vds.getName(), vds.getStoragePoolName());
    getLockManager().acquireLockWait(monitoringLock);
    log.infoFormat("Lock acquired, from now a monitoring of host will be skipped for host {0} from data-center {1}", vds.getName(), vds.getStoragePoolName());
    return monitoringLock;
}
#method_after
protected EngineLock acquireMonitorLock() {
    final VDS vds = getVds();
    EngineLock monitoringLock = new EngineLock(Collections.singletonMap(getParameters().getVdsId().toString(), new Pair<String, String>(LockingGroup.VDS_INIT.name(), "")), null);
    log.info("Before acquiring lock in order to prevent monitoring for host '{}' from data-center '{}'", vds.getName(), vds.getStoragePoolName());
    getLockManager().acquireLockWait(monitoringLock);
    log.info("Lock acquired, from now a monitoring of host will be skipped for host '{}' from data-center '{}'", vds.getName(), vds.getStoragePoolName());
    return monitoringLock;
}
#end_block

#method_before
protected void logMonitorLockReleased(String commandName) {
    final VDS vds = getVds();
    log.infoFormat(commandName + " finished. Lock released. Monitoring can run now for host {0} from data-center {1}", vds.getName(), vds.getStoragePoolName());
}
#method_after
protected void logMonitorLockReleased(String commandName) {
    final VDS vds = getVds();
    log.info("{} finished. Lock released. Monitoring can run now for host '{}' from data-center '{}'", commandName, vds.getName(), vds.getStoragePoolName());
}
#end_block

#method_before
protected void handleError(Exception e, VDSStatus status) {
    log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getName(), e);
    setVdsStatus(status);
    setSucceeded(false);
    _failureMessage = e.getMessage();
}
#method_after
protected void handleError(Exception e, VDSStatus status) {
    log.error("Host installation failed for host '{}', '{}': {}", getVds().getId(), getVds().getName(), e.getMessage());
    log.debug("Exception", e);
    setVdsStatus(status);
    setSucceeded(false);
    _failureMessage = e.getMessage();
}
#end_block

#method_before
protected String getErrorMessage(String msg) {
    return !StringUtils.isEmpty(msg) ? msg : String.format("Please refer to %1$s/engine.log and log logs under %1$s/ovirt-engine/host-deploy/ for further details.", EngineLocalConfig.getInstance().getLogDir());
}
#method_after
protected String getErrorMessage(String msg) {
    return !StringUtils.isEmpty(msg) ? msg : String.format("Please refer to %1$s/engine.log and log logs under %1$s/host-deploy/ for further details.", EngineLocalConfig.getInstance().getLogDir());
}
#end_block

#method_before
private static boolean isHostStatusOff(VDSFenceReturnValue returnValue) {
    String OFF = "off";
    boolean result = false;
    if (returnValue != null && returnValue.getFenceResult() != null) {
        FenceStatusReturnValue value = (FenceStatusReturnValue) returnValue.getFenceResult().getReturnValue();
        result = value.getStatus().equalsIgnoreCase(OFF);
    }
    return result;
}
#method_after
private static boolean isHostStatusOff(VDSFenceReturnValue returnValue) {
    String OFF = "off";
    boolean result = false;
    if (returnValue != null) {
        FenceStatusReturnValue value = (FenceStatusReturnValue) returnValue.getReturnValue();
        result = value.getStatus().equalsIgnoreCase(OFF);
    }
    return result;
}
#end_block

#method_before
@Override
protected Host postPopulate(Host from) {
    while (from.getPort() == 0) {
        from.setPort(MappingTestHelper.rand(65535));
    }
    from.getStorageManager().setPriority(3);
    return from;
}
#method_after
@Override
protected Host postPopulate(Host from) {
    while (from.getPort() == 0) {
        from.setPort(MappingTestHelper.rand(65535));
    }
    from.setProtocol(MappingTestHelper.shuffle(HostProtocol.class).value());
    from.getSpm().setPriority(3);
    return from;
}
#end_block

#method_before
@Override
protected VDS getInverse(VdsStatic to) {
    VDS inverse = new VDS();
    inverse.setId(to.getId());
    inverse.setVdsName(to.getName());
    inverse.setHostName(to.getHostName());
    inverse.setVdsGroupId(to.getVdsGroupId());
    inverse.setPort(to.getPort());
    inverse.setProtocol(to.getProtocol());
    inverse.setSshKeyFingerprint(to.getSshKeyFingerprint());
    inverse.setSshPort(to.getSshPort());
    inverse.setSshUsername(to.getSshUsername());
    inverse.setVdsSpmPriority(to.getVdsSpmPriority());
    inverse.setConsoleAddress(to.getConsoleAddress());
    inverse.setComment(to.getComment());
    return inverse;
}
#method_after
@Override
protected VDS getInverse(VdsStatic to) {
    VDS inverse = new VDS();
    inverse.setId(to.getId());
    inverse.setVdsName(to.getName());
    inverse.setHostName(to.getHostName());
    inverse.setVdsGroupId(to.getVdsGroupId());
    inverse.setPort(to.getPort());
    inverse.setProtocol(to.getProtocol());
    inverse.setSshKeyFingerprint(to.getSshKeyFingerprint());
    inverse.setHostProviderId(to.getHostProviderId());
    inverse.setSshPort(to.getSshPort());
    inverse.setSshUsername(to.getSshUsername());
    inverse.setVdsSpmPriority(to.getVdsSpmPriority());
    inverse.setConsoleAddress(to.getConsoleAddress());
    inverse.setComment(to.getComment());
    return inverse;
}
#end_block

#method_before
@Override
protected void verify(Host model, Host transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertEquals(model.getAddress(), transform.getAddress());
    assertEquals(model.getPort(), transform.getPort());
    assertEquals(model.getStorageManager().getPriority(), transform.getStorageManager().getPriority());
    assertEquals(model.getDisplay().getAddress(), transform.getDisplay().getAddress());
}
#method_after
@Override
protected void verify(Host model, Host transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertEquals(model.getAddress(), transform.getAddress());
    assertEquals(model.getPort(), transform.getPort());
    assertEquals(model.getSpm().getPriority(), transform.getSpm().getPriority());
    assertEquals(model.getDisplay().getAddress(), transform.getDisplay().getAddress());
}
#end_block

#method_before
@Test
public void testUpdatePowerManagementHostFromAgents() {
    String[] ip = { "1.1.1.111", "1.1.1.112" };
    PowerManagement powerMgmt = new PowerManagement();
    powerMgmt.setAddress(ip[0]);
    powerMgmt.setEnabled(true);
    powerMgmt.setPassword("passwd");
    powerMgmt.setType("apc");
    powerMgmt.setUsername("user");
    powerMgmt.setKdumpDetection(true);
    Agent agent = new Agent();
    agent.setOrder(1);
    agent.setAddress(ip[1]);
    Agents agents = new Agents();
    agents.getAgents().add(agent);
    powerMgmt.setAgents(agents);
    VdsStatic vdsStatic = new VdsStatic();
    vdsStatic.setPmEnabled(true);
    vdsStatic.setPmKdumpDetection(false);
    FencingAgent primaryAgent = new FencingAgent();
    primaryAgent.setIp(ip[0]);
    primaryAgent.setType("apc");
    primaryAgent.setUser("user");
    primaryAgent.setPassword("passwd");
    primaryAgent.setPort(123);
    primaryAgent.setOrder(1);
    VdsStatic mappedVdsStatic = HostMapper.map(powerMgmt, vdsStatic);
    assertEquals(mappedVdsStatic.isPmEnabled(), true);
    assertTrue(mappedVdsStatic.isPmKdumpDetection());
}
#method_after
@Test
public void testUpdatePowerManagementHostFromAgents() {
    String[] ip = { "1.1.1.111", "1.1.1.112" };
    PowerManagement powerMgmt = new PowerManagement();
    powerMgmt.setAddress(ip[0]);
    powerMgmt.setEnabled(true);
    powerMgmt.setPassword("passwd");
    powerMgmt.setType("apc");
    powerMgmt.setUsername("user");
    powerMgmt.setKdumpDetection(true);
    Agent agent = new Agent();
    agent.setOrder(1);
    agent.setAddress(ip[1]);
    Agents agents = new Agents();
    agents.getAgents().add(agent);
    powerMgmt.setAgents(agents);
    VdsStatic vdsStatic = new VdsStatic();
    vdsStatic.setPmEnabled(true);
    vdsStatic.setPmKdumpDetection(false);
    FenceAgent primaryAgent = new FenceAgent();
    primaryAgent.setIp(ip[0]);
    primaryAgent.setType("apc");
    primaryAgent.setUser("user");
    primaryAgent.setPassword("passwd");
    primaryAgent.setPort(123);
    primaryAgent.setOrder(1);
    VdsStatic mappedVdsStatic = HostMapper.map(powerMgmt, vdsStatic);
    assertEquals(mappedVdsStatic.isPmEnabled(), true);
    assertTrue(mappedVdsStatic.isPmKdumpDetection());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            addFencingAgentsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().getAddProvisioned()) {
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        AuditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending() && !getParameters().getAddProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().getAddProvisioned()) {
        if (getParameters().getComputeResource() == null) {
            log.error("Failed to provision: Compute resource cannot be empty");
            throw new VdcBLLException(VdcBllErrors.PROVIDER_PROVISION_MISSING_COMPUTERESOURCE);
        }
        if (getParameters().getHostGroup() == null) {
            log.error("Failed to provision: Host group cannot be empty");
            throw new VdcBLLException(VdcBllErrors.PROVIDER_PROVISION_MISSING_HOSTGROUP);
        }
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        getParameters().getvds().getStaticData().setHostProviderId(getParameters().getProviderId());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        AuditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            testVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending() && !getParameters().getAddProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
private boolean removeDeprecatedOvirtEntry(final Guid oVirtId) {
    final VDS vds = DbFacade.getInstance().getVdsDao().get(oVirtId);
    if (vds == null || !VdsHandler.isPendingOvirt(vds)) {
        return false;
    }
    String vdsName = getParameters().getVdsStaticData().getName();
    log.infoFormat("Host {0}, id {1} of type {2} is being re-registered as Host {3}", vds.getName(), vds.getId(), vds.getVdsType().name(), vdsName);
    VdcReturnValueBase result = TransactionSupport.executeInNewTransaction(new TransactionMethod<VdcReturnValueBase>() {

        @Override
        public VdcReturnValueBase runInTransaction() {
            return runInternalAction(VdcActionType.RemoveVds, new RemoveVdsParameters(oVirtId));
        }
    });
    if (!result.getSucceeded()) {
        String errors = result.getCanDoAction() ? result.getFault().getError().name() : StringUtils.join(result.getCanDoActionMessages(), ",");
        log.warnFormat("Failed to remove Host {0}, id {1}, re-registering it as Host {2} fails with errors {3}", vds.getName(), vds.getId(), vdsName, errors);
    } else {
        log.infoFormat("Host {0} is now known as Host {2}", vds.getName(), vdsName);
    }
    return result.getSucceeded();
}
#method_after
private boolean removeDeprecatedOvirtEntry(final Guid oVirtId) {
    final VDS vds = DbFacade.getInstance().getVdsDao().get(oVirtId);
    if (vds == null || !VdsHandler.isPendingOvirt(vds)) {
        return false;
    }
    String vdsName = getParameters().getVdsStaticData().getName();
    log.info("Host '{}', id '{}' of type '{}' is being re-registered as Host '{}'", vds.getName(), vds.getId(), vds.getVdsType().name(), vdsName);
    VdcReturnValueBase result = TransactionSupport.executeInNewTransaction(new TransactionMethod<VdcReturnValueBase>() {

        @Override
        public VdcReturnValueBase runInTransaction() {
            return runInternalAction(VdcActionType.RemoveVds, new RemoveVdsParameters(oVirtId));
        }
    });
    if (!result.getSucceeded()) {
        String errors = result.getCanDoAction() ? result.getFault().getError().name() : StringUtils.join(result.getCanDoActionMessages(), ",");
        log.warn("Failed to remove Host '{}', id '{}', re-registering it as Host '{}' fails with errors {}", vds.getName(), vds.getId(), vdsName, errors);
    } else {
        log.info("Host '{}' is now known as Host '{}'", vds.getName(), vdsName);
    }
    return result.getSucceeded();
}
#end_block

#method_before
private void AddVdsStaticToDb() {
    getParameters().getVdsStaticData().setServerSslEnabled(Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
    DbFacade.getInstance().getVdsStaticDao().save(getParameters().getVdsStaticData());
    getCompensationContext().snapshotNewEntity(getParameters().getVdsStaticData());
    setVdsIdRef(getParameters().getVdsStaticData().getId());
    setVds(null);
}
#method_after
private void AddVdsStaticToDb() {
    getParameters().getVdsStaticData().setServerSslEnabled(Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
    VdsStatic vdsStatic = getParameters().getVdsStaticData();
    if (vdsStatic.getProtocol() == null) {
        VDSGroup cluster = getVdsGroup();
        if (cluster != null && FeatureSupported.jsonProtocol(cluster.getcompatibility_version())) {
            vdsStatic.setProtocol(VdsProtocol.STOMP);
        } else {
            vdsStatic.setProtocol(VdsProtocol.XML);
        }
    }
    DbFacade.getInstance().getVdsStaticDao().save(getParameters().getVdsStaticData());
    getCompensationContext().snapshotNewEntity(getParameters().getVdsStaticData());
    setVdsIdRef(getParameters().getVdsStaticData().getId());
    setVds(null);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getName();
        String hostName = vds.getHostName();
        int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
        } else if (getVdsDAO().getByName(vdsName) != null) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        } else if (getVdsDAO().getAllForHostname(hostName).size() != 0) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
        } else if (!ValidationUtils.validatePort(vds.getSshPort())) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT);
        } else if ((StringUtils.isBlank(vds.getSshUsername())) || (vds.getSshUsername().length() > BusinessEntitiesDefinitions.USER_LOGIN_NAME_SIZE)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME);
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
            } else if (!getParameters().getAddPending() && (getParameters().getAuthMethod() == AuthenticationMethod.Password) && StringUtils.isEmpty(getParameters().getPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!isPowerManagementLegal(getParameters().getVdsStaticData(), getParameters().getFencingAgents(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (returnValue && isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
            if (upServer == null) {
                returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
            }
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getName();
        String hostName = vds.getHostName();
        int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
        } else if (getVdsDAO().getByName(vdsName) != null) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        } else if (getVdsDAO().getAllForHostname(hostName).size() != 0) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
        } else if (!ValidationUtils.validatePort(vds.getSshPort())) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT);
        } else if ((StringUtils.isBlank(vds.getSshUsername())) || (vds.getSshUsername().length() > BusinessEntitiesDefinitions.USER_LOGIN_NAME_SIZE)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME);
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
            } else if (!getParameters().getAddPending() && (getParameters().getAuthMethod() == AuthenticationMethod.Password) && StringUtils.isEmpty(getParameters().getPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!isPowerManagementLegal(getParameters().getVdsStaticData().isPmEnabled(), getParameters().getFenceAgents(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (returnValue && getParameters().getNetworkProviderId() != null) {
        returnValue = validateNetworkProviderProperties(getParameters().getNetworkProviderId(), getParameters().getNetworkMappings());
    }
    if (returnValue && isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
            if (upServer == null) {
                returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private String getInstalledVdsIdIfExists(SSHClient client) {
    try {
        ByteArrayOutputStream out = new ConstraintByteArrayOutputStream(256);
        client.executeCommand(Config.<String>getValue(ConfigValues.GetVdsmIdByVdsmToolCommand), null, out, null);
        return new String(out.toByteArray(), Charset.forName("UTF-8"));
    } catch (Exception e) {
        log.warnFormat("Failed to initiate vdsm-id request on host with message {0}", e.getMessage());
        return null;
    }
}
#method_after
private String getInstalledVdsIdIfExists(SSHClient client) {
    try {
        ByteArrayOutputStream out = new ConstraintByteArrayOutputStream(256);
        client.executeCommand(Config.<String>getValue(ConfigValues.GetVdsmIdByVdsmToolCommand), null, out, null);
        return new String(out.toByteArray(), Charset.forName("UTF-8"));
    } catch (Exception e) {
        log.warn("Failed to initiate vdsm-id request on host: {}", e.getMessage());
        log.debug("Exception", e);
        return null;
    }
}
#end_block

#method_before
protected boolean canConnect(VDS vds) {
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (!getParameters().getAddPending() && !getParameters().getAddProvisioned() && Config.<Boolean>getValue(ConfigValues.InstallVds)) {
        try (final EngineSSHClient sshclient = getSSHClient()) {
            sshclient.connect();
            sshclient.authenticate();
            String hostUUID = getInstalledVdsIdIfExists(sshclient);
            if (hostUUID != null && getVdsDAO().getAllWithUniqueId(hostUUID).size() != 0) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_UUID_EXIST);
            }
            return isValidGlusterPeer(sshclient, vds.getVdsGroupId());
        } catch (AuthenticationException e) {
            log.errorFormat("Failed to authenticate session with host {0}", vds.getName(), e);
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (SecurityException e) {
            log.errorFormat("Failed to connect to host {0}, fingerprint: {1}", vds.getName(), vds.getSshKeyFingerprint(), e);
            addCanDoActionMessage(VdcBllMessages.VDS_SECURITY_CONNECTION_ERROR);
            addCanDoActionMessageVariable("ErrorMessage", e.getMessage());
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (Exception e) {
            log.errorFormat("Failed to establish session with host {0}", vds.getName(), e);
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_CONNECT_TO_SERVER);
        }
    }
    return true;
}
#method_after
protected boolean canConnect(VDS vds) {
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (!getParameters().getAddPending() && !getParameters().getAddProvisioned() && Config.<Boolean>getValue(ConfigValues.InstallVds)) {
        try (final EngineSSHClient sshclient = getSSHClient()) {
            sshclient.connect();
            sshclient.authenticate();
            String hostUUID = getInstalledVdsIdIfExists(sshclient);
            if (hostUUID != null && getVdsDAO().getAllWithUniqueId(hostUUID).size() != 0) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_UUID_EXIST);
            }
            return isValidGlusterPeer(sshclient, vds.getVdsGroupId());
        } catch (AuthenticationException e) {
            log.error("Failed to authenticate session with host '{}': {}", vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (SecurityException e) {
            log.error("Failed to connect to host '{}', fingerprint '{}': {}", vds.getName(), vds.getSshKeyFingerprint(), e.getMessage());
            log.debug("Exception", e);
            addCanDoActionMessage(VdcBllMessages.VDS_SECURITY_CONNECTION_ERROR);
            addCanDoActionMessageVariable("ErrorMessage", e.getMessage());
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (Exception e) {
            log.error("Failed to establish session with host '{}': {}", vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_CONNECT_TO_SERVER);
        }
    }
    return true;
}
#end_block

#method_before
private boolean isValidGlusterPeer(SSHClient sshclient, Guid clusterId) {
    if (isGlusterSupportEnabled() && clusterHasServers()) {
        try {
            // Must not allow adding a server that already is part of another gluster cluster
            Set<String> peers = getGlusterUtil().getPeers(sshclient);
            if (peers.size() > 0) {
                for (String peer : peers) {
                    if (getGlusterDBUtils().serverExists(clusterId, peer)) {
                        // peer present in cluster. so server being added is valid.
                        return true;
                    }
                }
                // none of the peers present in the cluster. fail with appropriate error.
                return failCanDoAction(VdcBllMessages.SERVER_ALREADY_PART_OF_ANOTHER_CLUSTER);
            }
        } catch (Exception e) {
            // This can happen if glusterd is not running on the server. Ignore it and let the server get added.
            // Peer probe will anyway fail later and the server will then go to non-operational status.
            log.debugFormat("Could not check if server {0} is already part of another gluster cluster. Will allow adding it.", sshclient.getHost(), e);
        }
    }
    return true;
}
#method_after
private boolean isValidGlusterPeer(SSHClient sshclient, Guid clusterId) {
    if (isGlusterSupportEnabled() && clusterHasServers()) {
        try {
            // Must not allow adding a server that already is part of another gluster cluster
            Set<String> peers = getGlusterUtil().getPeers(sshclient);
            if (peers.size() > 0) {
                for (String peer : peers) {
                    if (getGlusterDBUtils().serverExists(clusterId, peer)) {
                        // peer present in cluster. so server being added is valid.
                        return true;
                    }
                }
                // none of the peers present in the cluster. fail with appropriate error.
                return failCanDoAction(VdcBllMessages.SERVER_ALREADY_PART_OF_ANOTHER_CLUSTER);
            }
        } catch (Exception e) {
            // This can happen if glusterd is not running on the server. Ignore it and let the server get added.
            // Peer probe will anyway fail later and the server will then go to non-operational status.
            log.debug("Could not check if server '{}' is already part of another gluster cluster. Will" + " allow adding it.", sshclient.getHost());
            log.debug("Exception", e);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VDS vds = DbFacade.getInstance().getVdsDao().get(getParameters().getVdsId());
    FenceExecutor executor = new FenceExecutor(vds);
    VDSFenceReturnValue result = executor.checkStatus();
    if (result.isSucceeded()) {
        // Remove all alerts including NOT CONFIG alert
        AlertDirector.RemoveAllVdsAlerts(getParameters().getVdsId(), true);
        getQueryReturnValue().setReturnValue(result.getFenceResult());
    } else {
        handleError(result);
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    VDS vds = DbFacade.getInstance().getVdsDao().get(getParameters().getVdsId());
    FenceExecutor executor = new FenceExecutor(vds);
    VDSFenceReturnValue result = executor.checkStatus();
    if (result.getSucceeded()) {
        // Remove all alerts including NOT CONFIG alert
        AlertDirector.RemoveAllVdsAlerts(getParameters().getVdsId(), true);
        getQueryReturnValue().setReturnValue(result);
    } else {
        handleError(result);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = false;
    _oldVds = getVdsDAO().get(getVdsId());
    if (_oldVds != null && getParameters().getVdsStaticData() != null) {
        String compatibilityVersion = _oldVds.getVdsGroupCompatibilityVersion().toString();
        if (VdsHandler.isUpdateValid(getParameters().getVdsStaticData(), _oldVds.getStaticData(), _oldVds.getStatus())) {
            if ("".equals(getParameters().getVdsStaticData().getName())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
            String vdsName = getParameters().getvds().getName();
            String hostName = getParameters().getvds().getHostName();
            int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
            // check that VDS name is not null or empty
            if (vdsName == null || vdsName.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
                returnValue = false;
            // check that VDS name is not too long
            } else if (vdsName.length() > maxVdsNameLength) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
                returnValue = false;
            } else if (_oldVds.getStatus() != VDSStatus.InstallFailed && !_oldVds.getHostName().equals(hostName)) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOSTNAME_CANNOT_CHANGE);
                returnValue = false;
            } else // check if a name is updated to an existing vds name
            if (!StringUtils.equalsIgnoreCase(_oldVds.getName(), getParameters().getVdsStaticData().getName()) && getVdsDAO().getByName(vdsName) != null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            } else if (!StringUtils.equalsIgnoreCase(_oldVds.getHostName(), getParameters().getVdsStaticData().getHostName()) && getVdsDAO().getAllForHostname(hostName).size() != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
            } else if (getParameters().getInstallVds() && _oldVds.getStatus() != VDSStatus.Maintenance && _oldVds.getStatus() != VDSStatus.NonOperational && _oldVds.getStatus() != VDSStatus.InstallFailed && _oldVds.getStatus() != VDSStatus.InstallingOS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
            } else if (getParameters().getInstallVds() && getParameters().getAuthMethod() == AuthenticationMethod.Password && StringUtils.isEmpty(getParameters().getPassword()) && getParameters().getVdsStaticData().getVdsType() == VDSType.VDS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!getParameters().getInstallVds() && _oldVds.getPort() != getParameters().getVdsStaticData().getPort()) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_CHANGE_REQUIRE_INSTALL);
            } else if (!_oldVds.getVdsGroupId().equals(getParameters().getVdsStaticData().getVdsGroupId())) {
                // Forbid updating group id - this must be done through
                // ChangeVDSClusterCommand
                // This is due to permission check that must be done both on
                // the VDS and on the VDSGroup
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPDATE_CLUSTER);
            } else {
                returnValue = true;
            }
            // if all ok check PM is legal
            returnValue = returnValue && isPowerManagementLegal(getParameters().getVdsStaticData(), getParameters().getFencingAgents(), compatibilityVersion);
        } else {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = false;
    _oldVds = getVdsDAO().get(getVdsId());
    if (_oldVds != null && getParameters().getVdsStaticData() != null) {
        String compatibilityVersion = _oldVds.getVdsGroupCompatibilityVersion().toString();
        if (VdsHandler.isUpdateValid(getParameters().getVdsStaticData(), _oldVds.getStaticData(), _oldVds.getStatus())) {
            if ("".equals(getParameters().getVdsStaticData().getName())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
            String vdsName = getParameters().getvds().getName();
            String hostName = getParameters().getvds().getHostName();
            int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
            // check that VDS name is not null or empty
            if (vdsName == null || vdsName.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
                returnValue = false;
            // check that VDS name is not too long
            } else if (vdsName.length() > maxVdsNameLength) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
                returnValue = false;
            } else if (_oldVds.getStatus() != VDSStatus.InstallFailed && !_oldVds.getHostName().equals(hostName)) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOSTNAME_CANNOT_CHANGE);
                returnValue = false;
            } else // check if a name is updated to an existing vds name
            if (!StringUtils.equalsIgnoreCase(_oldVds.getName(), getParameters().getVdsStaticData().getName()) && getVdsDAO().getByName(vdsName) != null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            } else if (!StringUtils.equalsIgnoreCase(_oldVds.getHostName(), getParameters().getVdsStaticData().getHostName()) && getVdsDAO().getAllForHostname(hostName).size() != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
            } else if (getParameters().getInstallVds() && _oldVds.getStatus() != VDSStatus.Maintenance && _oldVds.getStatus() != VDSStatus.NonOperational && _oldVds.getStatus() != VDSStatus.InstallFailed && _oldVds.getStatus() != VDSStatus.InstallingOS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
            } else if (getParameters().getInstallVds() && getParameters().getAuthMethod() == AuthenticationMethod.Password && StringUtils.isEmpty(getParameters().getPassword()) && getParameters().getVdsStaticData().getVdsType() == VDSType.VDS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!getParameters().getInstallVds() && _oldVds.getPort() != getParameters().getVdsStaticData().getPort()) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_CHANGE_REQUIRE_INSTALL);
            } else if (!_oldVds.getVdsGroupId().equals(getParameters().getVdsStaticData().getVdsGroupId())) {
                // Forbid updating group id - this must be done through
                // ChangeVDSClusterCommand
                // This is due to permission check that must be done both on
                // the VDS and on the VDSGroup
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPDATE_CLUSTER);
            } else if (getParameters().getInstallVds() && getParameters().getNetworkProviderId() != null) {
                returnValue = validateNetworkProviderProperties(getParameters().getNetworkProviderId(), getParameters().getNetworkMappings());
            } else if (getParameters().getVdsStaticData().getProtocol() != _oldVds.getProtocol() && _oldVds.getStatus() != VDSStatus.Maintenance && _oldVds.getStatus() != VDSStatus.InstallingOS) {
                addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
            } else {
                returnValue = true;
            }
            // if all ok check PM is legal
            returnValue = returnValue && isPowerManagementLegal(getParameters().getVdsStaticData().isPmEnabled(), getParameters().getFenceAgents(), compatibilityVersion);
        } else {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setNetworkProviderId(getParameters().getNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.errorFormat("Installation/upgrade of Host {0},{1} failed due to: {2} ", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setNetworkProviderId(getParameters().getNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.error("Installation/upgrade of Host '{}', '{}' failed: {}", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    if (_oldVds.getProtocol() != getParameters().getVdsStaticData().getProtocol()) {
        ResourceManager.getInstance().reestablishConnection(_oldVds.getId());
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    testVdsPowerManagementStatus(getParameters().getVdsStaticData());
    checkKdumpIntegrationStatus();
    setSucceeded(true);
}
#end_block

#method_before
private void updateVdsData() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(getVds().getStaticData());
            DbFacade.getInstance().getVdsStaticDao().update(getParameters().getVdsStaticData());
            // TODO: what compensation needed for fencing?
            updateFencingAgents();
            getCompensationContext().stateChanged();
            return null;
        }

        private void updateFencingAgents() {
            if (getParameters().getFencingAgents() != null) {
                // if == null, means no update. Empty list means
                // delete agents.
                DbFacade.getInstance().getFencingAgentDao().removeByVdsId(getVdsId());
                for (FencingAgent agent : getParameters().getFencingAgents()) {
                    agent.setHostId(getVdsId());
                    DbFacade.getInstance().getFencingAgentDao().save(agent);
                }
            }
        }
    });
}
#method_after
private void updateVdsData() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(getVds().getStaticData());
            DbFacade.getInstance().getVdsStaticDao().update(getParameters().getVdsStaticData());
            // TODO: what compensation needed for fencing?
            updateFenceAgents();
            getCompensationContext().stateChanged();
            return null;
        }

        private void updateFenceAgents() {
            if (getParameters().getFenceAgents() != null) {
                // if == null, means no update. Empty list means
                // delete agents.
                DbFacade.getInstance().getFenceAgentDao().removeByVdsId(getVdsId());
                for (FenceAgent agent : getParameters().getFenceAgents()) {
                    agent.setHostId(getVdsId());
                    DbFacade.getInstance().getFenceAgentDao().save(agent);
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public Host update(Host incoming) {
    validateEnums(Host.class, incoming);
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.equals(entity.getVdsGroupId())) {
            performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(clusterId, guid));
            // After changing the cluster with the specialized command we need to reload the entity, so that it
            // contains the new cluster id. If we don't do this the next command will think that we are trying
            // to change the cluster, and it will explicitly refuse to perform the update.
            entity = getEntity(hostResolver, true);
        }
    }
    deprecatedUpdateFencingAgents(incoming);
    Host host = performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
    deprecatedAddLinksToAgents(host);
    return host;
}
#method_after
@Override
public Host update(Host incoming) {
    validateEnums(Host.class, incoming);
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.equals(entity.getVdsGroupId())) {
            performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(clusterId, guid));
            // After changing the cluster with the specialized command we need to reload the entity, so that it
            // contains the new cluster id. If we don't do this the next command will think that we are trying
            // to change the cluster, and it will explicitly refuse to perform the update.
            entity = getEntity(hostResolver, true);
        }
    }
    // deprecatedUpdateFenceAgents(incoming);
    Host host = performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
    deprecatedAddLinksToAgents(host);
    return host;
}
#end_block

#method_before
@Override
public Response fence(Action action) {
    validateParameters(action, "fenceType");
    FenceType fenceType = validateEnum(FenceType.class, action.getFenceType().toUpperCase());
    switch(fenceType) {
        case MANUAL:
            return fenceManually(action);
        case RESTART:
            return fence(action, VdcActionType.RestartVds, FenceActionType.Restart);
        case START:
            return fence(action, VdcActionType.StartVds, FenceActionType.Start);
        case STOP:
            return fence(action, VdcActionType.StopVds, FenceActionType.Stop);
        case STATUS:
            return getFencingStatus(action);
        default:
            return null;
    }
}
#method_after
@Override
public Response fence(Action action) {
    validateParameters(action, "fenceType");
    FenceType fenceType = validateEnum(FenceType.class, action.getFenceType().toUpperCase());
    switch(fenceType) {
        case MANUAL:
            return fenceManually(action);
        case RESTART:
            return fence(action, VdcActionType.RestartVds, FenceActionType.Restart);
        case START:
            return fence(action, VdcActionType.StartVds, FenceActionType.Start);
        case STOP:
            return fence(action, VdcActionType.StopVds, FenceActionType.Stop);
        case STATUS:
            return getFenceStatus(action);
        default:
            return null;
    }
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Host incoming, VDS entity) {
    VdsStatic updated = getMapper(modelType, VdsStatic.class).map(incoming, entity.getStaticData());
    UpdateVdsActionParameters updateParams = new UpdateVdsActionParameters(updated, incoming.getRootPassword(), false);
    if (incoming.isSetOverrideIptables()) {
        updateParams.setOverrideFirewall(incoming.isOverrideIptables());
    }
    // Update of Transport protocol not supported
    updateParams = (UpdateVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(incoming, (VdsOperationActionParameters) updateParams);
    return updateParams;
}
#method_after
@Override
public VdcActionParametersBase getParameters(Host incoming, VDS entity) {
    VdsStatic updated = getMapper(modelType, VdsStatic.class).map(incoming, entity.getStaticData());
    UpdateVdsActionParameters updateParams = new UpdateVdsActionParameters(updated, incoming.getRootPassword(), false);
    // Updating Fence-agents is deprecated from this context, so the original, unchanged, list of agents is
    // passed to the engine.
    updateParams.setFenceAgents(entity.getFenceAgents());
    if (incoming.isSetOverrideIptables()) {
        updateParams.setOverrideFirewall(incoming.isOverrideIptables());
    }
    updateParams = (UpdateVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(incoming, (VdsOperationActionParameters) updateParams);
    return updateParams;
}
#end_block

#method_before
@Override
protected Host deprecatedPopulate(Host model, VDS entity) {
    Host host = parent.addStatistics(model, entity, uriInfo, httpHeaders);
    parent.addCertificateInfo(host);
    return host;
}
#method_after
@Override
protected Host deprecatedPopulate(Host model, VDS entity) {
    parent.addStatistics(model, entity);
    parent.addCertificateInfo(model);
    return model;
}
#end_block

#method_before
private void getAttachedTagsToSelectedHosts(TagListModel model) {
    ArrayList<Guid> hostIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        hostIds.add(vds.getId());
    }
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<Tags>();
    selectedItemsCounter = 0;
    for (Guid hostId : hostIds) {
        AsyncDataProvider.getAttachedTagsToHost(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                HostListModel hostListModel = (HostListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                hostListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                hostListModel.selectedItemsCounter++;
                if (hostListModel.selectedItemsCounter == hostListModel.getSelectedItems().size()) {
                    postGetAttachedTags(hostListModel, tagListModel);
                }
            }
        }), hostId);
    }
}
#method_after
private void getAttachedTagsToSelectedHosts(TagListModel model) {
    ArrayList<Guid> hostIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        hostIds.add(vds.getId());
    }
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<Tags>();
    selectedItemsCounter = 0;
    for (Guid hostId : hostIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToHost(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                HostListModel hostListModel = (HostListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                hostListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                hostListModel.selectedItemsCounter++;
                if (hostListModel.selectedItemsCounter == hostListModel.getSelectedItems().size()) {
                    postGetAttachedTags(hostListModel, tagListModel);
                }
            }
        }), hostId);
    }
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel<VDSGroup> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                VDSGroup cluster = clusterModel.getSelectedItem();
                Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getcompatibility_version().toString());
                if (jsonSupported) {
                    hostModel.getProtocol().setEntity(true);
                } else {
                    hostModel.getProtocol().setEntity(false);
                    hostModel.getProtocol().setIsChangable(false);
                }
            }
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            hostModel.setHelpTag(HelpTag.edit_host);
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            hostModel.setHelpTag(HelpTag.edit_host);
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFencingAgents(getFencingAgents(model));
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getIsProvisioning()) {
            Provider<?> provider = (Provider<?>) model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFencingAgents(getFencingAgents(model));
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(getFenceAgents(model));
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(getFenceAgents(model));
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    model.setHelpTag(HelpTag.remove_host);
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress(null);
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    model.setHelpTag(HelpTag.remove_host);
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress(null);
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void approve() {
    HostModel hostModel = new EditHostModel();
    setWindow(hostModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            innerHostModel.updateModelFromVds(host, dataCenters, false, getSystemTreeSelectedItem());
            innerHostModel.setTitle(ConstantsManager.getInstance().getConstants().editAndApproveHostTitle());
            innerHostModel.setHelpTag(HelpTag.edit_and_approve_host);
            // $NON-NLS-1$
            innerHostModel.setHashName("edit_and_approve_host");
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnApprove", hostListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            innerHostModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", hostListModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            innerHostModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void approve() {
    HostModel hostModel = new EditHostModel();
    setWindow(hostModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            innerHostModel.updateModelFromVds(host, dataCenters, false, getSystemTreeSelectedItem());
            innerHostModel.setTitle(ConstantsManager.getInstance().getConstants().editAndApproveHostTitle());
            innerHostModel.setHelpTag(HelpTag.edit_and_approve_host);
            // $NON-NLS-1$
            innerHostModel.setHashName("edit_and_approve_host");
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnApprove", hostListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            innerHostModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", hostListModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            innerHostModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void install() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    model.getUserPassword().setIsAvailable(true);
    model.getUserPassword().setIsChangable(true);
    Version v3 = new Version(3, 0);
    boolean isLessThan3 = host.getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
    if (!isLessThan3) {
        model.getOverrideIpTables().setIsAvailable(true);
        model.getOverrideIpTables().setEntity(true);
    }
    addInstallCommands(model, host, false);
    getWindow().stopProgress();
}
#method_after
public void install() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    model.getUserPassword().setIsAvailable(true);
    model.getUserPassword().setIsChangable(true);
    Version v3 = new Version(3, 0);
    boolean isLessThan3 = host.getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
    if (!isLessThan3) {
        model.getOverrideIpTables().setIsAvailable(true);
        model.getOverrideIpTables().setEntity(true);
    }
    model.getActivateHostAfterInstall().setEntity(true);
    addInstallCommands(model, host, false);
    getWindow().stopProgress();
}
#end_block

#method_before
public void onInstall() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = host.getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        model.setValidationFailed(new EntityModel<Boolean>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#method_after
public void onInstall() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = host.getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        model.setValidationFailed(new EntityModel<Boolean>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    param.setFenceAgents(host.getFenceAgents());
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#end_block

#method_before
public void upgrade() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            InstallModel model = (InstallModel) target;
            ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
            Collections.sort(isos, new Comparator<RpmVersion>() {

                @Override
                public int compare(RpmVersion rpmV1, RpmVersion rpmV2) {
                    return RpmVersionUtils.compareRpmParts(rpmV2.getRpmName(), rpmV1.getRpmName());
                }
            });
            model.getOVirtISO().setItems(isos);
            model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
            model.getOVirtISO().setIsAvailable(true);
            model.getOVirtISO().setIsChangable(!isos.isEmpty());
            model.getHostVersion().setIsAvailable(true);
            if (isos.isEmpty()) {
                model.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
            }
            if (host.getHostOs() == null) {
                model.setMessage(ConstantsManager.getInstance().getConstants().hostMustBeInstalledBeforeUpgrade());
            }
            addUpgradeCommands(model, host, isos.isEmpty());
            getWindow().stopProgress();
        }
    }), host.getId());
}
#method_after
public void upgrade() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getActivateHostAfterInstall().setEntity(true);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            InstallModel model = (InstallModel) target;
            ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
            Collections.sort(isos, new Comparator<RpmVersion>() {

                @Override
                public int compare(RpmVersion rpmV1, RpmVersion rpmV2) {
                    return RpmVersionUtils.compareRpmParts(rpmV2.getRpmName(), rpmV1.getRpmName());
                }
            });
            model.getOVirtISO().setItems(isos);
            model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
            model.getOVirtISO().setIsAvailable(true);
            model.getOVirtISO().setIsChangable(!isos.isEmpty());
            model.getHostVersion().setIsAvailable(true);
            if (isos.isEmpty()) {
                model.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
            }
            if (host.getHostOs() == null) {
                model.setMessage(ConstantsManager.getInstance().getConstants().hostMustBeInstalledBeforeUpgrade());
            }
            addUpgradeCommands(model, host, isos.isEmpty());
            getWindow().stopProgress();
        }
    }), host.getId());
}
#end_block

#method_before
public void onUpgrade() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = host.getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? model.getOVirtISO().getSelectedItem().getRpmName() : null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.UpgradeOvirtNode, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#method_after
public void onUpgrade() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = host.getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? model.getOVirtISO().getSelectedItem().getRpmName() : null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.UpgradeOvirtNode, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#end_block

#method_before
private void configureLocalStorage2(ConfigureLocalStorageModel model) {
    String prefix = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.RhevhLocalFSPath);
    if (!StringHelper.isNullOrEmpty(prefix)) {
        EntityModel pathModel = model.getStorage().getPath();
        pathModel.setEntity(prefix);
        pathModel.setIsChangable(false);
    }
    configureLocalStorage3(model);
}
#method_after
private void configureLocalStorage2(ConfigureLocalStorageModel model) {
    String prefix = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.RhevhLocalFSPath);
    if (!StringHelper.isNullOrEmpty(prefix)) {
        EntityModel pathModel = model.getStorage().getPath();
        pathModel.setEntity(prefix);
        pathModel.setIsChangable(false);
    }
    configureLocalStorage3(model);
}
#end_block

#method_before
private void onConfigureLocalStorage() {
    ConfigureLocalStorageModel model = (ConfigureLocalStorageModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.startProgress(ConstantsManager.getInstance().getConstants().configuringLocalStorageHost());
    ReversibleFlow flow = new ReversibleFlow();
    flow.getCompleteEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ConfigureLocalStorageModel model = (ConfigureLocalStorageModel) ev.getContext();
            model.stopProgress();
            cancel();
        }
    }, model);
    // $NON-NLS-1$
    String correlationId = TaskListModel.createCorrelationId("Configure Local Storage");
    flow.enlist(new AddDataCenterRM(correlationId));
    flow.enlist(new AddClusterRM(correlationId));
    flow.enlist(new ChangeHostClusterRM(correlationId));
    flow.enlist(new AddStorageDomainRM(correlationId));
    flow.run(new EnlistmentContext(this));
}
#method_after
private void onConfigureLocalStorage() {
    ConfigureLocalStorageModel model = (ConfigureLocalStorageModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.startProgress(ConstantsManager.getInstance().getConstants().configuringLocalStorageHost());
    ReversibleFlow flow = new ReversibleFlow();
    flow.getCompleteEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ConfigureLocalStorageModel model = (ConfigureLocalStorageModel) ev.getContext();
            model.stopProgress();
            cancel();
        }
    }, model);
    // $NON-NLS-1$
    String correlationId = TaskListModel.createCorrelationId("Configure Local Storage");
    flow.enlist(new AddDataCenterRM(correlationId));
    flow.enlist(new AddClusterRM(correlationId));
    flow.enlist(new ChangeHostClusterRM(correlationId));
    flow.enlist(new AddStorageDomainRM(correlationId));
    flow.run(new EnlistmentContext(this));
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.VDS, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(applySortOptions(getSearchString()), SearchType.VDS, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    if (getSelectedItem() != null) {
        updateAlerts();
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    boolean installAvailability = false;
    if (items.size() == 1 && items.get(0) instanceof VDS) {
        VDS host = items.get(0);
        installAvailability = host.getStatus() == VDSStatus.InstallFailed || host.getStatus() == VDSStatus.Maintenance;
    }
    getInstallCommand().setIsExecutionAllowed(installAvailability);
    getInstallCommand().setIsAvailable(installAvailability);
    boolean upgradeAvailability = false;
    if (installAvailability) {
        VDS host = items.get(0);
        if (host.getVdsType() == VDSType.oVirtNode) {
            upgradeAvailability = true;
        }
    }
    getUpgradeCommand().setIsExecutionAllowed(upgradeAvailability);
    getUpgradeCommand().setIsAvailable(upgradeAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
}
#method_after
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    boolean installAvailability = false;
    if (items.size() == 1 && items.get(0) instanceof VDS) {
        VDS host = items.get(0);
        installAvailability = host.getStatus() == VDSStatus.InstallFailed || host.getStatus() == VDSStatus.Maintenance;
    }
    getInstallCommand().setIsExecutionAllowed(installAvailability);
    getInstallCommand().setIsAvailable(installAvailability);
    boolean upgradeAvailability = false;
    if (installAvailability) {
        VDS host = items.get(0);
        if (host.getVdsType() == VDSType.oVirtNode) {
            upgradeAvailability = true;
        }
    }
    getUpgradeCommand().setIsExecutionAllowed(upgradeAvailability);
    getUpgradeCommand().setIsAvailable(upgradeAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
    boolean numaVisible = false;
    if (getSelectedItem() != null) {
        numaVisible = ((VDS) getSelectedItem()).isNumaSupport();
    }
    getNumaSupportCommand().setIsVisible(numaVisible);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit(false);
    } else if (command == getEditWithPMemphasisCommand()) {
        edit(true);
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSelectAsSpmCommand()) {
        selectAsSPM();
    } else if (command == getActivateCommand()) {
        activate();
    } else if (command == getMaintenanceCommand()) {
        maintenance();
    } else if (command == getApproveCommand()) {
        approve();
    } else if (command == getInstallCommand()) {
        install();
    } else if (command == getUpgradeCommand()) {
        upgrade();
    } else if (command == getRestartCommand()) {
        restart();
    } else if (command == getStartCommand()) {
        start();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getManualFenceCommand()) {
        manualFence();
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getConfigureLocalStorageCommand()) {
        configureLocalStorage();
    } else if (command == getRefreshCapabilitiesCommand()) {
        refreshCapabilities();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "OnManualFence".equals(command.getName())) {
        onManualFence();
    } else if (// $NON-NLS-1$
    "OnSaveFalse".equals(command.getName())) {
        onSaveFalse();
    } else if (// $NON-NLS-1$
    "OnSaveInternalFromApprove".equals(command.getName())) {
        onSaveInternalFromApprove();
    } else if (// $NON-NLS-1$
    "OnSaveInternalNotFromApprove".equals(command.getName())) {
        onSaveInternalNotFromApprove();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "CancelConfirm".equals(command.getName())) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    "CancelConfirmFocusPM".equals(command.getName())) {
        cancelConfirmFocusPM();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnMaintenance".equals(command.getName())) {
        onMaintenance();
    } else if (// $NON-NLS-1$
    "OnApprove".equals(command.getName())) {
        onApprove();
    } else if (// $NON-NLS-1$
    "OnInstall".equals(command.getName())) {
        onInstall();
    } else if (// $NON-NLS-1$
    "OnUpgrade".equals(command.getName())) {
        onUpgrade();
    } else if (// $NON-NLS-1$
    "OnRestart".equals(command.getName())) {
        onRestart();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnConfigureLocalStorage".equals(command.getName())) {
        onConfigureLocalStorage();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit(false);
    } else if (command == getEditWithPMemphasisCommand()) {
        edit(true);
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSelectAsSpmCommand()) {
        selectAsSPM();
    } else if (command == getActivateCommand()) {
        activate();
    } else if (command == getMaintenanceCommand()) {
        maintenance();
    } else if (command == getApproveCommand()) {
        approve();
    } else if (command == getInstallCommand()) {
        install();
    } else if (command == getUpgradeCommand()) {
        upgrade();
    } else if (command == getRestartCommand()) {
        restart();
    } else if (command == getStartCommand()) {
        start();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getManualFenceCommand()) {
        manualFence();
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getConfigureLocalStorageCommand()) {
        configureLocalStorage();
    } else if (command == getRefreshCapabilitiesCommand()) {
        refreshCapabilities();
    } else if (command == getNumaSupportCommand()) {
        numaSupport();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "OnManualFence".equals(command.getName())) {
        onManualFence();
    } else if (// $NON-NLS-1$
    "OnSaveFalse".equals(command.getName())) {
        onSaveFalse();
    } else if (// $NON-NLS-1$
    "OnSaveInternalFromApprove".equals(command.getName())) {
        onSaveInternalFromApprove();
    } else if (// $NON-NLS-1$
    "OnSaveInternalNotFromApprove".equals(command.getName())) {
        onSaveInternalNotFromApprove();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "CancelConfirm".equals(command.getName())) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    "CancelConfirmFocusPM".equals(command.getName())) {
        cancelConfirmFocusPM();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnMaintenance".equals(command.getName())) {
        onMaintenance();
    } else if (// $NON-NLS-1$
    "OnApprove".equals(command.getName())) {
        onApprove();
    } else if (// $NON-NLS-1$
    "OnInstall".equals(command.getName())) {
        onInstall();
    } else if (// $NON-NLS-1$
    "OnUpgrade".equals(command.getName())) {
        onUpgrade();
    } else if (// $NON-NLS-1$
    "OnRestart".equals(command.getName())) {
        onRestart();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnConfigureLocalStorage".equals(command.getName())) {
        onConfigureLocalStorage();
    } else if (NumaSupportModel.SUBMIT_NUMA_SUPPORT.equals(command.getName())) {
        onNumaSupport();
    }
}
#end_block

#method_before
private boolean initTrustedService() {
    List<String> hosts = new ArrayList<String>();
    if (AttestThread.isTrustedVds(getVds().getId())) {
        return true;
    }
    hosts.add(getVds().getHostName());
    List<AttestationValue> value = new ArrayList<AttestationValue>();
    try {
        value = AttestationService.getInstance().attestHosts(hosts);
    } catch (Exception e) {
        log.errorFormat("Encounter an exception while attesting host's trustworthiness for Host {0}, Error is {1}", hosts, e);
    }
    if (value.size() > 0 && value.get(0).getTrustLevel() == AttestationResultEnum.TRUSTED) {
        return true;
    } else {
        setNonOperational(NonOperationalReason.UNTRUSTED, null);
        return false;
    }
}
#method_after
private boolean initTrustedService() {
    List<String> hosts = new ArrayList<String>();
    if (AttestThread.isTrustedVds(getVds().getId())) {
        return true;
    }
    hosts.add(getVds().getHostName());
    List<AttestationValue> value = new ArrayList<AttestationValue>();
    try {
        value = AttestationService.getInstance().attestHosts(hosts);
    } catch (Exception e) {
        log.error("Encounter an exception while attesting host's trustworthiness for Host '{}': {}", hosts, e.getMessage());
        log.debug("Exception", e);
    }
    if (value.size() > 0 && value.get(0).getTrustLevel() == AttestationResultEnum.TRUSTED) {
        return true;
    } else {
        setNonOperational(NonOperationalReason.UNTRUSTED, null);
        return false;
    }
}
#end_block

#method_before
private void processFence() {
    FenceExecutor executor = new FenceExecutor(getVds());
    vdsProxyFound = executor.isProxyHostAvailable();
    if (getVds().getpm_enabled() && vdsProxyFound) {
        VDSFenceReturnValue returnValue = executor.checkStatus();
        fenceSucceeded = returnValue.isSucceeded();
        fenceStatusReturnValue = (FenceStatusReturnValue) returnValue.getFenceResult().getReturnValue();
    }
}
#method_after
private void processFence() {
    FenceExecutor executor = new FenceExecutor(getVds());
    vdsProxyFound = new FenceProxyLocator(getVds()).isProxyHostAvailable();
    if (getVds().getpm_enabled() && vdsProxyFound) {
        VDSFenceReturnValue returnValue = executor.checkStatus();
        // potential bug here - if no proxy host found, this variable
        fenceSucceeded = returnValue.getSucceeded();
        // is still 'true'
        fenceStatusReturnValue = (FenceStatusReturnValue) returnValue.getReturnValue();
    }
}
#end_block

#method_before
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomainByTypeAndPool(storagePoolId, StorageDomainType.Master);
    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(storagePoolId);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.Inactive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomain.getId(), storagePoolIsoMap));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.infoFormat("Could not connect host {0} to pool {1}, as the master domain is in inactive/unknown status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.errorFormat("Could not connect host {0} to pool {1} with the message: {2}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        Pair<Boolean, List<StorageDomainStatic>> vdsStatsResults = proceedVdsStats(!masterDomainInactiveOrUnknown);
        result.setSuccess(vdsStatsResults.getFirst());
        if (!result.isSuccess()) {
            result.setResultData(vdsStatsResults.getSecond());
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#method_after
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomain(storagePoolId, StorageDomainType.Master);
    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(storagePoolId);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.Inactive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomain.getId(), storagePoolIsoMap));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.info("Could not connect host '{}' to pool '{}', as the master domain is in inactive/unknown" + " status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.error("Could not connect host '{}' to pool '{}': {}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        Pair<Boolean, List<StorageDomainStatic>> vdsStatsResults = proceedVdsStats(!masterDomainInactiveOrUnknown);
        result.setSuccess(vdsStatsResults.getFirst());
        if (!result.isSuccess()) {
            result.setResultData(vdsStatsResults.getSecond());
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#end_block

#method_before
private VDSReturnValue runUpdateMomPolicy(final VDSGroup cluster, final VDS vds) {
    VDSReturnValue returnValue = new VDSReturnValue();
    if (cluster.getcompatibility_version().compareTo(Version.v3_3) >= 0) {
        try {
            returnValue = runVdsCommand(VDSCommandType.SetMOMPolicyParameters, new MomPolicyVDSParameters(vds, cluster.isEnableBallooning(), cluster.isEnableKsm()));
        } catch (VdcBLLException e) {
            log.errorFormat("Could not update MoM policy on host {0}", vds.getName());
            returnValue.setSucceeded(false);
        }
    }
    return returnValue;
}
#method_after
private VDSReturnValue runUpdateMomPolicy(final VDSGroup cluster, final VDS vds) {
    VDSReturnValue returnValue = new VDSReturnValue();
    if (cluster.getcompatibility_version().compareTo(Version.v3_3) >= 0) {
        try {
            returnValue = runVdsCommand(VDSCommandType.SetMOMPolicyParameters, new MomPolicyVDSParameters(vds, cluster.isEnableBallooning(), cluster.isEnableKsm()));
        } catch (VdcBLLException e) {
            log.error("Could not update MoM policy on host '{}'", vds.getName());
            returnValue.setSucceeded(false);
        }
    }
    return returnValue;
}
#end_block

#method_before
private Pair<Boolean, List<StorageDomainStatic>> proceedVdsStats(boolean shouldCheckReportedDomains) {
    Pair<Boolean, List<StorageDomainStatic>> returnValue = new Pair<>(true, null);
    try {
        runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
        if (shouldCheckReportedDomains) {
            List<Guid> problematicDomainsIds = IrsBrokerCommand.fetchDomainsReportedAsProblematic(getVds().getStoragePoolId(), getVds().getDomains());
            for (Guid domainId : problematicDomainsIds) {
                StorageDomainStatic domainInfo = getStorageDomainStaticDAO().get(domainId);
                log.errorFormat("Storage Domain {0} of pool {1} is in problem in host {2}", domainInfo != null ? domainInfo.getStorageName() : domainId, getStoragePool().getName(), getVds().getName());
                if (domainInfo == null || domainInfo.getStorageDomainType().isDataDomain()) {
                    returnValue.setFirst(false);
                    if (returnValue.getSecond() == null) {
                        returnValue.setSecond(new ArrayList<StorageDomainStatic>());
                    }
                    returnValue.getSecond().add(domainInfo);
                }
            }
        }
    } catch (VdcBLLException e) {
        log.errorFormat("Could not get Host statistics for Host {0}, Error is {1}", getVds().getName(), e);
        returnValue.setFirst(false);
    }
    return returnValue;
}
#method_after
private Pair<Boolean, List<StorageDomainStatic>> proceedVdsStats(boolean shouldCheckReportedDomains) {
    Pair<Boolean, List<StorageDomainStatic>> returnValue = new Pair<>(true, null);
    try {
        runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
        if (shouldCheckReportedDomains) {
            List<Guid> problematicDomainsIds = IrsBrokerCommand.fetchDomainsReportedAsProblematic(getVds().getStoragePoolId(), getVds().getDomains());
            for (Guid domainId : problematicDomainsIds) {
                StorageDomainStatic domainInfo = getStorageDomainStaticDAO().get(domainId);
                log.error("Storage Domain '{}' of pool '{}' is in problem in host '{}'", domainInfo != null ? domainInfo.getStorageName() : domainId, getStoragePool().getName(), getVds().getName());
                if (domainInfo == null || domainInfo.getStorageDomainType().isDataDomain()) {
                    returnValue.setFirst(false);
                    if (returnValue.getSecond() == null) {
                        returnValue.setSecond(new ArrayList<StorageDomainStatic>());
                    }
                    returnValue.getSecond().add(domainInfo);
                }
            }
        }
    } catch (VdcBLLException e) {
        log.error("Could not get Host statistics for Host '{}': {}", getVds().getName(), e.getMessage());
        log.debug("Exception", e);
        returnValue.setFirst(false);
    }
    return returnValue;
}
#end_block

#method_before
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!getGlusterUtil().isHostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!getGlusterUtil().isHostExists(newGlusterServers, getVds())) {
                            log.infoFormat("Failed to find host {0} in gluster peer list from {1} on attempt {2}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#method_after
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!getGlusterUtil().isHostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < getMaxRetriesGlusterProbeStatus()) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!getGlusterUtil().isHostExists(newGlusterServers, getVds())) {
                            log.info("Failed to find host '{}' in gluster peer list from '{}' on attempt {}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == getMaxRetriesGlusterProbeStatus()) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogableBase logable = new AuditLogableBase(getVdsId());
            logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
            AuditLogDirector.log(logable, AuditLogType.GLUSTER_SERVER_ADD_FAILED);
            glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.errorFormat("Could not peer probe the gluster server {0}. Error: {1}", getVds().getHostName(), e.getMessage());
        glusterPeerProbeSucceeded = false;
        return false;
    }
}
#method_after
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogableBase logable = new AuditLogableBase(getVdsId());
            logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
            AuditLogDirector.log(logable, AuditLogType.GLUSTER_SERVER_ADD_FAILED);
            glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.error("Could not peer probe the gluster server '{}': {}", getVds().getHostName(), e.getMessage());
        log.debug("Exception", e);
        glusterPeerProbeSucceeded = false;
        return false;
    }
}
#end_block

#method_before
private void initHostKdumpDetectionStatus() {
    // host is UP, remove kdump status
    getDbFacade().getVdsKdumpStatusDao().remove(getVdsId());
    if (getVds().isPmKdumpDetection() && getVds().getKdumpStatus() != KdumpStatus.ENABLED) {
        AuditLogableBase base = new AuditLogableBase();
        base.setVds(getVds());
        AuditLogDirector.log(base, AuditLogType.KDUMP_DETECTION_NOT_CONFIGURED_ON_VDS);
    }
}
#method_after
private void initHostKdumpDetectionStatus() {
    // host is UP, remove kdump status
    getDbFacade().getVdsKdumpStatusDao().remove(getVdsId());
    if (getVds().getpm_enabled() && getVds().isPmKdumpDetection() && getVds().getKdumpStatus() != KdumpStatus.ENABLED) {
        AuditLogableBase base = new AuditLogableBase();
        base.setVds(getVds());
        AuditLogDirector.log(base, AuditLogType.KDUMP_DETECTION_NOT_CONFIGURED_ON_VDS);
    }
}
#end_block

#method_before
public void initialize() {
    if (Config.<Boolean>getValue(ConfigValues.PMHealthCheckEnabled)) {
        log.info("Start initializing " + getClass().getSimpleName());
        Integer pmHealthCheckInterval = Config.<Integer>getValue(ConfigValues.PMHealthCheckIntervalInSec);
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "pmHealthCheck", new Class[] {}, new Object[] {}, pmHealthCheckInterval, pmHealthCheckInterval, TimeUnit.SECONDS);
        log.info("Finished initializing " + getClass().getSimpleName());
    }
}
#method_after
public void initialize() {
    if (Config.<Boolean>getValue(ConfigValues.PMHealthCheckEnabled)) {
        log.info("Start initializing {}", getClass().getSimpleName());
        Integer pmHealthCheckInterval = Config.<Integer>getValue(ConfigValues.PMHealthCheckIntervalInSec);
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "pmHealthCheck", new Class[] {}, new Object[] {}, pmHealthCheckInterval, pmHealthCheckInterval, TimeUnit.SECONDS);
        log.info("Finished initializing {}", getClass().getSimpleName());
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("pmHealthCheck")
public void pmHealthCheck() {
    // skip PM health check if previous operation is not completed yet
    if (!active) {
        try {
            synchronized (instance) {
                log.info("Power Management Health Check started.");
                active = true;
                List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
                for (VDS host : hosts) {
                    if (host.getpm_enabled()) {
                        // check health
                        PmHealth pmHealth = checkPMHealth(host);
                        // handle alerts - adding or canceling as necessary
                        handleAlerts(pmHealth);
                    }
                }
                log.info("Power Management Health Check completed.");
            }
        } finally {
            active = false;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("pmHealthCheck")
public void pmHealthCheck() {
    // skip PM health check if previous operation is not completed yet
    if (!active) {
        try {
            synchronized (instance) {
                log.info("Power Management Health Check started.");
                active = true;
                List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
                for (VDS host : hosts) {
                    if (host.getpm_enabled()) {
                        // check health
                        PmHealth pmHealth = checkPMHealth(host);
                        // handle alerts - adding or canceling as necessary
                        handleAlerts(pmHealth);
                        log.debug(pmHealth.toString());
                    }
                }
                log.info("Power Management Health Check completed.");
            }
        } finally {
            active = false;
        }
    }
}
#end_block

#method_before
private PmHealth checkPMHealth(VDS host) {
    PmHealth pmHealth = new PmHealth(host);
    AgentsIterator iterator = PowerManagementHelper.getAgentsIterator(host.getFencingAgents());
    // In each step of the loop deal with the agents with the next 'order' (one or more). Write info into PmHealth.
    while (iterator.hasNext()) {
        collectHealthStatus(pmHealth, iterator.next());
    }
    return pmHealth;
}
#method_after
private PmHealth checkPMHealth(VDS host) {
    PmHealth pmHealth = new PmHealth(host);
    AgentsIterator iterator = PowerManagementHelper.getAgentsIterator(host.getFenceAgents());
    // In each step of the loop deal with the agents with the next 'order' (one or more). Write info into PmHealth.
    while (iterator.hasNext()) {
        collectHealthStatus(pmHealth, iterator.next());
    }
    return pmHealth;
}
#end_block

#method_before
private void handleAlerts(PmHealth healthStatus) {
    Guid hostId = healthStatus.getHost().getId();
    for (Entry<FencingAgent, Boolean> entry : healthStatus.getHealthMap().entrySet()) {
        handleAgentAlerts(entry, hostId);
    }
    handleStartAlerts(healthStatus, hostId);
    handleStopAlerts(healthStatus, hostId);
}
#method_after
private void handleAlerts(PmHealth healthStatus) {
    Guid hostId = healthStatus.getHost().getId();
    // TODO: uncomment pending implementation of removing alerts by agent-id.
    // for (Entry<FenceAgent, Boolean> entry : healthStatus.getHealthMap().entrySet()) {
    // handleAgentAlerts(entry, hostId);
    // }
    handleStartAlerts(healthStatus, hostId);
    handleStopAlerts(healthStatus, hostId);
}
#end_block

#method_before
private void handleStartAlerts(PmHealth healthStatus, Guid hostId) {
    if (healthStatus.isStartShouldWork()) {
        removeAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    } else {
        addAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    }
}
#method_after
// private void handleAgentAlerts(Entry<FenceAgent, Boolean> entry, Guid hostId) {
// Guid agentId = entry.getKey().getId();
// boolean agentHealthy = entry.getValue();
// if (agentHealthy) {
// removeAlert(agentId, hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FENCE_AGENT_NON_RESPONSIVE);
// } else {
// addAlert(agentId, hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FENCE_AGENT_NON_RESPONSIVE);
// }
// 
// }
// private void addAlert(Guid agentId, Guid hostId, AuditLogType auditMessage) {
// AuditLogableBase alert = new AuditLogableBase();
// alert.addCustomValue(AGENT_ID, agentId.toString());
// AlertDirector.AddVdsAlert(hostId, auditMessage, alert);
// }
// 
// private void removeAlert(Guid agentId, Guid hostId, AuditLogType auditMessage) {
// AuditLogableBase alert = new AuditLogableBase();
// alert.addCustomValue(AGENT_ID, agentId.toString());
// AlertDirector.RemoveVdsAlert(hostId, auditMessage, alert);
// }
private void handleStartAlerts(PmHealth healthStatus, Guid hostId) {
    if (healthStatus.isStartShouldWork()) {
        removeAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    } else {
        addAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    }
}
#end_block

#method_before
private void collectHealthStatus(PmHealth healthStatus, List<FencingAgent> agents) {
    // initialize to false, and if one healthy agent found, change to true.
    boolean atLeastOneHealthy = false;
    // initialize to true, and if one unhealthy agent found, change to false.
    boolean allHealthy = true;
    for (FencingAgent agent : agents) {
        if (isHealthy(agent, healthStatus.getHost())) {
            atLeastOneHealthy = true;
        } else {
            allHealthy = false;
        }
    }
    if (atLeastOneHealthy) {
        healthStatus.setStartShouldWork(true);
    }
    if (allHealthy) {
        healthStatus.setStopShouldWork(true);
    }
}
#method_after
private void collectHealthStatus(PmHealth healthStatus, List<FenceAgent> agents) {
    // initialize to false, and if one healthy agent found, change to true.
    boolean atLeastOneHealthy = false;
    // initialize to true, and if one unhealthy agent found, change to false.
    boolean allHealthy = true;
    for (FenceAgent agent : agents) {
        if (isHealthy(agent, healthStatus.getHost())) {
            healthStatus.getHealthMap().put(agent, true);
            atLeastOneHealthy = true;
        } else {
            healthStatus.getHealthMap().put(agent, false);
            allHealthy = false;
        }
    }
    if (atLeastOneHealthy) {
        healthStatus.setStartShouldWork(true);
    }
    if (allHealthy) {
        healthStatus.setStopShouldWork(true);
    }
}
#end_block

#method_before
private boolean isHealthy(FencingAgent agent, VDS host) {
    return new FenceExecutor(host).checkStatus().isSucceeded();
}
#method_after
private boolean isHealthy(FenceAgent agent, VDS host) {
    return new FenceExecutor(host).fence(FenceActionType.Status, agent).getSucceeded();
}
#end_block

#method_before
public void startHosts(List<VDS> hostWithPMInStatusReboot) {
    for (VDS host : hostWithPMInStatusReboot) {
        RestartVdsCommand restartVdsCommand = new RestartVdsCommand(new FenceVdsActionParameters(host.getId(), FenceActionType.Status));
        if (restartVdsCommand.isPmReportsStatusDown()) {
            VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.RestartVds, restartVdsCommand.getParameters());
            if (retValue != null && retValue.getSucceeded()) {
                log.infoFormat("Host {0} was started successfully by PM Health Check Manager", host.getName());
            } else {
                log.infoFormat("PM Health Check Manager failed to start Host {0}", host.getName());
            }
        }
    }
}
#method_after
public void startHosts(List<VDS> hostWithPMInStatusReboot) {
    for (VDS host : hostWithPMInStatusReboot) {
        RestartVdsCommand<FenceVdsActionParameters> restartVdsCommand = new RestartVdsCommand<FenceVdsActionParameters>(new FenceVdsActionParameters(host.getId(), FenceActionType.Status));
        if (restartVdsCommand.isPmReportsStatusDown()) {
            VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.RestartVds, restartVdsCommand.getParameters());
            if (retValue != null && retValue.getSucceeded()) {
                log.info("Host '{}' was started successfully by PM Health Check Manager", host.getName());
            } else {
                log.info("PM Health Check Manager failed to start Host '{}'", host.getName());
            }
        }
    }
}
#end_block

#method_before
public Map<FencingAgent, Boolean> getHealthMap() {
    return healthMap;
}
#method_after
public Map<FenceAgent, Boolean> getHealthMap() {
    return healthMap;
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParams(final VdsStatic vds) {
    return getCustomMapSqlParameterSource().addValue("host_name", vds.getHostName()).addValue("free_text_comment", vds.getComment()).addValue("vds_unique_id", vds.getUniqueID()).addValue("port", vds.getPort()).addValue("protocol", vds.getProtocol()).addValue("vds_group_id", vds.getVdsGroupId()).addValue("vds_id", vds.getId()).addValue("vds_name", vds.getName()).addValue("server_SSL_enabled", vds.isServerSslEnabled()).addValue("vds_type", vds.getVdsType()).addValue("vds_strength", vds.getVdsStrength()).addValue("pm_enabled", vds.isPmEnabled()).addValue("pm_proxy_preferences", vds.getPmProxyPreferences()).addValue("pm_detect_kdump", vds.isPmKdumpDetection()).addValue("otp_validity", vds.getOtpValidity()).addValue("vds_spm_priority", vds.getVdsSpmPriority()).addValue("console_address", vds.getConsoleAddress()).addValue("sshKeyFingerprint", vds.getSshKeyFingerprint()).addValue("ssh_port", vds.getSshPort()).addValue("ssh_username", vds.getSshUsername()).addValue("disable_auto_pm", vds.isDisablePowerManagementPolicy());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParams(final VdsStatic vds) {
    return getCustomMapSqlParameterSource().addValue("host_name", vds.getHostName()).addValue("free_text_comment", vds.getComment()).addValue("vds_unique_id", vds.getUniqueID()).addValue("port", vds.getPort()).addValue("protocol", vds.getProtocol()).addValue("vds_group_id", vds.getVdsGroupId()).addValue("vds_id", vds.getId()).addValue("vds_name", vds.getName()).addValue("server_SSL_enabled", vds.isServerSslEnabled()).addValue("vds_type", vds.getVdsType()).addValue("vds_strength", vds.getVdsStrength()).addValue("pm_enabled", vds.isPmEnabled()).addValue("pm_proxy_preferences", vds.getPmProxyPreferences()).addValue("pm_detect_kdump", vds.isPmKdumpDetection()).addValue("otp_validity", vds.getOtpValidity()).addValue("vds_spm_priority", vds.getVdsSpmPriority()).addValue("console_address", vds.getConsoleAddress()).addValue("sshKeyFingerprint", vds.getSshKeyFingerprint()).addValue("ssh_port", vds.getSshPort()).addValue("ssh_username", vds.getSshUsername()).addValue("disable_auto_pm", vds.isDisablePowerManagementPolicy()).addValue("host_provider_id", vds.getHostProviderId());
}
#end_block

#method_before
@Override
public VdsStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsStatic entity = new VdsStatic();
    entity.setHostName(rs.getString("host_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueID(rs.getString("vds_unique_id"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setVdsGroupId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_group_id")));
    entity.setId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_id")));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    return entity;
}
#method_after
@Override
public VdsStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsStatic entity = new VdsStatic();
    entity.setHostName(rs.getString("host_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueID(rs.getString("vds_unique_id"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setVdsGroupId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_group_id")));
    entity.setId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_id")));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    return entity;
}
#end_block

#method_before
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setVdsName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetProtocol()) {
        entity.setProtocol(VdsProtocol.fromValue(model.getProtocol()));
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetStorageManager()) {
        if (model.getStorageManager().getPriority() != null) {
            entity.setVdsSpmPriority(model.getStorageManager().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    return entity;
}
#method_after
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setVdsName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetProtocol()) {
        map(model.getProtocol(), entity);
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetStorageManager()) {
        if (model.getStorageManager().getPriority() != null) {
            entity.setVdsSpmPriority(model.getStorageManager().getPriority());
        }
    }
    if (model.isSetSpm()) {
        if (model.getSpm().getPriority() != null) {
            entity.setVdsSpmPriority(model.getSpm().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    model.setProtocol(map(entity.getProtocol(), (String) null));
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    PowerManagement pm = map(entity, (PowerManagement) null);
    model.setPowerManagement(DeprecatedPowerManagementMapper.map(entity.getFencingAgents(), pm));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    model.setLiveSnapshotSupport(entity.getLiveSnapshotSupport());
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostProtocol protocol = map(entity.getProtocol(), null);
    model.setProtocol(protocol != null ? protocol.value() : null);
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    SPM spm = new SPM();
    spm.setPriority(entity.getVdsSpmPriority());
    if (spm.getStatus() != null) {
        spm.setStatus(StatusUtils.create(map(entity.getSpmStatus(), null)));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    PowerManagement pm = map(entity, (PowerManagement) null);
    model.setPowerManagement(DeprecatedPowerManagementMapper.map(entity.getFenceAgents(), pm));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    model.setLiveSnapshotSupport(entity.getLiveSnapshotSupport());
    return model;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    if (entity.getPmProxyPreferences() != null) {
        PmProxies pmProxies = new PmProxies();
        String[] proxies = StringUtils.split(entity.getPmProxyPreferences(), ",");
        for (String proxy : proxies) {
            PmProxy pmProxy = new PmProxy();
            pmProxy.setType(proxy);
            pmProxies.getPmProxy().add(pmProxy);
        }
        model.setPmProxies(pmProxies);
    }
    model.setKdumpDetection(entity.isPmKdumpDetection());
    model.setEnabled(entity.getpm_enabled());
    model.setAutomaticPmEnabled(!entity.isDisablePowerManagementPolicy());
    if (entity.getpm_enabled()) {
        DeprecatedPowerManagementMapper.map(entity.getFencingAgents(), model);
    }
    return model;
}
#method_after
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    if (entity.getPmProxyPreferences() != null) {
        PmProxies pmProxies = new PmProxies();
        String[] proxies = StringUtils.split(entity.getPmProxyPreferences(), ",");
        for (String proxy : proxies) {
            PmProxy pmProxy = new PmProxy();
            pmProxy.setType(proxy);
            pmProxies.getPmProxy().add(pmProxy);
        }
        model.setPmProxies(pmProxies);
    }
    model.setKdumpDetection(entity.isPmKdumpDetection());
    model.setEnabled(entity.getpm_enabled());
    model.setAutomaticPmEnabled(!entity.isDisablePowerManagementPolicy());
    if (entity.getpm_enabled()) {
        DeprecatedPowerManagementMapper.map(entity.getFenceAgents(), model);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VdsProtocol.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.VdsProtocol protocol, String template) {
    String result = null;
    if (protocol != null) {
        switch(protocol) {
            case STOMP:
                result = VdsProtocol.STOMP.value();
                break;
            case AMQP:
                result = VdsProtocol.AMQP.value();
                break;
            case XML:
            default:
                result = VdsProtocol.XML.value();
                break;
        }
    }
    return result;
}
#method_after
@Mapping(from = VdsProtocol.class, to = HostProtocol.class)
public static HostProtocol map(VdsProtocol protocol, HostProtocol template) {
    HostProtocol result = null;
    if (protocol != null) {
        switch(protocol) {
            case STOMP:
                result = HostProtocol.STOMP;
                break;
            case AMQP:
                result = HostProtocol.AMQP;
                break;
            case XML:
            default:
                result = HostProtocol.XML;
                break;
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean validateInputs() {
    if (!super.validateInputs()) {
        return false;
    }
    VdcQueryReturnValue returnValue = getQueryReturnValue();
    returnValue.setExceptionString("");
    try {
        String hostName = getParameters().getVdsHostName();
        if (StringUtils.isEmpty(hostName)) {
            returnValue.setExceptionString("Cannot register Host - no Hostname address specified.");
            return false;
        }
        String vdsUniqueId = getParameters().getVdsUniqueId();
        if (StringUtils.isEmpty(vdsUniqueId)) {
            returnValue.setExceptionString(String.format("Cannot register host '%1$s' - host id is empty.", hostName));
            AuditLogableBase logable = new AuditLogableBase();
            logable.addCustomValue("VdsHostName", hostName);
            AuditLogDirector.log(logable, AuditLogType.VDS_REGISTER_EMPTY_ID);
            return false;
        }
        List<VDS> vdssByUniqueId = getVdssByUniqueId();
        if (vdssByUniqueId.size() > 1) {
            returnValue.setExceptionString("Cannot register Host - unique id is ambigious.");
            return false;
        }
        if (vdssByUniqueId.size() == 1) {
            VDS vds = vdssByUniqueId.get(0);
            if (!VdsHandler.isPendingOvirt(vds)) {
                returnValue.setExceptionString(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE.name());
                return false;
            }
        }
    } catch (RuntimeException ex) {
        log.error(ex);
        returnValue.setExceptionString(String.format("Cannot register Host - An exception has been thrown: %1$s", ex.getMessage()));
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validateInputs() {
    if (!super.validateInputs()) {
        return false;
    }
    VdcQueryReturnValue returnValue = getQueryReturnValue();
    returnValue.setExceptionString("");
    try {
        String hostName = getParameters().getVdsHostName();
        if (StringUtils.isEmpty(hostName)) {
            returnValue.setExceptionString("Cannot register Host - no Hostname address specified.");
            return false;
        }
        String vdsUniqueId = getParameters().getVdsUniqueId();
        if (StringUtils.isEmpty(vdsUniqueId)) {
            returnValue.setExceptionString(String.format("Cannot register host '%1$s' - host id is empty.", hostName));
            AuditLogableBase logable = new AuditLogableBase();
            logable.addCustomValue("VdsHostName", hostName);
            AuditLogDirector.log(logable, AuditLogType.VDS_REGISTER_EMPTY_ID);
            return false;
        }
        List<VDS> vdssByUniqueId = getVdssByUniqueId();
        if (vdssByUniqueId.size() > 1) {
            returnValue.setExceptionString("Cannot register Host - unique id is ambigious.");
            return false;
        }
        if (vdssByUniqueId.size() == 1) {
            VDS vds = vdssByUniqueId.get(0);
            if (!VdsHandler.isPendingOvirt(vds)) {
                returnValue.setExceptionString(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE.name());
                return false;
            }
        }
    } catch (RuntimeException ex) {
        log.error("Exception", ex);
        returnValue.setExceptionString(String.format("Cannot register Host - An exception has been thrown: %1$s", ex.getMessage()));
        return false;
    }
    return true;
}
#end_block

#method_before
protected void executeRegisterVdsCommand() {
    synchronized (doubleRegistrationLock) {
        // force to reload vdss by unique ID used later on
        _vdssByUniqueId = null;
        VDS vdsByUniqueId = getVdssByUniqueId().size() != 0 ? getVdssByUniqueId().get(0) : null;
        // in case oVirt host was added for the second time - perform approval
        if (vdsByUniqueId != null && vdsByUniqueId.getStatus() == VDSStatus.PendingApproval) {
            getQueryReturnValue().setSucceeded(dispatchOvirtApprovalCommand(vdsByUniqueId.getId()));
            return;
        }
        log.debug("RegisterVdsQuery::ExecuteCommand - Entering");
        if (StringUtils.isEmpty(getParameters().getVdsName())) {
            getParameters().setVdsName(getParameters().getVdsUniqueId());
            log.debug("RegisterVdsQuery::ExecuteCommand - VdsName empty, using VdsUnique ID as name");
        }
        logable.addCustomValue("VdsName1", getParameters().getVdsName());
        Guid vdsGroupId;
        if (Guid.Empty.equals(getParameters().getVdsGroupId())) {
            vdsGroupId = Guid.createGuidFromStringDefaultEmpty(Config.<String>getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID));
            log.debugFormat("RegisterVdsQuery::ExecuteCommand - VdsGroupId received as -1, using AutoRegistrationDefaultVdsGroupID: {0}", vdsGroupId);
        } else {
            vdsGroupId = getParameters().getVdsGroupId();
        }
        // TODO: always add in pending state, and if auto approve call
        // approve command action after registration
        RefObject<Boolean> isPending = new RefObject<Boolean>(Boolean.FALSE);
        getQueryReturnValue().setSucceeded(HandleOldVdssWithSameHostName(vdsByUniqueId) && HandleOldVdssWithSameName(vdsByUniqueId) && CheckAutoApprovalDefinitions(isPending) && Register(vdsByUniqueId, vdsGroupId, isPending.argvalue.booleanValue()));
        log.debugFormat("RegisterVdsQuery::ExecuteCommand - Leaving Succeded value is {0}", getQueryReturnValue().getSucceeded());
    }
}
#method_after
protected void executeRegisterVdsCommand() {
    synchronized (doubleRegistrationLock) {
        List<VDS> hostsByHostName = DbFacade.getInstance().getVdsDao().getAllForHostname(getParameters().getVdsName());
        VDS provisionedVds = hostsByHostName.size() != 0 ? hostsByHostName.get(0) : null;
        if (provisionedVds != null && provisionedVds.getStatus() != VDSStatus.InstallingOS) {
            // if not in InstallingOS status, this host is not provisioned.
            provisionedVds = null;
        }
        // force to reload vdss by unique ID used later on
        _vdssByUniqueId = null;
        VDS vdsByUniqueId = getVdssByUniqueId().size() != 0 ? getVdssByUniqueId().get(0) : null;
        // in case oVirt host was added for the second time - perform approval
        if (vdsByUniqueId != null && vdsByUniqueId.getStatus() == VDSStatus.PendingApproval) {
            getQueryReturnValue().setSucceeded(dispatchOvirtApprovalCommand(vdsByUniqueId.getId()));
            return;
        }
        log.debug("RegisterVdsQuery::ExecuteCommand - Entering");
        if (StringUtils.isEmpty(getParameters().getVdsName())) {
            getParameters().setVdsName(getParameters().getVdsUniqueId());
            log.debug("RegisterVdsQuery::ExecuteCommand - VdsName empty, using VdsUnique ID as name");
        }
        logable.addCustomValue("VdsName1", getParameters().getVdsName());
        Guid vdsGroupId;
        if (Guid.Empty.equals(getParameters().getVdsGroupId())) {
            vdsGroupId = Guid.createGuidFromStringDefaultEmpty(Config.<String>getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID));
            log.debug("RegisterVdsQuery::ExecuteCommand - VdsGroupId received as -1, using AutoRegistrationDefaultVdsGroupID: '{}'", vdsGroupId);
        } else {
            vdsGroupId = getParameters().getVdsGroupId();
        }
        if (provisionedVds != null) {
            // In provision don't set host on pending - isPending = false
            getQueryReturnValue().setSucceeded(Register(provisionedVds, vdsGroupId, false));
        } else {
            // TODO: always add in pending state, and if auto approve call
            // approve command action after registration
            RefObject<Boolean> isPending = new RefObject<Boolean>(Boolean.FALSE);
            getQueryReturnValue().setSucceeded(HandleOldVdssWithSameHostName(vdsByUniqueId) && HandleOldVdssWithSameName(vdsByUniqueId) && CheckAutoApprovalDefinitions(isPending) && Register(vdsByUniqueId, vdsGroupId, isPending.argvalue.booleanValue()));
        }
        log.debug("RegisterVdsQuery::ExecuteCommand - Leaving Succeded value is '{}'", getQueryReturnValue().getSucceeded());
    }
}
#end_block

#method_before
private boolean dispatchOvirtApprovalCommand(Guid oVirtId) {
    boolean isApprovalDispatched = true;
    final ApproveVdsParameters params = new ApproveVdsParameters();
    params.setVdsId(oVirtId);
    params.setApprovedByRegister(true);
    try {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.ApproveVds, params);
                    if (ret == null || !ret.getSucceeded()) {
                        log.errorFormat("Approval of oVirt {0} failed. ", params.getVdsId());
                    } else if (ret.getSucceeded()) {
                        log.infoFormat("Approval of oVirt {0} ended successfully. ", params.getVdsId());
                    }
                } catch (RuntimeException ex) {
                    log.error("Failed to Approve host", ex);
                }
            }
        });
    } catch (Exception e) {
        isApprovalDispatched = false;
    }
    return isApprovalDispatched;
}
#method_after
private boolean dispatchOvirtApprovalCommand(Guid oVirtId) {
    boolean isApprovalDispatched = true;
    final ApproveVdsParameters params = new ApproveVdsParameters();
    params.setVdsId(oVirtId);
    params.setApprovedByRegister(true);
    try {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.ApproveVds, params);
                    if (ret == null || !ret.getSucceeded()) {
                        log.error("Approval of oVirt '{}' failed. ", params.getVdsId());
                    } else if (ret.getSucceeded()) {
                        log.info("Approval of oVirt '{}' ended successfully. ", params.getVdsId());
                    }
                } catch (RuntimeException ex) {
                    log.error("Failed to Approve host", ex);
                }
            }
        });
    } catch (Exception e) {
        isApprovalDispatched = false;
    }
    return isApprovalDispatched;
}
#end_block

#method_before
private boolean Register(VDS vdsByUniqueId, Guid vdsGroupId, boolean IsPending) {
    boolean returnValue = true;
    log.debugFormat("RegisterVdsQuery::Register - Entering");
    if (vdsByUniqueId == null) {
        returnValue = registerNewHost(vdsGroupId, IsPending);
    } else {
        returnValue = updateExistingHost(vdsByUniqueId, IsPending);
    }
    log.debugFormat("RegisterVdsQuery::Register - Leaving with value {0}", returnValue);
    return returnValue;
}
#method_after
private boolean Register(VDS vds, Guid vdsGroupId, boolean IsPending) {
    boolean returnValue = true;
    log.debug("RegisterVdsQuery::Register - Entering");
    if (vds == null) {
        returnValue = registerNewHost(vdsGroupId, IsPending);
    } else {
        returnValue = updateExistingHost(vds, IsPending);
    }
    log.debug("RegisterVdsQuery::Register - Leaving with value {}", returnValue);
    return returnValue;
}
#end_block

#method_before
private boolean updateExistingHost(VDS vdsByUniqueId, boolean IsPending) {
    boolean returnValue = true;
    vdsByUniqueId.setHostName(getParameters().getVdsHostName());
    vdsByUniqueId.setPort(getParameters().getVdsPort());
    log.debugFormat("RegisterVdsQuery::Register - Will try now to update VDS with existing unique id; Name: {0}, Hostname: {1}, Unique: {2}, VdsPort: {3}, IsPending: {4} with force synchronize", getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
    UpdateVdsActionParameters p = new UpdateVdsActionParameters(vdsByUniqueId.getStaticData(), "", false);
    if (vdsByUniqueId.isFencingAgentsExist()) {
        p.setFencingAgents(vdsByUniqueId.getFencingAgents());
    }
    // TODO: what about agent deletion?
    p.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    VdcReturnValueBase rc = Backend.getInstance().runInternalAction(VdcActionType.UpdateVds, p);
    if (rc == null || !rc.getSucceeded()) {
        error = AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED;
        log.debugFormat("RegisterVdsQuery::Register - Failed to update existing VDS Name: {0}, Hostname: {1}, Unique: {2}, VdsPort: {3}, IsPending: {4}", getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
        CaptureCommandErrorsToLogger(rc, "RegisterVdsQuery::Register");
        returnValue = false;
    } else {
        log.infoFormat("RegisterVdsQuery::Register -Updated a {3} registered VDS - Name: {0}, Hostname: {1}, UniqueID: {2}", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId(), vdsByUniqueId.getStatus() == VDSStatus.PendingApproval ? "Pending " : "");
    }
    return returnValue;
}
#method_after
private boolean updateExistingHost(VDS vds, boolean IsPending) {
    boolean returnValue = true;
    vds.setHostName(vds.getHostName());
    vds.setPort(getParameters().getVdsPort());
    log.debug("RegisterVdsQuery::Register - Will try now to update VDS with existing unique id; Name: '{}', Hostname: '{}', Unique: '{}', VdsPort: '{}', IsPending: '{}' with force synchronize", getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
    UpdateVdsActionParameters p = new UpdateVdsActionParameters(vds.getStaticData(), "", false);
    p.setInstallVds(!IsPending);
    p.setIsReinstallOrUpgrade(!IsPending);
    p.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.PublicKey);
    if (vds.isFenceAgentsExist()) {
        p.setFenceAgents(vds.getFenceAgents());
    }
    p.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    VdcReturnValueBase rc = Backend.getInstance().runInternalAction(VdcActionType.UpdateVds, p);
    if (rc == null || !rc.getSucceeded()) {
        error = AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED;
        log.debug("RegisterVdsQuery::Register - Failed to update existing VDS Name: '{}', Hostname: '{}', Unique: '{}', VdsPort: '{}', IsPending: '{}'", getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
        CaptureCommandErrorsToLogger(rc, "RegisterVdsQuery::Register");
        returnValue = false;
    } else {
        log.info("RegisterVdsQuery::Register - Updated a '{}' registered VDS - Name: '{}', Hostname: '{}', UniqueID: '{}'", vds.getStatus() == VDSStatus.PendingApproval ? "Pending " : "", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId());
    }
    return returnValue;
}
#end_block

#method_before
private boolean registerNewHost(Guid vdsGroupId, boolean IsPending) {
    boolean returnValue = true;
    VdsStatic vds = new VdsStatic(getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), getParameters().getSSHPort(), getParameters().getSSHUser(), vdsGroupId, Guid.Empty, getParameters().getVdsName(), Config.<Boolean>getValue(ConfigValues.SSLEnabled), VDSType.VDS);
    vds.setSshKeyFingerprint(getParameters().getSSHFingerprint());
    log.debugFormat("RegisterVdsQuery::Register - Will try now to add VDS from scratch; Name: {0}, Hostname: {1}, Unique: {2}, VdsPort: {3},Subnet mask: {4}, IsPending: {5} with force synchronize", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
    AddVdsActionParameters p = new AddVdsActionParameters(vds, "");
    p.setAddPending(IsPending);
    VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.AddVds, p);
    if (ret == null || !ret.getSucceeded()) {
        log.errorFormat("RegisterVdsQuery::Register - Registration failed for VDS - Name: {0}, Hostname: {1}, UniqueID: {2}, Subnet mask: {3}", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId());
        CaptureCommandErrorsToLogger(ret, "RegisterVdsQuery::Register");
        error = AuditLogType.VDS_REGISTER_FAILED;
        returnValue = false;
    } else {
        log.infoFormat("RegisterVdsQuery::Register - Registered a new VDS {3} - Name: {0}, Hostname: {1}, UniqueID: {2}", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId(), IsPending ? "pending approval" : "automatically approved");
    }
    return returnValue;
}
#method_after
private boolean registerNewHost(Guid vdsGroupId, boolean IsPending) {
    boolean returnValue = true;
    VdsStatic vds = new VdsStatic(getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), getParameters().getSSHPort(), getParameters().getSSHUser(), vdsGroupId, Guid.Empty, getParameters().getVdsName(), Config.<Boolean>getValue(ConfigValues.SSLEnabled), VDSType.VDS, null);
    vds.setSshKeyFingerprint(getParameters().getSSHFingerprint());
    log.debug("RegisterVdsQuery::Register - Will try now to add VDS from scratch; Name: '{}', Hostname: '{}', Unique: '{}', VdsPort: '{}',Subnet mask: '{}', IsPending: '{}' with force synchronize", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
    AddVdsActionParameters p = new AddVdsActionParameters(vds, "");
    p.setAddPending(IsPending);
    VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.AddVds, p);
    if (ret == null || !ret.getSucceeded()) {
        log.error("RegisterVdsQuery::Register - Registration failed for VDS - Name: '{}', Hostname: '{}', UniqueID: '{}', Subnet mask: '{}'", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId());
        CaptureCommandErrorsToLogger(ret, "RegisterVdsQuery::Register");
        error = AuditLogType.VDS_REGISTER_FAILED;
        returnValue = false;
    } else {
        log.info("RegisterVdsQuery::Register - Registered a new VDS '{}' - Name: '{}', Hostname: '{}', UniqueID: '{}'", IsPending ? "pending approval" : "automatically approved", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId());
    }
    return returnValue;
}
#end_block

#method_before
private boolean HandleOldVdssWithSameHostName(VDS vdsByUniqueId) {
    // handle old VDSs with same host_name (IP)
    log.debugFormat("RegisterVdsQuery::HandleOldVdssWithSameHostName - Entering");
    boolean returnValue = true;
    List<VDS> vdss_byHostName = DbFacade.getInstance().getVdsDao().getAllForHostname(getParameters().getVdsHostName());
    int lastIteratedIndex = 1;
    if (vdss_byHostName.size() > 0) {
        log.debugFormat("RegisterVdsQuery::HandleOldVdssWithSameHostName - found {0} VDS(s) with the same host name {1}.  Will try to change their hostname to a different value", vdss_byHostName.size(), getParameters().getVdsHostName());
        for (VDS vds_byHostName : vdss_byHostName) {
            /**
             * looping foreach VDS found with similar hostnames and change to each one to available hostname
             */
            if (vdsByUniqueId == null || !vds_byHostName.getId().equals(vdsByUniqueId.getId())) {
                boolean unique = false;
                String try_host_name = "";
                for (int i = lastIteratedIndex; i <= 100; i++, lastIteratedIndex = i) {
                    try_host_name = String.format("hostname-was-%1$s-%2$s", getParameters().getVdsHostName(), i);
                    if (DbFacade.getInstance().getVdsDao().getAllForHostname(try_host_name).size() == 0) {
                        unique = true;
                        break;
                    }
                }
                if (unique) {
                    String old_host_name = vds_byHostName.getHostName();
                    vds_byHostName.setHostName(try_host_name);
                    UpdateVdsActionParameters parameters = new UpdateVdsActionParameters(vds_byHostName.getStaticData(), "", false);
                    parameters.setShouldBeLogged(false);
                    parameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
                    if (vds_byHostName.isFencingAgentsExist()) {
                        parameters.setFencingAgents(vds_byHostName.getFencingAgents());
                    }
                    // TODO: what about agent deletion?
                    // If host exists in InstallingOs status, remove it from DB and move on
                    final VDS foundVds = DbFacade.getInstance().getVdsDao().getByName(parameters.getVdsStaticData().getName());
                    if ((foundVds != null) && (foundVds.getDynamicData().getStatus() == VDSStatus.InstallingOS)) {
                        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                            @Override
                            public Void runInTransaction() {
                                getDbFacade().getVdsStatisticsDao().remove(foundVds.getId());
                                getDbFacade().getVdsDynamicDao().remove(foundVds.getId());
                                getDbFacade().getVdsStaticDao().remove(foundVds.getId());
                                return null;
                            }
                        });
                    }
                    VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.UpdateVds, parameters);
                    if (ret == null || !ret.getSucceeded()) {
                        error = AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST;
                        logable.addCustomValue("VdsName2", vds_byHostName.getStaticData().getName());
                        log.errorFormat("RegisterVdsQuery::HandleOldVdssWithSameHostName - could not update VDS {0}", vds_byHostName.getStaticData().getName());
                        CaptureCommandErrorsToLogger(ret, "RegisterVdsQuery::HandleOldVdssWithSameHostName");
                        return false;
                    } else {
                        log.infoFormat("RegisterVdsQuery::HandleOldVdssWithSameHostName - Another VDS was using this IP {0}. Changed to {1}", old_host_name, try_host_name);
                    }
                } else {
                    log.errorFormat("VdcBLL::HandleOldVdssWithSameHostName - Could not change the IP for an existing VDS. All available hostnames are taken (ID = {0}, name = {1}, management IP = {2} , host name = {3})", vds_byHostName.getId(), vds_byHostName.getName(), vds_byHostName.getFencingAgents().isEmpty() ? "" : vds_byHostName.getFencingAgents().get(0).getIp(), vds_byHostName.getHostName());
                    error = AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN;
                    returnValue = false;
                }
            }
            log.infoFormat("RegisterVdsQuery::HandleOldVdssWithSameHostName - No Change required for VDS {0}. Since it has the same unique Id", vds_byHostName.getId());
        }
    }
    log.debugFormat("RegisterVdsQuery::HandleOldVdssWithSameHostName - Leaving with value {0}", returnValue);
    return returnValue;
}
#method_after
private boolean HandleOldVdssWithSameHostName(VDS vdsByUniqueId) {
    // handle old VDSs with same host_name (IP)
    log.debug("RegisterVdsQuery::HandleOldVdssWithSameHostName - Entering");
    boolean returnValue = true;
    List<VDS> vdss_byHostName = DbFacade.getInstance().getVdsDao().getAllForHostname(getParameters().getVdsHostName());
    int lastIteratedIndex = 1;
    if (vdss_byHostName.size() > 0) {
        log.debug("RegisterVdsQuery::HandleOldVdssWithSameHostName - found '{}' VDS(s) with the same host name '{}'.  Will try to change their hostname to a different value", vdss_byHostName.size(), getParameters().getVdsHostName());
        for (VDS vds_byHostName : vdss_byHostName) {
            /**
             * looping foreach VDS found with similar hostnames and change to each one to available hostname
             */
            if (vdsByUniqueId == null || !vds_byHostName.getId().equals(vdsByUniqueId.getId())) {
                boolean unique = false;
                String try_host_name = "";
                for (int i = lastIteratedIndex; i <= 100; i++, lastIteratedIndex = i) {
                    try_host_name = String.format("hostname-was-%1$s-%2$s", getParameters().getVdsHostName(), i);
                    if (DbFacade.getInstance().getVdsDao().getAllForHostname(try_host_name).size() == 0) {
                        unique = true;
                        break;
                    }
                }
                if (unique) {
                    String old_host_name = vds_byHostName.getHostName();
                    vds_byHostName.setHostName(try_host_name);
                    UpdateVdsActionParameters parameters = new UpdateVdsActionParameters(vds_byHostName.getStaticData(), "", false);
                    parameters.setShouldBeLogged(false);
                    parameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
                    if (vds_byHostName.isFenceAgentsExist()) {
                        parameters.setFenceAgents(vds_byHostName.getFenceAgents());
                    }
                    // If host exists in InstallingOs status, remove it from DB and move on
                    final VDS foundVds = DbFacade.getInstance().getVdsDao().getByName(parameters.getVdsStaticData().getName());
                    if ((foundVds != null) && (foundVds.getDynamicData().getStatus() == VDSStatus.InstallingOS)) {
                        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                            @Override
                            public Void runInTransaction() {
                                getDbFacade().getVdsStatisticsDao().remove(foundVds.getId());
                                getDbFacade().getVdsDynamicDao().remove(foundVds.getId());
                                getDbFacade().getVdsStaticDao().remove(foundVds.getId());
                                return null;
                            }
                        });
                    }
                    VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.UpdateVds, parameters);
                    if (ret == null || !ret.getSucceeded()) {
                        error = AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST;
                        logable.addCustomValue("VdsName2", vds_byHostName.getStaticData().getName());
                        log.error("RegisterVdsQuery::HandleOldVdssWithSameHostName - could not update VDS '{}'", vds_byHostName.getStaticData().getName());
                        CaptureCommandErrorsToLogger(ret, "RegisterVdsQuery::HandleOldVdssWithSameHostName");
                        return false;
                    } else {
                        log.info("RegisterVdsQuery::HandleOldVdssWithSameHostName - Another VDS was using this IP '{}'. Changed to '{}'", old_host_name, try_host_name);
                    }
                } else {
                    log.error("VdcBLL::HandleOldVdssWithSameHostName - Could not change the IP for an existing VDS. All available hostnames are taken (ID = '{}', name = '{}', management IP = '{}' , host name = '{}')", vds_byHostName.getId(), vds_byHostName.getName(), vds_byHostName.getFenceAgents().isEmpty() ? "" : vds_byHostName.getFenceAgents().get(0).getIp(), vds_byHostName.getHostName());
                    error = AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN;
                    returnValue = false;
                }
            }
            log.info("RegisterVdsQuery::HandleOldVdssWithSameHostName - No Change required for VDS '{}'. Since it has the same unique Id", vds_byHostName.getId());
        }
    }
    log.debug("RegisterVdsQuery::HandleOldVdssWithSameHostName - Leaving with value '{}'", returnValue);
    return returnValue;
}
#end_block

#method_before
private boolean HandleOldVdssWithSameName(VDS hostToRegister) {
    log.debugFormat("Entering");
    boolean returnValue = true;
    VdsDAO vdsDAO = DbFacade.getInstance().getVdsDao();
    VDS storedHost = vdsDAO.getByName(getParameters().getVdsName());
    List<String> allHostNames = getAllHostNames(vdsDAO.getAll());
    boolean hostExistInDB = hostToRegister != null;
    if (storedHost != null) {
        log.debugFormat("found VDS with the same name {0}.  Will try to register with a new name", getParameters().getVdsName());
        String nameToRegister = getParameters().getVdsName();
        String uniqueIdToRegister = getParameters().getVdsUniqueId();
        String newName;
        // check different uniqueIds but same name
        if (!uniqueIdToRegister.equals(storedHost.getUniqueId()) && nameToRegister.equals(storedHost.getName())) {
            if (hostExistInDB) {
                // update the registered host if exist in db
                allHostNames.remove(hostToRegister.getName());
                newName = generateUniqueName(nameToRegister, allHostNames);
                hostToRegister.setVdsName(newName);
                UpdateVdsActionParameters parameters = new UpdateVdsActionParameters(hostToRegister.getStaticData(), "", false);
                if (hostToRegister.isFencingAgentsExist()) {
                    parameters.setFencingAgents(hostToRegister.getFencingAgents());
                }
                // TODO: what about agent deletion?
                VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.UpdateVds, parameters);
                if (ret == null || !ret.getSucceeded()) {
                    error = AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME;
                    logable.addCustomValue("VdsName2", newName);
                    log.errorFormat("could not update VDS {0}", nameToRegister);
                    CaptureCommandErrorsToLogger(ret, "RegisterVdsQuery::HandleOldVdssWithSameName");
                    return false;
                } else {
                    log.infoFormat("Another VDS was using this name with IP {0}. Changed to {1}", nameToRegister, newName);
                }
            } else {
                // host doesn't exist in db yet. not persisting changes just object values.
                newName = generateUniqueName(nameToRegister, allHostNames);
                getParameters().setVdsName(newName);
            }
        }
    }
    log.debugFormat("Leaving with value {0}", returnValue);
    return returnValue;
}
#method_after
private boolean HandleOldVdssWithSameName(VDS hostToRegister) {
    log.debug("Entering");
    boolean returnValue = true;
    VdsDAO vdsDAO = DbFacade.getInstance().getVdsDao();
    VDS storedHost = vdsDAO.getByName(getParameters().getVdsName());
    List<String> allHostNames = getAllHostNames(vdsDAO.getAll());
    boolean hostExistInDB = hostToRegister != null;
    if (storedHost != null) {
        log.debug("found VDS with the same name {0}.  Will try to register with a new name", getParameters().getVdsName());
        String nameToRegister = getParameters().getVdsName();
        String uniqueIdToRegister = getParameters().getVdsUniqueId();
        String newName;
        // check different uniqueIds but same name
        if (!uniqueIdToRegister.equals(storedHost.getUniqueId()) && nameToRegister.equals(storedHost.getName())) {
            if (hostExistInDB) {
                // update the registered host if exist in db
                allHostNames.remove(hostToRegister.getName());
                newName = generateUniqueName(nameToRegister, allHostNames);
                hostToRegister.setVdsName(newName);
                UpdateVdsActionParameters parameters = new UpdateVdsActionParameters(hostToRegister.getStaticData(), "", false);
                if (hostToRegister.isFenceAgentsExist()) {
                    parameters.setFenceAgents(hostToRegister.getFenceAgents());
                }
                VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.UpdateVds, parameters);
                if (ret == null || !ret.getSucceeded()) {
                    error = AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME;
                    logable.addCustomValue("VdsName2", newName);
                    log.error("could not update VDS '{}'", nameToRegister);
                    CaptureCommandErrorsToLogger(ret, "RegisterVdsQuery::HandleOldVdssWithSameName");
                    return false;
                } else {
                    log.info("Another VDS was using this name with IP '{}'. Changed to '{}'", nameToRegister, newName);
                }
            } else {
                // host doesn't exist in db yet. not persisting changes just object values.
                newName = generateUniqueName(nameToRegister, allHostNames);
                getParameters().setVdsName(newName);
            }
        }
    }
    log.debug("Leaving with value '{}'", returnValue);
    return returnValue;
}
#end_block

#method_before
private boolean CheckAutoApprovalDefinitions(RefObject<Boolean> isPending) {
    // check auto approval definitions
    log.debugFormat("RegisterVdsQuery::CheckAutoApprovalDefinitions - Entering");
    isPending.argvalue = true;
    if (!Config.<String>getValue(ConfigValues.AutoApprovePatterns).equals("")) {
        for (String pattern : Config.<String>getValue(ConfigValues.AutoApprovePatterns).split("[,]", -1)) {
            try {
                String pattern_helper = pattern.toLowerCase();
                Regex pattern_regex = new Regex(pattern_helper);
                String vds_hostname_helper = getParameters().getVdsHostName().toLowerCase();
                String vds_unique_id_helper = getParameters().getVdsUniqueId().toLowerCase().replace(":", "-");
                if (vds_hostname_helper.startsWith(pattern) || vds_unique_id_helper.startsWith(pattern) || pattern_regex.IsMatch(vds_hostname_helper) || pattern_regex.IsMatch(vds_unique_id_helper)) {
                    isPending.argvalue = false;
                    break;
                }
            } catch (RuntimeException ex) {
                error = AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN;
                log.errorFormat("RegisterVdsQuery ::CheckAutoApprovalDefinitions(out bool) -  Error in auto approve pattern: {0}-{1}", pattern, ex.getMessage());
                return false;
            }
        }
    }
    log.debugFormat("RegisterVdsQuery::CheckAutoApprovalDefinitions - Leaving - return value {0}", isPending.argvalue);
    return true;
}
#method_after
private boolean CheckAutoApprovalDefinitions(RefObject<Boolean> isPending) {
    // check auto approval definitions
    log.debug("RegisterVdsQuery::CheckAutoApprovalDefinitions - Entering");
    isPending.argvalue = true;
    if (!Config.<String>getValue(ConfigValues.AutoApprovePatterns).equals("")) {
        for (String pattern : Config.<String>getValue(ConfigValues.AutoApprovePatterns).split("[,]", -1)) {
            try {
                String pattern_helper = pattern.toLowerCase();
                Regex pattern_regex = new Regex(pattern_helper);
                String vds_hostname_helper = getParameters().getVdsHostName().toLowerCase();
                String vds_unique_id_helper = getParameters().getVdsUniqueId().toLowerCase().replace(":", "-");
                if (vds_hostname_helper.startsWith(pattern) || vds_unique_id_helper.startsWith(pattern) || pattern_regex.IsMatch(vds_hostname_helper) || pattern_regex.IsMatch(vds_unique_id_helper)) {
                    isPending.argvalue = false;
                    break;
                }
            } catch (RuntimeException ex) {
                error = AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN;
                log.error("RegisterVdsQuery ::CheckAutoApprovalDefinitions(out bool) -  Error in auto approve pattern: '{}'-'{}'", pattern, ex.getMessage());
                return false;
            }
        }
    }
    log.debug("RegisterVdsQuery::CheckAutoApprovalDefinitions - Leaving - return value '{}'", isPending.argvalue);
    return true;
}
#end_block

#method_before
private void CaptureCommandErrorsToLogger(VdcReturnValueBase retValue, String prefixToMessage) {
    if (retValue.getFault() != null) {
        log.errorFormat("{0} - Fault - {1}", prefixToMessage, retValue.getFault().getMessage());
    }
    if (retValue.getCanDoActionMessages().size() > 0) {
        List<String> msgs = retValue.getCanDoActionMessages();
        for (String s : msgs) {
            log.errorFormat("{0} - CanDoAction Fault - {1}", prefixToMessage, s);
        }
    }
    if (retValue.getExecuteFailedMessages().size() > 0) {
        // ErrorTranslator.TranslateErrorText(retValue.ExecuteFailedMessages);
        for (String s : retValue.getExecuteFailedMessages()) {
            log.errorFormat("{0} - Ececution Fault - {1}", prefixToMessage, s);
        }
    }
}
#method_after
private void CaptureCommandErrorsToLogger(VdcReturnValueBase retValue, String prefixToMessage) {
    if (retValue.getFault() != null) {
        log.error("{} - Fault - {}", prefixToMessage, retValue.getFault().getMessage());
    }
    if (retValue.getCanDoActionMessages().size() > 0) {
        List<String> msgs = retValue.getCanDoActionMessages();
        for (String s : msgs) {
            log.error("{} - CanDoAction Fault - {}", prefixToMessage, s);
        }
    }
    if (retValue.getExecuteFailedMessages().size() > 0) {
        // ErrorTranslator.TranslateErrorText(retValue.ExecuteFailedMessages);
        for (String s : retValue.getExecuteFailedMessages()) {
            log.error("{} - Ececution Fault - {}", prefixToMessage, s);
        }
    }
}
#end_block

#method_before
@Override
public VDS get(Guid id, Guid userID, boolean isFiltered) {
    // several rows may be returned because of join with fencing agents table.
    List<VDS> vdsList = getCallsHandler().executeReadList("GetVdsByVdsId", VdsRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered));
    if (vdsList.size() == 0) {
        return null;
    } else {
        return uniteAgentsSingleVds(vdsList);
    }
}
#method_after
@Override
public VDS get(Guid id, Guid userID, boolean isFiltered) {
    // several rows may be returned because of join with fence agents table.
    List<VDS> vdsList = getCallsHandler().executeReadList("GetVdsByVdsId", VdsRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered));
    return vdsList.size() == 0 ? null : uniteAgentsSingleVds(vdsList);
}
#end_block

#method_before
@Override
public VDS getByName(String name) {
    List<VDS> vdsList = getCallsHandler().executeReadList("GetVdsByName", VdsRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_name", name));
    if (vdsList.size() == 0) {
        return null;
    } else {
        return uniteAgentsSingleVds(vdsList);
    }
}
#method_after
@Override
public VDS getByName(String name) {
    List<VDS> vdsList = getCallsHandler().executeReadList("GetVdsByName", VdsRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_name", name));
    return vdsList.size() == 0 ? null : uniteAgentsSingleVds(vdsList);
}
#end_block

#method_before
@Override
public List<VDS> getListForSpmSelection(Guid storagePoolId) {
    List<VDS> vdsList = getCallsHandler().executeReadList("GetUpAndPrioritizedVds", VdsRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_pool_id", storagePoolId));
    return uniteAgents(vdsList);
}
#method_after
@Override
public List<VDS> getListForSpmSelection(Guid storagePoolId) {
    List<VDS> vdsList = getCallsHandler().executeReadList("GetUpAndPrioritizedVds", VdsRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_pool_id", storagePoolId));
    return uniteAgentsPreserveSpmPrioritySorting(vdsList);
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    Guid agentGuid = getGuid(rs, "agent_id");
    if (agentGuid != null) {
        FencingAgent agent = new FencingAgent();
        agent.setId(agentGuid);
        agent.setHostId(getGuid(rs, "vds_id"));
        agent.setOrder(rs.getInt("agent_order"));
        agent.setType(rs.getString("agent_type"));
        agent.setUser(rs.getString("agent_user"));
        agent.setPassword(DbFacadeUtils.decryptPassword(rs.getString("agent_password")));
        int port = rs.getInt("agent_port");
        agent.setPort(port == 0 ? null : port);
        agent.setOptions(rs.getString("agent_options"));
        agent.setIp(rs.getString("agent_ip"));
        entity.getFencingAgents().add(agent);
    }
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setBalloonEnabled(rs.getBoolean("enable_balloon"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    Guid agentGuid = getGuid(rs, "agent_id");
    if (agentGuid != null) {
        FenceAgent agent = new FenceAgent();
        agent.setId(agentGuid);
        agent.setHostId(getGuid(rs, "vds_id"));
        agent.setOrder(rs.getInt("agent_order"));
        agent.setType(rs.getString("agent_type"));
        agent.setUser(rs.getString("agent_user"));
        agent.setPassword(DbFacadeUtils.decryptPassword(rs.getString("agent_password")));
        int port = rs.getInt("agent_port");
        agent.setPort(port == 0 ? null : port);
        agent.setOptions(rs.getString("agent_options"));
        agent.setIp(rs.getString("agent_ip"));
        entity.getFenceAgents().add(agent);
    }
    return entity;
}
#end_block

#method_before
private VDS uniteAgentsSingleVds(List<VDS> vdsList) {
    List<FencingAgent> agents = new LinkedList<>();
    for (VDS vds : vdsList) {
        // collect agents from all rows
        agents.addAll(vds.getFencingAgents());
    }
    VDS vds = vdsList.get(0);
    vds.setFencingAgents(agents);
    return vds;
}
#method_after
private VDS uniteAgentsSingleVds(List<VDS> vdsList) {
    List<FenceAgent> agents = new LinkedList<>();
    for (VDS vds : vdsList) {
        // collect agents from all rows
        agents.addAll(vds.getFenceAgents());
    }
    VDS vds = vdsList.get(0);
    vds.setFenceAgents(agents);
    return vds;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getParameters().getParentCommand() == VdcActionType.Unknown) {
        retValue = super.canDoAction();
        if (getVds() != null && getVds().getStatus() != VDSStatus.Maintenance) {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_STOP);
            retValue = false;
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getParameters().getParentCommand() == VdcActionType.Unknown) {
        retValue = super.canDoAction();
        if (getVds() != null && getVds().getStatus() != VDSStatus.Maintenance) {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_STOP);
            retValue = false;
        }
    }
    getReturnValue().setCanDoAction(retValue);
    return retValue;
}
#end_block

#method_before
@Override
protected void handleError() {
    addCanDoActionMessage(VdcBllMessages.VDS_FENCE_OPERATION_FAILED);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__STOP);
    log.errorFormat("Failed to run StopVdsCommand on vds :{0}", getVdsName());
}
#method_after
@Override
protected void handleError() {
    addCanDoActionMessage(VdcBllMessages.VDS_FENCE_OPERATION_FAILED);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__STOP);
    log.error("Failed to run StopVdsCommand on vds '{}'", getVdsName());
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((hostName == null) ? 0 : hostName.hashCode());
    result = prime * result + ((consoleAddress == null) ? 0 : consoleAddress.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + (int) (otpValidity ^ (otpValidity >>> 32));
    result = prime * result + (pmEnabled ? 1231 : 1237);
    result = prime * result + (pmKdumpDetection ? 1 : 0);
    result = prime * result + port;
    result = prime * result + ((protocol == null) ? 0 : protocol.hashCode());
    result = prime * result + sshPort;
    result = prime * result + ((sshUsername == null) ? 0 : sshUsername.hashCode());
    result = prime * result + ((serverSslEnabled == null) ? 0 : serverSslEnabled.hashCode());
    result = prime * result + ((uniqueId == null) ? 0 : uniqueId.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vdsStrength == null) ? 0 : vdsStrength.hashCode());
    result = prime * result + ((vdsType == null) ? 0 : vdsType.hashCode());
    result = prime * result + (disablePowerManagementPolicy ? 0 : 1);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((hostName == null) ? 0 : hostName.hashCode());
    result = prime * result + ((consoleAddress == null) ? 0 : consoleAddress.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + (int) (otpValidity ^ (otpValidity >>> 32));
    result = prime * result + (pmEnabled ? 1231 : 1237);
    result = prime * result + (pmKdumpDetection ? 1 : 0);
    result = prime * result + port;
    result = prime * result + ((protocol == null) ? 0 : protocol.hashCode());
    result = prime * result + sshPort;
    result = prime * result + ((sshUsername == null) ? 0 : sshUsername.hashCode());
    result = prime * result + ((serverSslEnabled == null) ? 0 : serverSslEnabled.hashCode());
    result = prime * result + ((uniqueId == null) ? 0 : uniqueId.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vdsStrength == null) ? 0 : vdsStrength.hashCode());
    result = prime * result + ((vdsType == null) ? 0 : vdsType.hashCode());
    result = prime * result + (disablePowerManagementPolicy ? 0 : 1);
    result = prime * result + ((hostProviderId == null) ? 0 : hostProviderId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(hostName, other.hostName) && ObjectUtils.objectsEqual(consoleAddress, other.consoleAddress) && ObjectUtils.objectsEqual(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && pmKdumpDetection == other.isPmKdumpDetection() && port == other.port && protocol == other.protocol && sshPort == other.sshPort && ObjectUtils.objectsEqual(sshUsername, other.sshUsername) && ObjectUtils.objectsEqual(serverSslEnabled, other.serverSslEnabled) && ObjectUtils.objectsEqual(uniqueId, other.uniqueId) && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && ObjectUtils.objectsEqual(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && ObjectUtils.objectsEqual(sshKeyFingerprint, other.sshKeyFingerprint)) && disablePowerManagementPolicy == other.disablePowerManagementPolicy;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(hostName, other.hostName) && ObjectUtils.objectsEqual(consoleAddress, other.consoleAddress) && ObjectUtils.objectsEqual(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && pmKdumpDetection == other.isPmKdumpDetection() && port == other.port && protocol == other.protocol && sshPort == other.sshPort && ObjectUtils.objectsEqual(sshUsername, other.sshUsername) && ObjectUtils.objectsEqual(serverSslEnabled, other.serverSslEnabled) && ObjectUtils.objectsEqual(uniqueId, other.uniqueId) && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && ObjectUtils.objectsEqual(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && ObjectUtils.objectsEqual(sshKeyFingerprint, other.sshKeyFingerprint)) && disablePowerManagementPolicy == other.disablePowerManagementPolicy && ObjectUtils.objectsEqual(hostProviderId, other.hostProviderId);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VdcReturnValueBase returnValueBase = new VdcReturnValueBase();
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // do not try to stop Host if Host is reported as Down via PM
    if (isPmReportsStatusDown()) {
        returnValueBase.setSucceeded(true);
    } else {
        // execute StopVds action
        returnValueBase = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Stop, VdcActionType.StopVds);
    }
    if (returnValueBase.getSucceeded()) {
        executeFenceVdsManuallyAction(vdsId, sessionId);
        // execute StartVds action
        returnValueBase = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Start, VdcActionType.StartVds);
        setSucceeded(returnValueBase.getSucceeded());
    } else {
        super.handleError();
        setSucceeded(false);
    }
    if (!getSucceeded()) {
        log.warnFormat("Restart host action failed, updating host {0} to {1}", vdsId, VDSStatus.NonResponsive.name());
        runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vdsId, VDSStatus.NonResponsive));
    }
}
#method_after
@Override
protected void executeCommand() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // do not try to stop Host if Host is reported as Down via PM
    if (isPmReportsStatusDown()) {
        returnValue.setSucceeded(true);
    } else {
        // execute StopVds action
        returnValue = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Stop, VdcActionType.StopVds);
    }
    if (wasSkippedDueToPolicy(returnValue)) {
        // fence execution was skipped due to fencing policy, host should be alive
        setSucceeded(false);
        runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vdsId, VDSStatus.NonResponsive));
        return;
    } else if (returnValue.getSucceeded()) {
        executeFenceVdsManuallyAction(vdsId, sessionId);
        // execute StartVds action
        returnValue = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Start, VdcActionType.StartVds);
        setSucceeded(returnValue.getSucceeded());
    } else {
        handleError();
        setSucceeded(false);
    }
    if (!getSucceeded()) {
        log.warn("Restart host action failed, updating host '{}' to '{}'", vdsId, VDSStatus.NonResponsive.name());
        runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vdsId, VDSStatus.NonResponsive));
    }
}
#end_block

#method_before
private VdcReturnValueBase executeVdsFenceAction(final Guid vdsId, String sessionId, FenceActionType fenceAction, VdcActionType action) {
    FenceVdsActionParameters params = new FenceVdsActionParameters(vdsId, fenceAction);
    params.setParentCommand(VdcActionType.RestartVds);
    params.setSessionId(sessionId);
    // If Host was in Maintenance, and was restarted manually , it should preserve its status after reboot
    if (getParameters().getParentCommand() != VdcActionType.VdsNotRespondingTreatment && getVds().getStatus() == VDSStatus.Maintenance) {
        params.setChangeHostToMaintenanceOnStart(true);
    }
    return runInternalAction(action, params, getContext());
}
#method_after
private VdcReturnValueBase executeVdsFenceAction(final Guid vdsId, String sessionId, FenceActionType fenceAction, VdcActionType action) {
    FenceVdsActionParameters params = new FenceVdsActionParameters(vdsId, fenceAction);
    params.setParentCommand(VdcActionType.RestartVds);
    params.setSessionId(sessionId);
    params.setFencingPolicy(getParameters().getFencingPolicy());
    // If Host was in Maintenance, and was restarted manually , it should preserve its status after reboot
    if (getParameters().getParentCommand() != VdcActionType.VdsNotRespondingTreatment && getVds().getStatus() == VDSStatus.Maintenance) {
        params.setChangeHostToMaintenanceOnStart(true);
    }
    return runInternalAction(action, params, getContext());
}
#end_block

#method_before
@Override
protected void handleError() {
    addCanDoActionMessage(VDS_FENCE_OPERATION_FAILED);
    addCanDoActionMessage(VAR__TYPE__HOST);
    addCanDoActionMessage(VAR__ACTION__RESTART);
    log.errorFormat("Failed to run RestartVdsCommand on vds :{0}", getVdsName());
}
#method_after
protected void handleError() {
    addCanDoActionMessage(VDS_FENCE_OPERATION_FAILED);
    addCanDoActionMessage(VAR__TYPE__HOST);
    addCanDoActionMessage(VAR__ACTION__RESTART);
    log.error("Failed to run RestartVdsCommand on vds '{}'", getVdsName());
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (balloonEnabled ? 0 : 1);
    result = prime * result + (countThreadsAsCores ? 0 : 1);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(mVdsStatic, other.mVdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && _spm_status == other._spm_status && ObjectUtils.objectsEqual(mImagesLastCheck, other.mImagesLastCheck) && ObjectUtils.objectsEqual(mImagesLastDelay, other.mImagesLastDelay) && ObjectUtils.objectsEqual(mInterfaceList, other.mInterfaceList) && ObjectUtils.objectsEqual(mNetworkList, other.mNetworkList) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(mVdsStatic, other.mVdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && _spm_status == other._spm_status && ObjectUtils.objectsEqual(mImagesLastCheck, other.mImagesLastCheck) && ObjectUtils.objectsEqual(mImagesLastDelay, other.mImagesLastDelay) && ObjectUtils.objectsEqual(mInterfaceList, other.mInterfaceList) && ObjectUtils.objectsEqual(mNetworkList, other.mNetworkList) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && balloonEnabled == other.balloonEnabled && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setFencingAgents(getFencingAgents());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    return vds;
}
#end_block

#method_before
public Double getCpuIdle() {
    return this.mVdsStatistics.getcpu_idle();
}
#method_after
public Double getCpuIdle() {
    return this.mVdsStatistics.getCpuIdle();
}
#end_block

#method_before
public void setCpuIdle(Double value) {
    this.mVdsStatistics.setcpu_idle(value);
}
#method_after
public void setCpuIdle(Double value) {
    this.mVdsStatistics.setCpuIdle(value);
}
#end_block

#method_before
public Double getCpuLoad() {
    return this.mVdsStatistics.getcpu_load();
}
#method_after
public Double getCpuLoad() {
    return this.mVdsStatistics.getCpuLoad();
}
#end_block

#method_before
public void setCpuLoad(Double value) {
    this.mVdsStatistics.setcpu_load(value);
}
#method_after
public void setCpuLoad(Double value) {
    this.mVdsStatistics.setCpuLoad(value);
}
#end_block

#method_before
public Double getCpuSys() {
    return this.mVdsStatistics.getcpu_sys();
}
#method_after
public Double getCpuSys() {
    return this.mVdsStatistics.getCpuSys();
}
#end_block

#method_before
public void setCpuSys(Double value) {
    this.mVdsStatistics.setcpu_sys(value);
}
#method_after
public void setCpuSys(Double value) {
    this.mVdsStatistics.setCpuSys(value);
}
#end_block

#method_before
public Double getCpuUser() {
    return this.mVdsStatistics.getcpu_user();
}
#method_after
public Double getCpuUser() {
    return this.mVdsStatistics.getCpuUser();
}
#end_block

#method_before
public void setCpuUser(Double value) {
    this.mVdsStatistics.setcpu_user(value);
}
#method_after
public void setCpuUser(Double value) {
    this.mVdsStatistics.setCpuUser(value);
}
#end_block

#method_before
public Integer getUsageMemPercent() {
    return this.mVdsStatistics.getusage_mem_percent();
}
#method_after
public Integer getUsageMemPercent() {
    return this.mVdsStatistics.getUsageMemPercent();
}
#end_block

#method_before
public void setUsageMemPercent(Integer value) {
    this.mVdsStatistics.setusage_mem_percent(value);
}
#method_after
public void setUsageMemPercent(Integer value) {
    this.mVdsStatistics.setUsageMemPercent(value);
}
#end_block

#method_before
public Integer getUsageCpuPercent() {
    return this.mVdsStatistics.getusage_cpu_percent();
}
#method_after
public Integer getUsageCpuPercent() {
    return this.mVdsStatistics.getUsageCpuPercent();
}
#end_block

#method_before
public void setUsageCpuPercent(Integer value) {
    this.mVdsStatistics.setusage_cpu_percent(value);
}
#method_after
public void setUsageCpuPercent(Integer value) {
    this.mVdsStatistics.setUsageCpuPercent(value);
}
#end_block

#method_before
public Integer getUsageNetworkPercent() {
    return this.mVdsStatistics.getusage_network_percent();
}
#method_after
public Integer getUsageNetworkPercent() {
    return this.mVdsStatistics.getUsageNetworkPercent();
}
#end_block

#method_before
public void setUsageNetworkPercent(Integer value) {
    this.mVdsStatistics.setusage_network_percent(value);
}
#method_after
public void setUsageNetworkPercent(Integer value) {
    this.mVdsStatistics.setUsageNetworkPercent(value);
}
#end_block

#method_before
public Long getBootTime() {
    return this.mVdsStatistics.getboot_time();
}
#method_after
public Long getBootTime() {
    return this.mVdsStatistics.getBootTime();
}
#end_block

#method_before
public void setBootTime(Long value) {
    this.mVdsStatistics.setboot_time(value);
}
#method_after
public void setBootTime(Long value) {
    this.mVdsStatistics.setBootTime(value);
}
#end_block

#method_before
public Long getMemAvailable() {
    return this.mVdsStatistics.getmem_available();
}
#method_after
public Long getMemAvailable() {
    return this.mVdsStatistics.getMemAvailable();
}
#end_block

#method_before
public void setMemAvailable(Long value) {
    this.mVdsStatistics.setmem_available(value);
}
#method_after
public void setMemAvailable(Long value) {
    this.mVdsStatistics.setMemAvailable(value);
}
#end_block

#method_before
public Long getMemShared() {
    return this.mVdsStatistics.getmem_shared();
}
#method_after
public Long getMemShared() {
    return this.mVdsStatistics.getMemShared();
}
#end_block

#method_before
public void setMemShared(Long value) {
    this.mVdsStatistics.setmem_shared(value);
}
#method_after
public void setMemShared(Long value) {
    this.mVdsStatistics.setMemShared(value);
}
#end_block

#method_before
public Integer getMemSharedPercent() {
    Long shared = mVdsStatistics.getmem_shared();
    Integer physical = mVdsDynamic.getphysical_mem_mb();
    if (shared == null || physical == null || physical == 0) {
        return 0;
    }
    return ((int) (shared * 100) / physical);
}
#method_after
public Integer getMemSharedPercent() {
    Long shared = mVdsStatistics.getMemShared();
    Integer physical = mVdsDynamic.getphysical_mem_mb();
    if (shared == null || physical == null || physical == 0) {
        return 0;
    }
    return (int) ((shared * 100) / physical);
}
#end_block

#method_before
public Long getSwapFree() {
    return this.mVdsStatistics.getswap_free();
}
#method_after
public Long getSwapFree() {
    return this.mVdsStatistics.getSwapFree();
}
#end_block

#method_before
public void setSwapFree(Long value) {
    this.mVdsStatistics.setswap_free(value);
}
#method_after
public void setSwapFree(Long value) {
    this.mVdsStatistics.setSwapFree(value);
}
#end_block

#method_before
public Long getSwapTotal() {
    return this.mVdsStatistics.getswap_total();
}
#method_after
public Long getSwapTotal() {
    return this.mVdsStatistics.getSwapTotal();
}
#end_block

#method_before
public void setSwapTotal(Long value) {
    this.mVdsStatistics.setswap_total(value);
}
#method_after
public void setSwapTotal(Long value) {
    this.mVdsStatistics.setSwapTotal(value);
}
#end_block

#method_before
public Integer getKsmCpuPercent() {
    return this.mVdsStatistics.getksm_cpu_percent();
}
#method_after
public Integer getKsmCpuPercent() {
    return this.mVdsStatistics.getKsmCpuPercent();
}
#end_block

#method_before
public void setKsmCpuPercent(Integer value) {
    this.mVdsStatistics.setksm_cpu_percent(value);
}
#method_after
public void setKsmCpuPercent(Integer value) {
    this.mVdsStatistics.setKsmCpuPercent(value);
}
#end_block

#method_before
public Long getKsmPages() {
    return this.mVdsStatistics.getksm_pages();
}
#method_after
public Long getKsmPages() {
    return this.mVdsStatistics.getKsmPages();
}
#end_block

#method_before
public void setKsmPages(Long value) {
    this.mVdsStatistics.setksm_pages(value);
}
#method_after
public void setKsmPages(Long value) {
    this.mVdsStatistics.setKsmPages(value);
}
#end_block

#method_before
public Boolean getKsmState() {
    return this.mVdsStatistics.getksm_state();
}
#method_after
public Boolean getKsmState() {
    return this.mVdsStatistics.getKsmState();
}
#end_block

#method_before
public void setKsmState(Boolean value) {
    this.mVdsStatistics.setksm_state(value);
}
#method_after
public void setKsmState(Boolean value) {
    this.mVdsStatistics.setKsmState(value);
}
#end_block

#method_before
public Date getCpuOverCommitTimestamp() {
    return mVdsDynamic.getcpu_over_commit_time_stamp();
}
#method_after
public Date getCpuOverCommitTimestamp() {
    return mVdsStatistics.getCpuOverCommitTimeStamp();
}
#end_block

#method_before
public void setCpuOverCommitTimestamp(Date value) {
    mVdsDynamic.setcpu_over_commit_time_stamp(value);
}
#method_after
public void setCpuOverCommitTimestamp(Date value) {
    mVdsStatistics.setCpuOverCommitTimeStamp(value);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = false;
    String event;
    if (getVds() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        return false;
    }
    // versa.
    if (getParameters().getAction() == FenceActionType.Start) {
        event = AuditLogType.USER_VDS_STOP.name();
    } else {
        event = AuditLogType.USER_VDS_START.name();
    }
    if (getVds().getpm_enabled() && isPowerManagementLegal()) {
        // && isPowerManagementLegal(getVds().getStaticData(), getVdsGroup().getcompatibility_version().toString())) {
        // check if we are in the interval of X seconds from startup
        // if yes , system is still initializing , ignore fence operations
        Date waitTo = Backend.getInstance().getStartedAt().addSeconds((Integer) Config.getValue(ConfigValues.DisableFenceAtStartupInSec));
        Date now = new Date();
        if (waitTo.before(now) || waitTo.equals(now)) {
            // Check Quiet time between PM operations, this is done only if command is not internal and parent
            // command is not <Restart>
            int secondsLeftToNextPmOp = (isInternalExecution() || (getParameters().getParentCommand() == VdcActionType.RestartVds)) ? 0 : DbFacade.getInstance().getAuditLogDao().getTimeToWaitForNextPmOp(getVds().getName(), event);
            if (secondsLeftToNextPmOp <= 0) {
                // Check for proxy
                if (new FenceExecutor(getVds()).isProxyHostAvailable()) {
                    retValue = true;
                } else {
                    addCanDoActionMessage(VdcBllMessages.VDS_NO_VDS_PROXY_FOUND);
                }
            } else {
                addCanDoActionMessage(VdcBllMessages.VDS_FENCE_DISABLED_AT_QUIET_TIME);
                addCanDoActionMessage(String.format("$seconds %1$s", secondsLeftToNextPmOp));
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VDS_FENCE_DISABLED_AT_SYSTEM_STARTUP_INTERVAL);
        }
    }
    // retry operation only when fence is enabled on Host.
    if (!retValue) {
        handleError();
    } else {
        addCanDoActionMessage(VdcBllMessages.VDS_FENCE_DISABLED);
        handleError();
    }
    getReturnValue().setSucceeded(retValue);
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    FenceValidator fenceValidator = new FenceValidator();
    List<String> messages = getReturnValue().getCanDoActionMessages();
    boolean canDo = fenceValidator.isHostExists(getVds(), messages) && fenceValidator.isPowerManagementEnabledAndLegal(getVds(), getVdsGroup(), messages) && fenceValidator.isStartupTimeoutPassed(messages) && isQuietTimeFromLastActionPassed() && fenceValidator.isProxyHostAvailable(getVds(), messages);
    if (!canDo) {
        handleError();
    }
    getReturnValue().setSucceeded(canDo);
    return canDo;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSStatus lastStatus = getVds().getStatus();
    boolean success = false;
    try {
        // Skip setting status if action is manual Start and Host was in Maintenance
        if (!(getParameters().getAction() == FenceActionType.Start && lastStatus == VDSStatus.Maintenance)) {
            setStatus();
        }
        success = fence(getParameters().getAction());
    } finally {
        if (!success) {
            setStatus(lastStatus);
            AlertIfPowerManagementOperationFailed();
        } else // Successful fencing with reboot or shutdown op. Clear the power management policy flag
        if ((getParameters().getAction() == FenceActionType.Restart || getParameters().getAction() == FenceActionType.Stop) && getParameters().getKeepPolicyPMEnabled() == false) {
            getVds().setPowerManagementControlledByPolicy(false);
            getDbFacade().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVdsId(), getVds().getDynamicData().isPowerManagementControlledByPolicy());
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    log.info("Power-Management: " + getAction() + " of Host " + getVdsName() + " initiated.");
    audit(AuditLogType.FENCE_OPERATION_STARTED);
    VDSStatus lastStatus = getVds().getStatus();
    VDSFenceReturnValue result = null;
    try {
        setup();
        result = fence();
        handleResult(result);
        if (getSucceeded()) {
            log.info("Power-Management: " + getAction() + " Host " + getVdsName() + " succeeded.");
            audit(AuditLogType.FENCE_OPERATION_SUCCEEDED);
        } else {
            log.info("Power-Management: " + getAction() + " Host " + getVdsName() + " failed.");
            audit(AuditLogType.FENCE_OPERATION_FAILED);
        }
    } finally {
        if (!getSucceeded()) {
            setStatus(lastStatus);
            if (!wasSkippedDueToPolicy(result)) {
                // show alert only if command was not skipped due to fencing policy
                alertIfPowerManagementOperationFailed();
            }
            throw new VdcBLLException(VdcBllErrors.VDS_FENCE_OPERATION_FAILED);
        } else {
            teardown();
        }
    }
}
#end_block

#method_before
private boolean fence(FenceActionType action) {
    // loop over agents and try to fence.
    AgentsIterator iterator = PowerManagementHelper.getAgentsIterator(getVds().getFencingAgents());
    while (iterator.hasNext()) {
        boolean success = attemptToFence(iterator.next(), action);
        if (success) {
            return true;
        } else {
            continue;
        }
    }
    return false;
}
#method_after
private VDSFenceReturnValue fence() {
    // loop over agents and try to fence.
    AgentsIterator iterator = PowerManagementHelper.getAgentsIterator(getVds().getFenceAgents());
    VDSFenceReturnValue result = null;
    while (iterator.hasNext()) {
        result = fence(iterator.next());
        if (result.getSucceeded()) {
            break;
        }
    }
    return result;
}
#end_block

#method_before
private Callable<FenceInvocationResult> createTask(final FencingAgent agent, final FenceActionType action) {
    final FenceExecutor fencingExecutor = new FenceExecutor(getVds());
    return (new Callable<FenceInvocationResult>() {

        @Override
        public FenceInvocationResult call() {
            return run(fencingExecutor, agent, action);
        }
    });
}
#method_after
protected Callable<VDSFenceReturnValue> createTask(final FenceAgent agent) {
    return (new Callable<VDSFenceReturnValue>() {

        @Override
        public VDSFenceReturnValue call() {
            return fence(agent, getFenceRetries());
        }
    });
}
#end_block

#method_before
protected void setStatus() {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Reboot));
    RunSleepOnReboot();
}
#method_after
protected void setStatus() {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Reboot));
    runSleepOnReboot();
}
#end_block

#method_before
protected boolean waitForStatus(FenceActionType actionType, FencingAgent fencingAgent) {
    FenceExecutor executor = new FenceExecutor(getVds());
    final String FENCE_CMD = (actionType == FenceActionType.Start) ? "on" : "off";
    final String ACTION_NAME = actionType.name().toLowerCase();
    int i = 1;
    boolean statusReached = false;
    String hostName = getVds().getName();
    log.infoFormat("Waiting for vds {0} to {1}", hostName, ACTION_NAME);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(SLEEP_BEFORE_FIRST_ATTEMPT);
    while (!statusReached && i <= getRerties()) {
        log.infoFormat("Attempt {0} to get vds {1} status", i, hostName);
        VDSFenceReturnValue returnValue = executor.fence(actionType, fencingAgent);
        if (returnValue != null && returnValue.isSucceeded()) {
            FenceStatusReturnValue value = (FenceStatusReturnValue) returnValue.getFenceResult().getReturnValue();
            if (value.getStatus().equalsIgnoreCase("unknown")) {
                // No need to retry , agent definitions are corrupted
                log.warnFormat("Host {0} {1} PM Agent definitions are corrupted, Waiting for Host to {2} aborted.", hostName, "Fencing agent ID: " + fencingAgent.getId(), actionType.name());
                break;
            } else {
                if (FENCE_CMD.equalsIgnoreCase(value.getStatus())) {
                    statusReached = true;
                    log.infoFormat("vds {0} status is {1}", hostName, FENCE_CMD);
                } else {
                    i++;
                    if (i <= getRerties())
                        ThreadUtils.sleep(getDelayInSeconds() * 1000);
                }
            }
        } else {
            log.errorFormat("Failed to get host {0} status.", hostName);
            break;
        }
    }
    if (!statusReached) {
        // Send an Alert
        String actionName = (getParameters().getParentCommand() == VdcActionType.RestartVds) ? FenceActionType.Restart.name() : ACTION_NAME;
        AuditLogableBase auditLogable = new AuditLogableBase();
        auditLogable.addCustomValue("Host", hostName);
        auditLogable.addCustomValue("Status", actionName);
        auditLogable.setVdsId(getVds().getId());
        AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED);
        log.errorFormat("Failed to verify host {0} {1} status. Have retried {2} times with delay of {3} seconds between each retry.", hostName, ACTION_NAME, getRerties(), getDelayInSeconds());
    }
    return statusReached;
}
#method_after
protected boolean waitForStatus() {
    FenceExecutor executor = createFenceExecutor();
    int i = 1;
    int j = 1;
    boolean requiredStatusReached = false;
    String requiredStatus = getRequiredStatus();
    String hostName = getVds().getName();
    log.info("Waiting for vds {} to reach status {}", hostName, requiredStatus);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(SLEEP_BEFORE_FIRST_ATTEMPT);
    int retries = getWaitForStatusRerties();
    while (!requiredStatusReached && i <= retries) {
        log.info("Attempt {} to get vds {} status", i, hostName);
        VDSFenceReturnValue returnValue = executor.checkStatus();
        if (returnValue != null && returnValue.getSucceeded()) {
            String status = ((FenceStatusReturnValue) returnValue.getReturnValue()).getStatus();
            if (status.equalsIgnoreCase(VDSM_STATUS_UNKONWN)) {
                // Allow command to fail temporarily
                if (j <= UNKNOWN_RESULT_ALLOWED && i <= retries) {
                    ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    i++;
                    j++;
                } else {
                    // No need to retry , agent definitions are corrupted
                    log.error("Host {} PM Agent definitions are corrupted, aborting fence operation.", hostName);
                    break;
                }
            } else {
                if (requiredStatus.equalsIgnoreCase(status)) {
                    requiredStatusReached = true;
                    log.info("vds {} status is {}", hostName, requiredStatus);
                } else {
                    i++;
                    if (i <= retries) {
                        ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    }
                }
            }
        } else {
            log.error("Failed to get host {} status.", hostName);
            break;
        }
    }
    return requiredStatusReached;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = super.canDoAction();
    VDS vds = getVds();
    if (vds != null) {
        VDSStatus vdsStatus = vds.getStatus();
        if (vdsStatus == VDSStatus.Connecting) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_INTERMITENT_CONNECTIVITY);
        } else if (!legalStatusForStartingVds(vdsStatus)) {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_START);
            retValue = false;
            log.errorFormat("VDS status for vds {0}:{1} is {2}", vds.getId(), vds.getName(), vdsStatus);
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = super.canDoAction();
    VDS vds = getVds();
    if (vds != null) {
        VDSStatus vdsStatus = vds.getStatus();
        if (vdsStatus == VDSStatus.Connecting) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_INTERMITENT_CONNECTIVITY);
        } else if (!legalStatusForStartingVds(vdsStatus)) {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_START);
            retValue = false;
            log.error("VDS status for vds '{}' '{}' is '{}'", vds.getId(), vds.getName(), vdsStatus);
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void handleError() {
    log.errorFormat("Failed to run StartVdsCommand on vds :{0}", getVdsName());
}
#method_after
@Override
protected void handleError() {
    addCanDoActionMessage(VdcBllMessages.VDS_FENCE_OPERATION_FAILED);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__START);
    log.error("Failed to run StartVdsCommand on vds '{}'", getVdsName());
}
#end_block

#method_before
@Override
public Response add(Host host) {
    validateEnums(Host.class, host);
    validateParameters(host, "name", "address");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setVdsGroupId(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(getMapper(Host.class, VdsStatic.class).map(host, null), host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetRebootAfterInstallation()) {
        addParams.setRebootAfterInstallation(host.isRebootAfterInstallation());
    }
    if (host.isSetPowerManagement() && host.getPowerManagement().isSetAgents()) {
        List<FencingAgent> agents = new LinkedList<FencingAgent>();
        for (Agent agent : host.getPowerManagement().getAgents().getAgents()) {
            agents.add(FencingAgentMapper.map(agent, null));
        }
        addParams.setFencingAgents(agents);
    }
    addParams = (AddVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(host, (VdsOperationActionParameters) addParams);
    return performCreate(VdcActionType.AddVds, addParams, new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class));
}
#method_after
@Override
public Response add(Host host) {
    validateEnums(Host.class, host);
    validateParameters(host, "name", "address");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setVdsGroupId(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(getMapper(Host.class, VdsStatic.class).map(host, null), host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetRebootAfterInstallation()) {
        addParams.setRebootAfterInstallation(host.isRebootAfterInstallation());
    }
    if (host.isSetPowerManagement() && host.getPowerManagement().isSetAgents()) {
        List<FenceAgent> agents = new LinkedList<FenceAgent>();
        for (Agent agent : host.getPowerManagement().getAgents().getAgents()) {
            agents.add(FenceAgentMapper.map(agent, null));
        }
        addParams.setFenceAgents(agents);
    }
    addParams = (AddVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(host, (VdsOperationActionParameters) addParams);
    return performCreate(VdcActionType.AddVds, addParams, new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class));
}
#end_block

#method_before
@Override
protected Host deprecatedPopulate(Host model, VDS entity) {
    Host host = addStatistics(model, entity, uriInfo, httpHeaders);
    addCertificateInfo(host);
    return host;
}
#method_after
@Override
protected Host deprecatedPopulate(Host model, VDS entity) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    if (details.contains("statistics")) {
        addStatistics(model, entity);
    }
    addCertificateInfo(model);
    return model;
}
#end_block

#method_before
Host addStatistics(Host model, VDS entity, UriInfo ui, HttpHeaders httpHeaders) {
    if (DetailHelper.include(httpHeaders, "statistics")) {
        model.setStatistics(new Statistics());
        HostStatisticalQuery query = new HostStatisticalQuery(newModel(model.getId()));
        List<Statistic> statistics = query.getStatistics(entity);
        for (Statistic statistic : statistics) {
            LinkHelper.addLinks(ui, statistic, query.getParentType());
        }
        model.getStatistics().getStatistics().addAll(statistics);
    }
    return model;
}
#method_after
public void addStatistics(Host model, VDS entity) {
    model.setStatistics(new Statistics());
    HostStatisticalQuery query = new HostStatisticalQuery(newModel(model.getId()));
    List<Statistic> statistics = query.getStatistics(entity);
    for (Statistic statistic : statistics) {
        LinkHelper.addLinks(uriInfo, statistic, query.getParentType());
    }
    model.getStatistics().getStatistics().addAll(statistics);
}
#end_block

#method_before
public Host addCertificateInfo(Host host) {
    VdcQueryReturnValue result = runQuery(VdcQueryType.GetVdsCertificateSubjectByVdsId, new IdQueryParameters(asGuid(host.getId())));
    if (result != null && result.getSucceeded() && result.getReturnValue() != null) {
        String subject = result.getReturnValue().toString();
        if (subject != null) {
            host.setCertificate(new Certificate());
            host.getCertificate().setSubject(subject);
            host.getCertificate().setOrganization(subject.split(",")[0].replace("O=", ""));
        }
    } else {
        LOG.error("Could not fetch certificate info for host " + host.getId());
    }
    return host;
}
#method_after
public Host addCertificateInfo(Host host) {
    VdcQueryReturnValue result = runQuery(VdcQueryType.GetVdsCertificateSubjectByVdsId, new IdQueryParameters(asGuid(host.getId())));
    if (result != null && result.getSucceeded() && result.getReturnValue() != null) {
        String subject = result.getReturnValue().toString();
        if (subject != null) {
            host.setCertificate(new Certificate());
            host.getCertificate().setSubject(subject);
            host.getCertificate().setOrganization(subject.split(",")[0].replace("O=", ""));
        }
    } else {
        log.error("Could not fetch certificate info for host '{}'", host.getId());
    }
    return host;
}
#end_block

#method_before
@Parameters
public static Collection<Object[]> data() {
    RandomUtils random = RandomUtils.instance();
    VdsStatic vdsStatic = new VdsStatic(random.nextString(10), random.nextString(10), random.nextInt(), random.nextInt(), random.nextString(10), Guid.newGuid(), Guid.newGuid(), random.nextString(10), random.nextBoolean(), random.nextEnum(VDSType.class));
    Object[][] data = new Object[][] { { vdsStatic }, { randomVdsDynamic() }, { randomVdsStatistics() }, { new vds_spm_id_map(Guid.newGuid(), Guid.newGuid(), random.nextInt()) }, { randomStorageDomainStatic() }, { new StorageDomainDynamic(random.nextInt(), Guid.newGuid(), random.nextInt()) }, { randomStoragePool() }, { new StoragePoolIsoMap(Guid.newGuid(), Guid.newGuid(), random.nextEnum(StorageDomainStatus.class)) }, { randomRole() }, { new IdContainerClass<vds_spm_id_map>(new vds_spm_id_map(Guid.newGuid(), Guid.newGuid(), random.nextInt())) }, { new IdContainerClass<Guid>(Guid.newGuid()) } };
    return Arrays.asList(data);
}
#method_after
@Parameters
public static Collection<Object[]> data() {
    RandomUtils random = RandomUtils.instance();
    VdsStatic vdsStatic = new VdsStatic(random.nextString(10), random.nextString(10), random.nextInt(), random.nextInt(), random.nextString(10), Guid.newGuid(), Guid.newGuid(), random.nextString(10), random.nextBoolean(), random.nextEnum(VDSType.class), Guid.newGuid());
    Object[][] data = new Object[][] { { vdsStatic }, { randomVdsDynamic() }, { randomVdsStatistics() }, { new vds_spm_id_map(Guid.newGuid(), Guid.newGuid(), random.nextInt()) }, { randomStorageDomainStatic() }, { new StorageDomainDynamic(random.nextInt(), Guid.newGuid(), random.nextInt()) }, { randomStoragePool() }, { new StoragePoolIsoMap(Guid.newGuid(), Guid.newGuid(), random.nextEnum(StorageDomainStatus.class)) }, { randomRole() }, { new IdContainerClass<vds_spm_id_map>(new vds_spm_id_map(Guid.newGuid(), Guid.newGuid(), random.nextInt())) }, { new IdContainerClass<Guid>(Guid.newGuid()) } };
    return Arrays.asList(data);
}
#end_block

#method_before
private static VdsDynamic randomVdsDynamic() {
    RandomUtils random = RandomUtils.instance();
    VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setcpu_cores(random.nextInt());
    vdsDynamic.setCpuThreads(random.nextInt());
    vdsDynamic.setcpu_model(random.nextString(10));
    vdsDynamic.setcpu_speed_mh(random.nextDouble());
    vdsDynamic.setif_total_speed(random.nextString(10));
    vdsDynamic.setkvm_enabled(random.nextBoolean());
    vdsDynamic.setmem_commited(random.nextInt());
    vdsDynamic.setphysical_mem_mb(random.nextInt());
    vdsDynamic.setStatus(random.nextEnum(VDSStatus.class));
    vdsDynamic.setId(Guid.newGuid());
    vdsDynamic.setvm_active(random.nextInt());
    vdsDynamic.setvm_count(random.nextInt());
    vdsDynamic.setvm_migrating(random.nextInt());
    vdsDynamic.setreserved_mem(random.nextInt());
    vdsDynamic.setguest_overhead(random.nextInt());
    vdsDynamic.setprevious_status(random.nextEnum(VDSStatus.class));
    vdsDynamic.setsoftware_version(random.nextNumericString(5) + '.' + random.nextNumericString(5));
    vdsDynamic.setversion_name(random.nextString(10));
    vdsDynamic.setcpu_over_commit_time_stamp(new Date(random.nextLong()));
    vdsDynamic.setpending_vcpus_count(random.nextInt());
    vdsDynamic.setpending_vmem_size(random.nextInt());
    vdsDynamic.setnet_config_dirty(random.nextBoolean());
    vdsDynamic.setTransparentHugePagesState(random.nextEnum(VdsTransparentHugePagesState.class));
    vdsDynamic.setHardwareUUID(Guid.newGuid().toString());
    vdsDynamic.setHardwareFamily(random.nextString(10));
    vdsDynamic.setHardwareSerialNumber(random.nextString(10));
    vdsDynamic.setHardwareVersion(random.nextString(10));
    vdsDynamic.setHardwareProductName(random.nextString(10));
    vdsDynamic.setHardwareManufacturer(random.nextString(10));
    return vdsDynamic;
}
#method_after
private static VdsDynamic randomVdsDynamic() {
    RandomUtils random = RandomUtils.instance();
    VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setcpu_cores(random.nextInt());
    vdsDynamic.setCpuThreads(random.nextInt());
    vdsDynamic.setcpu_model(random.nextString(10));
    vdsDynamic.setcpu_speed_mh(random.nextDouble());
    vdsDynamic.setif_total_speed(random.nextString(10));
    vdsDynamic.setkvm_enabled(random.nextBoolean());
    vdsDynamic.setmem_commited(random.nextInt());
    vdsDynamic.setphysical_mem_mb(random.nextInt());
    vdsDynamic.setStatus(random.nextEnum(VDSStatus.class));
    vdsDynamic.setId(Guid.newGuid());
    vdsDynamic.setvm_active(random.nextInt());
    vdsDynamic.setvm_count(random.nextInt());
    vdsDynamic.setvm_migrating(random.nextInt());
    vdsDynamic.setreserved_mem(random.nextInt());
    vdsDynamic.setguest_overhead(random.nextInt());
    vdsDynamic.setprevious_status(random.nextEnum(VDSStatus.class));
    vdsDynamic.setsoftware_version(random.nextNumericString(5) + '.' + random.nextNumericString(5));
    vdsDynamic.setversion_name(random.nextString(10));
    vdsDynamic.setpending_vcpus_count(random.nextInt());
    vdsDynamic.setpending_vmem_size(random.nextInt());
    vdsDynamic.setnet_config_dirty(random.nextBoolean());
    vdsDynamic.setTransparentHugePagesState(random.nextEnum(VdsTransparentHugePagesState.class));
    vdsDynamic.setHardwareUUID(Guid.newGuid().toString());
    vdsDynamic.setHardwareFamily(random.nextString(10));
    vdsDynamic.setHardwareSerialNumber(random.nextString(10));
    vdsDynamic.setHardwareVersion(random.nextString(10));
    vdsDynamic.setHardwareProductName(random.nextString(10));
    vdsDynamic.setHardwareManufacturer(random.nextString(10));
    return vdsDynamic;
}
#end_block

#method_before
private static VdsStatistics randomVdsStatistics() {
    RandomUtils random = RandomUtils.instance();
    VdsStatistics vdsStatistics = new VdsStatistics();
    vdsStatistics.setcpu_idle(random.nextDouble());
    vdsStatistics.setcpu_load(random.nextDouble());
    vdsStatistics.setcpu_sys(random.nextDouble());
    vdsStatistics.setcpu_user(random.nextDouble());
    vdsStatistics.setmem_available(random.nextLong());
    vdsStatistics.setMemFree(random.nextLong());
    vdsStatistics.setmem_shared(random.nextLong());
    vdsStatistics.setusage_cpu_percent(random.nextInt());
    vdsStatistics.setusage_mem_percent(random.nextInt());
    vdsStatistics.setusage_network_percent(random.nextInt());
    return vdsStatistics;
}
#method_after
private static VdsStatistics randomVdsStatistics() {
    RandomUtils random = RandomUtils.instance();
    VdsStatistics vdsStatistics = new VdsStatistics();
    vdsStatistics.setCpuIdle(random.nextDouble());
    vdsStatistics.setCpuLoad(random.nextDouble());
    vdsStatistics.setCpuSys(random.nextDouble());
    vdsStatistics.setCpuUser(random.nextDouble());
    vdsStatistics.setMemAvailable(random.nextLong());
    vdsStatistics.setMemFree(random.nextLong());
    vdsStatistics.setMemShared(random.nextLong());
    vdsStatistics.setUsageCpuPercent(random.nextInt());
    vdsStatistics.setUsageMemPercent(random.nextInt());
    vdsStatistics.setUsageNetworkPercent(random.nextInt());
    vdsStatistics.setCpuOverCommitTimeStamp(new Date(random.nextLong()));
    return vdsStatistics;
}
#end_block

#method_before
@Override
public int compare(Agent agent1, Agent agent2) {
    if (agent1.getOrder() < agent2.getOrder()) {
        return -1;
    } else if (agent1.getOrder() == agent2.getOrder()) {
        return 0;
    } else {
        return 1;
    }
}
#method_after
@Override
public int compare(Agent agent1, Agent agent2) {
    return agent1.getOrder().compareTo(agent2.getOrder());
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    vm.setCustomCpuName(instance.getCustomCpuName());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    vm.setCpuProfileId(instance.getCpuProfileId());
    vm.setAutoConverge(instance.getAutoConverge());
    vm.setMigrateCompressed(instance.getMigrateCompressed());
    vm.setPredefinedProperties(instance.getPredefinedProperties());
    vm.setUserDefinedProperties(instance.getUserDefinedProperties());
    vm.setCustomProperties(instance.getCustomProperties());
    return vm;
}
#end_block

#method_before
private static Object cloneVDS(VDS instance) {
    VDS obj = new VDS();
    obj.setHostName(instance.getHostName());
    obj.setSshKeyFingerprint(instance.getSshKeyFingerprint());
    obj.setSshPort(instance.getSshPort());
    obj.setSshUsername(instance.getSshUsername());
    obj.setFencingAgents(instance.getFencingAgents());
    obj.setDisablePowerManagementPolicy(instance.isDisablePowerManagementPolicy());
    obj.setPmKdumpDetection(instance.isPmKdumpDetection());
    obj.setPort(instance.getPort());
    obj.setServerSslEnabled(instance.isServerSslEnabled());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setVdsName(instance.getName());
    obj.setVdsStrength(instance.getVdsStrength());
    obj.setVdsType(instance.getVdsType());
    obj.setUniqueId(instance.getUniqueId());
    obj.setVdsSpmPriority(instance.getVdsSpmPriority());
    return obj;
}
#method_after
private static Object cloneVDS(VDS instance) {
    VDS obj = new VDS();
    obj.setHostName(instance.getHostName());
    obj.setSshKeyFingerprint(instance.getSshKeyFingerprint());
    obj.setSshPort(instance.getSshPort());
    obj.setSshUsername(instance.getSshUsername());
    obj.setFenceAgents(cloneAgents(instance.getFenceAgents()));
    obj.setDisablePowerManagementPolicy(instance.isDisablePowerManagementPolicy());
    obj.setPmKdumpDetection(instance.isPmKdumpDetection());
    obj.setPort(instance.getPort());
    obj.setServerSslEnabled(instance.isServerSslEnabled());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setVdsName(instance.getName());
    obj.setVdsStrength(instance.getVdsStrength());
    obj.setVdsType(instance.getVdsType());
    obj.setUniqueId(instance.getUniqueId());
    obj.setVdsSpmPriority(instance.getVdsSpmPriority());
    return obj;
}
#end_block

#method_before
private static VDSGroup cloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setcpu_name(instance.getcpu_name());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    obj.setEmulatedMachine(instance.getEmulatedMachine());
    obj.setDetectEmulatedMachine(instance.isDetectEmulatedMachine());
    obj.setArchitecture(instance.getArchitecture());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    return obj;
}
#method_after
private static VDSGroup cloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setcpu_name(instance.getcpu_name());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    obj.setEmulatedMachine(instance.getEmulatedMachine());
    obj.setDetectEmulatedMachine(instance.isDetectEmulatedMachine());
    obj.setArchitecture(instance.getArchitecture());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setFencingPolicy(new FencingPolicy(instance.getFencingPolicy()));
    obj.setAutoConverge(instance.getAutoConverge());
    obj.setMigrateCompressed(instance.getMigrateCompressed());
    return obj;
}
#end_block

#method_before
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setCreatedByUserId(instance.getCreatedByUserId());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    return obj;
}
#method_after
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    obj.setCustomCpuName(instance.getCustomCpuName());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setCreatedByUserId(instance.getCreatedByUserId());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    obj.setCpuProfileId(instance.getCpuProfileId());
    obj.setAutoConverge(instance.getAutoConverge());
    obj.setMigrateCompressed(instance.getMigrateCompressed());
    obj.setPredefinedProperties(instance.getPredefinedProperties());
    obj.setUserDefinedProperties(instance.getUserDefinedProperties());
    obj.setCustomProperties(instance.getCustomProperties());
    return obj;
}
#end_block

#method_before
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    return obj;
}
#method_after
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    obj.setCustomCpuName(instance.getCustomCpuName());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    obj.setCpuProfileId(instance.getCpuProfileId());
    obj.setAutoConverge(instance.getAutoConverge());
    obj.setMigrateCompressed(instance.getMigrateCompressed());
    obj.setPredefinedProperties(instance.getPredefinedProperties());
    obj.setUserDefinedProperties(instance.getUserDefinedProperties());
    obj.setCustomProperties(instance.getCustomProperties());
    return obj;
}
#end_block

#method_before
@Test
public void testMapPmToHost() {
    PowerManagement powerMgmt = createPowerManagement();
    List<FencingAgent> fencingAgents = DeprecatedPowerManagementMapper.map(powerMgmt, null);
    Collections.sort(fencingAgents, new FencingAgent.FencingAgentOrderComparator());
    assertEquals(fencingAgents.get(0).getIp(), "1.1.1.112");
    assertEquals(fencingAgents.get(0).getPassword(), "passwd");
    assertEquals(fencingAgents.get(0).getType(), "apc");
    assertEquals(fencingAgents.get(0).getUser(), "user");
    assertEquals(fencingAgents.get(0).getOrder(), new Integer(1));
}
#method_after
@Test
public void testMapPmToHost() {
    PowerManagement powerMgmt = createPowerManagement();
    List<FenceAgent> fenceAgents = DeprecatedPowerManagementMapper.map(powerMgmt, null);
    Collections.sort(fenceAgents, new FenceAgent.FenceAgentOrderComparator());
    assertEquals(fenceAgents.get(0).getIp(), "1.1.1.112");
    assertEquals(fenceAgents.get(0).getPassword(), "passwd");
    assertEquals(fenceAgents.get(0).getType(), "apc");
    assertEquals(fenceAgents.get(0).getUser(), "user");
    assertEquals(fenceAgents.get(0).getOrder(), 1);
}
#end_block

#method_before
@Test
public void testMapPmToHost_Priority_To_PM_Fields_Over_Agents() {
    // create PM object with address="1.1.1.112"
    PowerManagement powerMgmt = new PowerManagement();
    powerMgmt.setAddress("1.1.1.112");
    powerMgmt.setUsername("pm_user");
    powerMgmt.setType("apc_2");
    // create Agent with address="1.1.1.111"
    Agent agent = createAgent("1.1.1.111", "apc", "user", "passwd", 123, 1);
    powerMgmt.setAgents(new Agents());
    powerMgmt.getAgents().getAgents().add(agent);
    List<FencingAgent> agents = DeprecatedPowerManagementMapper.map(powerMgmt, null);
    // The value that's in the PM object should have been selected (not the value in the agent).
    assertEquals("1.1.1.112", agents.get(0).getIp());
    assertEquals("pm_user", agents.get(0).getUser());
    assertEquals("passwd", agents.get(0).getPassword());
    assertEquals("apc_2", agents.get(0).getType());
}
#method_after
@Test
public void testMapPmToHost_Priority_To_PM_Fields_Over_Agents() {
    // create PM object with address="1.1.1.112"
    PowerManagement powerMgmt = new PowerManagement();
    powerMgmt.setAddress("1.1.1.112");
    powerMgmt.setUsername("pm_user");
    powerMgmt.setType("apc_2");
    // create Agent with address="1.1.1.111"
    Agent agent = createAgent("1.1.1.111", "apc", "user", "passwd", 123, 1);
    powerMgmt.setAgents(new Agents());
    powerMgmt.getAgents().getAgents().add(agent);
    List<FenceAgent> agents = DeprecatedPowerManagementMapper.map(powerMgmt, null);
    // The value that's in the PM object should have been selected (not the value in the agent).
    assertEquals("1.1.1.112", agents.get(0).getIp());
    assertEquals("pm_user", agents.get(0).getUser());
    assertEquals("passwd", agents.get(0).getPassword());
    assertEquals("apc_2", agents.get(0).getType());
}
#end_block

#method_before
@Test
public void testMapHostToPmDeprecated() {
    String[] ip = { "1.1.1.111", "1.1.1.112" };
    int i = 0;
    List<FencingAgent> agents = new LinkedList<>();
    FencingAgent primaryAgent = createFencingAgent(ip[0], "apc", "user", "password", 80, "secure=true", 1);
    agents.add(primaryAgent);
    // concurrent
    FencingAgent secondaryAgent = createFencingAgent(ip[1], "apc", "user", "password", 80, "secure=true", 1);
    agents.add(secondaryAgent);
    PowerManagement powerMgmt = DeprecatedPowerManagementMapper.map(agents, null);
    assertEquals(powerMgmt.getAgents().getAgents().size(), 2);
    for (Agent agent : powerMgmt.getAgents().getAgents()) {
        assertEquals(agent.getAddress(), ip[i]);
        assertEquals(agent.getType(), "apc");
        assertEquals(agent.getUsername(), "user");
        assertTrue(agent.isConcurrent());
        assertEquals(agent.getOptions().getOptions().get(0).getName(), "secure");
        assertEquals(agent.getOptions().getOptions().get(0).getValue(), "true");
        if (i > 0) {
            assertEquals(agent.isConcurrent(), true);
        }
        i++;
    }
}
#method_after
@Test
public void testMapHostToPmDeprecated() {
    String[] ip = { "1.1.1.111", "1.1.1.112" };
    int i = 0;
    List<FenceAgent> agents = new LinkedList<>();
    FenceAgent primaryAgent = createFenceAgent(new Guid("00000000-0000-0000-0000-000000000000"), ip[0], "apc", "user", "password", 80, "secure=true", 1);
    agents.add(primaryAgent);
    FenceAgent secondaryAgent = createFenceAgent(new Guid("11111111-1111-1111-1111-111111111111"), ip[1], "apc", "user", "password", 80, "secure=true", // concurrent
    1);
    agents.add(secondaryAgent);
    PowerManagement powerMgmt = DeprecatedPowerManagementMapper.map(agents, null);
    assertEquals(powerMgmt.getAgents().getAgents().size(), 2);
    for (Agent agent : powerMgmt.getAgents().getAgents()) {
        assertEquals(agent.getAddress(), ip[i]);
        assertEquals(agent.getType(), "apc");
        assertEquals(agent.getUsername(), "user");
        assertTrue(agent.isConcurrent());
        assertEquals(agent.getOptions().getOptions().get(0).getName(), "secure");
        assertEquals(agent.getOptions().getOptions().get(0).getValue(), "true");
        if (i > 0) {
            assertEquals(agent.isConcurrent(), true);
        }
        i++;
    }
}
#end_block

#method_before
public static PowerManagement map(List<FencingAgent> agents, PowerManagement pm) {
    if (pm == null) {
        pm = new PowerManagement();
    }
    if (!agents.isEmpty()) {
        Collections.sort(agents, new FencingAgent.FencingAgentOrderComparator());
        // Set agent-related fields directly in PowerManagement object (for backwards compatibility).
        mapAgentToPm(agents.get(0), pm);
        pm.setAgents(new Agents());
        pm.getAgents().getAgents().add(new Agent());
        // map the first agent
        mapAgent(agents.get(0), pm.getAgents().getAgents().get(0));
        if (agents.size() > 1) {
            pm.getAgents().getAgents().add(new Agent());
            // map the second agent (if exists).
            mapAgent(agents.get(1), pm.getAgents().getAgents().get(1));
            setConcurrent(pm, agents);
        }
    }
    return pm;
}
#method_after
@Deprecated
public static List<FenceAgent> map(PowerManagement pm, List<FenceAgent> agents) {
    if (agents == null) {
        agents = new LinkedList<FenceAgent>();
    }
    if (pm != null) {
        if (pmAgentFieldsEmpty(pm)) {
            // client supplied empty <power_management/>, this means all PM agents should be deleted.
            agents.clear();
        } else {
            agents = mapPowerManagement(pm, agents);
        }
    }
    return agents;
}
#end_block

#method_before
private static List<FencingAgent> mapPowerManagement(PowerManagement pm, List<FencingAgent> agents) {
    if (isPmContainsAgents(pm)) {
        // In case there are agents in the PowerManagement, and also PowerManagement agent-related fields are filled
        // with values, map judiciously considering both sources.
        agents = mapPowerManagementConsideringAgents(pm, agents);
    } else {
        // In case there are no agents, but the agent related fields in PowerManagement object are filled, create an
        // Agent from the values in these fields.
        agents = mapPowerManagementNoAgents(pm, agents);
    }
    return agents;
}
#method_after
private static List<FenceAgent> mapPowerManagement(PowerManagement pm, List<FenceAgent> agents) {
    if (isPmContainsAgents(pm)) {
        // In case there are agents in the PowerManagement, and also PowerManagement agent-related fields are filled
        // with values, map judiciously considering both sources.
        agents = mapPowerManagementConsideringAgents(pm, agents);
    } else {
        // In case there are no agents, but the agent related fields in PowerManagement object are filled, create an
        // Agent from the values in these fields.
        agents = mapPowerManagementNoAgents(pm, agents);
    }
    return agents;
}
#end_block

#method_before
private static List<FencingAgent> mapPowerManagementConsideringAgents(PowerManagement pm, List<FencingAgent> agentsEngine) {
    // get and sort the API agents (agents found in PowerManagement object).
    List<Agent> agentsApi = pm.getAgents().getAgents();
    Collections.sort(agentsApi, new AgentComparator());
    // sort the existing agents in the engine.
    Collections.sort(agentsEngine, new FencingAgent.FencingAgentOrderComparator());
    FencingAgent primaryAgent = getPrimaryAgent(agentsEngine);
    mapPrimaryAgent(pm, agentsApi.get(0), primaryAgent);
    if (agentsApi.size() > 1) {
        mapAgent(agentsApi.get(1), getSecondaryAgent(agentsEngine));
    } else if (agentsEngine.size() > 1) {
        // client supplied 1 agent, 2 agents exist in the engine, this means the second
        agentsEngine.remove(1);
    // agent should be deleted.
    }
    return agentsEngine;
}
#method_after
private static List<FenceAgent> mapPowerManagementConsideringAgents(PowerManagement pm, List<FenceAgent> agentsEngine) {
    // get and sort the API agents (agents found in PowerManagement object).
    List<Agent> agentsApi = pm.getAgents().getAgents();
    Collections.sort(agentsApi, new AgentComparator());
    // sort the existing agents in the engine.
    Collections.sort(agentsEngine, new FenceAgent.FenceAgentOrderComparator());
    FenceAgent primaryAgent = getPrimaryAgent(agentsEngine);
    mapPrimaryAgent(pm, agentsApi.get(0), primaryAgent);
    if (agentsApi.size() > 1) {
        mapAgent(agentsApi.get(1), getSecondaryAgent(agentsEngine));
    } else if (agentsEngine.size() > 1) {
        // client supplied 1 agent, 2 agents exist in the engine, this means the second
        agentsEngine.remove(1);
    // agent should be deleted.
    }
    return agentsEngine;
}
#end_block

#method_before
private static List<FencingAgent> mapPowerManagementNoAgents(PowerManagement pm, List<FencingAgent> agents) {
    Collections.sort(agents, new FencingAgent.FencingAgentOrderComparator());
    FencingAgent agent = getPrimaryAgent(agents);
    agent.setIp(pm.getAddress());
    agent.setType(pm.getType());
    agent.setUser(pm.getUsername());
    agent.setPassword(pm.getPassword());
    if (pm.getOptions() != null) {
        String modelOptions = HostMapper.map(pm.getOptions(), null);
        if (!modelOptions.equals(agent.getOptions())) {
            agent.setOptions(modelOptions);
        }
    }
    agent.setOrder(1);
    return agents;
}
#method_after
private static List<FenceAgent> mapPowerManagementNoAgents(PowerManagement pm, List<FenceAgent> agents) {
    Collections.sort(agents, new FenceAgent.FenceAgentOrderComparator());
    FenceAgent agent = getPrimaryAgent(agents);
    agent.setIp(pm.getAddress());
    agent.setType(pm.getType());
    agent.setUser(pm.getUsername());
    agent.setPassword(pm.getPassword());
    if (pm.getOptions() != null) {
        String modelOptions = HostMapper.map(pm.getOptions(), null);
        if (!modelOptions.equals(agent.getOptions())) {
            agent.setOptions(modelOptions);
        }
    }
    agent.setOrder(1);
    return agents;
}
#end_block

#method_before
private static FencingAgent getPrimaryAgent(List<FencingAgent> fencingAgents) {
    if (fencingAgents.isEmpty()) {
        fencingAgents.add(new FencingAgent());
    }
    return fencingAgents.get(0);
}
#method_after
private static FenceAgent getPrimaryAgent(List<FenceAgent> fenceAgents) {
    if (fenceAgents.isEmpty()) {
        fenceAgents.add(new FenceAgent());
    }
    return fenceAgents.get(0);
}
#end_block

#method_before
private static FencingAgent getSecondaryAgent(List<FencingAgent> fencingAgents) {
    // this method called after verifying that at least 1 agent exists.
    assert (!fencingAgents.isEmpty());
    if (fencingAgents.size() == 1) {
        fencingAgents.add(new FencingAgent());
    }
    return fencingAgents.get(1);
}
#method_after
private static FenceAgent getSecondaryAgent(List<FenceAgent> fenceAgents) {
    // this method called after verifying that at least 1 agent exists.
    assert (!fenceAgents.isEmpty());
    if (fenceAgents.size() == 1) {
        fenceAgents.add(new FenceAgent());
    }
    return fenceAgents.get(1);
}
#end_block

#method_before
private static void mapPrimaryAgent(PowerManagement pm, Agent agentApi, FencingAgent agentEngine) {
    setManagementIp(agentApi, agentEngine, pm);
    setManagementType(agentApi, agentEngine, pm);
    setManagementUser(agentApi, agentEngine, pm);
    setManagementPassword(agentApi, agentEngine, pm);
    setManagementOptions(agentApi, agentEngine, pm);
    agentEngine.setOrder(agentApi.getOrder());
    agentEngine.setPort(agentApi.getPort());
}
#method_after
private static void mapPrimaryAgent(PowerManagement pm, Agent agentApi, FenceAgent agentEngine) {
    setManagementIp(agentApi, agentEngine, pm);
    setManagementType(agentApi, agentEngine, pm);
    setManagementUser(agentApi, agentEngine, pm);
    setManagementPassword(agentApi, agentEngine, pm);
    setManagementOptions(agentApi, agentEngine, pm);
    agentEngine.setOrder(agentApi.getOrder());
    agentEngine.setPort(agentApi.getPort());
}
#end_block

#method_before
private static void setManagementIp(Agent agentApi, FencingAgent agentEngine, PowerManagement pm) {
    if (pm.isSetAddress() && !pm.getAddress().equals(agentEngine.getIp())) {
        agentEngine.setIp(pm.getAddress());
    } else if (agentApi.isSetAddress() && !agentApi.getAddress().equals(agentEngine.getIp())) {
        agentEngine.setIp(agentApi.getAddress());
    }
}
#method_after
private static void setManagementIp(Agent agentApi, FenceAgent agentEngine, PowerManagement pm) {
    if (pm.isSetAddress() && !pm.getAddress().equals(agentEngine.getIp())) {
        agentEngine.setIp(pm.getAddress());
    } else if (agentApi.isSetAddress() && !agentApi.getAddress().equals(agentEngine.getIp())) {
        agentEngine.setIp(agentApi.getAddress());
    }
}
#end_block

#method_before
private static void setManagementType(Agent agentApi, FencingAgent agentEngine, PowerManagement pm) {
    if (pm.isSetType() && !pm.getType().equals(agentEngine.getType())) {
        agentEngine.setType(pm.getType());
    } else if (agentApi.isSetType() && !agentApi.getType().equals(agentEngine.getType())) {
        agentEngine.setType(agentApi.getType());
    }
}
#method_after
private static void setManagementType(Agent agentApi, FenceAgent agentEngine, PowerManagement pm) {
    if (pm.isSetType() && !pm.getType().equals(agentEngine.getType())) {
        agentEngine.setType(pm.getType());
    } else if (agentApi.isSetType() && !agentApi.getType().equals(agentEngine.getType())) {
        agentEngine.setType(agentApi.getType());
    }
}
#end_block

#method_before
private static void setManagementUser(Agent agentApi, FencingAgent agentEngine, PowerManagement pm) {
    if (pm.isSetUsername() && !pm.getUsername().equals(agentEngine.getUser())) {
        agentEngine.setUser(pm.getUsername());
    } else if (agentApi.isSetUsername() && !agentApi.getUsername().equals(agentEngine.getUser())) {
        agentEngine.setUser(agentApi.getUsername());
    }
}
#method_after
private static void setManagementUser(Agent agentApi, FenceAgent agentEngine, PowerManagement pm) {
    if (pm.isSetUsername() && !pm.getUsername().equals(agentEngine.getUser())) {
        agentEngine.setUser(pm.getUsername());
    } else if (agentApi.isSetUsername() && !agentApi.getUsername().equals(agentEngine.getUser())) {
        agentEngine.setUser(agentApi.getUsername());
    }
}
#end_block

#method_before
private static void setManagementPassword(Agent agentApi, FencingAgent agentEngine, PowerManagement pm) {
    if (pm.isSetPassword() && !pm.getPassword().equals(agentEngine.getPassword())) {
        agentEngine.setPassword(pm.getPassword());
    } else if (agentApi.isSetPassword() && !agentApi.getPassword().equals(agentEngine.getPassword())) {
        agentEngine.setPassword(agentApi.getPassword());
    }
}
#method_after
private static void setManagementPassword(Agent agentApi, FenceAgent agentEngine, PowerManagement pm) {
    if (pm.isSetPassword() && !pm.getPassword().equals(agentEngine.getPassword())) {
        agentEngine.setPassword(pm.getPassword());
    } else if (agentApi.isSetPassword() && !agentApi.getPassword().equals(agentEngine.getPassword())) {
        agentEngine.setPassword(agentApi.getPassword());
    }
}
#end_block

#method_before
private static void setManagementOptions(Agent agentApi, FencingAgent agentEngine, PowerManagement pm) {
    if (pm.isSetOptions()) {
        String modelOptions = HostMapper.map(pm.getOptions(), null);
        if (!modelOptions.equals(agentEngine.getOptions())) {
            agentEngine.setOptions(modelOptions);
        }
    } else if (agentApi.isSetOptions()) {
        String agentOptions = HostMapper.map(agentApi.getOptions(), null);
        if (!agentOptions.equals(agentEngine.getOptions())) {
            agentEngine.setOptions(agentOptions);
        }
    }
}
#method_after
private static void setManagementOptions(Agent agentApi, FenceAgent agentEngine, PowerManagement pm) {
    if (pm.isSetOptions()) {
        String modelOptions = HostMapper.map(pm.getOptions(), null);
        if (!modelOptions.equals(agentEngine.getOptions())) {
            agentEngine.setOptions(modelOptions);
        }
    } else if (agentApi.isSetOptions()) {
        String agentOptions = HostMapper.map(agentApi.getOptions(), null);
        if (!agentOptions.equals(agentEngine.getOptions())) {
            agentEngine.setOptions(agentOptions);
        }
    }
}
#end_block

#method_before
private static void mapAgent(FencingAgent agentEngine, Agent agentApi) {
    agentApi.setId(agentEngine.getId().toString());
    agentApi.setType(agentEngine.getType());
    agentApi.setAddress(agentEngine.getIp());
    agentApi.setUsername(agentEngine.getUser());
    if (agentEngine.getOptionsMap() != null) {
        agentApi.setOptions(HostMapper.map(agentEngine.getOptionsMap(), null));
    }
    agentApi.setOrder(agentEngine.getOrder());
    agentApi.setPort(agentEngine.getPort());
    if (agentEngine.getOptions() != null && !agentEngine.getOptions().isEmpty() && agentEngine.getOptionsMap() != null) {
        agentApi.setOptions(HostMapper.map(agentEngine.getOptionsMap(), null));
    }
}
#method_after
private static void mapAgent(Agent agentApi, FenceAgent agentEngine) {
    if (agentApi.isSetId()) {
        agentEngine.setId(Guid.createGuidFromString(agentApi.getId()));
    }
    if (agentApi.isSetAddress()) {
        agentEngine.setIp(agentApi.getAddress());
    }
    if (agentApi.isSetType()) {
        agentEngine.setType(agentApi.getType());
    }
    if (agentApi.isSetOptions()) {
        agentEngine.setOptions(HostMapper.map(agentApi.getOptions(), null));
    }
    if (agentApi.isSetUsername()) {
        agentEngine.setUser(agentApi.getUsername());
    }
    if (agentApi.isSetPassword()) {
        agentEngine.setPassword(agentApi.getPassword());
    }
    if (agentApi.isSetPort()) {
        agentEngine.setPort(agentApi.getPort());
    }
}
#end_block

#method_before
private static void mapAgentToPm(FencingAgent primaryAgentEngine, PowerManagement pm) {
    pm.setType(primaryAgentEngine.getType());
    pm.setAddress(primaryAgentEngine.getIp());
    pm.setUsername(primaryAgentEngine.getUser());
    if (primaryAgentEngine.getOptionsMap() != null) {
        pm.setOptions(HostMapper.map(primaryAgentEngine.getOptionsMap(), null));
    }
}
#method_after
private static void mapAgentToPm(FenceAgent primaryAgentEngine, PowerManagement pm) {
    pm.setType(primaryAgentEngine.getType());
    pm.setAddress(primaryAgentEngine.getIp());
    pm.setUsername(primaryAgentEngine.getUser());
    if (primaryAgentEngine.getOptionsMap() != null) {
        pm.setOptions(HostMapper.map(primaryAgentEngine.getOptionsMap(), null));
    }
}
#end_block

#method_before
private static void setConcurrent(PowerManagement pm, List<FencingAgent> fencingAgents) {
    assert fencingAgents.size() >= 2;
    boolean concurrent = fencingAgents.get(0).getOrder() == fencingAgents.get(1).getOrder();
    // When a second agent exists, 'concurrent' field is relevant for both agents, so here we
    // set it retroactively in the first agent.
    pm.getAgents().getAgents().get(0).setConcurrent(concurrent);
    pm.getAgents().getAgents().get(1).setConcurrent(concurrent);
}
#method_after
private static void setConcurrent(PowerManagement pm, List<FenceAgent> fenceAgents) {
    assert fenceAgents.size() >= 2;
    boolean concurrent = fenceAgents.get(0).getOrder() == fenceAgents.get(1).getOrder();
    // When a second agent exists, 'concurrent' field is relevant for both agents, so here we
    // set it retroactively in the first agent.
    pm.getAgents().getAgents().get(0).setConcurrent(concurrent);
    pm.getAgents().getAgents().get(1).setConcurrent(concurrent);
}
#end_block

#method_before
public VDSFenceReturnValue checkStatus() {
    VDSFenceReturnValue returnValue = null;
    VDS proxyHost = findProxyHost(FenceActionType.Status);
    if (proxyHost == null) {
        returnValue = proxyNotFound();
    } else {
        for (FencingAgent agent : _vds.getFencingAgents()) {
            returnValue = fence(FenceActionType.Status, agent, proxyHost);
            if (returnValue.isSucceeded()) {
                returnValue.setProxyHostUsed(proxyHost);
                returnValue.setFencingAgentUsed(agent);
                break;
            }
        }
    }
    return returnValue;
}
#method_after
public VDSFenceReturnValue checkStatus() {
    VDSFenceReturnValue returnValue = null;
    VDS proxyHost = new FenceProxyLocator(_vds, fencingPolicy).findProxyHost(false);
    if (proxyHost == null) {
        returnValue = proxyNotFound();
    } else {
        for (FenceAgent agent : _vds.getFenceAgents()) {
            returnValue = fence(FenceActionType.Status, agent, proxyHost);
            if (returnValue.getSucceeded()) {
                returnValue.setProxyHostUsed(proxyHost);
                returnValue.setFenceAgentUsed(agent);
                break;
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
public VDSFenceReturnValue fence(FenceActionType action, FencingAgent agent, VDS proxyHost) {
    VDSReturnValue result = null;
    try {
        if (action == FenceActionType.Restart || action == FenceActionType.Stop) {
            stopSPM(action);
        }
        result = runFenceAction(action, agent, proxyHost);
        if (!result.getSucceeded()) {
            log.warnFormat("Fencing operation failed with proxy host {0}, trying another proxy...", proxyHost.getId());
            // if fence failed, retry with another proxy
            VDS alternativeProxy = findProxyHostExcluding(action, proxyHost.getId());
            if (alternativeProxy != null) {
                result = runFenceAction(action, agent, alternativeProxy);
            } else {
                log.warnFormat("Failed to find other proxy to re-run failed fence operation, retrying with the same proxy...");
                result = runFenceAction(action, agent, proxyHost);
            }
        }
    } catch (VdcBLLException e) {
        result = new VDSReturnValue();
        result.setReturnValue(new FenceStatusReturnValue("unknown", e.getMessage()));
        result.setExceptionString(e.getMessage());
        result.setSucceeded(false);
    }
    return new VDSFenceReturnValue(result);
}
#method_after
public VDSFenceReturnValue fence(FenceActionType action, FenceAgent agent) {
    // for status check, no retries on proxy-host selection.
    boolean withRetries = action != FenceActionType.Status;
    VDS proxyHost = new FenceProxyLocator(_vds, fencingPolicy).findProxyHost(withRetries);
    if (proxyHost == null) {
        return proxyNotFound();
    } else {
        return fence(action, agent, proxyHost);
    }
}
#end_block

#method_before
private VDSFenceReturnValue proxyNotFound() {
    VDSFenceReturnValue returnValue = new VDSFenceReturnValue();
    returnValue.setSucceeded(false);
    returnValue.setExceptionString("Failed to run Power Management command on Host " + _vds.getName() + " no running proxy Host was found");
    return returnValue;
}
#method_after
private VDSFenceReturnValue proxyNotFound() {
    VDSFenceReturnValue returnValue = new VDSFenceReturnValue();
    returnValue.setSucceeded(false);
    returnValue.setExceptionString("Failed to run Power Management command on Host " + getNameOrId(_vds) + " no running proxy Host was found");
    return returnValue;
}
#end_block

#method_before
private VDSReturnValue runFenceAction(FenceActionType action, FencingAgent agent, VDS proxyHost) {
    log.infoFormat("Executing <{0}> Power Management command, Proxy Host:{1}, " + "Agent:{2}, Target Host:{3}, Management IP:{4}, User:{5}, Options:{6}", action, proxyHost.getName(), VdsFenceOptions.getRealAgent(agent.getType()), _vds.getName(), agent.getIp(), agent.getUser(), agent.getOptions());
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FenceVds, new FenceVdsVDSCommandParameters(proxyHost.getId(), _vds.getId(), agent.getIp(), String.valueOf(agent.getPort()), VdsFenceOptions.getRealAgent(agent.getType()), agent.getUser(), agent.getPassword(), agent.getOptions(), action));
}
#method_after
private VDSReturnValue runFenceAction(FenceActionType action, FenceAgent agent, VDS proxyHost) {
    auditFenceAction(action, agent, proxyHost);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FenceVds, new FenceVdsVDSCommandParameters(proxyHost.getId(), _vds.getId(), agent.getIp(), String.valueOf(agent.getPort()), VdsFenceOptions.getRealAgent(agent.getType()), agent.getUser(), agent.getPassword(), getOptions(agent), action, fencingPolicy));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), ExecutionHandler.createInternalJobContext(getContext()));
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    getReturnValue().setSucceeded(shouldBeFenced);
}
#method_after
@Override
protected void executeCommand() {
    boolean skippedDueToFencingPolicy = false;
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), getContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getVdsGroupDao().get(getVds().getVdsGroupId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        if (fencingPolicy.isSkipFencingIfSDActive()) {
            // host storage lease should be renewed each ConfigValues.HostStorageLeaseAliveInterval
            // so we need to be sure not to execute fencing before host is non responsive for longer time
            long interval = TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.HostStorageLeaseAliveCheckingInterval));
            long difference = System.currentTimeMillis() - getParameters().getLastUpdate();
            if (difference < interval) {
                int sleepMs = (int) (interval - difference);
                log.info("Sleeping {} ms before proceeding with fence execution", sleepMs);
                ThreadUtils.sleep(sleepMs);
            }
        }
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (skippedDueToFencingPolicy) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogableBase alb = new AuditLogableBase(getVds().getId());
        alb.setRepeatable(true);
        AuditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#end_block

#method_before
@Override
protected void handleError() {
    // if fence failed on spm, move storage pool to non operational
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        log.infoFormat("Fence failed on vds {0} which is spm of pool {1} - moving pool to non operational", getVds().getName(), getVds().getStoragePoolId());
        runInternalAction(VdcActionType.SetStoragePoolStatus, new SetStoragePoolStatusParameters(getVds().getStoragePoolId(), StoragePoolStatus.NotOperational, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM));
    }
    log.errorFormat("Failed to run Fence script on vds:{0}.", getVdsName());
    AlertIfPowerManagementOperationSkipped(RESTART, null);
}
#method_after
@Override
protected void handleError() {
    // if fence failed on spm, move storage pool to non operational
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        log.info("Fence failed on vds '{}' which is spm of pool '{}' - moving pool to non operational", getVds().getName(), getVds().getStoragePoolId());
        runInternalAction(VdcActionType.SetStoragePoolStatus, new SetStoragePoolStatusParameters(getVds().getStoragePoolId(), StoragePoolStatus.NotOperational, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM));
    }
    log.error("Failed to run Fence script on vds '{}'.", getVdsName());
    alertIfPowerManagementOperationSkipped(RESTART, null);
}
#end_block

#method_before
@Test
public void canDoAction() {
    UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
    Guid vdsId = Guid.newGuid();
    VDS newVdsData = makeTestVds(vdsId);
    VDS oldVdsData = newVdsData.clone();
    oldVdsData.setVdsName("FOO");
    oldVdsData.setVdsGroupCompatibilityVersion(new Version("1.2.3"));
    parameters.setvds(newVdsData);
    @SuppressWarnings("unchecked")
    UpdateVdsCommand<UpdateVdsActionParameters> commandMock = Mockito.mock(UpdateVdsCommand.class);
    Mockito.when(commandMock.getVdsId()).thenReturn(vdsId);
    Mockito.when(commandMock.canDoAction()).thenCallRealMethod();
    Mockito.when(commandMock.getParameters()).thenReturn(parameters);
    Mockito.when(commandMock.isPowerManagementLegal(Mockito.any(VdsStatic.class), Mockito.any(String.class))).thenReturn(true);
    VdsDAO vdsDaoMock = Mockito.mock(VdsDAO.class);
    Mockito.when(vdsDaoMock.get(vdsId)).thenReturn(oldVdsData);
    Mockito.when(commandMock.getVdsDAO()).thenReturn(vdsDaoMock);
    VdsHandler.init();
    Assert.assertTrue(commandMock.canDoAction());
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void canDoAction() {
    UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
    Guid vdsId = Guid.newGuid();
    VDS newVdsData = makeTestVds(vdsId);
    VDS oldVdsData = newVdsData.clone();
    oldVdsData.setVdsName("FOO");
    oldVdsData.setVdsGroupCompatibilityVersion(new Version("1.2.3"));
    parameters.setvds(newVdsData);
    UpdateVdsCommand<UpdateVdsActionParameters> commandMock = Mockito.mock(UpdateVdsCommand.class);
    Mockito.when(commandMock.getVdsId()).thenReturn(vdsId);
    Mockito.when(commandMock.canDoAction()).thenCallRealMethod();
    Mockito.when(commandMock.getParameters()).thenReturn(parameters);
    Version version = new Version("1.2.3");
    VDSGroup vdsGroup = new VDSGroup();
    vdsGroup.setcompatibility_version(version);
    when(commandMock.getVdsGroup()).thenReturn(vdsGroup);
    when(commandMock.isPowerManagementLegal(parameters.getVdsStaticData().isPmEnabled(), parameters.getFenceAgents(), new Version("1.2.3").toString())).thenReturn(true);
    VdsDAO vdsDaoMock = Mockito.mock(VdsDAO.class);
    Mockito.when(vdsDaoMock.get(vdsId)).thenReturn(oldVdsData);
    Mockito.when(commandMock.getVdsDAO()).thenReturn(vdsDaoMock);
    VdsHandler.init();
    Assert.assertTrue(commandMock.canDoAction());
}
#end_block

#method_before
@Test
public void canDoActionSameName() {
    UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
    Guid vdsId = Guid.newGuid();
    VDS newVdsData = makeTestVds(vdsId);
    VDS oldVdsData = newVdsData.clone();
    oldVdsData.setVdsName("FOO");
    oldVdsData.setVdsGroupCompatibilityVersion(new Version("1.2.3"));
    parameters.setvds(newVdsData);
    @SuppressWarnings("unchecked")
    UpdateVdsCommand<UpdateVdsActionParameters> commandMock = Mockito.mock(UpdateVdsCommand.class);
    Mockito.when(commandMock.getVdsId()).thenReturn(vdsId);
    Mockito.when(commandMock.canDoAction()).thenCallRealMethod();
    Mockito.when(commandMock.getParameters()).thenReturn(parameters);
    Mockito.when(commandMock.isPowerManagementLegal(Mockito.any(VdsStatic.class), Mockito.any(String.class))).thenReturn(true);
    VdsDAO vdsDaoMock = Mockito.mock(VdsDAO.class);
    Mockito.when(vdsDaoMock.get(vdsId)).thenReturn(oldVdsData);
    // now return the old vds data
    Mockito.when(vdsDaoMock.getByName("BAR")).thenReturn(oldVdsData);
    Mockito.when(commandMock.getVdsDAO()).thenReturn(vdsDaoMock);
    VdsHandler.init();
    Assert.assertFalse(commandMock.canDoAction());
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void canDoActionSameName() {
    UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
    Guid vdsId = Guid.newGuid();
    VDS newVdsData = makeTestVds(vdsId);
    VDS oldVdsData = newVdsData.clone();
    oldVdsData.setVdsName("FOO");
    oldVdsData.setVdsGroupCompatibilityVersion(new Version("1.2.3"));
    parameters.setvds(newVdsData);
    UpdateVdsCommand<UpdateVdsActionParameters> commandMock = Mockito.mock(UpdateVdsCommand.class);
    Mockito.when(commandMock.getVdsId()).thenReturn(vdsId);
    Mockito.when(commandMock.canDoAction()).thenCallRealMethod();
    Mockito.when(commandMock.getParameters()).thenReturn(parameters);
    Version version = new Version("1.2.3");
    VDSGroup vdsGroup = new VDSGroup();
    vdsGroup.setcompatibility_version(version);
    when(commandMock.getVdsGroup()).thenReturn(vdsGroup);
    when(commandMock.isPowerManagementLegal(parameters.getVdsStaticData().isPmEnabled(), parameters.getFenceAgents(), new Version("1.2.3").toString())).thenReturn(true);
    VdsDAO vdsDaoMock = Mockito.mock(VdsDAO.class);
    Mockito.when(vdsDaoMock.get(vdsId)).thenReturn(oldVdsData);
    // now return the old vds data
    Mockito.when(vdsDaoMock.getByName("BAR")).thenReturn(oldVdsData);
    Mockito.when(commandMock.getVdsDAO()).thenReturn(vdsDaoMock);
    VdsHandler.init();
    Assert.assertFalse(commandMock.canDoAction());
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getVdsStaticDao();
    dynamicDao = dbFacade.getVdsDynamicDao();
    statisticsDao = dbFacade.getVdsStatisticsDao();
    existingVds = dao.get(FixturesTool.VDS_GLUSTER_SERVER2);
    newStaticVds = new VdsStatic();
    newStaticVds.setHostName("farkle.redhat.com");
    newStaticVds.setSshPort(22);
    newStaticVds.setSshUsername("root");
    newStaticVds.setVdsGroupId(existingVds.getVdsGroupId());
    newStaticVds.setSshKeyFingerprint("b5:ad:16:19:06:9f:b3:41:69:eb:1c:42:1d:12:b5:31");
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getVdsStaticDao();
    dynamicDao = dbFacade.getVdsDynamicDao();
    statisticsDao = dbFacade.getVdsStatisticsDao();
    existingVds = dao.get(FixturesTool.VDS_GLUSTER_SERVER2);
    newStaticVds = new VdsStatic();
    newStaticVds.setHostName("farkle.redhat.com");
    newStaticVds.setSshPort(22);
    newStaticVds.setSshUsername("root");
    newStaticVds.setVdsGroupId(existingVds.getVdsGroupId());
    newStaticVds.setSshKeyFingerprint("b5:ad:16:19:06:9f:b3:41:69:eb:1c:42:1d:12:b5:31");
    newStaticVds.setProtocol(VdsProtocol.STOMP);
}
#end_block

#method_before
private void updateOptionsNonLocalFSData() {
    AsyncDataProvider.getHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            clusterGuideModel.hosts = hosts;
            clusterGuideModel.updateOptionsNonLocalFS();
        }
    }), getEntity().getName());
    AsyncDataProvider.getHostList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            clusterGuideModel.allHosts = hosts;
            clusterGuideModel.updateOptionsNonLocalFS();
        }
    }));
    if (getEntity().supportsGlusterService()) {
        AsyncDataProvider.isAnyHostUpInCluster(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
                isAnyHostUpInCluster = (Boolean) returnValue;
                clusterGuideModel.updateOptionsNonLocalFS();
            }
        }), getEntity().getName());
    }
}
#method_after
private void updateOptionsNonLocalFSData() {
    AsyncDataProvider.getInstance().getHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            clusterGuideModel.hosts = hosts;
            clusterGuideModel.updateOptionsNonLocalFS();
        }
    }), getEntity().getName());
    AsyncDataProvider.getInstance().getHostList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            clusterGuideModel.allHosts = hosts;
            clusterGuideModel.updateOptionsNonLocalFS();
        }
    }));
    if (getEntity().supportsGlusterService()) {
        AsyncDataProvider.getInstance().isAnyHostUpInCluster(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
                isAnyHostUpInCluster = (Boolean) returnValue;
                clusterGuideModel.updateOptionsNonLocalFS();
            }
        }), getEntity().getName());
    }
}
#end_block

#method_before
private void updateOptionsLocalFSData() {
    AsyncDataProvider.getLocalStorageHost(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            VDS localStorageHost = (VDS) returnValue;
            clusterGuideModel.localStorageHost = localStorageHost;
            clusterGuideModel.updateOptionsLocalFS();
        }
    }), dataCenter.getName());
}
#method_after
private void updateOptionsLocalFSData() {
    AsyncDataProvider.getInstance().getLocalStorageHost(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            VDS localStorageHost = (VDS) returnValue;
            clusterGuideModel.localStorageHost = localStorageHost;
            clusterGuideModel.updateOptionsLocalFS();
        }
    }), dataCenter.getName());
}
#end_block

#method_before
private void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    if (getEntity() != null && getEntity().getStoragePoolId() != null) {
        startProgress(null);
        AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ClusterGuideModel model = (ClusterGuideModel) target;
                model.dataCenter = (StoragePool) returnValue;
                if (model.dataCenter == null || !model.dataCenter.isLocal()) {
                    model.updateOptionsNonLocalFSData();
                } else {
                    model.updateOptionsLocalFSData();
                }
            }
        }), getEntity().getStoragePoolId());
    }
}
#method_after
private void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    if (getEntity() != null && getEntity().getStoragePoolId() != null) {
        startProgress(null);
        AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ClusterGuideModel model = (ClusterGuideModel) target;
                model.dataCenter = (StoragePool) returnValue;
                if (model.dataCenter == null || !model.dataCenter.isLocal()) {
                    model.updateOptionsNonLocalFSData();
                } else {
                    model.updateOptionsLocalFSData();
                }
            }
        }), getEntity().getStoragePoolId());
    }
}
#end_block

#method_before
public void selectHost() {
    final ArrayList<VDSGroup> clusters = new ArrayList<VDSGroup>();
    clusters.add(getEntity());
    final MoveHost model = new MoveHost();
    model.setTitle(ConstantsManager.getInstance().getConstants().selectHostTitle());
    model.setHelpTag(HelpTag.select_host);
    // $NON-NLS-1$
    model.setHashName("select_host");
    // In case of local storage, only one host is allowed in the cluster so we should disable multi selection
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            dataCenter = (StoragePool) returnValue;
            boolean isMultiHostDC = dataCenter.isLocal();
            if (isMultiHostDC) {
                model.setMultiSelection(false);
            }
            setWindow(model);
            model.getCluster().setItems(clusters);
            model.getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
            model.getCluster().setIsAvailable(false);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnSelectHost", ClusterGuideModel.this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            model.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", ClusterGuideModel.this);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            model.getCommands().add(tempVar2);
        }
    }), getEntity().getStoragePoolId());
}
#method_after
public void selectHost() {
    final ArrayList<VDSGroup> clusters = new ArrayList<VDSGroup>();
    clusters.add(getEntity());
    final MoveHost model = new MoveHost();
    model.setTitle(ConstantsManager.getInstance().getConstants().selectHostTitle());
    model.setHelpTag(HelpTag.select_host);
    // $NON-NLS-1$
    model.setHashName("select_host");
    // In case of local storage, only one host is allowed in the cluster so we should disable multi selection
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            dataCenter = (StoragePool) returnValue;
            boolean isMultiHostDC = dataCenter.isLocal();
            if (isMultiHostDC) {
                model.setMultiSelection(false);
            }
            setWindow(model);
            model.getCluster().setItems(clusters);
            model.getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
            model.getCluster().setIsAvailable(false);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnSelectHost", ClusterGuideModel.this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            model.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", ClusterGuideModel.this);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            model.getCommands().add(tempVar2);
        }
    }), getEntity().getStoragePoolId());
}
#end_block

#method_before
public void addHost() {
    HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    model.setHashName("new_host");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getCluster().setSelectedItem(getEntity());
    model.getCluster().setIsChangable(false);
    AsyncDataProvider.getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            HostModel model = (HostModel) clusterGuideModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
            model.getDataCenter().setItems(dataCenters);
            if (getEntity().getStoragePoolId() != null) {
                model.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(clusterGuideModel.getEntity().getStoragePoolId())));
            }
            model.getDataCenter().setIsChangable(false);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnConfirmPMHost", clusterGuideModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            model.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", clusterGuideModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            model.getCommands().add(tempVar2);
        }
    }));
}
#method_after
public void addHost() {
    HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    model.setHashName("new_host");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getCluster().setSelectedItem(getEntity());
    model.getCluster().setIsChangable(false);
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            HostModel model = (HostModel) clusterGuideModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
            model.getDataCenter().setItems(dataCenters);
            if (getEntity().getStoragePoolId() != null) {
                model.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(clusterGuideModel.getEntity().getStoragePoolId())));
            }
            model.getDataCenter().setIsChangable(false);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnConfirmPMHost", clusterGuideModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            model.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", clusterGuideModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            model.getCommands().add(tempVar2);
        }
    }));
    ListModel<VDSGroup> clusterModel = model.getCluster();
    if (clusterModel.getSelectedItem() != null) {
        VDSGroup cluster = clusterModel.getSelectedItem();
        Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getcompatibility_version().toString());
        if (jsonSupported) {
            model.getProtocol().setEntity(true);
        } else {
            model.getProtocol().setEntity(false);
            model.getProtocol().setIsChangable(false);
        }
    }
}
#end_block

#method_before
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName(model.getName().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(model.getPort().getEntity());
    host.setSshPort(model.getAuthSshPort().getEntity());
    host.setSshUsername(model.getUserName().getEntity());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity());
    host.setVdsGroupId(model.getCluster().getSelectedItem().getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    AddVdsActionParameters vdsActionParams = new AddVdsActionParameters();
    vdsActionParams.setvds(host);
    vdsActionParams.setVdsId(host.getId());
    if (model.getUserPassword().getEntity() != null) {
        vdsActionParams.setPassword(model.getUserPassword().getEntity());
    }
    vdsActionParams.setAuthMethod(model.getAuthenticationMethod());
    vdsActionParams.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    vdsActionParams.setRebootAfterInstallation(model.getCluster().getSelectedItem().supportsVirtService());
    vdsActionParams.setFencingAgents(getFencingAgents(model));
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, vdsActionParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterGuideModel localModel = (ClusterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#method_after
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName(model.getName().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(model.getPort().getEntity());
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(model.getAuthSshPort().getEntity());
    host.setSshUsername(model.getUserName().getEntity());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity());
    host.setVdsGroupId(model.getCluster().getSelectedItem().getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    AddVdsActionParameters vdsActionParams = new AddVdsActionParameters();
    vdsActionParams.setvds(host);
    vdsActionParams.setVdsId(host.getId());
    if (model.getUserPassword().getEntity() != null) {
        vdsActionParams.setPassword(model.getUserPassword().getEntity());
    }
    vdsActionParams.setAuthMethod(model.getAuthenticationMethod());
    vdsActionParams.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    vdsActionParams.setRebootAfterInstallation(model.getCluster().getSelectedItem().supportsVirtService());
    vdsActionParams.setFenceAgents(getFenceAgents(model));
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, vdsActionParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterGuideModel localModel = (ClusterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
@Override
public List<StorageServerConnections> getAllForConnection(StorageServerConnections connection) {
    // actual value (empty string can't be used).
    return getCallsHandler().executeReadList("Getstorage_server_connectionsByKey", mapper, getCustomMapSqlParameterSource().addValue("iqn", connection.getiqn()).addValue("connection", connection.getconnection()).addValue("port", connection.getport()).addValue("portal", connection.getportal()).addValue("username", connection.getuser_name()).addValue("password", DbFacadeUtils.encryptPassword(connection.getpassword())));
}
#method_after
@Override
public List<StorageServerConnections> getAllForConnection(StorageServerConnections connection) {
    // actual value (empty string can't be used).
    return getCallsHandler().executeReadList("Getstorage_server_connectionsByKey", mapper, getCustomMapSqlParameterSource().addValue("iqn", connection.getiqn()).addValue("connection", connection.getconnection()).addValue("port", connection.getport()).addValue("portal", connection.getportal()).addValue("username", connection.getuser_name()));
}
#end_block

#method_before
public String getArchitectureName() {
    // $NON-NLS-1$
    return architectureName != null ? architectureName : "";
}
#method_after
public String getArchitectureName() {
    return architectureName;
}
#end_block

#method_before
public String getDomainName() {
    // $NON-NLS-1$
    return domainName != null ? domainName : "";
}
#method_after
public String getDomainName() {
    return domainName;
}
#end_block

#method_before
public String getOperatingsystemName() {
    // $NON-NLS-1$
    return operatingsystemName != null ? operatingsystemName : "";
}
#method_after
public String getOperatingsystemName() {
    return operatingsystemName;
}
#end_block

#method_before
public String getSubnetName() {
    // $NON-NLS-1$
    return subnetName != null ? subnetName : "";
}
#method_after
public String getSubnetName() {
    return subnetName;
}
#end_block

#method_before
@Override
public String getDescription() {
    return "OS: " + getOperatingsystemName() + "\n" + " | Subnet: " + getSubnetName() + "\n" + " | Domain: " + getDomainName() + "\n" + " | Arch: " + getArchitectureName();
}
#method_after
@Override
public String getDescription() {
    return "OS: " + (operatingsystemName != null ? operatingsystemName : "[N/A]") + "\n" + " | Subnet: " + (subnetName != null ? subnetName : "[N/A]") + "\n" + " | Domain: " + (domainName != null ? domainName : "[N/A]") + "\n" + " | Arch: " + (architectureName != null ? architectureName : "[N/A]");
}
#end_block

#method_before
public String getSubnetName() {
    // $NON-NLS-1$
    return subnetName != null ? subnetName : "";
}
#method_after
public String getSubnetName() {
    return subnetName;
}
#end_block

#method_before
public String getLastReport() {
    // $NON-NLS-1$
    return lastReport != null ? lastReport : "";
}
#method_after
public String getLastReport() {
    return lastReport;
}
#end_block

#method_before
public String getMac() {
    // $NON-NLS-1$
    return mac != null ? mac : "";
}
#method_after
public String getMac() {
    return mac;
}
#end_block

#method_before
public String getIp() {
    // $NON-NLS-1$
    return ip != null ? ip : "";
}
#method_after
public String getIp() {
    return ip;
}
#end_block

#method_before
@Override
public String getDescription() {
    return "MAC: " + getMac() + "\n" + " | DiscoverTime : " + getLastReport() + "\n" + " | Subnet: " + getSubnetName() + "\n" + " | IP: " + getIp();
}
#method_after
@Override
public String getDescription() {
    return "MAC: " + (mac != null ? mac : "[N/A]") + "\n" + " | DiscoverTime : " + (lastReport != null ? lastReport : "[N/A]") + "\n" + " | Subnet: " + (subnetName != null ? subnetName : "[N/A]") + "\n" + " | IP: " + (ip != null ? ip : "[N/A]");
}
#end_block

#method_before
public String getProvider() {
    // $NON-NLS-1$
    return provider != null ? provider : "";
}
#method_after
public String getProvider() {
    return provider;
}
#end_block

#method_before
public String getUser() {
    // $NON-NLS-1$
    return user != null ? user : "";
}
#method_after
public String getUser() {
    return user;
}
#end_block

#method_before
public String getUrl() {
    // $NON-NLS-1$
    return url != null ? url : "";
}
#method_after
public String getUrl() {
    return url;
}
#end_block

#method_before
@Override
public String getDescription() {
    return "URL: " + getUrl() + " | Provider: " + getProvider() + "\n" + " | User: " + getUser();
}
#method_after
@Override
public String getDescription() {
    return "URL: " + (url != null ? url : "[N/A]") + "\n" + " | Provider: " + (provider != null ? provider : "[N/A]") + "\n" + " | User: " + (user != null ? user : "[N/A]");
}
#end_block

#method_before
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setName(entity.getDomain());
        dom.setId(DirectoryEntryIdUtils.encode(dom.getName()));
    }
    model.setDomainEntryId(DirectoryEntryIdUtils.encode(entity.getExternalId()));
    model.setNamespace(entity.getNamespace());
    return model;
}
#method_after
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setName(entity.getDomain());
        dom.setId(DirectoryEntryIdUtils.encode(dom.getName()));
        model.setDomain(dom);
    }
    model.setDomainEntryId(DirectoryEntryIdUtils.encode(entity.getExternalId()));
    model.setNamespace(entity.getNamespace());
    return model;
}
#end_block

#method_before
public void setElementId(String elementId) {
    this.elementId = elementId;
}
#method_after
@Override
public void setElementId(String elementId) {
    this.elementId = elementId;
}
#end_block

#method_before
private boolean restoreInitialState() {
    Guid statelessVmSnapshotId = getVmSnapshotIdForType(SnapshotType.STATELESS);
    if (statelessVmSnapshotId == null) {
        return true;
    }
    List<DiskImage> statelessDiskSnapshots = getDiskSnapshotsForVmSnapshot(statelessVmSnapshotId);
    Guid activeVmSnapshotId = getVmSnapshotIdForType(SnapshotType.ACTIVE);
    List<DiskImage> activeDiskSnapshots = getDiskSnapshotsForVmSnapshot(activeVmSnapshotId);
    Set<Guid> disksWithStatelessSnapshot = new HashSet<>();
    for (DiskImage statelessDiskSnapshot : statelessDiskSnapshots) {
        disksWithStatelessSnapshot.add(statelessDiskSnapshot.getId());
    }
    for (DiskImage activeDiskSnapshot : activeDiskSnapshots) {
        if (!disksWithStatelessSnapshot.contains(activeDiskSnapshot.getId())) {
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.DetachDiskFromVm, new AttachDetachVmDiskParameters(getVmId(), activeDiskSnapshot.getId(), false, false));
            if (!returnValue.getSucceeded()) {
                return false;
            }
        }
    }
    if (!statelessDiskSnapshots.isEmpty()) {
        // restore all snapshots
        return runInternalActionWithTasksContext(VdcActionType.RestoreAllSnapshots, buildRestoreAllSnapshotsParameters(statelessDiskSnapshots), getLock()).getSucceeded();
    }
    return true;
}
#method_after
private boolean restoreInitialState() {
    Guid statelessVmSnapshotId = getVmSnapshotIdForType(SnapshotType.STATELESS);
    if (statelessVmSnapshotId == null) {
        return true;
    }
    List<DiskImage> statelessDiskSnapshots = getDiskSnapshotsForVmSnapshot(statelessVmSnapshotId);
    Guid activeVmSnapshotId = getVmSnapshotIdForType(SnapshotType.ACTIVE);
    List<DiskImage> activeDiskSnapshots = getDiskSnapshotsForVmSnapshot(activeVmSnapshotId);
    List<Guid> disksWithStatelessSnapshot = Entities.getIds(statelessDiskSnapshots);
    for (DiskImage activeDiskSnapshot : activeDiskSnapshots) {
        if (!disksWithStatelessSnapshot.contains(activeDiskSnapshot.getId())) {
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.DetachDiskFromVm, new AttachDetachVmDiskParameters(getVmId(), activeDiskSnapshot.getId(), false, false));
            if (!returnValue.getSucceeded()) {
                log.error("Could not restore stateless VM  {} due to a failure to detach Disk {}", getVmId(), activeDiskSnapshot.getId());
                return false;
            }
        }
    }
    if (!statelessDiskSnapshots.isEmpty()) {
        // restore all snapshots
        return runInternalActionWithTasksContext(VdcActionType.RestoreAllSnapshots, buildRestoreAllSnapshotsParameters(statelessDiskSnapshots), getLock()).getSucceeded();
    }
    return true;
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> execute() {
    Iterator<VdcActionParametersBase> iterator = getParameters() == null ? null : getParameters().iterator();
    if (iterator != null && iterator.hasNext()) {
        VdcActionParametersBase parameter = iterator.next();
        StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(((StorageDomainPoolParametersBase) parameter).getStoragePoolId());
        if (pool.getStatus() == StoragePoolStatus.Uninitialized) {
            ArrayList<Guid> storageDomainIds = new ArrayList<Guid>();
            for (VdcActionParametersBase param : getParameters()) {
                storageDomainIds.add(((StorageDomainPoolParametersBase) param).getStorageDomainId());
            }
            ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
            parameters.add(new StoragePoolWithStoragesParameter(pool, storageDomainIds, parameter.getSessionId()));
            if (isInternal) {
                return Backend.getInstance().runInternalMultipleActions(VdcActionType.AddStoragePoolWithStorages, parameters);
            } else {
                return Backend.getInstance().runMultipleActions(VdcActionType.AddStoragePoolWithStorages, parameters, false);
            }
        } else {
            return super.execute();
        }
    } else {
        return super.execute();
    }
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> execute() {
    Iterator<?> iterator = getParameters() == null ? null : getParameters().iterator();
    Object parameter = iterator != null && iterator.hasNext() ? iterator.next() : null;
    if (parameter instanceof StorageDomainPoolParametersBase) {
        StorageDomainPoolParametersBase storagePoolParameter = (StorageDomainPoolParametersBase) parameter;
        StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePoolParameter.getStoragePoolId());
        if (pool.getStatus() == StoragePoolStatus.Uninitialized) {
            ArrayList<Guid> storageDomainIds = new ArrayList<Guid>();
            for (VdcActionParametersBase param : getParameters()) {
                storageDomainIds.add(((StorageDomainPoolParametersBase) param).getStorageDomainId());
            }
            ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
            parameters.add(new StoragePoolWithStoragesParameter(pool, storageDomainIds, storagePoolParameter.getSessionId()));
            if (isInternal) {
                return Backend.getInstance().runInternalMultipleActions(VdcActionType.AddStoragePoolWithStorages, parameters);
            } else {
                return Backend.getInstance().runMultipleActions(VdcActionType.AddStoragePoolWithStorages, parameters, false);
            }
        } else {
            return super.execute();
        }
    } else {
        return super.execute();
    }
}
#end_block

#method_before
private RemoveVmFromPoolParameters getFirstParam() {
    Iterator<VdcActionParametersBase> iterator = getParameters() == null ? null : getParameters().iterator();
    if (iterator != null && iterator.hasNext()) {
        VdcActionParametersBase param = iterator.next();
        if (param instanceof RemoveVmFromPoolParameters) {
            return ((RemoveVmFromPoolParameters) param);
        }
    }
    return null;
}
#method_after
private RemoveVmFromPoolParameters getFirstParam() {
    Iterator<?> iterator = getParameters() == null ? null : getParameters().iterator();
    if (iterator != null && iterator.hasNext()) {
        Object param = iterator.next();
        if (param instanceof RemoveVmFromPoolParameters) {
            return ((RemoveVmFromPoolParameters) param);
        }
    }
    return null;
}
#end_block

#method_before
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        boolean useTags = syntax.isSearchUsingTags();
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax, useTags);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    ConditionData conditionData = generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe, useTags);
                    whereBuilder.addLast(conditionData.getConditionText());
                    if (conditionData.isFullTableRequired() && !useTags) {
                        useTags = true;
                        fromStatement = generateFromStatement(syntax, useTags);
                    }
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // for not deleted events, add this to the where clause
        if (searchObjStr.equalsIgnoreCase("EVENT")) {
            whereBuilder.add("not deleted");
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr, useTags);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        String inQuery = "";
        if (useTags) {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", mSearchObjectAC.getRelatedTableName(searchObjStr, false), primeryKey, getInnerQuery(tableName, primeryKey, fromStatement, wherePhrase));
        } else {
            inQuery = "(" + getInnerQuery(tableName, "*", fromStatement, wherePhrase);
        }
        if (syntax.getSearchFrom() > 0) {
            inQuery = StringFormat.format("%1$s and  %2$s >  %3$s", inQuery, primeryKey, syntax.getSearchFrom());
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#method_after
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        boolean useTags = syntax.isSearchUsingTags();
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax, useTags);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    ConditionData conditionData = generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe, useTags);
                    whereBuilder.addLast(conditionData.getConditionText());
                    if (conditionData.isFullTableRequired() && !useTags) {
                        useTags = true;
                        fromStatement = generateFromStatement(syntax, useTags);
                    }
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // for not deleted events, add this to the where clause
        if (searchObjStr.equalsIgnoreCase("EVENT")) {
            whereBuilder.add("not deleted");
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr, useTags);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        String inQuery = "";
        if (useTags) {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", mSearchObjectAC.getRelatedTableName(searchObjStr, false), primeryKey, getInnerQuery(tableName, primeryKey, fromStatement, wherePhrase));
        } else {
            inQuery = "(" + getInnerQuery(tableName, "*", fromStatement, wherePhrase);
        }
        if (syntax.getSearchFrom() > 0) {
            inQuery = StringFormat.format("%1$s and  %2$s >  %3$s", inQuery, primeryKey, syntax.getSearchFrom());
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: {}", retval);
    }
    return retval;
}
#end_block

#method_before
private PagingType getPagingType() {
    String val = Config.<String>getValue(ConfigValues.DBPagingType);
    PagingType type = null;
    try {
        type = PagingType.valueOf(val);
    } catch (Exception e) {
        log.error("Unknown paging type " + val);
    }
    return type;
}
#method_after
private PagingType getPagingType() {
    String val = Config.<String>getValue(ConfigValues.DBPagingType);
    PagingType type = null;
    try {
        type = PagingType.valueOf(val);
    } catch (Exception e) {
        log.error("Unknown paging type '{}'", val);
    }
    return type;
}
#end_block

#method_before
public void updateOptionsAsync(String search) {
    getItems().clear();
    SyntaxContainer syntax = getSyntaxChecker().getCompletion(search);
    int lastHandledIndex = syntax.getLastHandledIndex();
    String pf = search.substring(0, lastHandledIndex);
    String notHandled = search.substring(lastHandledIndex);
    String[] suggestedItems = syntax.getCompletionArray();
    // Ensure that filtered search objects will invalidate the whole search query
    if (getSearchObjectFilter() != null && syntax.getState() != SyntaxObjectType.BEGIN) {
        for (String value : getSearchObjectFilter()) {
            if (pf.toLowerCase().equals(value.toLowerCase()) || pf.toLowerCase().startsWith(value.toLowerCase() + ":") || containsWithItemsToIgnore(pf)) {
                // $NON-NLS-1$
                // $NON-NLS-1$
                addSuggestItem("", SuggestItemPartType.Valid, search, SuggestItemPartType.Erroneous);
                return;
            }
        }
    }
    if (syntax.getError() == SyntaxError.NO_ERROR) {
        List<String> actualItems = new ArrayList<String>(Arrays.asList(suggestedItems));
        // Filter search object suggestions
        if (getSearchObjectFilter() != null && syntax.getState() == SyntaxObjectType.BEGIN) {
            for (String value : getSearchObjectFilter()) {
                for (String item : suggestedItems) {
                    if (item.toLowerCase().equals(value.toLowerCase())) {
                        actualItems.remove(item);
                    }
                }
            }
            // Ensure that empty search suggestion list invalidates the search query
            if (actualItems.isEmpty()) {
                // $NON-NLS-1$
                addSuggestItem("", SuggestItemPartType.Valid, search, SuggestItemPartType.Erroneous);
                return;
            }
        }
        for (String item : actualItems) {
            // Apply filter
            if (getFilter() != null) {
                boolean skipItem = false;
                for (String value : getFilter()) {
                    if (ObjectUtils.objectsEqual(value.toLowerCase(), item.toLowerCase())) {
                        skipItem = true;
                        break;
                    }
                }
                if (skipItem) {
                    continue;
                }
            }
            // $NON-NLS-1$
            String space = "";
            if (// $NON-NLS-1$
            (pf.length() > 0) && (!pf.substring(pf.length() - 1, pf.length() - 1 + 1).equals(".")) && // $NON-NLS-1$
            (!".".equals(item))) {
                space = SPACE;
            }
            // Patch: monitor-desktop
            if (!inItemsToIgnore(item)) {
                addSuggestItem(StringHelper.trimEnd(pf), SuggestItemPartType.Valid, space + item.trim(), SuggestItemPartType.New);
            }
        }
    } else {
        addSuggestItem(pf, SuggestItemPartType.Valid, notHandled, SuggestItemPartType.Erroneous);
    }
}
#method_after
public void updateOptionsAsync(String search) {
    getItems().clear();
    SyntaxContainer syntax = getSyntaxChecker().getCompletion(search);
    int lastHandledIndex = syntax.getLastHandledIndex();
    String pf = search.substring(0, lastHandledIndex);
    String notHandled = search.substring(lastHandledIndex);
    String[] suggestedItems = syntax.getCompletionArray();
    // Ensure that filtered search objects will invalidate the whole search query
    if (getSearchObjectFilter() != null && syntax.getState() != SyntaxObjectType.BEGIN) {
        for (String value : getSearchObjectFilter()) {
            if (pf.toLowerCase().equals(value.toLowerCase()) || pf.toLowerCase().startsWith(value.toLowerCase() + ":") || containsWithItemsToIgnore(pf)) {
                // $NON-NLS-1$
                // $NON-NLS-1$
                addSuggestItem("", SuggestItemPartType.Valid, search, SuggestItemPartType.Erroneous);
                return;
            }
        }
    }
    if (syntax.getError() == SyntaxError.NO_ERROR) {
        List<String> actualItems = new ArrayList<String>(Arrays.asList(suggestedItems));
        // Filter search object suggestions
        if (getSearchObjectFilter() != null && syntax.getState() == SyntaxObjectType.BEGIN) {
            for (String value : getSearchObjectFilter()) {
                for (String item : suggestedItems) {
                    if (item.toLowerCase().equals(value.toLowerCase())) {
                        actualItems.remove(item);
                    }
                }
            }
            // Ensure that empty search suggestion list invalidates the search query
            if (actualItems.isEmpty()) {
                // $NON-NLS-1$
                addSuggestItem("", SuggestItemPartType.Valid, search, SuggestItemPartType.Erroneous);
                return;
            }
        }
        for (String item : actualItems) {
            // Apply filter
            if (getFilter() != null) {
                boolean skipItem = false;
                for (String value : getFilter()) {
                    if (ObjectUtils.objectsEqual(value.toLowerCase(), item.toLowerCase())) {
                        skipItem = true;
                        break;
                    }
                }
                if (skipItem) {
                    continue;
                }
            }
            // $NON-NLS-1$
            String space = "";
            if (// $NON-NLS-1$
            (pf.length() > 0) && (!pf.substring(pf.length() - 1, pf.length() - 1 + 1).equals(".")) && // $NON-NLS-1$
            (!".".equals(item))) {
                space = StringConstants.SPACE;
            }
            // Patch: monitor-desktop
            if (!inItemsToIgnore(item)) {
                addSuggestItem(StringHelper.trimEnd(pf), SuggestItemPartType.Valid, space + item.trim(), SuggestItemPartType.New);
            }
        }
    } else {
        addSuggestItem(pf, SuggestItemPartType.Valid, notHandled, SuggestItemPartType.Erroneous);
    }
}
#end_block

#method_before
private boolean containsWithItemsToIgnore(String pf) {
    for (String item : itemsToIgnore) {
        if (pf.toUpperCase().contains(SPACE + item.trim().toUpperCase())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean containsWithItemsToIgnore(String pf) {
    for (String item : itemsToIgnore) {
        if (pf.toUpperCase().contains(StringConstants.SPACE + item.trim().toUpperCase())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl(), ReportInit.getInstance().getSsoToken());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    profileList = new VnicProfileListModel();
    list.add(profileList);
    instanceTypeListModel = new InstanceTypeListModel();
    list.add(instanceTypeListModel);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    sharedMacPoolListModel = new SharedMacPoolListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#method_after
private void initItems() {
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#end_block

#method_before
private void tagListModel_SelectedItemsChanged(Object sender, EventArgs e) {
    boolean hadSelectedTags = getHasSelectedTags();
    updateHasSelectedTags();
    if (getHasSelectedTags()) {
        setAllListModelsUnavailable();
        hostList.setIsAvailable(true);
        vmList.setIsAvailable(true);
        userList.setIsAvailable(true);
    } else {
        updateAvailability(SystemTreeItemType.System, null);
    }
    // Switch the selected item as neccessary.
    ListModel oldSelectedItem = getSelectedItem();
    if (getHasSelectedTags() && oldSelectedItem != hostList && oldSelectedItem != volumeList && oldSelectedItem != vmList && oldSelectedItem != userList) {
        setSelectedItem(vmList);
    } else // Update search string only when selecting or de-selecting tags
    if (getHasSelectedTags() || hadSelectedTags) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        searchStringChanged();
    }
}
#method_after
private void tagListModel_SelectedItemsChanged(Object sender, EventArgs e) {
    boolean hadSelectedTags = getHasSelectedTags();
    updateHasSelectedTags();
    if (getHasSelectedTags()) {
        setAllListModelsUnavailable();
        getHostList().setIsAvailable(true);
        getVmList().setIsAvailable(true);
        getUserList().setIsAvailable(true);
    } else {
        updateAvailability(SystemTreeItemType.System, null);
    }
    // Switch the selected item as neccessary.
    ListModel oldSelectedItem = getSelectedItem();
    if (getHasSelectedTags() && oldSelectedItem != getHostList() && oldSelectedItem != getVolumeList() && oldSelectedItem != getVmList() && oldSelectedItem != getUserList()) {
        setSelectedItem(getVmList());
    } else if (getHasSelectedTags() || hadSelectedTags) {
        // Update search string only when selecting or de-selecting tags
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        searchStringChanged();
    }
}
#end_block

#method_before
private void systemTree_ItemChanged(Object sender, EventArgs args) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    updateHasSelectedTags();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    SystemTreeItemModel model = getSystemTree().getSelectedItem();
    if (model == null) {
        return;
    }
    updateAvailability(model.getType(), model.getEntity());
    // Select a default item depending on system tree selection.
    ListModel oldSelectedItem = getSelectedItem();
    boolean performSearch = false;
    // Do not Change Tab if the Selection is the Reports
    if (!reportsList.getIsAvailable() || (getSelectedItem() != reportsList && !reportsList.isReportsTabSelected())) {
        changeSelectedTabIfNeeded(model);
        performSearch = true;
    } else {
        reportsList.refreshReportModel();
    }
    // dont perform search if refreshing reports
    if (performSearch && getSelectedItem() == oldSelectedItem) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        if (getSelectedItem() instanceof ISupportSystemTreeContext) {
            ISupportSystemTreeContext treeContext = (ISupportSystemTreeContext) getSelectedItem();
            treeContext.setSystemTreeSelectedItem(getSystemTree().getSelectedItem());
        }
    }
}
#method_after
private void systemTree_ItemChanged(Object sender, EventArgs args) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    updateHasSelectedTags();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    SystemTreeItemModel model = getSystemTree().getSelectedItem();
    if (model == null) {
        return;
    }
    updateAvailability(model.getType(), model.getEntity());
    // Select a default item depending on system tree selection.
    ListModel oldSelectedItem = getSelectedItem();
    boolean performSearch = false;
    // Do not Change Tab if the Selection is the Reports
    if (!getReportsList().getIsAvailable() || (getSelectedItem() != getReportsList() && !getReportsList().isReportsTabSelected())) {
        changeSelectedTabIfNeeded(model);
        performSearch = true;
    } else {
        getReportsList().refreshReportModel();
    }
    // dont perform search if refreshing reports
    if (performSearch && getSelectedItem() == oldSelectedItem) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        if (getSelectedItem() instanceof ISupportSystemTreeContext) {
            ISupportSystemTreeContext treeContext = (ISupportSystemTreeContext) getSelectedItem();
            treeContext.setSystemTreeSelectedItem(getSystemTree().getSelectedItem());
        }
    }
}
#end_block

#method_before
public void updateReportsAvailability() {
    updateReportsAvailability(getSystemTree().getSelectedItem() == null ? SystemTreeItemType.System : getSystemTree().getSelectedItem().getType());
    dataCenterList.updateReportsAvailability();
    clusterList.updateReportsAvailability();
    hostList.updateReportsAvailability();
    storageList.updateReportsAvailability();
    vmList.updateReportsAvailability();
}
#method_after
public void updateReportsAvailability() {
    updateReportsAvailability(getSystemTree().getSelectedItem() == null ? SystemTreeItemType.System : getSystemTree().getSelectedItem().getType());
    getDataCenterList().updateReportsAvailability();
    getClusterList().updateReportsAvailability();
    getHostList().updateReportsAvailability();
    getStorageList().updateReportsAvailability();
    getVmList().updateReportsAvailability();
}
#end_block

#method_before
private void updateReportsAvailability(SystemTreeItemType type) {
    reportsList.setIsAvailable(ReportInit.getInstance().isReportsEnabled() && ReportInit.getInstance().getDashboard(type.toString()) != null);
}
#method_after
private void updateReportsAvailability(SystemTreeItemType type) {
    getReportsList().setIsAvailable(ReportInit.getInstance().isReportsEnabled() && ReportInit.getInstance().getDashboard(type.toString()) != null);
}
#end_block

#method_before
private void updateAvailability(SystemTreeItemType type, Object entity) {
    // Update items availability depending on system tree selection
    dataCenterList.setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Storage || type == SystemTreeItemType.System || type == SystemTreeItemType.DataCenters);
    clusterList.setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Clusters || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Storage || type == SystemTreeItemType.Network || type == SystemTreeItemType.System);
    hostList.setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Hosts || type == SystemTreeItemType.Host || type == SystemTreeItemType.Storage || type == SystemTreeItemType.Network || type == SystemTreeItemType.System);
    volumeList.setIsAvailable(type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Volume || type == SystemTreeItemType.Volumes || type == SystemTreeItemType.System);
    if (type == SystemTreeItemType.Cluster) {
        volumeList.setIsAvailable(false);
    }
    storageList.setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Host || type == SystemTreeItemType.Storages || type == SystemTreeItemType.Storage || type == SystemTreeItemType.System);
    quotaList.setIsAvailable(type == SystemTreeItemType.DataCenter);
    boolean isDataStorage = false;
    if (type == SystemTreeItemType.Storage && entity != null) {
        StorageDomain storage = (StorageDomain) entity;
        isDataStorage = storage.getStorageDomainType().isDataDomain();
    }
    diskList.setIsAvailable(type == SystemTreeItemType.DataCenter || isDataStorage || type == SystemTreeItemType.System);
    vmList.setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Host || type == SystemTreeItemType.Network || isDataStorage || type == SystemTreeItemType.VMs || type == SystemTreeItemType.System);
    poolList.setIsAvailable(type == SystemTreeItemType.System || type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster);
    templateList.setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Host || type == SystemTreeItemType.Network || isDataStorage || type == SystemTreeItemType.Templates || type == SystemTreeItemType.System);
    if (type == SystemTreeItemType.Cluster_Gluster && entity != null) {
        VDSGroup cluster = (VDSGroup) entity;
        if (!cluster.supportsVirtService()) {
            vmList.setIsAvailable(false);
            templateList.setIsAvailable(false);
            storageList.setIsAvailable(false);
            poolList.setIsAvailable(false);
        }
    }
    userList.setIsAvailable(type == SystemTreeItemType.System);
    eventList.setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Host || type == SystemTreeItemType.Storage || type == SystemTreeItemType.System || type == SystemTreeItemType.Volume);
    updateReportsAvailability(type);
    networkList.setIsAvailable(type == SystemTreeItemType.Network || type == SystemTreeItemType.Networks || type == SystemTreeItemType.System || type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Host);
    providerList.setIsAvailable(type == SystemTreeItemType.Providers || type == SystemTreeItemType.Provider);
    profileList.setIsAvailable(type == SystemTreeItemType.Network || type == SystemTreeItemType.DataCenter);
}
#method_after
private void updateAvailability(SystemTreeItemType type, Object entity) {
    // Update items availability depending on system tree selection
    getDataCenterList().setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Storage || type == SystemTreeItemType.System || type == SystemTreeItemType.DataCenters);
    getClusterList().setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Clusters || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Storage || type == SystemTreeItemType.Network || type == SystemTreeItemType.System);
    getHostList().setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Hosts || type == SystemTreeItemType.Host || type == SystemTreeItemType.Storage || type == SystemTreeItemType.Network || type == SystemTreeItemType.System);
    getVolumeList().setIsAvailable(type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Volume || type == SystemTreeItemType.Volumes || type == SystemTreeItemType.System);
    if (type == SystemTreeItemType.Cluster) {
        getVolumeList().setIsAvailable(false);
    }
    getStorageList().setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Host || type == SystemTreeItemType.Storages || type == SystemTreeItemType.Storage || type == SystemTreeItemType.System);
    getQuotaList().setIsAvailable(type == SystemTreeItemType.DataCenter);
    boolean isDataStorage = false;
    if (type == SystemTreeItemType.Storage && entity != null) {
        StorageDomain storage = (StorageDomain) entity;
        isDataStorage = storage.getStorageDomainType().isDataDomain();
    }
    getDiskList().setIsAvailable(type == SystemTreeItemType.DataCenter || isDataStorage || type == SystemTreeItemType.System);
    getVmList().setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Host || type == SystemTreeItemType.Network || isDataStorage || type == SystemTreeItemType.VMs || type == SystemTreeItemType.System);
    getPoolList().setIsAvailable(type == SystemTreeItemType.System || type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster);
    getTemplateList().setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Host || type == SystemTreeItemType.Network || isDataStorage || type == SystemTreeItemType.Templates || type == SystemTreeItemType.System);
    if (type == SystemTreeItemType.Cluster_Gluster && entity != null) {
        VDSGroup cluster = (VDSGroup) entity;
        if (!cluster.supportsVirtService()) {
            getVmList().setIsAvailable(false);
            getTemplateList().setIsAvailable(false);
            getStorageList().setIsAvailable(false);
            getPoolList().setIsAvailable(false);
        }
    }
    getUserList().setIsAvailable(type == SystemTreeItemType.System);
    getEventList().setIsAvailable(type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Cluster_Gluster || type == SystemTreeItemType.Host || type == SystemTreeItemType.Storage || type == SystemTreeItemType.System || type == SystemTreeItemType.Volume);
    updateReportsAvailability(type);
    getNetworkList().setIsAvailable(type == SystemTreeItemType.Network || type == SystemTreeItemType.Networks || type == SystemTreeItemType.System || type == SystemTreeItemType.DataCenter || type == SystemTreeItemType.Cluster || type == SystemTreeItemType.Host);
    getProviderList().setIsAvailable(type == SystemTreeItemType.Providers || type == SystemTreeItemType.Provider);
    getProfileList().setIsAvailable(type == SystemTreeItemType.Network || type == SystemTreeItemType.DataCenter);
}
#end_block

#method_before
private void changeSelectedTabIfNeeded(SystemTreeItemModel model) {
    if (getSelectedItem() != null && getSelectedItem().getIsAvailable()) {
        // Do not change tab if we can show it
        return;
    } else {
        switch(model.getType()) {
            case DataCenters:
            case DataCenter:
                setSelectedItem(dataCenterList);
                break;
            case Clusters:
            case Cluster:
            case Cluster_Gluster:
                setSelectedItem(clusterList);
                break;
            case Hosts:
            case Host:
                setSelectedItem(hostList);
                break;
            case Volumes:
            case Volume:
                setSelectedItem(volumeList);
                break;
            case Storages:
            case Storage:
                setSelectedItem(storageList);
                break;
            case Templates:
                setSelectedItem(templateList);
                break;
            case VMs:
                setSelectedItem(vmList);
                break;
            case Disk:
                setSelectedItem(diskList);
                break;
            case Networks:
            case Network:
                setSelectedItem(networkList);
                break;
            case Providers:
            case Provider:
                setSelectedItem(providerList);
                break;
            default:
                // webadmin: redirect to default tab in case no tab is selected.
                setSelectedItem(getDefaultItem());
        }
    }
}
#method_after
private void changeSelectedTabIfNeeded(SystemTreeItemModel model) {
    if (getSelectedItem() != null && getSelectedItem().getIsAvailable()) {
        // Do not change tab if we can show it
        return;
    } else {
        switch(model.getType()) {
            case DataCenters:
            case DataCenter:
                setSelectedItem(getDataCenterList());
                break;
            case Clusters:
            case Cluster:
            case Cluster_Gluster:
                setSelectedItem(getClusterList());
                break;
            case Hosts:
            case Host:
                setSelectedItem(getHostList());
                break;
            case Volumes:
            case Volume:
                setSelectedItem(getVolumeList());
                break;
            case Storages:
            case Storage:
                setSelectedItem(getStorageList());
                break;
            case Templates:
                setSelectedItem(getTemplateList());
                break;
            case VMs:
                setSelectedItem(getVmList());
                break;
            case Disk:
                setSelectedItem(getDiskList());
                break;
            case Networks:
            case Network:
                setSelectedItem(getNetworkList());
                break;
            case Providers:
            case Provider:
                setSelectedItem(getProviderList());
                break;
            default:
                // webadmin: redirect to default tab in case no tab is selected.
                setSelectedItem(getDefaultItem());
        }
    }
}
#end_block

#method_before
public void configure() {
    if (getWindow() != null) {
        return;
    }
    EntityModel model = new EntityModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().ConfigureTitle());
    model.setHelpTag(HelpTag.configure);
    // $NON-NLS-1$
    model.setHashName("configure");
    model.setEntity(new Model[] { roleListModel, systemPermissionListModel, clusterPolicyListModel, sharedMacPoolListModel });
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("Cancel", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
    tempVar.setIsDefault(true);
    tempVar.setIsCancel(true);
    model.getCommands().add(tempVar);
}
#method_after
public void configure() {
    if (getWindow() != null) {
        return;
    }
    EntityModel model = new EntityModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().ConfigureTitle());
    model.setHelpTag(HelpTag.configure);
    // $NON-NLS-1$
    model.setHashName("configure");
    model.setEntity(new Model[] { getRoleList(), getSystemPermissionList(), getClusterPolicyList(), getSharedMacPoolListModel() });
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("Cancel", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
    tempVar.setIsDefault(true);
    tempVar.setIsCancel(true);
    model.getCommands().add(tempVar);
}
#end_block

#method_before
private SearchableListModel getDefaultItem() {
    return vmList;
}
#method_after
private SearchableListModel getDefaultItem() {
    return getVmList();
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getSearchCommand()) {
        search();
    } else if (command == getConfigureCommand()) {
        configure();
    } else if (command == getClearSearchStringCommand()) {
        clearSearchString();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getSearchCommand()) {
        search();
    } else if (command == getConfigureCommand()) {
        configure();
    } else if (command == getClearSearchStringCommand()) {
        clearSearchString();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#end_block

#method_before
private void splitSearchString(String source, RefObject<String> prefix, RefObject<String> search) {
    ArrayList<TagModel> tags = (ArrayList<TagModel>) getTagList().getSelectedItems();
    SystemTreeItemModel model = getSystemTree().getSelectedItem();
    // $NON-NLS-1$
    prefix.argvalue = "";
    // Split for tags.
    if (tags != null && tags.size() > 0) {
        // $NON-NLS-1$
        Regex regex = new Regex("tag\\s*=\\s*(?:[\\w-]+)(?:\\sor\\s)?", RegexOptions.IgnoreCase);
        // $NON-NLS-1$
        String[] array = source.split("[:]", -1);
        String entityClause = array[0];
        String searchClause = array[1];
        StringBuilder tagsClause = new StringBuilder();
        for (TagModel tag : tags) {
            // $NON-NLS-1$
            tagsClause.append("tag=").append(tag.getName().getEntity());
            if (tag != tags.get(tags.size() - 1)) {
                // $NON-NLS-1$
                tagsClause.append(" or ");
            }
        }
        // $NON-NLS-1$
        prefix.argvalue = entityClause + ": " + tagsClause.toString();
        // $NON-NLS-1$
        search.argvalue = regex.replace(searchClause, "").trim();
    } else // Split for system tree.
    if (model != null && model.getType() != SystemTreeItemType.System) {
        // $NON-NLS-1$ //$NON-NLS-2$
        getAutoCompleteModel().setFilter(new String[] { "or", "and" });
        switch(model.getType()) {
            case DataCenters:
                if (dataCenterList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "DataCenter:";
                }
                break;
            case DataCenter:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: datacenter = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: datacenter = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_datacenter = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Disk: datacenter.name = " + model.getTitle() + " and disk_type = image";
                    } else if (quotaList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Quota: storagepoolname = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: datacenter = " + model.getTitle();
                    } else if (profileList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "VnicProfile: datacenter = " + model.getTitle();
                    }
                }
                break;
            case Clusters:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Cluster:
            case Cluster_Gluster:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + model.getTitle();
                    } else if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: cluster.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: cluster = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: cluster = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Cluster_network.cluster_name = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: cluster = " + model.getTitle();
                    }
                }
                break;
            case Hosts:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Host:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: host.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: Host = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: Hosts.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: host.name = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Host_network.host_name = " + model.getTitle();
                    }
                }
                break;
            case Volumes:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Volume:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Volume: name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: volume.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Events: volume.name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    }
                }
                break;
            case Storages:
                {
                    if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Storage:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: storage.name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: storage.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: storage.name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: storage.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Templates: storage.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_storage = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Disk: storages.name = " + model.getTitle();
                    }
                }
                break;
            case Templates:
                {
                    if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case VMs:
                {
                    if (vmList.isSearchStringMatch(source)) {
                        SystemTreeItemModel ancestor = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (ancestor == null) {
                            ancestor = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + ancestor.getTitle();
                    }
                }
                break;
            case Networks:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Network:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Network: name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Cluster: Cluster_network.network_name = " + model.getTitle() + " Datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Host : Nic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Vm : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Template : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (profileList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "VnicProfile : network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Providers:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider:";
                }
                break;
            case Provider:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider: name = " + model.getTitle();
                }
                break;
        }
        // $NON-NLS-1$
        prefix.argvalue = prefix.argvalue + " ";
        // $NON-NLS-1$
        search.argvalue = "";
    } else {
        search.argvalue = source;
        getAutoCompleteModel().setFilter(null);
    }
}
#method_after
private void splitSearchString(String source, RefObject<String> prefix, RefObject<String> search) {
    ArrayList<TagModel> tags = (ArrayList<TagModel>) getTagList().getSelectedItems();
    SystemTreeItemModel model = getSystemTree().getSelectedItem();
    // $NON-NLS-1$
    prefix.argvalue = "";
    // Split for tags.
    if (tags != null && tags.size() > 0) {
        // $NON-NLS-1$
        Regex regex = new Regex("tag\\s*=\\s*(?:[\\w-]+)(?:\\sor\\s)?", RegexOptions.IgnoreCase);
        // $NON-NLS-1$
        String[] array = source.split("[:]", -1);
        String entityClause = array[0];
        String searchClause = array[1];
        StringBuilder tagsClause = new StringBuilder();
        for (TagModel tag : tags) {
            // $NON-NLS-1$
            tagsClause.append("tag=").append(tag.getName().getEntity());
            if (tag != tags.get(tags.size() - 1)) {
                // $NON-NLS-1$
                tagsClause.append(" or ");
            }
        }
        // $NON-NLS-1$
        prefix.argvalue = entityClause + ": " + tagsClause.toString();
        // $NON-NLS-1$
        search.argvalue = regex.replace(searchClause, "").trim();
    } else if (model != null && model.getType() != SystemTreeItemType.System) {
        // Split for system tree.
        // $NON-NLS-1$ //$NON-NLS-2$
        getAutoCompleteModel().setFilter(new String[] { "or", "and" });
        switch(model.getType()) {
            case DataCenters:
                if (getDataCenterList().isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "DataCenter:";
                }
                break;
            case DataCenter:
                {
                    if (getDataCenterList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: name = " + model.getTitle();
                    } else if (getClusterList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + model.getTitle();
                    } else if (getHostList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: datacenter = " + model.getTitle();
                    } else if (getStorageList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + model.getTitle();
                    } else if (getVmList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: datacenter = " + model.getTitle();
                    } else if (getTemplateList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + model.getTitle();
                    } else if (getEventList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_datacenter = " + model.getTitle();
                    } else if (getDiskList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Disk: datacenter.name = " + model.getTitle() + " and disk_type = image";
                    } else if (getQuotaList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Quota: storagepoolname = " + model.getTitle();
                    } else if (getNetworkList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + model.getTitle();
                    } else if (getPoolList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: datacenter = " + model.getTitle();
                    } else if (getProfileList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "VnicProfile: datacenter = " + model.getTitle();
                    }
                }
                break;
            case Clusters:
                {
                    if (getClusterList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        "Cluster: datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Cluster:
            case Cluster_Gluster:
                {
                    if (getClusterList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: name = " + model.getTitle();
                    } else if (getHostList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + model.getTitle();
                    } else if (getVolumeList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + model.getTitle();
                    } else if (getStorageList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: cluster.name = " + model.getTitle();
                    } else if (getVmList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + model.getTitle();
                    } else if (getTemplateList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: cluster = " + model.getTitle();
                    } else if (getEventList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: cluster = " + model.getTitle();
                    } else if (getNetworkList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Cluster_network.cluster_name = " + model.getTitle();
                    } else if (getPoolList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: cluster = " + model.getTitle();
                    }
                }
                break;
            case Hosts:
                {
                    if (getHostList().isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Host:
                {
                    if (getHostList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: name = " + model.getTitle();
                    } else if (getStorageList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: host.name = " + model.getTitle();
                    } else if (getVmList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: Host = " + model.getTitle();
                    } else if (getTemplateList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: Hosts.name = " + model.getTitle();
                    } else if (getEventList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: host.name = " + model.getTitle();
                    } else if (getNetworkList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Host_network.host_name = " + model.getTitle();
                    }
                }
                break;
            case Volumes:
                {
                    if (getVolumeList().isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Volume:
                {
                    if (getVolumeList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$ //$NON-NLS-2$
                        "Volume: name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    } else if (getClusterList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: volume.name = " + model.getTitle();
                    } else if (getEventList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$ //$NON-NLS-2$
                        "Events: volume.name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    }
                }
                break;
            case Storages:
                {
                    if (getStorageList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        "Storage: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Storage:
                {
                    if (getDataCenterList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: storage.name = " + model.getTitle();
                    } else if (getClusterList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: storage.name = " + model.getTitle();
                    } else if (getHostList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: storage.name = " + model.getTitle();
                    } else if (getStorageList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: name = " + model.getTitle();
                    } else if (getVmList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: storage.name = " + model.getTitle();
                    } else if (getTemplateList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Templates: storage.name = " + model.getTitle();
                    } else if (getEventList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_storage = " + model.getTitle();
                    } else if (getDiskList().isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Disk: storages.name = " + model.getTitle();
                    }
                }
                break;
            case Templates:
                {
                    if (getTemplateList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        "Template: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case VMs:
                {
                    if (getVmList().isSearchStringMatch(source)) {
                        SystemTreeItemModel ancestor = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (ancestor == null) {
                            ancestor = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + ancestor.getTitle();
                    }
                }
                break;
            case Networks:
                {
                    if (getNetworkList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        "Network: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Network:
                {
                    if (getNetworkList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$ //$NON-NLS-2$
                        "Network: name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (getClusterList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$ //$NON-NLS-2$
                        "Cluster: Cluster_network.network_name = " + model.getTitle() + " Datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (getHostList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$ //$NON-NLS-2$
                        "Host : Nic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (getVmList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$ //$NON-NLS-2$
                        "Vm : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (getTemplateList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$ //$NON-NLS-2$
                        "Template : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (getProfileList().isSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$ //$NON-NLS-2$
                        "VnicProfile : network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Providers:
                if (getProviderList().isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider:";
                }
                break;
            case Provider:
                if (getProviderList().isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider: name = " + model.getTitle();
                }
                break;
        }
        // $NON-NLS-1$
        prefix.argvalue = prefix.argvalue + " ";
        // $NON-NLS-1$
        search.argvalue = "";
    } else {
        search.argvalue = source;
        getAutoCompleteModel().setFilter(null);
    }
}
#end_block

#method_before
public Event<EventArgs> getSignedOutEvent() {
    return privateSignedOutEvent;
}
#method_after
public Event getSignedOutEvent() {
    return privateSignedOutEvent;
}
#end_block

#method_before
private void setSignedOutEvent(Event<EventArgs> value) {
    privateSignedOutEvent = value;
}
#method_after
private void setSignedOutEvent(Event value) {
    privateSignedOutEvent = value;
}
#end_block

#method_before
public SearchableListModel getEventList() {
    return privateEventList;
}
#method_after
public EventListModel getEventList() {
    return eventListModel;
}
#end_block

#method_before
public StorageListModel getStorageList() {
    return storageList;
}
#method_after
public StorageListModel getStorageList() {
    return storageListModel;
}
#end_block

#method_before
public ClusterListModel getClusterList() {
    return clusterList;
}
#method_after
public ClusterListModel getClusterList() {
    return clusterListModel;
}
#end_block

#method_before
public BookmarkListModel getBookmarkList() {
    return privateBookmarkList;
}
#method_after
public BookmarkListModel getBookmarkList() {
    return bookmarkListModel;
}
#end_block

#method_before
public TagListModel getTagList() {
    return privateTagList;
}
#method_after
public TagListModel getTagList() {
    return tagListModel;
}
#end_block

#method_before
public SystemTreeModel getSystemTree() {
    return privateSystemTree;
}
#method_after
public SystemTreeModel getSystemTree() {
    return systemTreeModel;
}
#end_block

#method_before
public TaskListModel getTaskList() {
    return privateTaskList;
}
#method_after
public TaskListModel getTaskList() {
    return taskListModel;
}
#end_block

#method_before
public AlertListModel getAlertList() {
    return privateAlertList;
}
#method_after
public AlertListModel getAlertList() {
    return alertListModel;
}
#end_block

#method_before
public SearchSuggestModel getAutoCompleteModel() {
    return privateAutoCompleteModel;
}
#method_after
public SearchSuggestModel getAutoCompleteModel() {
    return searchSuggestModel;
}
#end_block

#method_before
public void setSearchString(String value) {
    if (value == null || (!value.toUpperCase().contains(SPACE + SyntaxChecker.SORTBY) && !value.toUpperCase().contains(SPACE + SyntaxChecker.PAGE))) {
        setSearchString(value, true);
    }
}
#method_after
public void setSearchString(String value) {
    if (value == null || !containsTokens(value, SyntaxObjectType.SORTBY, SyntaxObjectType.PAGE, SyntaxObjectType.SORT_DIRECTION)) {
        setSearchString(value, true);
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getValueObject(ServletUtils.getBaseContextPath(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getValueObject(StringUtils.join(UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()), // $NON-NLS-1$
    ",")));
    // Set attribute for userInfo object
    DbUser loggedInUser = getLoggedInUser(getEngineSessionId(request));
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
        request.setAttribute(MD5Attributes.ATTR_SSO_TOKEN.getKey(), getValueObject(request.getSession().getId()));
    }
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getValueObject(ServletUtils.getBaseContextPath(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getValueObject(StringUtils.join(UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()), // $NON-NLS-1$
    ",")));
    // Set attribute for userInfo object
    DbUser loggedInUser = getLoggedInUser(getEngineSessionId(request));
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
        String ssoToken = (String) request.getSession().getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        if (ssoToken != null) {
            request.setAttribute(MD5Attributes.ATTR_SSO_TOKEN.getKey(), getValueObject(ssoToken));
        }
    }
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#end_block

#method_before
protected MessageDigest getMd5Digest(final HttpServletRequest request) throws NoSuchAlgorithmException, UnsupportedEncodingException {
    MessageDigest digest = createMd5Digest();
    for (MD5Attributes attribute : MD5Attributes.values()) {
        if (request.getAttribute(attribute.getKey()) != null) {
            digest.update(request.getAttribute(attribute.getKey()).toString().getBytes(UTF8));
        }
    }
    return digest;
}
#method_after
protected MessageDigest getMd5Digest(final HttpServletRequest request) throws NoSuchAlgorithmException, UnsupportedEncodingException {
    MessageDigest digest = createMd5Digest();
    for (MD5Attributes attribute : MD5Attributes.values()) {
        if (request.getAttribute(attribute.getKey()) != null) {
            digest.update(request.getAttribute(attribute.getKey()).toString().getBytes(StandardCharsets.UTF_8));
        }
    }
    return digest;
}
#end_block

#method_before
private static Properties loadProperties(File localeFile) throws IOException {
    Properties properties = new Properties();
    Reader fr = null;
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(localeFile);
        fr = new InputStreamReader(fis, "UTF-8");
        properties.load(fr);
    } finally {
        if (fis != null) {
            fis.close();
        }
        if (fr != null) {
            fr.close();
        }
    }
    return properties;
}
#method_after
private static Properties loadProperties(File localeFile) throws IOException {
    Properties properties = new Properties();
    Reader fr = null;
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(localeFile);
        fr = new InputStreamReader(fis, StandardCharsets.UTF_8);
        properties.load(fr);
    } finally {
        if (fis != null) {
            fis.close();
        }
        if (fr != null) {
            fr.close();
        }
    }
    return properties;
}
#end_block

#method_before
@Before
public void setUpMockRequest() {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode mockPluginDef = mapper.createObjectNode();
    // $NON-NLS-1$ //$NON-NLS-2$
    mockPluginDef.put("foo", "bar");
    mockPluginDefinitionsArray = mapper.createArrayNode();
    mockPluginDefinitionsArray.add(mockPluginDef);
    when(mockApplicationModeObject.toString()).thenReturn(APPLICATION_MODE);
    when(mockRequest.getAttribute(WebAdminHostPageServlet.ATTR_APPLICATION_MODE)).thenReturn(mockApplicationModeObject);
    when(mockRequest.getAttribute(WebAdminHostPageServlet.ATTR_PLUGIN_DEFS)).thenReturn(mockPluginDefinitionsArray);
    when(mockRequest.getAttribute(WebAdminHostPageServlet.ATTR_ENGINE_SESSION_TIMEOUT)).thenReturn(mockEngineSessionTimeoutObject);
}
#method_after
@Before
public void setUpMockRequest() {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode mockPluginDef = mapper.createObjectNode();
    // $NON-NLS-1$ //$NON-NLS-2$
    mockPluginDef.put("foo", "bar");
    mockPluginDefinitionsArray = mapper.createArrayNode();
    mockPluginDefinitionsArray.add(mockPluginDef);
    when(mockApplicationModeObject.toString()).thenReturn(APPLICATION_MODE);
    when(mockRequest.getAttribute(WebAdminHostPageServlet.ATTR_APPLICATION_MODE)).thenReturn(mockApplicationModeObject);
    when(mockRequest.getAttribute(WebAdminHostPageServlet.ATTR_PLUGIN_DEFS)).thenReturn(mockPluginDefinitionsArray);
    when(mockRequest.getAttribute(WebAdminHostPageServlet.ATTR_ENGINE_SESSION_TIMEOUT)).thenReturn(mockEngineSessionTimeoutObject);
    when(mockRequest.getAttribute(WebAdminHostPageServlet.ATTR_ENGINE_REPORTS_BASE_URL)).thenReturn("");
}
#end_block

#method_before
@Override
protected void setUpTestServlet() throws NoSuchAlgorithmException {
    super.setUpTestServlet();
    // Avoid touching PluginDataManager via getPluginData method
    doReturn(new ArrayList<PluginData>()).when(testServlet).getPluginData();
}
#method_after
@Override
protected void setUpTestServlet() throws NoSuchAlgorithmException {
    super.setUpTestServlet();
    // Avoid touching PluginDataManager via getPluginData method
    doReturn(new ArrayList<PluginData>()).when(testServlet).getPluginData();
    testServlet.reportBaseUrl = "";
    testServlet.reportRedirectUrl = "";
    testServlet.reportRightClickRedirectUrl = "";
}
#end_block

#method_before
@Test
public void testGetMd5Digest_WithExtraObjects_WithoutUserInfoObject() throws NoSuchAlgorithmException, UnsupportedEncodingException {
    MessageDigest result = testServlet.getMd5Digest(mockRequest);
    assertEquals(result, mockDigest);
    verify(mockDigest, atLeast(3)).update(byteArrayCaptor.capture());
    assertArrayEquals(SELECTOR_SCRIPT.getBytes(GwtDynamicHostPageServlet.UTF8), byteArrayCaptor.getAllValues().get(0));
    assertArrayEquals(APPLICATION_MODE.getBytes(GwtDynamicHostPageServlet.UTF8), byteArrayCaptor.getAllValues().get(1));
    assertArrayEquals(mockPluginDefinitionsArray.toString().getBytes(GwtDynamicHostPageServlet.UTF8), byteArrayCaptor.getAllValues().get(2));
}
#method_after
@Test
public void testGetMd5Digest_WithExtraObjects_WithoutUserInfoObject() throws NoSuchAlgorithmException, UnsupportedEncodingException {
    MessageDigest result = testServlet.getMd5Digest(mockRequest);
    assertEquals(result, mockDigest);
    verify(mockDigest, atLeast(3)).update(byteArrayCaptor.capture());
    assertArrayEquals(SELECTOR_SCRIPT.getBytes(StandardCharsets.UTF_8), byteArrayCaptor.getAllValues().get(0));
    assertArrayEquals(APPLICATION_MODE.getBytes(StandardCharsets.UTF_8), byteArrayCaptor.getAllValues().get(1));
    assertArrayEquals(mockPluginDefinitionsArray.toString().getBytes(StandardCharsets.UTF_8), byteArrayCaptor.getAllValues().get(2));
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for applicationMode object
    Integer applicationMode = getApplicationMode(getEngineSessionId(request));
    request.setAttribute(ATTR_APPLICATION_MODE, getApplicationModeObject(applicationMode));
    // Set attribute for pluginDefinitions array
    List<PluginData> pluginData = getPluginData();
    request.setAttribute(ATTR_PLUGIN_DEFS, getPluginDefinitionsArray(pluginData));
    // Set attribute for engineSessionTimeout object
    Integer engineSessionTimeout = getEngineSessionTimeout(getEngineSessionId(request));
    request.setAttribute(ATTR_ENGINE_SESSION_TIMEOUT, getEngineSessionTimeoutObject(engineSessionTimeout));
    super.doGet(request, response);
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for applicationMode object
    Integer applicationMode = getApplicationMode(getEngineSessionId(request));
    request.setAttribute(ATTR_APPLICATION_MODE, getApplicationModeObject(applicationMode));
    // Set attribute for pluginDefinitions array
    List<PluginData> pluginData = getPluginData();
    request.setAttribute(ATTR_PLUGIN_DEFS, getPluginDefinitionsArray(pluginData));
    // Set attribute for engineSessionTimeout object
    Integer engineSessionTimeout = getEngineSessionTimeout(getEngineSessionId(request));
    request.setAttribute(ATTR_ENGINE_SESSION_TIMEOUT, getEngineSessionTimeoutObject(engineSessionTimeout));
    // Set attribute for engineReportsUrl object
    request.setAttribute(ATTR_ENGINE_REPORTS_BASE_URL, getReportInit(reportRedirectUrl.substring(reportBaseUrl.length()), reportRightClickRedirectUrl.substring(reportBaseUrl.length())));
    super.doGet(request, response);
}
#end_block

#method_before
@Override
protected MessageDigest getMd5Digest(HttpServletRequest request) throws NoSuchAlgorithmException, UnsupportedEncodingException {
    MessageDigest digest = super.getMd5Digest(request);
    // Update based on applicationMode object
    digest.update(request.getAttribute(ATTR_APPLICATION_MODE).toString().getBytes(UTF8));
    // Update based on pluginDefinitions array
    digest.update(request.getAttribute(ATTR_PLUGIN_DEFS).toString().getBytes(UTF8));
    // Update based on engineSessionTimeout object
    digest.update(request.getAttribute(ATTR_ENGINE_SESSION_TIMEOUT).toString().getBytes(UTF8));
    return digest;
}
#method_after
@Override
protected MessageDigest getMd5Digest(HttpServletRequest request) throws NoSuchAlgorithmException, UnsupportedEncodingException {
    MessageDigest digest = super.getMd5Digest(request);
    // Update based on applicationMode object
    digest.update(request.getAttribute(ATTR_APPLICATION_MODE).toString().getBytes(StandardCharsets.UTF_8));
    // Update based on pluginDefinitions array
    digest.update(request.getAttribute(ATTR_PLUGIN_DEFS).toString().getBytes(StandardCharsets.UTF_8));
    // Update based on engineSessionTimeout object
    digest.update(request.getAttribute(ATTR_ENGINE_SESSION_TIMEOUT).toString().getBytes(StandardCharsets.UTF_8));
    // Update based on report URL parameters.
    digest.update(request.getAttribute(ATTR_ENGINE_REPORTS_BASE_URL).toString().getBytes());
    return digest;
}
#end_block

#method_before
@Override
public void setSubTabPanelVisible(boolean subTabPanelVisible) {
    if (this.subTabPanelVisible != subTabPanelVisible) {
        splitPanel.clear();
        if (subTabPanelVisible) {
            splitPanel.addSouth(subTabPanelContainer, getSubTabHeight());
            splitPanel.add(mainTabPanelContainer);
        } else {
            splitPanel.add(mainTabPanelContainer);
        }
        this.subTabPanelVisible = subTabPanelVisible;
    }
}
#method_after
@Override
public void setSubTabPanelVisible(boolean subTabPanelVisible) {
    if (this.subTabPanelVisible != subTabPanelVisible) {
        splitPanel.clear();
        if (subTabPanelVisible) {
            splitPanel.addSouth(subTabPanelContainer, SubTabHelper.getSubTabHeight(clientStorage, splitPanel));
            splitPanel.add(mainTabPanelContainer);
        } else {
            splitPanel.add(mainTabPanelContainer);
        }
        this.subTabPanelVisible = subTabPanelVisible;
    }
}
#end_block

#method_before
private void validateNetworkQos() {
    Set<String> someSubInterfacesHaveQos = new HashSet<>();
    Set<String> notAllSubInterfacesHaveQos = new HashSet<>();
    Map<String, Float> relativeCommitmentByBaseInterface = new HashMap<>();
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        if (networkName == null) {
            continue;
        }
        Network network = existingClusterNetworks.get(networkName);
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        if (NetworkUtils.qosConfiguredOnInterface(iface, network)) {
            someSubInterfacesHaveQos.add(baseIfaceName);
            HostNetworkQos qos = iface.isQosOverridden() ? iface.getQos() : getDbFacade().getHostNetworkQosDao().get(network.getQosId());
            Float baseInterfaceCommitment = relativeCommitmentByBaseInterface.get(baseIfaceName);
            if (baseInterfaceCommitment == null) {
                baseInterfaceCommitment = new Float(0);
            }
            Integer subInterfaceCommitment = qos.getOutAverageRealtime();
            if (subInterfaceCommitment != null) {
                baseInterfaceCommitment += (float) subInterfaceCommitment / computeInterfaceSpeed(baseIfaceName);
            }
            relativeCommitmentByBaseInterface.put(baseIfaceName, baseInterfaceCommitment);
            if (iface.isQosOverridden()) {
                if (!hostNetworkQosSupported) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName);
                }
                HostNetworkQosValidator qosValidator = new HostNetworkQosValidator(iface.getQos());
                if (qosValidator.requiredValuesPresent() != ValidationResult.VALID) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES, networkName);
                }
                if (qosValidator.valuesConsistent() != ValidationResult.VALID) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_INCONSISTENT_VALUES, networkName);
                }
            }
        } else {
            notAllSubInterfacesHaveQos.add(baseIfaceName);
        }
    }
    for (String ifaceName : someSubInterfacesHaveQos) {
        if (notAllSubInterfacesHaveQos.contains(ifaceName)) {
            addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INTERFACES_WITHOUT_QOS, ifaceName);
        }
    }
    for (Map.Entry<String, Float> entry : relativeCommitmentByBaseInterface.entrySet()) {
        if (entry.getValue() > QOS_OVERCOMMITMENT_THRESHOLD) {
            addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_OVERCOMMITMENT, entry.getKey());
        }
    }
}
#method_after
private void validateNetworkQos() {
    validateQosOverriddenInterfaces();
    validateQosNotPartiallyConfigured();
    validateQosCommitment();
}
#end_block

#method_before
private int computeInterfaceSpeed(String ifaceName) {
    VdsNetworkInterface iface = ifaceByNames.get(ifaceName);
    Iterable<VdsNetworkInterface> slaves = bonds.get(ifaceName);
    if (slaves == null) {
        // this is a simple interface
        return iface.getSpeed();
    } else {
        // this is a bond, check if speed is already cached
        Integer speed = bondSpeeds.get(ifaceName);
        if (speed != null) {
            return speed;
        }
        // not cached, compute and cache for future reference
        boolean chooseMinimum = isBondModeFailover(iface.getBondType());
        speed = chooseMinimum ? Integer.MAX_VALUE : 0;
        for (VdsNetworkInterface slave : slaves) {
            speed = chooseMinimum ? Math.min(speed, slave.getSpeed()) : speed + slave.getSpeed();
        }
        bondSpeeds.put(ifaceName, speed);
        return speed;
    }
}
#method_after
private Integer computeInterfaceSpeed(String ifaceName) {
    VdsNetworkInterface iface = ifaceByNames.get(ifaceName);
    if (ifaceSpeeds.containsKey(ifaceName)) {
        return ifaceSpeeds.get(ifaceName);
    } else {
        Integer speed = null;
        if (iface.hasSpeed()) {
            // vdsm reported some speed for this interface, use it
            speed = iface.getSpeed();
        } else {
            // vdsm didn't report any speed - if this is a new bond, calculate its speed
            Iterable<VdsNetworkInterface> slaves = bonds.get(ifaceName);
            if (slaves != null) {
                boolean chooseMinimum = isBondModeFailover(iface.getBondOptions());
                speed = chooseMinimum ? Integer.MAX_VALUE : 0;
                for (VdsNetworkInterface slave : slaves) {
                    if (!slave.hasSpeed()) {
                        speed = null;
                        break;
                    }
                    speed = chooseMinimum ? Math.min(speed, slave.getSpeed()) : speed + slave.getSpeed();
                }
            }
        }
        // cache the speed for future reference
        ifaceSpeeds.put(ifaceName, speed);
        return speed;
    }
}
#end_block

#method_before
private boolean isBondModeFailover(Integer bondMode) {
    return bondMode == 1 || bondMode == 3;
}
#method_after
private boolean isBondModeFailover(String bondOptions) {
    Matcher matcher = BOND_OPTS_MODE_CAPTURE.matcher(bondOptions);
    matcher.find();
    int bondMode = Integer.parseInt(matcher.group(1));
    return bondMode == 1 || bondMode == 3;
}
#end_block

#method_before
@Test
public void qosValuesModified() {
    Network network = createNetwork(MANAGEMENT_NETWORK_NAME);
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    iface.setQosOverridden(true);
    mockExistingIfaces(iface);
    iface.setQos(createQos());
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface), Version.v3_4);
    validateAndAssertNetworkModified(helper, network);
}
#method_after
@Test
public void qosValuesModified() {
    Network network = createNetwork(MANAGEMENT_NETWORK_NAME);
    SetupNetworksHelper helper = qosValuesTest(network, createQos());
    validateAndAssertNetworkModified(helper, network);
}
#end_block

#method_before
private SetupNetworksHelper setupCompositeQosConfiguration(String nicName, HostNetworkQos qos) {
    return setupCompositeQosConfiguration(nicName, true, qos);
}
#method_after
private SetupNetworksHelper setupCompositeQosConfiguration(boolean constructBond, boolean qosOnAll, HostNetworkQos qos, Integer slaveSpeed, Integer masterSpeed, String bondOptions) {
    Network net1 = createNetwork("net1");
    net1.setVlanId(100);
    Network net2 = createNetwork("net2");
    net2.setVlanId(200);
    Network net3 = createNetwork("net3");
    net3.setVmNetwork(false);
    VdsNetworkInterface master = createNic(BOND_NAME, net3.getName());
    master.setSpeed(masterSpeed);
    VdsNetworkInterface vlan1 = createVlan(master.getName(), net1.getVlanId(), net1.getName());
    VdsNetworkInterface vlan2 = createVlan(master.getName(), net2.getVlanId(), net2.getName());
    vlan1.setQosOverridden(true);
    vlan1.setQos(qos);
    Guid qosId = Guid.newGuid();
    when(qosDao.get(qosId)).thenReturn(qos);
    net2.setQosId(qosId);
    net3.setQosId(qosOnAll ? qosId : null);
    mockExistingNetworks(net1, net2, net3);
    if (constructBond) {
        master.setBonded(true);
        VdsNetworkInterface slave1 = createNic("nic1", null);
        VdsNetworkInterface slave2 = createNic("nic2", null);
        slave2.setSpeed(slaveSpeed);
        master.setBondOptions(bondOptions);
        mockExistingIfaces(master, slave1, slave2);
        slave1.setBondName(master.getName());
        slave2.setBondName(master.getName());
        return createHelper(createParametersForNics(master, slave1, slave2, vlan1, vlan2), Version.v3_4);
    } else {
        mockExistingIfaces(master);
        return createHelper(createParametersForNics(master, vlan1, vlan2), Version.v3_4);
    }
}
#end_block

#method_before
private SetupNetworksHelper setupCompositeQosConfiguration(boolean qosOnAll) {
    return setupCompositeQosConfiguration("nic0", qosOnAll);
}
#method_after
private SetupNetworksHelper setupCompositeQosConfiguration(boolean qosOnAll) {
    return setupCompositeQosConfiguration(qosOnAll, createQos(), null, DEFAULT_SPEED, BOND_MODE_4);
}
#end_block

#method_before
@Test
public void qosNotConfiguredOnAllNetworks() {
    String nicName = "nic0";
    SetupNetworksHelper helper = setupCompositeQosConfiguration(nicName, false);
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INTERFACES_WITHOUT_QOS, nicName);
}
#method_after
@Test
public void qosNotConfiguredOnAllNetworks() {
    SetupNetworksHelper helper = setupCompositeQosConfiguration(false);
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INTERFACES_WITHOUT_QOS, BOND_NAME);
}
#end_block

#method_before
private SetupNetworksHelper qosCommitmentSetup(int totalCommitment) {
    return qosCommitmentSetup("nic0", totalCommitment);
}
#method_after
private SetupNetworksHelper qosCommitmentSetup(boolean constructBond, int totalCommitment, Integer slaveSpeed, Integer masterSpeed, String bondOptions) {
    HostNetworkQos qos = new HostNetworkQos();
    qos.setOutAverageLinkshare(10);
    qos.setOutAverageRealtime(totalCommitment / 3);
    return constructBond ? setupCompositeQosConfiguration(true, qos, slaveSpeed, masterSpeed, bondOptions) : setupCompositeQosConfiguration(false, true, qos, masterSpeed);
}
#end_block

#method_before
private boolean hostEmulationModeMatchesTheConfigValues(VDS vds) {
    // match this host against the config flags by order
    String matchedEmulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, vds.getVdsGroupCompatibilityVersion().getValue()), vds.getSupportedEmulatedMachines().split(","));
    if (matchedEmulatedMachine != null && !matchedEmulatedMachine.isEmpty() && vds.getStatus() != VDSStatus.NonOperational) {
        setClusterEmulatedMachine(vds, matchedEmulatedMachine);
        return true;
    }
    return false;
}
#method_after
private boolean hostEmulationModeMatchesTheConfigValues(VDS vds) {
    // match this host against the config flags by order
    String matchedEmulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, vds.getVdsGroupCompatibilityVersion().getValue()), vds.getSupportedEmulatedMachines().split(","));
    boolean isValidStatus = (vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.Maintenance);
    if (matchedEmulatedMachine != null && !matchedEmulatedMachine.isEmpty() && isValidStatus) {
        setClusterEmulatedMachine(vds, matchedEmulatedMachine);
        return true;
    }
    return false;
}
#end_block

#method_before
public void runQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback, final boolean isPublic) {
    initQueryParamsFilter(parameters);
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation = new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryType, parameters, isPublic, false, new VdcOperationCallback<VdcOperation<VdcQueryType, VdcQueryParametersBase>, VdcQueryReturnValue>() {

        @Override
        public void onSuccess(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final VdcQueryReturnValue result) {
            try {
                if (!result.getSucceeded()) {
                    logger.log(Level.WARNING, // $NON-NLS-1$
                    "Failure while invoking runQuery [" + result.getExceptionString() + // $NON-NLS-1$
                    "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                        failedResult.add(result);
                        // getEventsHandler().runQueryFailed(failedResult);
                        String errorMessage = result.getExceptionString();
                        handleNotLoggedInEvent(errorMessage);
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().onSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                }
            } finally {
                AsyncOperationCompleteEvent.fire(Frontend.this, callback.getModel());
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.getDel().onSuccess(callback.getModel(), null);
                }
            } finally {
                AsyncOperationCompleteEvent.fire(Frontend.this, callback.getModel());
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }
    });
    // raise the query started event.
    raiseQueryStartedEvent(queryType, callback.getContext());
    AsyncOperationStartedEvent.fire(Frontend.this, callback.getModel());
    if (isPublic) {
        getOperationManager().addPublicOperation(operation);
    } else {
        getOperationManager().addOperation(operation);
    }
}
#method_after
public void runQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback, final boolean isPublic) {
    initQueryParamsFilter(parameters);
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation = new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryType, parameters, isPublic, false, new VdcOperationCallback<VdcOperation<VdcQueryType, VdcQueryParametersBase>, VdcQueryReturnValue>() {

        @Override
        public void onSuccess(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final VdcQueryReturnValue result) {
            try {
                if (!result.getSucceeded()) {
                    logger.log(Level.WARNING, // $NON-NLS-1$
                    "Failure while invoking runQuery [" + result.getExceptionString() + // $NON-NLS-1$
                    "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                        failedResult.add(result);
                        // getEventsHandler().runQueryFailed(failedResult);
                        String errorMessage = result.getExceptionString();
                        handleNotLoggedInEvent(errorMessage);
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().onSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                }
            } finally {
                fireAsyncOperationCompleteEvent(callback.getModel());
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.getDel().onSuccess(callback.getModel(), null);
                }
            } finally {
                fireAsyncOperationCompleteEvent(callback.getModel());
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }
    });
    // raise the query started event.
    raiseQueryStartedEvent(queryType, callback.getContext());
    fireAsyncOperationStartedEvent(callback.getModel());
    if (isPublic) {
        getOperationManager().addPublicOperation(operation);
    } else {
        getOperationManager().addOperation(operation);
    }
}
#end_block

#method_before
public void runMultipleQueries(final List<VdcQueryType> queryTypeList, final List<VdcQueryParametersBase> queryParamsList, final IFrontendMultipleQueryAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final List<VdcQueryReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from runMultipleQueries!");
            FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, resultObject);
            callback.executed(f);
            AsyncOperationCompleteEvent.fire(Frontend.this, state);
            raiseQueryCompleteEvent(queryTypeList, state);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runMultipleQueries: " + caught, caught);
                FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, null);
                failureEventHandler(caught);
                callback.executed(f);
            } finally {
                AsyncOperationCompleteEvent.fire(Frontend.this, state);
                raiseQueryCompleteEvent(queryTypeList, state);
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (int i = 0; i < queryTypeList.size(); i++) {
        VdcQueryParametersBase parameters = queryParamsList.get(i);
        // Why do we do this?
        parameters.setRefresh(false);
        initQueryParamsFilter(parameters);
        operationList.add(new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryTypeList.get(i), parameters, true, multiCallback));
    }
    AsyncOperationStartedEvent.fire(Frontend.this, state);
    raiseQueryStartedEvent(queryTypeList, state);
    getOperationManager().addOperationList(operationList);
}
#method_after
public void runMultipleQueries(final List<VdcQueryType> queryTypeList, final List<VdcQueryParametersBase> queryParamsList, final IFrontendMultipleQueryAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final List<VdcQueryReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from runMultipleQueries!");
            FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, resultObject);
            callback.executed(f);
            fireAsyncOperationCompleteEvent(state);
            raiseQueryCompleteEvent(queryTypeList, state);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runMultipleQueries: " + caught, caught);
                FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, null);
                failureEventHandler(caught);
                callback.executed(f);
            } finally {
                fireAsyncOperationCompleteEvent(state);
                raiseQueryCompleteEvent(queryTypeList, state);
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (int i = 0; i < queryTypeList.size(); i++) {
        VdcQueryParametersBase parameters = queryParamsList.get(i);
        // Why do we do this?
        parameters.setRefresh(false);
        initQueryParamsFilter(parameters);
        operationList.add(new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryTypeList.get(i), parameters, true, multiCallback));
    }
    raiseQueryStartedEvent(queryTypeList, state);
    fireAsyncOperationStartedEvent(state);
    getOperationManager().addOperationList(operationList);
}
#end_block

#method_before
public void runAction(final VdcActionType actionType, final VdcActionParametersBase parameters, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameters, new VdcOperationCallback<VdcOperation<VdcActionType, VdcActionParametersBase>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Frontend: sucessfully executed runAction, determining result!");
            handleActionResult(actionType, parameters, result, callback != null ? callback : NULLABLE_ASYNC_CALLBACK, state, showErrorDialog);
            AsyncOperationCompleteEvent.fire(Frontend.this, state);
            RefreshActiveModelEvent.fire(Frontend.this, true);
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runAction: " + caught, caught);
            failureEventHandler(caught);
            FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, null, state);
            if (callback != null) {
                callback.executed(f);
            }
            AsyncOperationCompleteEvent.fire(Frontend.this, state);
        }
    });
    AsyncOperationStartedEvent.fire(Frontend.this, state);
    getOperationManager().addOperation(operation);
}
#method_after
public void runAction(final VdcActionType actionType, final VdcActionParametersBase parameters, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameters, new VdcOperationCallback<VdcOperation<VdcActionType, VdcActionParametersBase>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Frontend: sucessfully executed runAction, determining result!");
            handleActionResult(actionType, parameters, result, callback != null ? callback : NULLABLE_ASYNC_CALLBACK, state, showErrorDialog);
            fireAsyncOperationCompleteEvent(state);
            RefreshActiveModelEvent.fire(Frontend.this, true);
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runAction: " + caught, caught);
            failureEventHandler(caught);
            FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, null, state);
            if (callback != null) {
                callback.executed(f);
            }
            fireAsyncOperationCompleteEvent(state);
        }
    });
    fireAsyncOperationStartedEvent(state);
    getOperationManager().addOperation(operation);
}
#end_block

#method_before
public void runMultipleAction(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final boolean isRunOnlyIfAllCanDoPass, final IFrontendMultipleActionAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operationList, final List<VdcReturnValueBase> resultObject) {
            // $NON-NLS-1$
            logger.finer("Frontend: successfully executed runMultipleAction, determining result!");
            ArrayList<VdcReturnValueBase> failed = new ArrayList<VdcReturnValueBase>();
            for (VdcReturnValueBase v : resultObject) {
                if (!v.getCanDoAction()) {
                    failed.add(v);
                }
            }
            if (!failed.isEmpty()) {
                translateErrors(failed);
                getEventsHandler().runMultipleActionFailed(actionType, failed);
            }
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, resultObject, state));
            }
            AsyncOperationCompleteEvent.fire(Frontend.this, state);
            RefreshActiveModelEvent.fire(Frontend.this, true);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runMultipleAction: " + caught, caught);
            failureEventHandler(caught);
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, null, state));
            }
            AsyncOperationCompleteEvent.fire(Frontend.this, state);
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (VdcActionParametersBase parameter : parameters) {
        VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameter, true, multiCallback);
        operationList.add(operation);
    }
    AsyncOperationStartedEvent.fire(Frontend.this, state);
    if (operationList.isEmpty()) {
        // it ourselves.
        if (scheduler == null) {
            scheduler = Scheduler.get();
        }
        scheduler.scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                if (callback != null) {
                    List<VdcReturnValueBase> emptyResult = new ArrayList<VdcReturnValueBase>();
                    callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, emptyResult, state));
                }
            }
        });
    } else {
        getOperationManager().addOperationList(operationList);
    }
}
#method_after
public void runMultipleAction(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final boolean isRunOnlyIfAllCanDoPass, final IFrontendMultipleActionAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operationList, final List<VdcReturnValueBase> resultObject) {
            // $NON-NLS-1$
            logger.finer("Frontend: successfully executed runMultipleAction, determining result!");
            ArrayList<VdcReturnValueBase> failed = new ArrayList<VdcReturnValueBase>();
            for (VdcReturnValueBase v : resultObject) {
                if (!v.getCanDoAction()) {
                    failed.add(v);
                }
            }
            if (!failed.isEmpty()) {
                translateErrors(failed);
                getEventsHandler().runMultipleActionFailed(actionType, failed);
            }
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, resultObject, state));
            }
            fireAsyncOperationCompleteEvent(state);
            RefreshActiveModelEvent.fire(Frontend.this, true);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runMultipleAction: " + caught, caught);
            failureEventHandler(caught);
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, null, state));
            }
            fireAsyncOperationCompleteEvent(state);
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (VdcActionParametersBase parameter : parameters) {
        VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameter, true, multiCallback);
        operationList.add(operation);
    }
    fireAsyncOperationStartedEvent(state);
    if (operationList.isEmpty()) {
        // it ourselves.
        if (scheduler == null) {
            scheduler = Scheduler.get();
        }
        scheduler.scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                if (callback != null) {
                    List<VdcReturnValueBase> emptyResult = new ArrayList<VdcReturnValueBase>();
                    callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, emptyResult, state));
                }
            }
        });
    } else {
        getOperationManager().addOperationList(operationList);
    }
}
#end_block

#method_before
public void init(final T model) {
    this.model = model;
    // Set up async operation listeners to automatically display/hide progress bar
    asyncOperationCounter = 0;
    manageProgress = false;
    addRegisteredHandler(AsyncOperationStartedEvent.getType(), new AsyncOperationStartedHandler() {

        @Override
        public void onAsyncOperationStarted(AsyncOperationStartedEvent event) {
            if (event.getTarget() != model) {
                return;
            }
            if (model.getProgress() == null) {
                manageProgress = true;
            }
            if (manageProgress && asyncOperationCounter++ == 0) {
                model.startProgress(null);
            }
        }
    });
    addRegisteredHandler(AsyncOperationCompleteEvent.getType(), new AsyncOperationCompleteHandler() {

        @Override
        public void onAsyncOperationComplete(AsyncOperationCompleteEvent event) {
            if (event.getTarget() != model) {
                return;
            }
            if (manageProgress && --asyncOperationCounter == 0) {
                manageProgress = false;
                model.stopProgress();
            }
        }
    });
    // Set up model command invoker
    this.modelCommandInvoker = new DeferredModelCommandInvoker(model) {

        @Override
        protected void commandFailed(UICommand command) {
            // Clear Window and ConfirmWindow models when "Cancel" command execution fails
            if (command.getIsCancel() && command.getTarget() instanceof Model) {
                Model source = (Model) command.getTarget();
                source.setWindow(null);
                source.setConfirmWindow(null);
            }
        }

        @Override
        protected void commandFinished(UICommand command) {
            // Enforce popup close after executing "Cancel" command
            if (command.getIsCancel()) {
                hideAndUnbind();
            }
        }
    };
    // Set common popup properties
    updateTitle(model);
    updateMessage(model);
    updateItems(model);
    updateHashName(model);
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("Title".equals(propName)) {
                // $NON-NLS-1$
                updateTitle(model);
            } else if ("Message".equals(propName)) {
                // $NON-NLS-1$
                updateMessage(model);
            } else if ("Items".equals(propName)) {
                // $NON-NLS-1$
                updateItems(model);
            } else if ("HashName".equals(propName)) {
                // $NON-NLS-1$
                updateHashName(model);
            } else if ("OpenDocumentation".equals(propName)) {
                // $NON-NLS-1$
                openDocumentation(model);
            }
        }
    });
    // Add popup footer buttons
    addFooterButtons(model);
    if (model.getCommands() instanceof ObservableCollection) {
        ObservableCollection<UICommand> commands = (ObservableCollection<UICommand>) model.getCommands();
        commands.getCollectionChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                getView().removeButtons();
                addFooterButtons(model);
                getView().updateTabIndexes();
            }
        });
    }
    // Register dialog model property change listener
    popupHandler.addDialogModelListener(model);
    // Initialize popup contents from the model
    getView().edit(model);
    getView().updateTabIndexes();
    if (!model.hasEventBusSet()) {
        model.setEventBus((EventBus) getEventBus());
    }
}
#method_after
public void init(final T model) {
    this.model = model;
    // Set up async operation listeners to automatically display/hide progress bar
    asyncOperationCounter = 0;
    addRegisteredHandler(AsyncOperationStartedEvent.getType(), new AsyncOperationStartedHandler() {

        @Override
        public void onAsyncOperationStarted(AsyncOperationStartedEvent event) {
            if (event.getTarget() != getModel() || (getModel().getProgress() != null && asyncOperationCounter == 0)) {
                return;
            }
            if (asyncOperationCounter == 0) {
                getModel().startProgress(null);
            }
            asyncOperationCounter++;
        }
    });
    addRegisteredHandler(AsyncOperationCompleteEvent.getType(), new AsyncOperationCompleteHandler() {

        @Override
        public void onAsyncOperationComplete(AsyncOperationCompleteEvent event) {
            if (event.getTarget() != getModel() || asyncOperationCounter == 0) {
                return;
            }
            asyncOperationCounter--;
            if (asyncOperationCounter == 0) {
                getModel().stopProgress();
            }
        }
    });
    // Set up model command invoker
    this.modelCommandInvoker = new DeferredModelCommandInvoker(model) {

        @Override
        protected void commandFailed(UICommand command) {
            // Clear Window and ConfirmWindow models when "Cancel" command execution fails
            if (command.getIsCancel() && command.getTarget() instanceof Model) {
                Model source = (Model) command.getTarget();
                source.setWindow(null);
                source.setConfirmWindow(null);
            }
        }

        @Override
        protected void commandFinished(UICommand command) {
            // Enforce popup close after executing "Cancel" command
            if (command.getIsCancel()) {
                hideAndUnbind();
            }
        }
    };
    // Set common popup properties
    updateTitle(model);
    updateMessage(model);
    updateItems(model);
    updateHashName(model);
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("Title".equals(propName)) {
                // $NON-NLS-1$
                updateTitle(model);
            } else if ("Message".equals(propName)) {
                // $NON-NLS-1$
                updateMessage(model);
            } else if ("Items".equals(propName)) {
                // $NON-NLS-1$
                updateItems(model);
            } else if ("HashName".equals(propName)) {
                // $NON-NLS-1$
                updateHashName(model);
            } else if ("OpenDocumentation".equals(propName)) {
                // $NON-NLS-1$
                openDocumentation(model);
            }
        }
    });
    // Add popup footer buttons
    addFooterButtons(model);
    if (model.getCommands() instanceof ObservableCollection) {
        ObservableCollection<UICommand> commands = (ObservableCollection<UICommand>) model.getCommands();
        commands.getCollectionChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                getView().removeButtons();
                addFooterButtons(model);
                getView().updateTabIndexes();
            }
        });
    }
    // Register dialog model property change listener
    popupHandler.addDialogModelListener(model);
    // Initialize popup contents from the model
    getView().edit(model);
    getView().updateTabIndexes();
    if (!model.hasEventBusSet()) {
        model.setEventBus((EventBus) getEventBus());
    }
}
#end_block

#method_before
@Override
protected boolean canAddDomain() {
    if (getStorageDomainStaticDAO().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    List<LUNs> physicalVolumeIdsOnStorage = getLUNsFromVgInfo(getStorageDomain().getStorage());
    if (CollectionUtils.containsAny(physicalVolumeIdsOnStorage, getPhysicalVolumesFromLunsList(getDbFacade().getLunDao().getAll()))) {
        log.info("There are existing luns in the system which are part of VG id '{}'", getStorageDomain().getStorage());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_STORAGE_DOMAIN_EXTERNAL_LUN_DISK_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean canAddDomain() {
    if (getStorageDomainStaticDAO().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    List<LUNs> physicalVolumeIdsOnStorage = getLUNsFromVgInfo(getStorageDomain().getStorage());
    if (CollectionUtils.containsAny(Entities.getPhysicalVolumesFromLunsList(physicalVolumeIdsOnStorage), Entities.getPhysicalVolumesFromLunsList(getDbFacade().getLunDao().getAll()))) {
        log.info("There are existing luns in the system which are part of VG id '{}'", getStorageDomain().getStorage());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_STORAGE_DOMAIN_EXTERNAL_LUN_DISK_EXIST);
    }
    return true;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected List<StorageDomain> getStorageDomainsByVolumeGroupIds(List<String> vgIDs) {
    List<StorageDomain> storageDomains = new ArrayList<>();
    // Get existing PhysicalVolumes.
    List<String> existingPhysicalVolumeIds = getPhysicalVolumesFromLunsList(getDbFacade().getLunDao().getAll());
    for (String vgID : vgIDs) {
        VDSReturnValue returnValue = null;
        try {
            returnValue = executeGetVGInfo(new GetVGInfoVDSCommandParameters(getParameters().getVdsId(), vgID));
        } catch (RuntimeException e) {
            log.error("Could not get info for VG ID: '{}': {}", vgID, e.getMessage());
            log.debug("Exception", e);
            continue;
        }
        ArrayList<LUNs> luns = (ArrayList<LUNs>) returnValue.getReturnValue();
        List<String> physicalVolumeIdsOnStorage = getPhysicalVolumesFromLunsList(luns);
        if (CollectionUtils.containsAny(physicalVolumeIdsOnStorage, existingPhysicalVolumeIds)) {
            log.info("There are existing luns in the system which are part of VG id '{}'", vgID);
            continue;
        }
        // Get storage domain ID by a representative LUN
        LUNs lun = luns.get(0);
        Guid storageDomainId = lun.getStorageDomainId();
        // Get storage domain using GetStorageDomainInfo
        StorageDomain storageDomain = getStorageDomainById(storageDomainId);
        if (storageDomain != null) {
            storageDomains.add(storageDomain);
        }
    }
    return storageDomains;
}
#method_after
@SuppressWarnings("unchecked")
protected List<StorageDomain> getStorageDomainsByVolumeGroupIds(List<String> vgIDs) {
    List<StorageDomain> storageDomains = new ArrayList<>();
    // Get existing PhysicalVolumes.
    List<String> existingPhysicalVolumeIds = Entities.getPhysicalVolumesFromLunsList(getLunDAO().getAll());
    for (String vgID : vgIDs) {
        VDSReturnValue returnValue = null;
        try {
            returnValue = executeGetVGInfo(new GetVGInfoVDSCommandParameters(getParameters().getVdsId(), vgID));
        } catch (RuntimeException e) {
            log.error("Could not get info for VG ID: '{}': {}", vgID, e.getMessage());
            log.debug("Exception", e);
            continue;
        }
        ArrayList<LUNs> luns = (ArrayList<LUNs>) returnValue.getReturnValue();
        List<String> physicalVolumeIdsOnStorage = Entities.getPhysicalVolumesFromLunsList(luns);
        if (CollectionUtils.containsAny(physicalVolumeIdsOnStorage, existingPhysicalVolumeIds)) {
            log.info("There are existing luns in the system which are part of VG id '{}'", vgID);
            continue;
        }
        // Get storage domain ID by a representative LUN
        LUNs lun = luns.get(0);
        Guid storageDomainId = lun.getStorageDomainId();
        // Get storage domain using GetStorageDomainInfo
        StorageDomain storageDomain = getStorageDomainById(storageDomainId);
        if (storageDomain != null) {
            storageDomains.add(storageDomain);
        }
    }
    return storageDomains;
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    getModel().getVmId().setIsChangable(true);
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (!dataCenters.isEmpty()) {
                AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusterList = (List<VDSGroup>) returnValue;
                        List<VDSGroup> filteredClusterList = AsyncDataProvider.getInstance().filterClustersWithoutArchitecture(clusterList);
                        model.setDataCentersAndClusters(model, dataCenters, filteredClusterList, null);
                        initCdImage();
                    }
                }, getModel().getHash()), true, false);
            } else {
                getModel().disableEditing(ConstantsManager.getInstance().getConstants().notAvailableWithNoUpDC());
            }
        }
    }, getModel().getHash()), true, false);
    initPriority(0);
    getModel().getVmInitModel().init(null);
    instanceTypeManager = new NewVmInstanceTypeManager(getModel());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    getModel().getVmId().setIsAvailable(true);
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (!dataCenters.isEmpty()) {
                AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusterList = (List<VDSGroup>) returnValue;
                        List<VDSGroup> filteredClusterList = AsyncDataProvider.getInstance().filterClustersWithoutArchitecture(clusterList);
                        model.setDataCentersAndClusters(model, dataCenters, filteredClusterList, null);
                        initCdImage();
                    }
                }, getModel().getHash()), true, false);
            } else {
                getModel().disableEditing(ConstantsManager.getInstance().getConstants().notAvailableWithNoUpDC());
            }
        }
    }, getModel().getHash()), true, false);
    initPriority(0);
    getModel().getVmInitModel().init(null);
    instanceTypeManager = new NewVmInstanceTypeManager(getModel());
}
#end_block

#method_before
protected void commonInitialize() {
    priorityUtil = new PriorityUtil(getModel());
    virtioScsiUtil = new VirtioScsiUtil(getModel());
    getModel().getVmId().setIsChangable(false);
}
#method_after
protected void commonInitialize() {
    priorityUtil = new PriorityUtil(getModel());
    virtioScsiUtil = new VirtioScsiUtil(getModel());
    getModel().getVmId().setIsAvailable(false);
}
#end_block

#method_before
protected List<Widget> adancedFieldsFromGeneralTab() {
    return Arrays.<Widget>asList(memSizeEditor, totalvCPUsEditor, vcpusAdvancedParameterExpander, copyTemplatePermissionsEditor);
}
#method_after
protected List<Widget> adancedFieldsFromGeneralTab() {
    return Arrays.<Widget>asList(memSizeEditor, totalvCPUsEditor, vcpusAdvancedParameterExpander, copyTemplatePermissionsEditor, vmIdEditor);
}
#end_block

#method_before
protected List<Widget> adminOnlyWidgets() {
    return Arrays.<Widget>asList(// general tab
    oSTypeEditor, // system tab
    detachableMemSizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, vcpusAdvancedParameterExpanderContent, serialNumberPolicyEditor, // console tab
    usbSupportEditor, numOfMonitorsLabel, numOfMonitorsEditor, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab);
}
#method_after
protected List<Widget> adminOnlyWidgets() {
    return Arrays.<Widget>asList(// general tab
    oSTypeEditor, vmIdEditor, // system tab
    detachableMemSizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, vcpusAdvancedParameterExpanderContent, serialNumberPolicyEditor, // console tab
    usbSupportEditor, numOfMonitorsLabel, numOfMonitorsEditor, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab);
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmId().setIsChangable(false);
    getModel().getDisksAllocationModel().setIsVolumeFormatAvailable(false);
    getModel().getDisksAllocationModel().setIsAliasChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(false);
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (!dataCenters.isEmpty()) {
                postDataCentersLoaded(dataCenters);
            } else {
                getModel().disableEditing(ConstantsManager.getInstance().getConstants().notAvailableWithNoUpDC());
            }
        }
    }, getModel().getHash()), true, false);
    getModel().getSpiceProxyEnabled().setEntity(false);
    getModel().getSpiceProxy().setIsChangable(false);
    getModel().getSpiceProxyEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getModel().getSpiceProxy().setIsChangable(getModel().getSpiceProxyEnabled().getEntity());
        }
    });
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getDisksAllocationModel().setIsVolumeFormatAvailable(false);
    getModel().getDisksAllocationModel().setIsAliasChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(false);
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (!dataCenters.isEmpty()) {
                postDataCentersLoaded(dataCenters);
            } else {
                getModel().disableEditing(ConstantsManager.getInstance().getConstants().notAvailableWithNoUpDC());
            }
        }
    }, getModel().getHash()), true, false);
    getModel().getSpiceProxyEnabled().setEntity(false);
    getModel().getSpiceProxy().setIsChangable(false);
    getModel().getSpiceProxyEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getModel().getSpiceProxy().setIsChangable(getModel().getSpiceProxyEnabled().getEntity());
        }
    });
}
#end_block

#method_before
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.getInstance().isWindowsOsType(osType) ? AsyncDataProvider.getInstance().getMaxVmNameLengthWin() : AsyncDataProvider.getInstance().getMaxVmNameLengthNonWin()), isValidTab(TabName.POOL_TAB) ? new PoolNameValidation() : new I18NNameValidation() });
        getValid().setIsValid(true);
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getName().getIsValid() && getVmId().getIsValid() && getDescription().getIsValid() && getComment().getIsValid());
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.FIRST_RUN, vmInitIsValid);
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#method_after
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.getInstance().isWindowsOsType(osType) ? AsyncDataProvider.getInstance().getMaxVmNameLengthWin() : AsyncDataProvider.getInstance().getMaxVmNameLengthNonWin()), isValidTab(TabName.POOL_TAB) ? new PoolNameValidation() : new I18NNameValidation() });
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getName().getIsValid() && getVmId().getIsValid() && getDescription().getIsValid() && getComment().getIsValid());
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.FIRST_RUN, vmInitIsValid);
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#end_block

#method_before
@Test
public void testGetOrderedVmGuidsForRunMultipleActionsByMigrationSupport() {
    List<VmStatic> vmStatics = dao.getAllByName(STATIC_VM_NAME);
    VmStatic[] vmStaticArrayInDescOrder = initVmStaticsOrderedByMigrationSupport(vmStatics);
    // execute
    List<Guid> vmStaticGuidsInDb = dao.getOrderedVmGuidsForRunMultipleActions(getListOfGuidFromListOfVmStatics(vmStatics));
    assertNotNull(vmStaticGuidsInDb);
    Guid[] guidsArrayToBeChecked = vmStaticGuidsInDb.toArray(new Guid[vmStaticGuidsInDb.size()]);
    boolean result = compareGuidArrays(guidsArrayToBeChecked, vmStaticArrayInDescOrder);
    assertTrue(result);
}
#method_after
@Test
public void testGetOrderedVmGuidsForRunMultipleActionsByMigrationSupport() {
    List<VmStatic> vmStatics = dao.getAllByName(STATIC_VM_NAME);
    if (vmStatics.size() > 3) {
        // migration support has only 3 possible values
        vmStatics = vmStatics.subList(0, 3);
    }
    VmStatic[] vmStaticArrayInDescOrder = initVmStaticsOrderedByMigrationSupport(vmStatics);
    // execute
    List<Guid> vmStaticGuidsInDb = dao.getOrderedVmGuidsForRunMultipleActions(getListOfGuidFromListOfVmStatics(vmStatics));
    assertNotNull(vmStaticGuidsInDb);
    Guid[] guidsArrayToBeChecked = vmStaticGuidsInDb.toArray(new Guid[vmStaticGuidsInDb.size()]);
    boolean result = compareGuidArrays(guidsArrayToBeChecked, vmStaticArrayInDescOrder);
    assertTrue(result);
}
#end_block

#method_before
@Override
public KeyManager[] getKeyManagers() throws GeneralSecurityException {
    if (keyManagers == null) {
        KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        kmfactory.init(getKeyStore(), "changeit".toCharArray());
        keyManagers = kmfactory.getKeyManagers();
    }
    return keyManagers;
}
#method_after
@Override
public KeyManager[] getKeyManagers() throws GeneralSecurityException {
    if (keyManagers == null) {
        KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        kmfactory.init(getKeyStore(), keyStorePassword.toCharArray());
        keyManagers = kmfactory.getKeyManagers();
    }
    return keyManagers;
}
#end_block

#method_before
public KeyStore getKeyStore() {
    if (keystorePassword == null) {
        return _getKeyStore("PKCS12", keystoreFile, null);
    } else {
        return _getKeyStore("PKCS12", keystoreFile, keystorePassword.toCharArray());
    }
}
#method_after
public KeyStore getKeyStore() {
    File keystoreFile = new File(keyStoreLocation);
    if (keyStorePassword == null) {
        return getKeyStore(KEY_STORE_FORMAT, keystoreFile, null);
    } else {
        return getKeyStore(KEY_STORE_FORMAT, keystoreFile, keyStorePassword.toCharArray());
    }
}
#end_block

#method_before
public KeyStore getTrustStore() {
    if (trustStorePassword == null) {
        return _getKeyStore("JKS", truststoreFile, null);
    } else {
        return _getKeyStore("JKS", truststoreFile, trustStorePassword.toCharArray());
    }
}
#method_after
public KeyStore getTrustStore() {
    File truststoreFile = new File(trustStoreLocation);
    if (trustStorePassword == null) {
        return getKeyStore(TRUST_STORE_FORMAT, truststoreFile, null);
    } else {
        return getKeyStore(TRUST_STORE_FORMAT, truststoreFile, trustStorePassword.toCharArray());
    }
}
#end_block

#method_before
public KeyStore getKeyStore() {
    if (keystorePassword == null) {
        return _getKeyStore("PKCS12", keystoreFile, null);
    } else {
        return _getKeyStore("PKCS12", keystoreFile, keystorePassword.toCharArray());
    }
}
#method_after
private static KeyStore getKeyStore(String type, File file, char[] password) {
    try (final InputStream in = new FileInputStream(file)) {
        KeyStore ks = KeyStore.getInstance(type);
        ks.load(in, password);
        return ks;
    } catch (Exception e) {
        throw new RuntimeException(String.format("Failed to load local keystore '%1$s'", file), e);
    }
}
#end_block

#method_before
public void start() {
    try {
        String hostName = "localhost";
        log.debug("Opening a Stomp server " + hostName + ":" + jsonPort);
        Reactor reactor;
        if (!encrypted) {
            reactor = ReactorFactory.getReactor(null, ReactorType.STOMP);
        } else {
            reactor = ReactorFactory.getReactor(new FakeVDSMSSLProvider(), ReactorType.STOMP);
        }
        final Future<ReactorListener> futureListener = reactor.createListener(hostName, jsonPort, new ReactorListener.EventListener() {

            @Override
            public void onAcccept(final ReactorClient client) {
                client.addEventListener(new MessageListener() {

                    // you can provide your implementation of MessageListener
                    @Override
                    public void onMessageReceived(byte[] message) {
                        try {
                            JsonRpcRequest request = JsonRpcRequest.fromByteArray(message);
                            ContextHolder.init();
                            ContextHolder.setServerName(client.getHostname());
                            ResponseBuilder builder = new ResponseBuilder(request.getId());
                            String methodName = request.getMethod();
                            builder = CommandFactory.createCommand(methodName).run(request.getParams(), builder);
                            JsonRpcResponse response = builder.build();
                            log.info("Request is " + request.getMethod() + " got response " + new String(response.toByteArray()));
                            client.sendMessage(response.toByteArray());
                        } catch (Throwable e) {
                            log.error("Failure in processing request", e);
                        }
                    }
                });
            }
        });
        listener = futureListener.get(TIMEOUT, TimeUnit.MILLISECONDS);
    } catch (Exception e) {
        log.error("Failure to start json server socket", e);
    }
}
#method_after
public void start() {
    try {
        String hostName = System.getProperty("fake.host");
        if (hostName == null) {
            hostName = "localhost";
        }
        log.debug("Opening a Stomp server " + hostName + ":" + jsonPort);
        Reactor reactor;
        if (!encrypted) {
            reactor = ReactorFactory.getReactor(null, ReactorType.STOMP);
        } else {
            reactor = ReactorFactory.getReactor(new FakeVDSMSSLProvider(System.getProperty("fake.keystore"), System.getProperty("fake.truststore"), "changeit", null), ReactorType.STOMP);
        }
        final Future<ReactorListener> futureListener = reactor.createListener(hostName, jsonPort, new ReactorListener.EventListener() {

            @Override
            public void onAcccept(final ReactorClient client) {
                client.addEventListener(new MessageListener() {

                    // you can provide your implementation of MessageListener
                    @Override
                    public void onMessageReceived(byte[] message) {
                        try {
                            JsonRpcRequest request = JsonRpcRequest.fromByteArray(message);
                            ContextHolder.init();
                            ContextHolder.setServerName(client.getHostname());
                            ResponseBuilder builder = new ResponseBuilder(request.getId());
                            String methodName = request.getMethod();
                            builder = CommandFactory.createCommand(methodName).run(request.getParams(), builder);
                            JsonRpcResponse response = builder.build();
                            log.info("Request is " + request.getMethod() + " got response " + new String(response.toByteArray()));
                            client.sendMessage(response.toByteArray());
                        } catch (Throwable e) {
                            log.error("Failure in processing request", e);
                        }
                    }
                });
            }
        });
        listener = futureListener.get(TIMEOUT, TimeUnit.MILLISECONDS);
    } catch (Exception e) {
        log.error("Failure to start json server socket", e);
    }
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (getVdsManager().getCopyVds().isBalloonEnabled()) {
        VmBalloonInfo balloonInfo = vdsmVm.getVmStatistics().getVmBalloonInfo();
        /* first time we check or we're not getting the balloon info
               from vdsm rhbz#1171491
             */
        if (balloonInfo.getBalloonLastMemory() == null) {
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            return;
        }
        Guid vmId = vdsmVm.getVmDynamic().getId();
        if (dbVm == null) {
            return;
        }
        if (isBalloonDeviceActiveOnVm(vdsmVm) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
            vmBalloonDriverIsRequestedAndUnavailable(vmId);
        } else {
            vmBalloonDriverIsNotRequestedOrAvailable(vmId);
        }
        // save the current value for the next time we check it
        balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
        if (vdsmVm.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
        vdsmVm.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
        balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
            guestAgentIsDownAndBalloonInfalted(vmId);
        } else {
            guestAgentIsUpOrBalloonDeflated(vmId);
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (getVdsManager().getCopyVds().isBalloonEnabled()) {
        VmBalloonInfo balloonInfo = vdsmVm.getVmStatistics().getVmBalloonInfo();
        Guid vmId = vdsmVm.getVmDynamic().getId();
        if (dbVm == null) {
            return;
        }
        /* last memory is null the first time we check it or when
               we're not getting the balloon info from vdsm
            */
        if (balloonInfo.getBalloonLastMemory() == null || balloonInfo.getBalloonLastMemory() == 0) {
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            return;
        }
        if (isBalloonDeviceActiveOnVm(vdsmVm) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
            vmBalloonDriverIsRequestedAndUnavailable(vmId);
        } else {
            vmBalloonDriverIsNotRequestedOrAvailable(vmId);
        }
        // save the current value for the next time we check it
        balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
        if (vdsmVm.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
        vdsmVm.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
        balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
            guestAgentIsDownAndBalloonInfalted(vmId);
        } else {
            guestAgentIsUpOrBalloonDeflated(vmId);
        }
    }
}
#end_block

#method_before
@Override
protected void init(T parameters) {
    super.init(parameters);
    // Images must be specified in parameters and belong to a single Disk;
    // Otherwise, we'll fail on canDoAction.
    DiskImage representativeImage = getRepresentativeImage();
    if (representativeImage == null) {
        return;
    }
    setImage(representativeImage);
    setStorageDomainId(representativeImage.getStorageIds().get(0));
    if (!Guid.isNullOrEmpty(getParameters().getContainerId())) {
        setVmId(getParameters().getContainerId());
    } else {
        List<VM> listVms = getVmDAO().getVmsListForDisk(representativeImage.getId(), false);
        if (!listVms.isEmpty()) {
            VM vm = listVms.get(0);
            setVm(vm);
        }
    }
    // initTaskHandlers() can't yet tell if this is a live or cold merge.
    if (isLiveMerge()) {
        clearTaskHandlers();
    }
}
#method_after
@Override
protected void init(T parameters) {
    super.init(parameters);
    // Images must be specified in parameters and belong to a single Disk;
    // Otherwise, we'll fail on canDoAction.
    DiskImage representativeImage = getRepresentativeImage();
    if (representativeImage == null) {
        return;
    }
    setImage(representativeImage);
    setStorageDomainId(representativeImage.getStorageIds().get(0));
    if (!Guid.isNullOrEmpty(getParameters().getContainerId())) {
        setVmId(getParameters().getContainerId());
    } else {
        List<VM> listVms = getVmDAO().getVmsListForDisk(representativeImage.getId(), false);
        if (!listVms.isEmpty()) {
            VM vm = listVms.get(0);
            setVm(vm);
        }
    }
    // thus initTaskHandlers() can't yet tell if this is a live or cold merge.
    if (isLiveMerge()) {
        clearTaskHandlers();
    }
}
#end_block

#method_before
protected List<DiskImage> getImages() {
    if (images == null) {
        images = new ArrayList<>();
        for (Guid imageId : getParameters().getImageIds()) {
            if (imageId == null) {
                // Disks existence is validated in canDoAction
                continue;
            }
            images.add(getDiskImageDao().getSnapshotById(imageId));
        }
    }
    return images;
}
#method_after
protected List<DiskImage> getImages() {
    if (images == null) {
        images = new ArrayList<>();
        for (Guid imageId : getParameters().getImageIds()) {
            if (imageId == null) {
                // Disks existence is validated in canDoAction
                continue;
            }
            DiskImage image = getDiskImageDao().getSnapshotById(imageId);
            if (image != null) {
                images.add(image);
            }
        }
    }
    return images;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    DiskSnapshotsValidator diskSnapshotsValidator = createDiskSnapshotsValidator(getImages());
    if (!validate(diskSnapshotsValidator.diskSnapshotsNotExist(getParameters().getImageIds())) || !validate(diskSnapshotsValidator.diskImagesBelongToSameImageGroup()) || !validate(diskSnapshotsValidator.imagesAreSnapshots())) {
        return false;
    }
    // Validate all chain of images in the disk
    if (!validateAllDiskImages()) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = createDiskImageValidator(getImages());
    if (!validate(diskImagesValidator.diskImagesSnapshotsNotAttachedToOtherVms(false))) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = createVmValidator(getVm());
    if (isDiskPlugged() && !validate(vmValidator.vmDown())) {
        return false;
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateStorageDomainActive()) {
        return false;
    }
    if (!validateStorageDomainAvailableSpace()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    DiskSnapshotsValidator diskSnapshotsValidator = createDiskSnapshotsValidator(getImages());
    if (!validate(diskSnapshotsValidator.diskSnapshotsNotExist(getParameters().getImageIds())) || !validate(diskSnapshotsValidator.diskImagesBelongToSameImageGroup()) || !validate(diskSnapshotsValidator.imagesAreSnapshots())) {
        return false;
    }
    // Validate all chain of images in the disk
    if (!validateAllDiskImages()) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = createDiskImageValidator(getImages());
    if (!validate(diskImagesValidator.diskImagesSnapshotsNotAttachedToOtherVms(false))) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (isDiskPlugged()) {
        VmValidator vmValidator = createVmValidator(getVm());
        if (isLiveMergeSupported() ? (!validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmHostCanLiveMerge())) : !validate(vmValidator.vmDown())) {
            return false;
        }
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateStorageDomainActive()) {
        return false;
    }
    if (!validateStorageDomainAvailableSpace()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    for (Guid imageId : getParameters().getImageIds()) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return taskHandlers;
}
#method_after
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // merge (and we can't yet run isLiveMerge()), so we just use an explicit flag.
    if (!getParameters().isImageIdsSorted()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = LinqUtils.filter(images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage image) {
                return getImages().contains(image);
            }
        });
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
        getParameters().setImageIdsSorted(true);
    }
    for (Guid imageId : getParameters().getImageIds()) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return taskHandlers;
}
#end_block

#method_before
@Override
public CommandCallBack getCallBack() {
    if (isLiveMerge()) {
        return new RemoveDiskSnapshotsCommandCallback();
    } else {
        return null;
    }
}
#method_after
@Override
public CommandCallBack getCallBack() {
    // Handle first execution based on vm status, and recovery based on isLiveMerge (VM may be down)
    if (isLiveMerge()) {
        return new RemoveDiskSnapshotsCommandCallback();
    } else {
        return null;
    }
}
#end_block

#method_before
private boolean isLiveMerge() {
    return (!getVm().isDown());
}
#method_after
private boolean isLiveMerge() {
    return (getParameters().isLiveMerge() || (getVm() != null && getVm().isQualifiedForLiveSnapshotMerge()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isLiveMerge()) {
        persistCommand(getParameters().getParentCommand(), true);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (isLiveMerge()) {
        getParameters().setLiveMerge(true);
        persistCommand(getParameters().getParentCommand(), true);
    }
    setSucceeded(true);
}
#end_block

#method_before
public void startNextLiveMerge(int completedChildren) {
    Guid imageId = getParameters().getImageIds().get(completedChildren);
    log.infoFormat("Starting child command {0} of {1}, image {2}", completedChildren + 1, getParameters().getImageIds().size(), imageId);
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveSnapshotSingleDiskLive, buildRemoveSnapshotSingleDiskLiveParameters(imageId), cloneContextAndDetachFromParent());
}
#method_after
public void startNextLiveMerge(int completedChildren) {
    if (completedChildren == 0) {
        // Lock all disk images in advance
        ImagesHandler.updateAllDiskImageSnapshotsStatus(getImageGroupId(), ImageStatus.LOCKED);
    } else {
        checkImageIdConsistency(completedChildren - 1);
    }
    Guid imageId = getParameters().getImageIds().get(completedChildren);
    log.info("Starting child command {} of {}, image '{}'", completedChildren + 1, getParameters().getImageIds().size(), imageId);
    RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskLiveParameters(imageId);
    if (getParameters().getChildImageIds() == null) {
        getParameters().setChildImageIds(Arrays.asList(new Guid[getParameters().getImageIds().size()]));
    }
    getParameters().getChildImageIds().set(completedChildren, parameters.getDestinationImageId());
    persistCommand(getParameters().getParentCommand(), true);
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveSnapshotSingleDiskLive, parameters, cloneContextAndDetachFromParent());
}
#end_block

#method_before
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskLiveParameters(Guid imageId) {
    DiskImage dest = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForParent(imageId).get(0);
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(imageId, getVmId());
    parameters.setDestinationImageId(dest.getImageId());
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(VdcActionType.RemoveSnapshotSingleDiskLive);
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setSessionId(getParameters().getSessionId());
    return parameters;
}
#method_after
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskLiveParameters(Guid imageId) {
    DiskImage dest = getDiskImageDao().getAllSnapshotsForParent(imageId).get(0);
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(imageId, getVmId());
    parameters.setDestinationImageId(dest.getImageId());
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(VdcActionType.RemoveSnapshotSingleDiskLive);
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setSessionId(getParameters().getSessionId());
    return parameters;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    unlockImages();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    unlockImages();
    setSucceeded(true);
}
#end_block

#method_before
protected boolean validateStorageDomainAvailableSpace() {
    return validate(getStorageDomainValidator().hasSpaceForRemovingDiskSnapshots(getImages()));
}
#method_after
protected boolean validateStorageDomainAvailableSpace() {
    // (as opposed to the whole chain).
    return validate(getStorageDomainValidator().hasSpaceForClonedDisks(getImages()));
}
#end_block

#method_before
public void addChildCommandInfo(Guid id, VdcActionType vdcActionType, VdcActionParametersBase parameters) {
    childCommandInfoMap.put(id, new Pair<VdcActionType, VdcActionParametersBase>(vdcActionType, parameters));
}
#method_after
public void addChildCommandInfo(Guid id, VdcActionType vdcActionType, VdcActionParametersBase parameters) {
    childCommandInfoMap.put(id, new Pair<>(vdcActionType, parameters));
}
#end_block

#method_before
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, getExecutionContext());
}
#method_after
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return commandObjectsHandlerProvider.get().runAction(command, getExecutionContext());
}
#end_block

#method_before
protected BackendInternal getBackend() {
    return Backend.getInstance();
}
#method_after
protected BackendInternal getBackend() {
    return Injector.get(BackendInternal.class);
}
#end_block

#method_before
private CompensationContext createCompensationContext(TransactionScopeOption transactionScopeOption, boolean forceCompensation) {
    if (transactionScopeOption == TransactionScopeOption.Suppress && !forceCompensation) {
        return NoOpCompensationContext.getInstance();
    }
    DefaultCompensationContext defaultContext = new DefaultCompensationContext();
    defaultContext.setCommandId(commandId);
    defaultContext.setCommandType(getClass().getName());
    defaultContext.setBusinessEntitySnapshotDAO(getBusinessEntitySnapshotDAO());
    defaultContext.setSnapshotSerializer(SerializationFactory.getSerializer());
    return defaultContext;
}
#method_after
private CompensationContext createCompensationContext(TransactionScopeOption transactionScopeOption, boolean forceCompensation) {
    if (transactionScopeOption == TransactionScopeOption.Suppress && !forceCompensation) {
        return NoOpCompensationContext.getInstance();
    }
    return createDefaultCompensationContext(commandId);
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed = false;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        actionAllowed = getReturnValue().getCanDoAction() || internalCanDoAction();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        actionAllowed = getReturnValue().getCanDoAction() || internalCanDoAction();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setCanDoAction(false);
            clearChildAsyncTasksWithOutVdsmId();
        }
    } finally {
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = CommandCoordinatorUtil.getAsyncTaskFromDb(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        CommandCoordinatorUtil.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#method_after
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTask task = CommandCoordinatorUtil.getAsyncTaskFromDb(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        CommandCoordinatorUtil.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        ExecutionHandler.startFinalizingStep(getExecutionContext());
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("endAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        startFinalizingStep();
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            setCommandStatus(CommandStatus.SUCCEEDED);
            internalEndSuccessfully();
        } else {
            setCommandStatus(CommandStatus.FAILED);
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            if (getCallBack() == null) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            internalEndSuccessfully();
        } else {
            if (getCallBack() == null) {
                setCommandStatus(CommandStatus.FAILED);
            }
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected void logExceptionAndCompensate(Exception e) {
    log.errorFormat("Exception while wrapping-up compensation in endAction: {0}.", ExceptionUtils.getMessage(e), e);
    compensate();
}
#method_after
protected void logExceptionAndCompensate(Exception e) {
    log.error("Exception while wrapping-up compensation in endAction", e);
    compensate();
}
#end_block

#method_before
private void internalEndSuccessfully() {
    log.infoFormat("Ending command successfully: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endSuccessfully();
        getParameters().incrementExecutionIndex();
        if (getExecutionIndex() < getTaskHandlers().size()) {
            _actionState = CommandActionState.EXECUTE;
            execute();
        }
    } else {
        endSuccessfully();
    }
}
#method_after
private void internalEndSuccessfully() {
    log.info("Ending command '{}' successfully.", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endSuccessfully();
        getParameters().incrementExecutionIndex();
        if (getExecutionIndex() < getTaskHandlers().size()) {
            _actionState = CommandActionState.EXECUTE;
            execute();
        }
    } else {
        endSuccessfully();
    }
}
#end_block

#method_before
private void internalEndWithFailure() {
    log.errorFormat("Ending command with failure: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        if (hasStepsToRevert()) {
            getCurrentTaskHandler().endWithFailure();
            revertPreviousHandlers();
        }
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollbackQuota();
}
#method_after
private void internalEndWithFailure() {
    log.error("Ending command '{}' with failure.", getClass().getName());
    if (hasTaskHandlers()) {
        if (hasStepsToRevert()) {
            getCurrentTaskHandler().endWithFailure();
            revertPreviousHandlers();
        } else {
            // since no handlers have been run we don't have to retry endAction
            getReturnValue().setEndActionTryAgain(false);
        }
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollbackQuota();
}
#end_block

#method_before
protected void logRollbackedTask() {
    String type = (getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name());
    log.errorFormat("Reverting task {0}, handler: {1}", type, getCurrentTaskHandler().getClass().getName());
}
#method_after
protected void logRollbackedTask() {
    String type = (getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name());
    log.error("Reverting task '{}', handler '{}'", type, getCurrentTaskHandler().getClass().getName());
}
#end_block

#method_before
private boolean internalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = TransactionSupport.suspend();
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warnFormat("CanDoAction of action {0} failed. Reasons:{1}", getActionType(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            TransactionSupport.resume(transaction);
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#method_after
private boolean internalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = TransactionSupport.suspend();
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warn("CanDoAction of action '{}' failed. Reasons: {}", getActionType(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            TransactionSupport.resume(transaction);
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean checkUserAuthorization(Guid userId, final ActionGroup actionGroup, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final Guid permId = getDbFacade().getPermissionDao().getEntityPermissions(userId, actionGroup, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAuthorization(Guid userId, final ActionGroup actionGroup, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final Guid permId = getDbFacade().getPermissionDao().getEntityPermissions(userId, actionGroup, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debug("Found permission '{}' for user when running '{}', on '{}' with id '{}'", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debug("No permission found for user when running action '{}', on object '{}' for action group '{}' with id '{}'.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, List<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debugFormat("Checking whether user {0} or groups {1} have action group {3} on object type {4}", userId, StringUtils.join(groupIds, ","), actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, Collection<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debug("Checking whether user '{}' or groups '{}' have action group '{}' on object type '{}'", userId, groupIds, actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debug("Found permission '{}' for user when running '{}', on '{}' with id '{}'", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debug("No permission found for user when running action '{}', on object '{}' for action group '{}' with id '{}'.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    if (log.isDebugEnabled()) {
        StringBuilder builder = getPermissionSubjectsAsStringBuilder(permSubjects);
        log.debugFormat("Checking whether user {0} or one of the groups he is member of, have the following permissions: {1}", getCurrentUser().getId(), builder.toString());
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#method_after
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debug("Permission check skipped for internal action {}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debug("Permission check for action '{}' skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debug("The set of objects to check is null or empty for action '{}'.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    if (log.isDebugEnabled()) {
        StringBuilder builder = getPermissionSubjectsAsStringBuilder(permSubjects);
        log.debug("Checking whether user '{}' or one of the groups he is member of, have the following permissions: {}", getCurrentUser().getId(), builder.toString());
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#end_block

#method_before
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            log.infoFormat("No permission found for user {0} or one of the groups he is member of," + " when running action {1}, Required permissions are: Action type: {2} Action group: {3}" + " Object type: {4}  Object ID: {5}.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            log.info("No permission found for user '{}' or one of the groups he is member of," + " when running action '{}', Required permissions are: Action type: '{}' Action group: '{}'" + " Object type: '{}'  Object ID: '{}'.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
final protected boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The object to check is null for action {0}.", getActionType());
        }
        messages.add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("No action group is defined for action {0}.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#method_after
final protected boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debug("The object to check is null for action '{}'.", getActionType());
        }
        messages.add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debug("No action group is defined for action '{}'.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            clearChildAsyncTasksWithOutVdsmId();
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            clearChildAsyncTasksWithOutVdsmId();
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to SUCCEEDED if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallBack() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = getPermissionSubjectsAsStringBuilder(permissionSubjectList);
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = getPermissionSubjectsAsStringBuilder(permissionSubjectList);
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info("{}", logInfo);
}
#end_block

#method_before
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    for (PermissionSubject permSubject : permissionSubjects) {
        if (permSubject.getObjectId() != null) {
            // affected.
            if (builder.length() != 0) {
                builder.append(", ");
            }
            builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            if (permSubject.getActionGroup() != null) {
                builder.append(permSubject.getActionGroup().toString());
            }
        }
    }
    return builder;
}
#method_after
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    for (PermissionSubject permSubject : permissionSubjects) {
        if (permSubject.getObjectId() != null) {
            // affected.
            if (builder.length() != 0) {
                builder.append(", ");
            }
            builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            if (permSubject.getActionGroup() != null) {
                builder.append("Action group " + permSubject.getActionGroup().name() + " with role type " + permSubject.getActionGroup().getRoleType().name());
            }
        }
    }
    return builder;
}
#end_block

#method_before
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    if (getCallBack() != null) {
        persistCommand(getParameters().getParentCommand(), true);
    }
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                log.infoFormat("Command {0} persisting async task placeholder for child command {1}", getCommandId(), command.getCommandId());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#method_after
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = commandObjectsHandlerProvider.get().createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                log.info("Command '{}' persisting async task placeholder for child command '{}'", getCommandId(), command.getCommandId());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#end_block

#method_before
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, final String taskKey) {
    if (taskKeyToTaskIdMap.containsKey(taskKey)) {
        return taskKeyToTaskIdMap.get(taskKey);
    }
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTasks task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during persistAsyncTaskPlaceHolder for command: {0}. Exception {1}", getClass().getName(), ex);
    }
    return taskId;
}
#method_after
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, final String taskKey) {
    if (taskKeyToTaskIdMap.containsKey(taskKey)) {
        return taskKeyToTaskIdMap.get(taskKey);
    }
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTask task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.error("Error during persistAsyncTaskPlaceHolder for command '{}': {}", getClass().getName(), ex.getMessage());
        log.error("Exception", ex);
    }
    return taskId;
}
#end_block

#method_before
private void saveTaskAndPutInMap(String taskKey, AsyncTasks task) {
    CommandCoordinatorUtil.saveAsyncTaskToDb(task);
    taskKeyToTaskIdMap.put(taskKey, task.getTaskId());
}
#method_after
private void saveTaskAndPutInMap(String taskKey, AsyncTask task) {
    CommandCoordinatorUtil.saveAsyncTaskToDb(task);
    taskKeyToTaskIdMap.put(taskKey, task.getTaskId());
}
#end_block

#method_before
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        return createTaskImpl(taskId, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during createTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return Guid.Empty;
}
#method_after
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        return createTaskImpl(taskId, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
    } catch (RuntimeException ex) {
        log.error("Error during createTask for command '{}': {}", getClass().getName(), ex.getMessage());
        log.error("Exception", ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return Guid.Empty;
}
#end_block

#method_before
private Map<Guid, VdcObjectType> createEntitiesMapForSingleEntityType(VdcObjectType entityType, Guid... entityIds) {
    Map<Guid, VdcObjectType> entitiesMap = new HashMap<Guid, VdcObjectType>();
    for (Guid entityId : entityIds) {
        entitiesMap.put(entityId, entityType);
    }
    return entitiesMap;
}
#method_after
private Map<Guid, VdcObjectType> createEntitiesMapForSingleEntityType(VdcObjectType entityType, Guid... entityIds) {
    Map<Guid, VdcObjectType> entitiesMap = new HashMap<>();
    for (Guid entityId : entityIds) {
        entitiesMap.put(entityId, entityType);
    }
    return entitiesMap;
}
#end_block

#method_before
private AsyncTasks createAsyncTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinatorUtil.createAsyncTask(this, asyncTaskCreationInfo, parentCommand);
}
#method_after
private AsyncTask createAsyncTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinatorUtil.createAsyncTask(this, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
@Override
public void rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.error("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#method_after
@Override
public void rollback() {
    log.error("Transaction rolled-back for command '{}'.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.error("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#end_block

#method_before
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                context.withLock(lock);
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.info("Lock Acquired to object '{}'", lock);
                context.withLock(lock);
            } else {
                log.info("Failed to Acquire Lock to object '{}'", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
protected List<String> extractVariableDeclarations(Iterable<String> appendedCanDoMsgs) {
    final List<String> result = new ArrayList<String>();
    Iterator<String> iter = appendedCanDoMsgs.iterator();
    while (iter.hasNext()) {
        result.addAll(Arrays.asList(iter.next().split("(?=\\$)")));
    }
    return result;
}
#method_after
protected List<String> extractVariableDeclarations(Iterable<String> appendedCanDoMsgs) {
    final List<String> result = new ArrayList<>();
    Iterator<String> iter = appendedCanDoMsgs.iterator();
    while (iter.hasNext()) {
        result.addAll(Arrays.asList(iter.next().split("(?=\\$)")));
    }
    return result;
}
#end_block

#method_before
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.infoFormat("Lock freed to object {0}", context.getLock());
        context.withLock(null);
    }
}
#method_after
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.info("Lock freed to object '{}'", context.getLock());
        context.withLock(null);
    }
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        if (validationResult.getVariableReplacements() != null) {
            for (String variableReplacement : validationResult.getVariableReplacements()) {
                addCanDoActionMessage(variableReplacement);
            }
        }
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            addCanDoActionMessage(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#end_block

#method_before
@Override
public void setCorrelationId(String correlationId) {
    // correlation ID thread local variable is set for non multi-action
    if (!_parameters.getMultipleAction()) {
        ThreadLocalParamsContainer.setCorrelationId(correlationId);
    }
    super.setCorrelationId(correlationId);
}
#method_after
@Override
public void setCorrelationId(String correlationId) {
    // correlation ID thread local variable is set for non multi-action
    if (!_parameters.getMultipleAction()) {
        CorrelationIdTracker.setCorrelationId(correlationId);
    }
    super.setCorrelationId(correlationId);
}
#end_block

#method_before
private CommandEntity buildCommandEntity(Guid parentCommandId, boolean callBackEnabled) {
    return CommandEntity.buildCommandEntity(getCommandId(), parentCommandId, getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, callBackEnabled, getReturnValue());
}
#method_after
private CommandEntity buildCommandEntity(Guid parentCommandId, boolean callBackEnabled) {
    return CommandEntity.buildCommandEntity(getCommandId(), parentCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, callBackEnabled, getReturnValue());
}
#end_block

#method_before
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    boolean anyFailed = false;
    int completedChildren = 0;
    for (Guid childCmdId : childCmdIds) {
        switch(CommandCoordinatorUtil.getCommandStatus(childCmdId)) {
            case ACTIVE:
                log.info("Waiting on Live Merge child commands to complete");
                return;
            case FAILED:
            case FAILED_RESTARTED:
            case UNKNOWN:
                anyFailed = true;
                break;
            default:
                ++completedChildren;
                break;
        }
    }
    RemoveDiskSnapshotsCommand<RemoveDiskSnapshotsParameters> command = getCommand(cmdId);
    if (!anyFailed && completedChildren < command.getParameters().getImageIds().size()) {
        command.startNextLiveMerge(completedChildren);
        return;
    }
    command.getParameters().setTaskGroupSuccess(!anyFailed);
    command.setCommandStatus(anyFailed ? CommandStatus.FAILED : CommandStatus.SUCCEEDED);
    log.infoFormat("All Live Merge child commands have completed, status {0}", command.getCommandStatus());
}
#method_after
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    boolean anyFailed = false;
    int completedChildren = 0;
    for (Guid childCmdId : childCmdIds) {
        switch(CommandCoordinatorUtil.getCommandStatus(childCmdId)) {
            case NOT_STARTED:
            case ACTIVE:
                log.info("Waiting on Live Merge child commands to complete");
                return;
            case FAILED:
            case FAILED_RESTARTED:
            case UNKNOWN:
                anyFailed = true;
                break;
            default:
                CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(childCmdId);
                if (cmdEntity.isCallBackNotified()) {
                    ++completedChildren;
                    break;
                } else {
                    log.info("Waiting on Live Merge child command to finalize");
                    return;
                }
        }
    }
    RemoveDiskSnapshotsCommand<RemoveDiskSnapshotsParameters> command = getCommand(cmdId);
    if (!anyFailed && completedChildren < command.getParameters().getImageIds().size()) {
        command.startNextLiveMerge(completedChildren);
        return;
    }
    command.getParameters().setTaskGroupSuccess(!anyFailed);
    command.setCommandStatus(anyFailed ? CommandStatus.FAILED : CommandStatus.SUCCEEDED);
    log.info("All Live Merge child commands have completed, status '{}'", command.getCommandStatus());
}
#end_block

#method_before
private void initVmTemplate() {
    OvfHelper ovfHelper = new OvfHelper();
    List<OvfEntityData> ovfEntityList = getUnregisteredOVFDataDao().getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            OvfEntityData ovfEntityData = ovfEntityList.get(0);
            vmTemplateFromConfiguration = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            vmTemplateFromConfiguration.setVdsGroupId(getParameters().getVdsGroupId());
            setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setVdsGroupId(getParameters().getVdsGroupId());
    setStoragePoolId(getVdsGroup().getStoragePoolId());
}
#method_after
private void initVmTemplate() {
    OvfHelper ovfHelper = new OvfHelper();
    List<OvfEntityData> ovfEntityList = getUnregisteredOVFDataDao().getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            vmTemplateFromConfiguration = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            vmTemplateFromConfiguration.setVdsGroupId(getParameters().getVdsGroupId());
            setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setVdsGroupId(getParameters().getVdsGroupId());
    setStoragePoolId(getVdsGroup().getStoragePoolId());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (isImagesAlreadyOnTarget()) {
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(vmFromConfiguration, ovfEntityData, getImages()))) {
            return false;
        }
        setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), getVm().getImages());
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (isImagesAlreadyOnTarget()) {
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(vmFromConfiguration, ovfEntityData, getImages()))) {
            return false;
        }
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return super.canDoAction();
}
#end_block

#method_before
@Test
public void testInsertTemplateToUnregisteredEntity() {
    final String ovfExtraData = "<ovf> Some extra OVF data </ovf>";
    OvfEntityData ovfEntityData = new OvfEntityData(FixturesTool.VM_TEMPLATE_RHEL5, "AnyVM", VmEntityType.TEMPLATE, ArchitectureType.x86_64, Version.v3_4, FixturesTool.STORAGE_DOAMIN_NFS2_1, null, ovfExtraData);
    dao.saveOVFData(ovfEntityData);
    List<OvfEntityData> fetchedOvfEntityData = dao.getByEntityIdAndStorageDomain(FixturesTool.VM_TEMPLATE_RHEL5, FixturesTool.STORAGE_DOAMIN_NFS2_1);
    assertFalse(fetchedOvfEntityData.isEmpty());
    assertTrue("The entity type should be template", fetchedOvfEntityData.get(0).getEntityType().isTemplateType());
    assertTrue("The entity OVF extra data should be updated", fetchedOvfEntityData.get(0).getOvfExtraData().equals(ovfExtraData));
}
#method_after
@Test
public void testInsertTemplateToUnregisteredEntity() {
    final String ovfExtraData = "<ovf> Some extra OVF data </ovf>";
    OvfEntityData ovfEntityData = new OvfEntityData(FixturesTool.VM_TEMPLATE_RHEL5, "AnyVM", VmEntityType.TEMPLATE, ArchitectureType.x86_64, Version.v3_4, FixturesTool.STORAGE_DOAMIN_NFS2_1, null, ovfExtraData);
    dao.saveOVFData(ovfEntityData);
    List<OvfEntityData> fetchedOvfEntityData = dao.getByEntityIdAndStorageDomain(FixturesTool.VM_TEMPLATE_RHEL5, FixturesTool.STORAGE_DOAMIN_NFS2_1);
    assertTrue(fetchedOvfEntityData.size() == 1);
    assertTrue("The entity type should be template", fetchedOvfEntityData.get(0).getEntityType().isTemplateType());
    assertTrue("The entity OVF extra data should be updated", fetchedOvfEntityData.get(0).getOvfExtraData().equals(ovfExtraData));
}
#end_block

#method_before
@Test
public void testDeleteUnregisteredEntity() {
    List<OvfEntityData> ovfEntityDataList = dao.getByEntityIdAndStorageDomain(FixturesTool.UNREGISTERED_VM, FixturesTool.STORAGE_DOAMIN_NFS2_1);
    assertFalse(ovfEntityDataList.isEmpty());
    dao.removeEntity(FixturesTool.UNREGISTERED_VM, FixturesTool.STORAGE_DOAMIN_NFS2_1);
    List<OvfEntityData> ovfEntityDataList2 = dao.getByEntityIdAndStorageDomain(FixturesTool.UNREGISTERED_VM, FixturesTool.STORAGE_DOAMIN_NFS2_1);
    assertTrue(ovfEntityDataList2.isEmpty());
}
#method_after
@Test
public void testDeleteUnregisteredEntity() {
    List<OvfEntityData> ovfEntityDataList = dao.getByEntityIdAndStorageDomain(FixturesTool.UNREGISTERED_VM, FixturesTool.STORAGE_DOAMIN_NFS2_1);
    assertTrue(ovfEntityDataList.size() == 1);
    assertFalse(ovfEntityDataList.isEmpty());
    dao.removeEntity(FixturesTool.UNREGISTERED_VM, FixturesTool.STORAGE_DOAMIN_NFS2_1);
    List<OvfEntityData> ovfEntityDataList2 = dao.getByEntityIdAndStorageDomain(FixturesTool.UNREGISTERED_VM, FixturesTool.STORAGE_DOAMIN_NFS2_1);
    assertTrue(ovfEntityDataList2.isEmpty());
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    endCommandActions();
    getVmStaticDAO().incrementDbGeneration(getVmTemplate().getId());
}
#method_after
@Override
protected void endSuccessfully() {
    endCommandActions();
    incrementDbGenerationForRelatedEntities();
}
#end_block

#method_before
@Override
public void executeCommand() {
    super.executeCommand();
    if (isImagesAlreadyOnTarget()) {
        setCopiedImages();
        getUnregisteredOVFDataDao().removeEntity(ovfEntityData.getEntityId(), null);
    }
    setActionReturnValue(getVmTemplate().getId());
    setSucceeded(true);
}
#method_after
@Override
public void executeCommand() {
    super.executeCommand();
    if (isImagesAlreadyOnTarget()) {
        if (!getImages().isEmpty()) {
            findAndSaveDiskCopies();
        }
        getUnregisteredOVFDataDao().removeEntity(ovfEntityData.getEntityId(), null);
    }
    setActionReturnValue(getVmTemplate().getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public VdcQueryReturnValue runPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetAAAProfileList:
        case RegisterVds:
        case CheckDBConnection:
        case GetValueBySession:
        case ValidateSession:
            parameters.setRefresh(false);
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
            if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion || configParameters.getConfigValue() == ConfigurationValues.ApplicationMode || configParameters.getConfigValue() == ConfigurationValues.UserMessageOfTheDay || configParameters.getConfigValue() == ConfigurationValues.UserSessionTimeOutInterval) {
                parameters.setRefresh(false);
                return runQueryImpl(actionType, parameters, false);
            }
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
        default:
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
    }
}
#method_after
@Override
public VdcQueryReturnValue runPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    parameters.setRefresh(false);
    switch(actionType) {
        case GetAAAProfileList:
        case RegisterVds:
        case CheckDBConnection:
        case GetValueBySession:
        case ValidateSession:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
            if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion || configParameters.getConfigValue() == ConfigurationValues.ApplicationMode || configParameters.getConfigValue() == ConfigurationValues.UserMessageOfTheDay || configParameters.getConfigValue() == ConfigurationValues.UserSessionTimeOutInterval) {
                return runQueryImpl(actionType, parameters, false);
            }
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
        default:
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
    }
}
#end_block

#method_before
public void importFileStorageAddDomain(ArrayList<StorageDomain> domains) {
    StorageDomain sdToAdd = Linq.firstOrDefault(domains);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.getInstance().runAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId(), model.getActivateDomain().getEntity());
                    onFinish(storageListModel.context, true, storageListModel.storageModel, null);
                } else {
                    postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
                }
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
                Frontend.getInstance().runAction(VdcActionType.RemoveStorageServerConnection, new StorageServerConnectionParametersBase(fileConnection, hostId), null, this);
            }
        }
    }, new Object[] { this, sdToAdd });
}
#method_after
public void importFileStorageAddDomain(ArrayList<StorageDomain> domains) {
    StorageDomain sdToAdd = Linq.firstOrDefault(domains);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.getInstance().runAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId(), model.getActivateDomain().getEntity());
                    onFinish(storageListModel.context, true, storageListModel.storageModel, null);
                } else {
                    postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
                }
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
                cleanConnection(fileConnection, hostId);
            }
        }
    }, new Object[] { this, sdToAdd });
}
#end_block

#method_before
protected void doChangeDefautlHost(Guid hostGuid) {
    // Second time (when the user change cluster/datacenter we leave the default (which is any host)
    if (hostGuid != null && firstRun) {
        Guid vdsId = hostGuid;
        if (getModel().getDefaultHost().getItems() != null) {
            getModel().getDefaultHost().setSelectedItem(Linq.firstOrDefault(getModel().getDefaultHost().getItems(), new Linq.HostPredicate(vdsId)));
        }
        getModel().getIsAutoAssign().setEntity(false);
    } else {
        getModel().getIsAutoAssign().setEntity(true);
    }
    firstRun = false;
}
#method_after
protected void doChangeDefautlHost(Guid hostGuid) {
    getModel().getIsAutoAssign().setEntity(true);
    if (hostGuid != null) {
        Guid vdsId = hostGuid;
        if (getModel().getDefaultHost().getItems() != null) {
            getModel().getDefaultHost().setSelectedItem(Linq.firstOrDefault(getModel().getDefaultHost().getItems(), new Linq.HostPredicate(vdsId)));
            if (getModel().getDefaultHost().getSelectedItem() != null && getModel().getDefaultHost().getSelectedItem().getId().equals(vdsId)) {
                getModel().getIsAutoAssign().setEntity(false);
            }
        }
    }
}
#end_block

#method_before
@SuppressWarnings("NonJREEmulationClassesInClientCode")
@Test
public void testDuplicateKeys() throws FileNotFoundException {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    String fileName = "AppErrors.properties";
    // $NON-NLS-1$
    final File dir = new File(baseDir, "src/main/resources/org/ovirt/engine/ui/frontend");
    File file = new File(dir, fileName);
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#method_after
@SuppressWarnings("NonJREEmulationClassesInClientCode")
@Test
public void testDuplicateKeys() throws FileNotFoundException {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    File file = new File(baseDir, "src/main/resources/org/ovirt/engine/ui/frontend/AppErrors.properties");
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#end_block

#method_before
@Test
public void testDuplicateKeys() throws FileNotFoundException {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    String fileName = "AppErrors.properties";
    // $NON-NLS-1$
    final File dir = new File(baseDir, "src/main/resources/bundles");
    File file = new File(dir, fileName);
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#method_after
@Test
public void testDuplicateKeys() throws FileNotFoundException {
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    File file = new File(baseDir, "src/main/resources/bundles/AppErrors.properties");
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#end_block

#method_before
@SuppressWarnings("NonJREEmulationClassesInClientCode")
@Test
public void testDuplicateKeys() throws FileNotFoundException {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    String fileName = "AppErrors.properties";
    // $NON-NLS-1$
    final File dir = new File(baseDir, "src/main/resources/org/ovirt/engine/ui/frontend");
    File file = new File(dir, fileName);
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#method_after
@SuppressWarnings("NonJREEmulationClassesInClientCode")
@Test
public void testDuplicateKeys() throws FileNotFoundException {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    File file = new File(baseDir, "src/main/resources/org/ovirt/engine/ui/frontend/AppErrors.properties");
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#end_block

#method_before
@Override
public void validateEnums(Host host) {
    if (host.isSetPowerManagement()) {
        if (host.getPowerManagement().isSetPmProxies()) {
            for (PmProxy proxy : host.getPowerManagement().getPmProxies().getPmProxy()) {
                validateEnum(PmProxyType.class, proxy.getType(), true);
            }
        }
    }
    if (host.isSetSsh()) {
        sshValidator.validateEnums(host.getSsh());
    }
    if (host.isSetProtocol()) {
        validateEnum(VdsProtocol.class, host.getProtocol(), true);
    }
}
#method_after
@Override
public void validateEnums(Host host) {
    if (host.isSetPowerManagement()) {
        if (host.getPowerManagement().isSetPmProxies()) {
            for (PmProxy proxy : host.getPowerManagement().getPmProxies().getPmProxy()) {
                validateEnum(PmProxyType.class, proxy.getType(), true);
            }
        }
    }
    if (host.isSetSsh()) {
        sshValidator.validateEnums(host.getSsh());
    }
    if (host.isSetProtocol()) {
        validateEnum(HostProtocol.class, host.getProtocol(), true);
    }
}
#end_block

#method_before
@Test
public void testGetAllByStatus() {
    List<StoragePool> result = dao.getAllByStatus(StoragePoolStatus.Up);
    assertNotNull("list of returned pools in status up shouldn't be null", result);
    assertEquals("wrong number of storage pools returned for up status", 6, result.size());
    result = dao.getAllByStatus(StoragePoolStatus.Maintenance);
    assertNotNull("list of returned pools in maintenance status shouldn't be null", result);
    assertEquals("wrong number of storage pool returned for maintenance status", 0, result.size());
}
#method_after
@Test
public void testGetAllByStatus() {
    List<StoragePool> result = dao.getAllByStatus(StoragePoolStatus.Up);
    assertNotNull("list of returned pools in status up shouldn't be null", result);
    assertEquals("wrong number of storage pools returned for up status", 7, result.size());
    result = dao.getAllByStatus(StoragePoolStatus.Maintenance);
    assertNotNull("list of returned pools in maintenance status shouldn't be null", result);
    assertEquals("wrong number of storage pool returned for maintenance status", 0, result.size());
}
#end_block

#method_before
public ValidationResult notRemovingUsedPool() {
    final StoragePoolDAO storagePoolDao = DbFacade.getInstance().getStoragePoolDao();
    final List<StoragePool> dataCenters = storagePoolDao.getAllDataCentersByMacPoolId(macPool.getId());
    final Collection<String> replacements = ReplacementUtils.replaceWithNameable("DATACENTERS_USING_MAC_POOL", dataCenters);
    replacements.add(VdcBllMessages.VAR__ENTITIES__STORAGE_POOLS.name());
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_STILL_USED_MAC_POOL, replacements.toArray(new String[0])).when(dataCenters.size() != 0);
}
#method_after
public ValidationResult notRemovingUsedPool() {
    final StoragePoolDAO storagePoolDao = getDbFacade().getStoragePoolDao();
    final List<StoragePool> dataCenters = storagePoolDao.getAllDataCentersByMacPoolId(macPool.getId());
    final Collection<String> replacements = ReplacementUtils.replaceWithNameable("DATACENTERS_USING_MAC_POOL", dataCenters);
    replacements.add(VdcBllMessages.VAR__ENTITIES__DATA_CENTERS.name());
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_STILL_USED_MAC_POOL, replacements.toArray(new String[0])).when(dataCenters.size() != 0);
}
#end_block

#method_before
private MacPoolDao getMacPoolDao() {
    return DbFacade.getInstance().getMacPoolDao();
}
#method_after
private MacPoolDao getMacPoolDao() {
    return getDbFacade().getMacPoolDao();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    macPool = new MacPool();
    final DbFacade dbFacadeMock = mock(DbFacade.class);
    DbFacadeLocator.setDbFacade(dbFacadeMock);
    when(dbFacadeMock.getMacPoolDao()).thenReturn(macPoolDaoMock);
    when(dbFacadeMock.getStoragePoolDao()).thenReturn(storagePoolDao);
}
#method_after
@Before
public void setUp() throws Exception {
    this.macPoolValidator = createMacPoolValidator(macPool);
    when(dbFacadeMock.getMacPoolDao()).thenReturn(macPoolDaoMock);
    when(dbFacadeMock.getStoragePoolDao()).thenReturn(storagePoolDao);
}
#end_block

#method_before
@Test
public void testDefaultPoolFlagIsNotSetValidUsage() throws Exception {
    macPool.setDefaultPool(false);
    assertThat(new MacPoolValidator(macPool).defaultPoolFlagIsNotSet(), isValid());
}
#method_after
@Test
public void testDefaultPoolFlagIsNotSetValidUsage() throws Exception {
    macPool.setDefaultPool(false);
    assertThat(macPoolValidator.defaultPoolFlagIsNotSet(), isValid());
}
#end_block

#method_before
@Test
public void testDefaultPoolFlagIsNotSetInvalidUsage() throws Exception {
    macPool.setDefaultPool(true);
    assertThat(new MacPoolValidator(macPool).defaultPoolFlagIsNotSet(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_SETTING_DEFAULT_MAC_POOL_IS_NOT_SUPPORTED));
}
#method_after
@Test
public void testDefaultPoolFlagIsNotSetInvalidUsage() throws Exception {
    macPool.setDefaultPool(true);
    assertThat(macPoolValidator.defaultPoolFlagIsNotSet(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_SETTING_DEFAULT_MAC_POOL_IS_NOT_SUPPORTED));
}
#end_block

#method_before
private ValidationResult callHasUniqueName(Guid macPool1Id, Guid macPool2Id, String macPool1Name, String macPool2Name) {
    when(macPoolDaoMock.getAll()).thenReturn(Arrays.asList(createMacPool(macPool1Id, macPool1Name)));
    return new MacPoolValidator(createMacPool(macPool2Id, macPool2Name)).hasUniqueName();
}
#method_after
private ValidationResult callHasUniqueName(Guid macPool1Id, Guid macPool2Id, String macPool1Name, String macPool2Name) {
    final MacPool existingMacPool = new MacPool();
    existingMacPool.setId(macPool1Id);
    existingMacPool.setName(macPool1Name);
    when(macPoolDaoMock.getAll()).thenReturn(Arrays.asList(existingMacPool));
    macPool.setId(macPool2Id);
    macPool.setName(macPool2Name);
    return macPoolValidator.hasUniqueName();
}
#end_block

#method_before
@Test
public void testNotRemovingDefaultPool() throws Exception {
    macPool.setDefaultPool(true);
    assertThat(new MacPoolValidator(macPool).notRemovingDefaultPool(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_DEFAULT_MAC_POOL));
}
#method_after
@Test
public void testNotRemovingDefaultPool() throws Exception {
    macPool.setDefaultPool(true);
    assertThat(macPoolValidator.notRemovingDefaultPool(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_DEFAULT_MAC_POOL));
}
#end_block

#method_before
@Test
public void testNotRemovingDefaultPoolNonDefaultIsRemoved() throws Exception {
    assertThat(new MacPoolValidator(macPool).notRemovingDefaultPool(), isValid());
}
#method_after
@Test
public void testNotRemovingDefaultPoolNonDefaultIsRemoved() throws Exception {
    assertThat(macPoolValidator.notRemovingDefaultPool(), isValid());
}
#end_block

#method_before
@Test
public void testNotRemovingUsedPoolRecordIsUsed() throws Exception {
    macPool.setId(Guid.newGuid());
    final StoragePool storagePool = new StoragePool();
    storagePool.setName("storagePool");
    when(storagePoolDao.getAllDataCentersByMacPoolId(macPool.getId())).thenReturn(Collections.singletonList(storagePool));
    assertThat(new MacPoolValidator(macPool).notRemovingUsedPool(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_STILL_USED_MAC_POOL));
}
#method_after
@Test
public void testNotRemovingUsedPoolRecordIsUsed() throws Exception {
    macPool.setId(Guid.newGuid());
    final StoragePool storagePool = new StoragePool();
    storagePool.setName("storagePool");
    when(storagePoolDao.getAllDataCentersByMacPoolId(macPool.getId())).thenReturn(Collections.singletonList(storagePool));
    assertThat(macPoolValidator.notRemovingUsedPool(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_STILL_USED_MAC_POOL));
}
#end_block

#method_before
@Test
public void testNotRemovingUsedPoolRecordNotUsed() throws Exception {
    macPool.setId(Guid.newGuid());
    when(storagePoolDao.getAllDataCentersByMacPoolId(macPool.getId())).thenReturn(Collections.<StoragePool>emptyList());
    assertThat(new MacPoolValidator(macPool).notRemovingUsedPool(), isValid());
}
#method_after
@Test
public void testNotRemovingUsedPoolRecordNotUsed() throws Exception {
    macPool.setId(Guid.newGuid());
    when(storagePoolDao.getAllDataCentersByMacPoolId(macPool.getId())).thenReturn(Collections.<StoragePool>emptyList());
    assertThat(macPoolValidator.notRemovingUsedPool(), isValid());
}
#end_block

#method_before
@Test
public void testMacPoolExistsEntityNotExist() throws Exception {
    assertThat(new MacPoolValidator(null).macPoolExists(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_MAC_POOL_DOES_NOT_EXIST));
}
#method_after
@Test
public void testMacPoolExistsEntityNotExist() throws Exception {
    assertThat(createMacPoolValidator(null).macPoolExists(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_MAC_POOL_DOES_NOT_EXIST));
}
#end_block

#method_before
@Test
public void testMacPoolExistsEntityDoesExist() throws Exception {
    assertThat(new MacPoolValidator(macPool).macPoolExists(), isValid());
}
#method_after
@Test
public void testMacPoolExistsEntityDoesExist() throws Exception {
    assertThat(macPoolValidator.macPoolExists(), isValid());
}
#end_block

#method_before
@Override
protected int getEneitiesTotalCount() {
    return 3;
}
#method_after
@Override
protected int getEneitiesTotalCount() {
    return 4;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    if (ImagesHandler.isHostedEngineDisk(disk)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOSTED_ENGINE_DISK);
    }
    disk.setReadOnly(getParameters().isReadOnly());
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!checkDiskUsedAsOvfStore(diskValidator)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(getSnapshotsValidator().snapshotExists(getSnapshot())) || !validate(getSnapshotsValidator().snapshotTypeSupported(getSnapshot(), Collections.singletonList(SnapshotType.REGULAR))))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addCanDoActionMessageVariable("diskAliases", disk.getDiskAlias());
            return false;
        }
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return canPerformDiskHotPlug(disk);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    DiskValidator oldDiskValidator = new DiskValidator(disk);
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    disk.setReadOnly(getParameters().isReadOnly());
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!checkDiskUsedAsOvfStore(diskValidator)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(getSnapshotsValidator().snapshotExists(getSnapshot())) || !validate(getSnapshotsValidator().snapshotTypeSupported(getSnapshot(), Collections.singletonList(SnapshotType.REGULAR))))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addCanDoActionMessageVariable("diskAliases", disk.getDiskAlias());
            return false;
        }
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return canPerformDiskHotPlug(disk);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getDisk() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    if (ImagesHandler.isHostedEngineDisk(getDisk())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOSTED_ENGINE_DISK);
    }
    return validateAllVmsForDiskAreDown() && canRemoveDiskBasedOnStorageTypeCheck();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getDisk() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    DiskValidator oldDiskValidator = new DiskValidator(getDisk());
    return validate(oldDiskValidator.validateNotHostedEngineDisk()) && validateAllVmsForDiskAreDown() && canRemoveDiskBasedOnStorageTypeCheck();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (ImagesHandler.isHostedEngineDisk(getOldDisk())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOSTED_ENGINE_DISK);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__PROVIDER_CERTIFICATE);
}
#end_block

#method_before
private void handleException(Throwable e) {
    log.error(String.format("Failed to import certificate: %1$s", e.getMessage()));
    log.debug("Exception", e);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__PROVIDER_CERTIFICATE);
}
#method_after
private void handleException(Throwable e) {
    log.error(String.format("Failed to import certificate: %1$s", e.getMessage()));
    log.debug("Exception", e);
    throw new VdcBLLException(VdcBllErrors.PROVIDER_IMPORT_CERTIFICATE_ERROR, e.getMessage());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!setAndValidateDiskProfiles()) {
            return false;
        }
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#end_block

#method_before
private AuditLogType getExecuteAuditLogTypeValue(boolean successful) {
    boolean isVmNameExist = StringUtils.isNotEmpty(getVmName());
    if (successful) {
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM;
        } else {
            return AuditLogType.USER_ADD_DISK;
        }
    } else {
        if (isVmNameExist) {
            return AuditLogType.USER_FAILED_ADD_DISK_TO_VM;
        } else {
            return AuditLogType.USER_FAILED_ADD_DISK;
        }
    }
}
#method_after
private AuditLogType getExecuteAuditLogTypeValue(boolean successful) {
    boolean isVmNameExist = StringUtils.isNotEmpty(getVmName());
    if (successful) {
        if (isInternalExecution()) {
            return AuditLogType.ADD_DISK_INTERNAL;
        }
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM;
        } else {
            return AuditLogType.USER_ADD_DISK;
        }
    } else {
        if (isInternalExecution()) {
            return AuditLogType.ADD_DISK_INTERNAL_FAILURE;
        }
        if (isVmNameExist) {
            return AuditLogType.USER_FAILED_ADD_DISK_TO_VM;
        } else {
            return AuditLogType.USER_FAILED_ADD_DISK;
        }
    }
}
#end_block

#method_before
private void detach() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachStorageTitle());
    model.setHelpTag(HelpTag.detach_storage);
    // $NON-NLS-1$
    model.setHashName("detach_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDetachStorageFromDcsMsg());
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        StorageDomain a = (StorageDomain) item;
        items.add(a.getStoragePoolName());
    }
    model.setItems(items);
    if (containsLocalStorage(model)) {
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangable(true);
        model.setNote(ConstantsManager.getInstance().getMessages().detachNote(getLocalStoragesFormattedString()));
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnDetach", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void detach() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachStorageTitle());
    model.setHelpTag(HelpTag.detach_storage);
    // $NON-NLS-1$
    model.setHashName("detach_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDetachStorageFromDcsMsg());
    ArrayList<String> items = new ArrayList<String>();
    boolean shouldAddressWarnning = false;
    for (Object item : getSelectedItems()) {
        StorageDomain a = (StorageDomain) item;
        items.add(a.getStoragePoolName());
        if (a.getStorageDomainType().isDataDomain()) {
            shouldAddressWarnning = true;
            break;
        }
    }
    model.setItems(items);
    if (containsLocalStorage(model)) {
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangable(true);
        shouldAddressWarnning = false;
        model.setNote(ConstantsManager.getInstance().getMessages().detachNote(getLocalStoragesFormattedString()));
    }
    if (shouldAddressWarnning) {
        model.setNote(ConstantsManager.getInstance().getConstants().detachWarnningNote());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnDetach", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
protected List<Pair<Guid, Boolean>> connectHostsInUpToDomainStorageServer() {
    List<VDS> hostsInStatusUp = getAllRunningVdssInPool();
    List<Callable<Pair<Guid, Boolean>>> callables = new LinkedList<>();
    for (final VDS vds : hostsInStatusUp) {
        callables.add(new Callable<Pair<Guid, Boolean>>() {

            @Override
            public Pair<Guid, Boolean> call() throws Exception {
                Pair<Guid, Boolean> toReturn = new Pair<>(vds.getId(), Boolean.FALSE);
                try {
                    boolean connectResult = StorageHelperDirector.getInstance().getItem(getStorageDomain().getStorageType()).connectStorageToDomainByVdsId(getStorageDomain(), vds.getId());
                    toReturn.setSecond(connectResult);
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to connect host {0} to storage domain (name: {1}, id: {2}). Exception: {3}", vds.getName(), getStorageDomain().getName(), getStorageDomain().getId(), e);
                }
                return toReturn;
            }
        });
    }
    return ThreadPoolUtil.invokeAll(callables);
}
#method_after
protected List<Pair<Guid, Boolean>> connectHostsInUpToDomainStorageServer() {
    List<VDS> hostsInStatusUp = getAllRunningVdssInPool();
    List<Callable<Pair<Guid, Boolean>>> callables = new LinkedList<>();
    for (final VDS vds : hostsInStatusUp) {
        callables.add(new Callable<Pair<Guid, Boolean>>() {

            @Override
            public Pair<Guid, Boolean> call() throws Exception {
                Pair<Guid, Boolean> toReturn = new Pair<>(vds.getId(), Boolean.FALSE);
                try {
                    boolean connectResult = StorageHelperDirector.getInstance().getItem(getStorageDomain().getStorageType()).connectStorageToDomainByVdsId(getStorageDomain(), vds.getId());
                    toReturn.setSecond(connectResult);
                } catch (RuntimeException e) {
                    log.error("Failed to connect host '{}' to storage domain (name '{}', id '{}'): {}", vds.getName(), getStorageDomain().getName(), getStorageDomain().getId(), e.getMessage());
                    log.debug("Exception", e);
                }
                return toReturn;
            }
        });
    }
    return ThreadPoolUtil.invokeAll(callables);
}
#end_block

#method_before
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warnFormat("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    if (storageDomains.isEmpty()) {
        log.warnFormat("Cannot elect new master, no storage domains found for pool {0}", getStoragePool().getName());
        return null;
    }
    Collections.sort(storageDomains, LastTimeUsedAsMasterComp.instance);
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#method_after
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warn("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    if (storageDomains.isEmpty()) {
        log.warn("Cannot elect new master, no storage domains found for pool {}", getStoragePool().getName());
        return null;
    }
    Collections.sort(storageDomains, LastTimeUsedAsMasterComp.instance);
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#end_block

#method_before
public void updateOvfData(List<StoragePool> storagePools) {
    log.info("Attempting to update VMs/Templates Ovf.");
    for (StoragePool pool : storagePools) {
        VdcReturnValueBase returnValueBase = performOvfUpdateForStoragePool(pool.getId());
        if (!returnValueBase.getSucceeded()) {
            log.errorFormat("Exception while trying to update or remove VMs/Templates ovf in Data Center {0}.", pool.getName());
        }
        if (ovfOnAnyDomainSupported(pool)) {
            log.infoFormat("Attempting to update ovfs in domain in Data Center {0}", pool.getName());
            Set<Guid> domainsToUpdate = (Set<Guid>) returnValueBase.getActionReturnValue();
            if (domainsToUpdate != null) {
                for (Guid id : domainsToUpdate) {
                    performOvfUpdateForDomain(pool.getId(), id);
                }
            }
        }
    }
}
#method_after
public void updateOvfData(List<StoragePool> storagePools) {
    log.info("Attempting to update VMs/Templates Ovf.");
    for (StoragePool pool : storagePools) {
        VdcReturnValueBase returnValueBase = performOvfUpdateForStoragePool(pool.getId());
        if (!returnValueBase.getSucceeded()) {
            log.error("Exception while trying to update or remove VMs/Templates ovf in Data Center '{}'.", pool.getName());
        }
        if (ovfOnAnyDomainSupported(pool)) {
            log.debug("Attempting to update ovfs in domain in Data Center '{}'", pool.getName());
            Set<Guid> domainsToUpdate = (Set<Guid>) returnValueBase.getActionReturnValue();
            if (domainsToUpdate != null) {
                for (Guid id : domainsToUpdate) {
                    performOvfUpdateForDomain(pool.getId(), id);
                }
            } else {
                log.error("Data Center '{}' domains list for OVF update returned as NULL");
            }
        }
    }
}
#end_block

#method_before
private boolean performOvfUpdateForDomain(byte[] ovfData, StorageDomainOvfInfo storageDomainOvfInfo, DiskImage ovfDisk, List<Guid> vmAndTemplatesIds) {
    Guid storagePoolId = ovfDisk.getStoragePoolId();
    Guid storageDomainId = ovfDisk.getStorageIds().get(0);
    Guid diskId = ovfDisk.getId();
    Guid volumeId = ovfDisk.getImageId();
    storageDomainOvfInfo.setStoredOvfIds(null);
    try {
        setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, generateOvfStoreDescription(storageDomainOvfInfo.getLastUpdated(), false, null));
        getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ovfData);
        Long size = Long.valueOf(ovfData.length);
        UploadStreamParameters uploadStreamParameters = new UploadStreamParameters(storagePoolId, storageDomainId, diskId, volumeId, byteArrayInputStream, size);
        if (hasParentCommand()) {
            uploadStreamParameters.setParentCommand(getParameters().getParentCommand());
            uploadStreamParameters.setParentParameters(getParameters().getParentParameters());
        } else {
            uploadStreamParameters.setParentCommand(getActionType());
            uploadStreamParameters.setParentParameters(getParameters());
        }
        VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.UploadStream, uploadStreamParameters);
        if (vdcReturnValueBase.getSucceeded()) {
            storageDomainOvfInfo.setStatus(StorageDomainOvfInfoStatus.UPDATED);
            storageDomainOvfInfo.setStoredOvfIds(vmAndTemplatesIds);
            storageDomainOvfInfo.setLastUpdated(updateDate);
            setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, getPostUpdateOvfStoreDescription(size));
            getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
            if (hasParentCommand()) {
                getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
            } else {
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
            }
            return true;
        }
    } catch (VdcBLLException e) {
        log.warnFormat("failed to update domain {0} ovf store disk {1}", storageDomainId, diskId);
    }
    failedOvfDisks.add(diskId);
    return false;
}
#method_after
private boolean performOvfUpdateForDomain(byte[] ovfData, StorageDomainOvfInfo storageDomainOvfInfo, DiskImage ovfDisk, List<Guid> vmAndTemplatesIds) {
    Guid storagePoolId = ovfDisk.getStoragePoolId();
    Guid storageDomainId = ovfDisk.getStorageIds().get(0);
    Guid diskId = ovfDisk.getId();
    Guid volumeId = ovfDisk.getImageId();
    storageDomainOvfInfo.setStoredOvfIds(null);
    try {
        setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, generateOvfStoreDescription(storageDomainOvfInfo.getLastUpdated(), false, null));
        getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ovfData);
        Long size = Long.valueOf(ovfData.length);
        UploadStreamParameters uploadStreamParameters = new UploadStreamParameters(storagePoolId, storageDomainId, diskId, volumeId, byteArrayInputStream, size);
        if (hasParentCommand()) {
            uploadStreamParameters.setParentCommand(getParameters().getParentCommand());
            uploadStreamParameters.setParentParameters(getParameters().getParentParameters());
        } else {
            uploadStreamParameters.setParentCommand(getActionType());
            uploadStreamParameters.setParentParameters(getParameters());
        }
        VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.UploadStream, uploadStreamParameters);
        if (vdcReturnValueBase.getSucceeded()) {
            storageDomainOvfInfo.setStatus(StorageDomainOvfInfoStatus.UPDATED);
            storageDomainOvfInfo.setStoredOvfIds(vmAndTemplatesIds);
            storageDomainOvfInfo.setLastUpdated(updateDate);
            setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, getPostUpdateOvfStoreDescription(size));
            getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
            if (hasParentCommand()) {
                getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
            } else {
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
            }
            return true;
        }
    } catch (VdcBLLException e) {
        log.warn("failed to update domain '{}' ovf store disk '{}'", storageDomainId, diskId);
    }
    failedOvfDisks.add(diskId);
    return false;
}
#end_block

#method_before
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, getExecutionContext());
}
#method_after
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return commandObjectsHandlerProvider.get().runAction(command, getExecutionContext());
}
#end_block

#method_before
protected BackendInternal getBackend() {
    return Backend.getInstance();
}
#method_after
protected BackendInternal getBackend() {
    return Injector.get(BackendInternal.class);
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        ExecutionHandler.startFinalizingStep(getExecutionContext());
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("endAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        ExecutionHandler.startFinalizingStep(getExecutionContext());
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            setCommandStatus(CommandStatus.SUCCEEDED);
            internalEndSuccessfully();
        } else {
            setCommandStatus(CommandStatus.FAILED);
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            if (getCallBack() == null) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            internalEndSuccessfully();
        } else {
            if (getCallBack() == null) {
                setCommandStatus(CommandStatus.FAILED);
            }
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected void logExceptionAndCompensate(Exception e) {
    log.errorFormat("Exception while wrapping-up compensation in endAction: {0}.", ExceptionUtils.getMessage(e), e);
    compensate();
}
#method_after
protected void logExceptionAndCompensate(Exception e) {
    log.error("Exception while wrapping-up compensation in endAction", e);
    compensate();
}
#end_block

#method_before
private void internalEndSuccessfully() {
    log.infoFormat("Ending command successfully: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endSuccessfully();
        getParameters().incrementExecutionIndex();
        if (getExecutionIndex() < getTaskHandlers().size()) {
            _actionState = CommandActionState.EXECUTE;
            execute();
        }
    } else {
        endSuccessfully();
    }
}
#method_after
private void internalEndSuccessfully() {
    log.info("Ending command '{}' successfully.", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endSuccessfully();
        getParameters().incrementExecutionIndex();
        if (getExecutionIndex() < getTaskHandlers().size()) {
            _actionState = CommandActionState.EXECUTE;
            execute();
        }
    } else {
        endSuccessfully();
    }
}
#end_block

#method_before
private void internalEndWithFailure() {
    log.errorFormat("Ending command with failure: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        if (hasStepsToRevert()) {
            getCurrentTaskHandler().endWithFailure();
            revertPreviousHandlers();
        }
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollbackQuota();
}
#method_after
private void internalEndWithFailure() {
    log.error("Ending command '{}' with failure.", getClass().getName());
    if (hasTaskHandlers()) {
        if (hasStepsToRevert()) {
            getCurrentTaskHandler().endWithFailure();
            revertPreviousHandlers();
        } else {
            // since no handlers have been run we don't have to retry endAction
            getReturnValue().setEndActionTryAgain(false);
        }
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollbackQuota();
}
#end_block

#method_before
protected void logRollbackedTask() {
    String type = (getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name());
    log.errorFormat("Reverting task {0}, handler: {1}", type, getCurrentTaskHandler().getClass().getName());
}
#method_after
protected void logRollbackedTask() {
    String type = (getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name());
    log.error("Reverting task '{}', handler '{}'", type, getCurrentTaskHandler().getClass().getName());
}
#end_block

#method_before
private boolean internalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = TransactionSupport.suspend();
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warnFormat("CanDoAction of action {0} failed. Reasons:{1}", getActionType(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            TransactionSupport.resume(transaction);
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#method_after
private boolean internalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = TransactionSupport.suspend();
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warn("CanDoAction of action '{}' failed. Reasons: {}", getActionType(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            TransactionSupport.resume(transaction);
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean checkUserAuthorization(Guid userId, final ActionGroup actionGroup, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final Guid permId = getDbFacade().getPermissionDao().getEntityPermissions(userId, actionGroup, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAuthorization(Guid userId, final ActionGroup actionGroup, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final Guid permId = getDbFacade().getPermissionDao().getEntityPermissions(userId, actionGroup, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debug("Found permission '{}' for user when running '{}', on '{}' with id '{}'", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debug("No permission found for user when running action '{}', on object '{}' for action group '{}' with id '{}'.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, Collection<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debugFormat("Checking whether user {0} or groups {1} have action group {3} on object type {4}", userId, StringUtils.join(groupIds, ","), actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, Collection<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debug("Checking whether user '{}' or groups '{}' have action group '{}' on object type '{}'", userId, groupIds, actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debug("Found permission '{}' for user when running '{}', on '{}' with id '{}'", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debug("No permission found for user when running action '{}', on object '{}' for action group '{}' with id '{}'.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    if (log.isDebugEnabled()) {
        StringBuilder builder = getPermissionSubjectsAsStringBuilder(permSubjects);
        log.debugFormat("Checking whether user {0} or one of the groups he is member of, have the following permissions: {1}", getCurrentUser().getId(), builder.toString());
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#method_after
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debug("Permission check skipped for internal action {}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debug("Permission check for action '{}' skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debug("The set of objects to check is null or empty for action '{}'.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    if (log.isDebugEnabled()) {
        StringBuilder builder = getPermissionSubjectsAsStringBuilder(permSubjects);
        log.debug("Checking whether user '{}' or one of the groups he is member of, have the following permissions: {}", getCurrentUser().getId(), builder.toString());
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#end_block

#method_before
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            log.infoFormat("No permission found for user {0} or one of the groups he is member of," + " when running action {1}, Required permissions are: Action type: {2} Action group: {3}" + " Object type: {4}  Object ID: {5}.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            log.info("No permission found for user '{}' or one of the groups he is member of," + " when running action '{}', Required permissions are: Action type: '{}' Action group: '{}'" + " Object type: '{}'  Object ID: '{}'.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
final protected boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The object to check is null for action {0}.", getActionType());
        }
        messages.add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("No action group is defined for action {0}.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#method_after
final protected boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debug("The object to check is null for action '{}'.", getActionType());
        }
        messages.add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debug("No action group is defined for action '{}'.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            clearChildAsyncTasksWithOutVdsmId();
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to SUCCEEDED if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallBack() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            clearChildAsyncTasksWithOutVdsmId();
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to SUCCEEDED if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallBack() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = getPermissionSubjectsAsStringBuilder(permissionSubjectList);
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = getPermissionSubjectsAsStringBuilder(permissionSubjectList);
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info("{}", logInfo);
}
#end_block

#method_before
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    if (getCallBack() != null) {
        persistCommand(getParameters().getParentCommand(), true);
    }
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    if (getCallBack() != null) {
        persistCommand(getParameters().getParentCommand(), true);
    }
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                log.infoFormat("Command {0} persisting async task placeholder for child command {1}", getCommandId(), command.getCommandId());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#method_after
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = commandObjectsHandlerProvider.get().createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                log.info("Command '{}' persisting async task placeholder for child command '{}'", getCommandId(), command.getCommandId());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#end_block

#method_before
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, final String taskKey) {
    if (taskKeyToTaskIdMap.containsKey(taskKey)) {
        return taskKeyToTaskIdMap.get(taskKey);
    }
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTask task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during persistAsyncTaskPlaceHolder for command: {0}. Exception {1}", getClass().getName(), ex);
    }
    return taskId;
}
#method_after
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, final String taskKey) {
    if (taskKeyToTaskIdMap.containsKey(taskKey)) {
        return taskKeyToTaskIdMap.get(taskKey);
    }
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTask task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.error("Error during persistAsyncTaskPlaceHolder for command '{}': {}", getClass().getName(), ex.getMessage());
        log.error("Exception", ex);
    }
    return taskId;
}
#end_block

#method_before
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        return createTaskImpl(taskId, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during createTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return Guid.Empty;
}
#method_after
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        return createTaskImpl(taskId, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
    } catch (RuntimeException ex) {
        log.error("Error during createTask for command '{}': {}", getClass().getName(), ex.getMessage());
        log.error("Exception", ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return Guid.Empty;
}
#end_block

#method_before
@Override
public void rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.error("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#method_after
@Override
public void rollback() {
    log.error("Transaction rolled-back for command '{}'.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.error("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#end_block

#method_before
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                context.withLock(lock);
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.info("Lock Acquired to object '{}'", lock);
                context.withLock(lock);
            } else {
                log.info("Failed to Acquire Lock to object '{}'", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.infoFormat("Lock freed to object {0}", context.getLock());
        context.withLock(null);
    }
}
#method_after
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.info("Lock freed to object '{}'", context.getLock());
        context.withLock(null);
    }
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        if (validationResult.getVariableReplacements() != null) {
            for (String variableReplacement : validationResult.getVariableReplacements()) {
                addCanDoActionMessage(variableReplacement);
            }
        }
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            addCanDoActionMessage(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#end_block

#method_before
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Execution);
}
#method_after
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    Scope scope = getParameters().isSkipLock() ? Scope.None : Scope.Execution;
    return lockProperties.withScope(scope);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    proceedStorageDomainTreatmentByDomainType(false);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    if (_isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure to stop SPM");
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, _newMasterStorageDomainId);
                return null;
            }
        });
        if (spm != null) {
            getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
        }
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.Inactive);
            } else if (_isLastMaster) {
                map.setStatus(StorageDomainStatus.Maintenance);
            } else {
                log.infoFormat("Domain {0} will remain in {1} status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (!Guid.Empty.equals(_newMasterStorageDomainId)) {
                StoragePoolIsoMap mapOfNewMaster = getNewMaster(false).getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    proceedStorageDomainTreatmentByDomainType(false);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    if (_isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure to stop SPM");
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, _newMasterStorageDomainId);
                return null;
            }
        });
        if (spm != null) {
            getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
        }
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.Inactive);
            } else if (_isLastMaster) {
                map.setStatus(StorageDomainStatus.Maintenance);
            } else {
                log.info("Domain '{}' will remain in '{}' status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (!Guid.Empty.equals(_newMasterStorageDomainId)) {
                StoragePoolIsoMap mapOfNewMaster = getNewMaster(false).getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Locked);
    if (shouldPerformOvfUpdate()) {
        Backend.getInstance().runInternalAction(VdcActionType.ProcessOvfUpdateForStoragePool, new StoragePoolParametersBase(getStoragePoolId()));
        VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.ProcessOvfUpdateForStorageDomain, createProcessOvfUpdateForDomainParams(), getLock());
        getReturnValue().getVdsmTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    }
    if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
        executeDeactivateCommnad();
    } else {
        setCommandShouldBeLogged(false);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Locked);
    if (shouldPerformOvfUpdate()) {
        runInternalAction(VdcActionType.ProcessOvfUpdateForStoragePool, new StoragePoolParametersBase(getStoragePoolId()), null);
        VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.ProcessOvfUpdateForStorageDomain, createProcessOvfUpdateForDomainParams(), null);
        getReturnValue().getVdsmTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    }
    if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
        executeDeactivateCommnad(true);
    } else {
        setCommandShouldBeLogged(false);
    }
    setSucceeded(true);
}
#end_block

#method_before
private void executeDeactivateCommnad() {
    final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(getStorageDomainId(), getStoragePoolId());
    params.setSkipChecks(true);
    runInternalAction(VdcActionType.DeactivateStorageDomain, params, cloneContextAndDetachFromParent());
}
#method_after
private boolean executeDeactivateCommnad(boolean passContext) {
    final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(getStorageDomainId(), getStoragePoolId());
    params.setSkipChecks(true);
    params.setSkipLock(true);
    CommandContext context = passContext ? cloneContext() : null;
    return getBackend().runInternalAction(VdcActionType.DeactivateStorageDomain, params, context).getSucceeded();
}
#end_block

#method_before
protected void deactivateStorageDomainAfterTaskExecution() {
    final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(getStorageDomainId(), getStoragePoolId());
    params.setSkipChecks(true);
    boolean newThread = getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getNewMaster(false) == null;
    if (newThread) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    waitForTasksToBeCleared();
                    executeDeactivateCommnad();
                } catch (Exception e) {
                    setSucceeded(false);
                    log.errorFormat("Error when attempting to deactivate storage domain {0}", getStorageDomainId(), e);
                    compensate();
                }
            }
        });
    } else {
        executeDeactivateCommnad();
    }
}
#method_after
protected void deactivateStorageDomainAfterTaskExecution() {
    final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(getStorageDomainId(), getStoragePoolId());
    params.setSkipChecks(true);
    boolean newThread = getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getNewMaster(false) == null;
    if (newThread) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    waitForTasksToBeCleared();
                    executeDeactivateCommnad(false);
                } catch (Exception e) {
                    setSucceeded(false);
                    log.error("Error when attempting to deactivate storage domain {}", getStorageDomainId(), e);
                    compensate();
                }
            }
        });
    } else {
        executeDeactivateCommnad(false);
    }
}
#end_block

#method_before
protected void waitForTasksToBeCleared() throws InterruptedException {
    while (true) {
        Thread.sleep(3000);
        List<Guid> tasks = getDbFacade().getAsyncTaskDao().getAsyncTaskIdsByEntity(getStorageDomainId());
        if (tasks.isEmpty()) {
            return;
        }
    }
}
#method_after
protected void waitForTasksToBeCleared() throws InterruptedException {
    log.info("waiting for all tasks related to domain {} to be cleared (if exist) before attempting to deactivate", getStorageDomainId());
    while (true) {
        TimeUnit.SECONDS.sleep(3);
        List<Guid> tasks = getDbFacade().getAsyncTaskDao().getAsyncTaskIdsByEntity(getStorageDomainId());
        if (tasks.isEmpty()) {
            log.info("no tasks for the deactivated domain {}, proceeding with deactivation", getStorageDomainId());
            return;
        } else {
            log.info("tasks {} were found for domain {}, waiting before attempting to deactivate", tasks, getStorageDomainId());
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    for (int i = 0; i < getParameters().getStoresCount(); i++) {
        CreateOvfVolumeForStorageDomainCommandParameters parameters = new CreateOvfVolumeForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId());
        parameters.setSkipDomainChecks(getParameters().isSkipDomainChecks());
        if (hasParentCommand()) {
            parameters.setParentCommand(getParameters().getParentCommand());
            parameters.setParentParameters(getParameters().getParentParameters());
        } else {
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
        }
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.CreateOvfVolumeForStorageDomain, parameters);
        getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    for (int i = 0; i < getParameters().getStoresCount(); i++) {
        CreateOvfVolumeForStorageDomainCommandParameters parameters = createCreateOvfVolumeForStorageDomainParams();
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.CreateOvfVolumeForStorageDomain, parameters);
        getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
    }
    setSucceeded(true);
}
#end_block

#method_before
private ProcessOvfUpdateForStorageDomainCommandParameters createProcessOvfUpdateForDomainParams() {
    ProcessOvfUpdateForStorageDomainCommandParameters params = new ProcessOvfUpdateForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId());
    params.setSkipDomainChecks(getParameters().isSkipDomainChecks());
    params.setParentCommand(getParameters().getParentCommand());
    params.setSkipDomainChecks(getParameters().isSkipDomainChecks());
    params.setParentParameters(getParameters().getParentParameters());
    return params;
}
#method_after
private ProcessOvfUpdateForStorageDomainCommandParameters createProcessOvfUpdateForDomainParams() {
    ProcessOvfUpdateForStorageDomainCommandParameters params = new ProcessOvfUpdateForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId());
    params.setSkipDomainChecks(getParameters().isSkipDomainChecks());
    params.setParentCommand(getParameters().getParentCommand());
    params.setParentParameters(getParameters().getParentParameters());
    return params;
}
#end_block

#method_before
@Override
protected StorageDomain addParents(StorageDomain storageDomain) {
    storageDomain.setDataCenter(new DataCenter());
    storageDomain.getDataCenter().setId(dataCenterId.toString());
    return storageDomain;
}
#method_after
@Override
protected StorageDomain addParents(StorageDomain storageDomain) {
    // This is for backwards compatibility and will be removed in the future:
    storageDomain.setDataCenter(new DataCenter());
    storageDomain.getDataCenter().setId(dataCenterId.toString());
    // Find all the data centers that this storage domain is attached to and add references to them:
    StorageDomainHelper.addAttachedDataCenterReferences(this, storageDomain);
    return storageDomain;
}
#end_block

#method_before
public void detach() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachStorageTitle());
    model.setHelpTag(HelpTag.detach_storage);
    // $NON-NLS-1$
    model.setHashName("detach_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDetachFollowingStoragesMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (StorageDomain item : Linq.<StorageDomain>cast(getSelectedItems())) {
        list.add(item.getStorageName());
    }
    model.setItems(list);
    if (containsLocalStorage(model)) {
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangable(true);
        model.setNote(ConstantsManager.getInstance().getMessages().detachNote(getLocalStoragesFormattedString()));
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnDetach", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void detach() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachStorageTitle());
    model.setHelpTag(HelpTag.detach_storage);
    // $NON-NLS-1$
    model.setHashName("detach_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDetachFollowingStoragesMsg());
    ArrayList<String> list = new ArrayList<String>();
    boolean shouldAddressWarnning = false;
    for (StorageDomain item : Linq.<StorageDomain>cast(getSelectedItems())) {
        list.add(item.getStorageName());
        if (item.getStorageDomainType().isDataDomain()) {
            shouldAddressWarnning = true;
            break;
        }
    }
    model.setItems(list);
    if (containsLocalStorage(model)) {
        shouldAddressWarnning = false;
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangable(true);
        model.setNote(ConstantsManager.getInstance().getMessages().detachNote(getLocalStoragesFormattedString()));
    }
    if (shouldAddressWarnning) {
        model.setNote(ConstantsManager.getInstance().getConstants().detachWarnningNote());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnDetach", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
protected void deactivateStorageDomainAfterTaskExecution() {
    final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(getStorageDomainId(), getStoragePoolId());
    params.setSkipChecks(true);
    boolean newThread = getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getNewMaster(false) == null;
    if (newThread) {
        StoragePoolIsoMap map = loadStoragePoolIsoMap();
        final CompensationContext ctx = createDefaultCompensationContext(Guid.newGuid());
        changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Locked, ctx);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    waitForTasksToBeCleared();
                    executeDeactivateCommnad(false);
                    ctx.resetCompensation();
                } catch (Exception e) {
                    setSucceeded(false);
                    log.error("Error when attempting to deactivate storage domain {}", getStorageDomainId(), e);
                    compensate();
                }
            }
        });
    } else {
        executeDeactivateCommnad(false);
    }
}
#method_after
protected void deactivateStorageDomainAfterTaskExecution() {
    final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(getStorageDomainId(), getStoragePoolId());
    params.setSkipChecks(true);
    boolean newThread = getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getNewMaster(false) == null;
    if (newThread) {
        StoragePoolIsoMap map = loadStoragePoolIsoMap();
        // The creation of the compensation context is needed in case of an engine restart between the tasks clearance and the
        // execution of the deactivate command from the new thread. If the compensation context won't be created and the tasks
        // will be cleared, when the engine start there's nothing to start the thread (as the end method won't be called as there
        // are no tasks) and the domain will remain locked.
        final CompensationContext ctx = createDefaultCompensationContext(Guid.newGuid());
        changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Locked, ctx);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    waitForTasksToBeCleared();
                    executeDeactivateCommnad(false);
                    ctx.resetCompensation();
                } catch (Exception e) {
                    setSucceeded(false);
                    log.error("Error when attempting to deactivate storage domain {}", getStorageDomainId(), e);
                    compensate();
                }
            }
        });
    } else {
        executeDeactivateCommnad(false);
    }
}
#end_block

#method_before
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, getExecutionContext());
}
#method_after
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return commandObjectsHandlerProvider.get().runAction(command, getExecutionContext());
}
#end_block

#method_before
protected BackendInternal getBackend() {
    return Backend.getInstance();
}
#method_after
protected BackendInternal getBackend() {
    return Injector.get(BackendInternal.class);
}
#end_block

#method_before
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                log.info("Command '{}' persisting async task placeholder for child command '{}'", getCommandId(), command.getCommandId());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#method_after
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = commandObjectsHandlerProvider.get().createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                log.info("Command '{}' persisting async task placeholder for child command '{}'", getCommandId(), command.getCommandId());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmStatic vm) {
    return createBaseParametersMapper(vm).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("is_initialized", vm.isInitialized()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR).addValue("numatune_mode", vm.getNumaTuneMode() == null ? NumaTuneMode.INTERLEAVE.getValue() : vm.getNumaTuneMode().getValue());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmStatic vm) {
    return createBaseParametersMapper(vm).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("is_initialized", vm.isInitialized()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR);
}
#end_block

#method_before
public List<Guid> getVmAndTemplatesIdsWithoutAttachedImageDisks(boolean shareableDisks, boolean snapshotDisks) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("active", !snapshotDisks).addValue("shareable", shareableDisks);
    return getCallsHandler().executeReadList("GetVmAndTemplatesIdsWithoutAttachedImageDisks", createGuidMapper(), parameterSource);
}
#method_after
public List<Guid> getVmAndTemplatesIdsWithoutAttachedImageDisks(boolean shareableDisks) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("shareable", shareableDisks);
    return getCallsHandler().executeReadList("GetVmsAndTemplatesIdsWithoutAttachedImageDisks", createGuidMapper(), parameterSource);
}
#end_block

#method_before
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    return entity;
}
#method_after
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    itemsCountPerUpdate = loadConfigValue();
    proccessedDomains = new HashSet<>();
    StoragePool pool = getStoragePool();
    if (ovfOnAnyDomainSupported(pool)) {
        proccessDomainsForOvfUpdate(pool);
    }
    logInfoIfNeeded(pool, "Attempting to update VM OVFs in Data Center {0}", pool.getName());
    initProcessedInfoLists();
    updateOvfForVmsOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully updated VM OVFs in Data Center {0}", pool.getName());
    logInfoIfNeeded(pool, "Attempting to update template OVFs in Data Center {0}", pool.getName());
    updateOvfForTemplatesOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully updated templates OVFs in Data Center {0}", pool.getName());
    logInfoIfNeeded(pool, "Attempting to remove unneeded template/vm OVFs in Data Center {0}", pool.getName());
    removeOvfForTemplatesAndVmsOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully removed unneeded template/vm OVFs in Data Center {0}", pool.getName());
    getReturnValue().setActionReturnValue(proccessedDomains);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    itemsCountPerUpdate = loadConfigValue();
    proccessedDomains = new HashSet<>();
    StoragePool pool = getStoragePool();
    if (ovfOnAnyDomainSupported(pool)) {
        proccessDomainsForOvfUpdate(pool);
    }
    logInfoIfNeeded(pool, "Attempting to update VM OVFs in Data Center '{}'", pool.getName());
    initProcessedInfoLists();
    updateOvfForVmsOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully updated VM OVFs in Data Center '{}'", pool.getName());
    logInfoIfNeeded(pool, "Attempting to update template OVFs in Data Center '{}'", pool.getName());
    updateOvfForTemplatesOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully updated templates OVFs in Data Center '{}'", pool.getName());
    logInfoIfNeeded(pool, "Attempting to remove unneeded template/vm OVFs in Data Center '{}'", pool.getName());
    removeOvfForTemplatesAndVmsOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully removed unneeded template/vm OVFs in Data Center '{}'", pool.getName());
    getReturnValue().setActionReturnValue(proccessedDomains);
    setSucceeded(true);
}
#end_block

#method_before
private void logInfoIfNeeded(StoragePool pool, String message, Object... args) {
    // if supported, the info would be logged when executing for each domain
    if (!ovfOnAnyDomainSupported(pool)) {
        log.infoFormat(message, args);
    }
}
#method_after
private void logInfoIfNeeded(StoragePool pool, String message, Object... args) {
    // if supported, the info would be logged when executing for each domain
    if (!ovfOnAnyDomainSupported(pool)) {
        log.info(message, args);
    }
}
#end_block

#method_before
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VM> vms = getVmDAO().getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            if (!verifyImagesStatus(vm.getDiskList())) {
                continue;
            }
            ArrayList<DiskImage> vmImages = getOvfUpdateProcessHelper().getVmImagesFromDb(vm);
            if (!verifyImagesStatus(vmImages)) {
                continue;
            }
            vm.setSnapshots(getSnapshotDAO().getAllWithConfiguration(vm.getId()));
            if (!verifySnapshotsStatus(vm.getSnapshots())) {
                continue;
            }
            getOvfUpdateProcessHelper().loadVmData(vm);
            Long currentDbGeneration = getVmStaticDAO().getDbGeneration(vm.getId());
            if (currentDbGeneration == null) {
                log.warnFormat("currentDbGeneration of VM (name: {0}, id: {1}) is null, probably because the VM was deleted during the run of OvfDataUpdater.", vm.getName(), vm.getId());
                continue;
            }
            if (vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                proccessedOvfConfigurationsInfo.add(getOvfUpdateProcessHelper().buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata, vmImages));
                proccessedIdsInfo.add(vm.getId());
                proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                proccessDisksDomains(vm.getDiskList());
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#method_after
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VM> vms = getVmDAO().getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            if (!verifyImagesStatus(vm.getDiskList())) {
                continue;
            }
            ArrayList<DiskImage> vmImages = getOvfUpdateProcessHelper().getVmImagesFromDb(vm);
            if (!verifyImagesStatus(vmImages)) {
                continue;
            }
            vm.setSnapshots(getSnapshotDAO().getAllWithConfiguration(vm.getId()));
            if (!verifySnapshotsStatus(vm.getSnapshots())) {
                continue;
            }
            getOvfUpdateProcessHelper().loadVmData(vm);
            Long currentDbGeneration = getVmStaticDAO().getDbGeneration(vm.getId());
            if (currentDbGeneration == null) {
                log.warn("currentDbGeneration of VM (name: '{}', id: '{}') is null, probably because the VM was deleted during the run of OvfDataUpdater.", vm.getName(), vm.getId());
                continue;
            }
            if (vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                proccessedOvfConfigurationsInfo.add(getOvfUpdateProcessHelper().buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata, vmImages));
                proccessedIdsInfo.add(vm.getId());
                proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                proccessDisksDomains(vm.getDiskList());
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    loadStorageDomain();
    if (!isInternalExecution()) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    loadStorageDomain();
    if (!getParameters().isSkipDomainChecks()) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private byte[] buildOvfInfoFileByteArray(List<Guid> vmAndTemplatesIds) {
    ByteArrayOutputStream bufferedOutputStream = new ByteArrayOutputStream();
    try (InMemoryTar inMemoryTar = new InMemoryTar(bufferedOutputStream)) {
        inMemoryTar.addTarEntry(generateInfoFileData().getBytes(), "info.json");
        int i = 0;
        while (i < vmAndTemplatesIds.size()) {
            int size = Math.min(StorageConstants.OVF_MAX_ITEMS_PER_SQL_STATEMENT, vmAndTemplatesIds.size() - i);
            List<Guid> idsToProcess = vmAndTemplatesIds.subList(i, i + size);
            i += size;
            List<Pair<Guid, String>> ovfs = getVmAndTemplatesGenerationsDao().loadOvfDataForIds(idsToProcess);
            if (!ovfs.isEmpty()) {
                buildFilesForOvfs(ovfs, inMemoryTar);
            }
        }
    } catch (Exception e) {
        throw new RuntimeException(String.format("Exception while building in memory tar of the OVFs of domain %s", getParameters().getStorageDomainId()), e);
    }
    return bufferedOutputStream.toByteArray();
}
#method_after
private byte[] buildOvfInfoFileByteArray(List<Guid> vmAndTemplatesIds) {
    ByteArrayOutputStream bufferedOutputStream = new ByteArrayOutputStream();
    Set<Guid> processedIds = new HashSet<>();
    try (InMemoryTar inMemoryTar = new InMemoryTar(bufferedOutputStream)) {
        inMemoryTar.addTarEntry(generateInfoFileData().getBytes(), "info.json");
        int i = 0;
        while (i < vmAndTemplatesIds.size()) {
            int size = Math.min(StorageConstants.OVF_MAX_ITEMS_PER_SQL_STATEMENT, vmAndTemplatesIds.size() - i);
            List<Guid> idsToProcess = vmAndTemplatesIds.subList(i, i + size);
            i += size;
            List<Pair<Guid, String>> ovfs = getVmAndTemplatesGenerationsDao().loadOvfDataForIds(idsToProcess);
            if (!ovfs.isEmpty()) {
                processedIds.addAll(buildFilesForOvfs(ovfs, inMemoryTar));
            }
        }
        List<Pair<Guid, String>> unprocessedOvfData = retrieveUnprocessedUnregisteredOvfData(processedIds);
        buildFilesForOvfs(unprocessedOvfData, inMemoryTar);
    } catch (Exception e) {
        throw new RuntimeException(String.format("Exception while building in memory tar of the OVFs of domain %s", getParameters().getStorageDomainId()), e);
    }
    return bufferedOutputStream.toByteArray();
}
#end_block

#method_before
protected void updateOvfStoreContent() {
    if (domainOvfStoresInfoForUpdate.isEmpty()) {
        return;
    }
    updateDate = new Date();
    List<Guid> vmAndTemplatesIds = getStorageDomainDAO().getVmAndTemplatesIdsByStorageDomainId(getParameters().getStorageDomainId(), false, false);
    vmAndTemplatesIds.addAll(getVmStaticDAO().getVmAndTemplatesIdsWithoutAttachedImageDisks(false, false));
    byte[] bytes = buildOvfInfoFileByteArray(vmAndTemplatesIds);
    Pair<StorageDomainOvfInfo, DiskImage> lastOvfStoreForUpdate = domainOvfStoresInfoForUpdate.getLast();
    // possibly have some ovf data on storage)
    if (lastOvfStoreForUpdate.getFirst().getLastUpdated() != null) {
        domainOvfStoresInfoForUpdate.removeLast();
    } else {
        lastOvfStoreForUpdate = null;
    }
    boolean shouldUpdateLastOvfStore = false;
    failedOvfDisks = new ArrayList<>();
    for (Pair<StorageDomainOvfInfo, DiskImage> pair : domainOvfStoresInfoForUpdate) {
        shouldUpdateLastOvfStore |= performOvfUpdateForDomain(bytes, pair.getFirst(), pair.getSecond(), vmAndTemplatesIds);
    }
    // backup (if we did)
    if (shouldUpdateLastOvfStore && lastOvfStoreForUpdate != null) {
        performOvfUpdateForDomain(bytes, lastOvfStoreForUpdate.getFirst(), lastOvfStoreForUpdate.getSecond(), vmAndTemplatesIds);
    }
    if (!failedOvfDisks.isEmpty()) {
        AuditLogableBase auditLogableBase = new AuditLogableBase();
        auditLogableBase.addCustomValue("DataCenterName", getStoragePool().getName());
        auditLogableBase.addCustomValue("StorageDomainName", storageDomain.getName());
        auditLogableBase.addCustomValue("DisksIds", StringUtils.join(failedOvfDisks, ", "));
        AuditLogDirector.log(auditLogableBase, AuditLogType.UPDATE_FOR_OVF_STORES_FAILED);
    }
}
#method_after
protected void updateOvfStoreContent() {
    if (domainOvfStoresInfoForUpdate.isEmpty()) {
        return;
    }
    updateDate = new Date();
    List<Guid> vmAndTemplatesIds = getStorageDomainDAO().getVmAndTemplatesIdsByStorageDomainId(getParameters().getStorageDomainId(), false, false);
    vmAndTemplatesIds.addAll(getVmStaticDAO().getVmAndTemplatesIdsWithoutAttachedImageDisks(false));
    byte[] bytes = buildOvfInfoFileByteArray(vmAndTemplatesIds);
    Pair<StorageDomainOvfInfo, DiskImage> lastOvfStoreForUpdate = domainOvfStoresInfoForUpdate.getLast();
    // possibly have some ovf data on storage)
    if (lastOvfStoreForUpdate.getFirst().getLastUpdated() != null) {
        domainOvfStoresInfoForUpdate.removeLast();
    } else {
        lastOvfStoreForUpdate = null;
    }
    boolean shouldUpdateLastOvfStore = false;
    failedOvfDisks = new ArrayList<>();
    for (Pair<StorageDomainOvfInfo, DiskImage> pair : domainOvfStoresInfoForUpdate) {
        shouldUpdateLastOvfStore |= performOvfUpdateForDomain(bytes, pair.getFirst(), pair.getSecond(), vmAndTemplatesIds);
    }
    // backup (if we did)
    if (shouldUpdateLastOvfStore && lastOvfStoreForUpdate != null) {
        performOvfUpdateForDomain(bytes, lastOvfStoreForUpdate.getFirst(), lastOvfStoreForUpdate.getSecond(), vmAndTemplatesIds);
    }
    if (!failedOvfDisks.isEmpty()) {
        AuditLogableBase auditLogableBase = new AuditLogableBase();
        auditLogableBase.addCustomValue("DataCenterName", getStoragePool().getName());
        auditLogableBase.addCustomValue("StorageDomainName", storageDomain.getName());
        auditLogableBase.addCustomValue("DisksIds", StringUtils.join(failedOvfDisks, ", "));
        AuditLogDirector.log(auditLogableBase, AuditLogType.UPDATE_FOR_OVF_STORES_FAILED);
    }
}
#end_block

#method_before
private boolean performOvfUpdateForDomain(byte[] ovfData, StorageDomainOvfInfo storageDomainOvfInfo, DiskImage ovfDisk, List<Guid> vmAndTemplatesIds) {
    Guid storagePoolId = ovfDisk.getStoragePoolId();
    Guid storageDomainId = ovfDisk.getStorageIds().get(0);
    Guid diskId = ovfDisk.getId();
    Guid volumeId = ovfDisk.getImageId();
    storageDomainOvfInfo.setStoredOvfIds(null);
    try {
        setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, generateOvfStoreDescription(storageDomainOvfInfo.getLastUpdated(), false, null));
        getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ovfData);
        Long size = Long.valueOf(ovfData.length);
        UploadStreamParameters uploadStreamParameters = new UploadStreamParameters(storagePoolId, storageDomainId, diskId, volumeId, byteArrayInputStream, size);
        if (hasParentCommand()) {
            uploadStreamParameters.setParentCommand(getParameters().getParentCommand());
            uploadStreamParameters.setParentParameters(getParameters().getParentParameters());
        } else {
            uploadStreamParameters.setParentCommand(getActionType());
            uploadStreamParameters.setParentParameters(getParameters());
        }
        VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.UploadStream, uploadStreamParameters);
        if (vdcReturnValueBase.getSucceeded()) {
            storageDomainOvfInfo.setStatus(StorageDomainOvfInfoStatus.UPDATED);
            storageDomainOvfInfo.setStoredOvfIds(vmAndTemplatesIds);
            storageDomainOvfInfo.setLastUpdated(updateDate);
            setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, getPostUpdateOvfStoreDescription(size));
            getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
            if (hasParentCommand()) {
                getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
            } else {
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
            }
            return true;
        }
    } catch (VdcBLLException e) {
        log.warnFormat("failed to update domain {0} ovf store disk {1}", storageDomainId, diskId);
    }
    failedOvfDisks.add(diskId);
    return false;
}
#method_after
private boolean performOvfUpdateForDomain(byte[] ovfData, StorageDomainOvfInfo storageDomainOvfInfo, DiskImage ovfDisk, List<Guid> vmAndTemplatesIds) {
    Guid storagePoolId = ovfDisk.getStoragePoolId();
    Guid storageDomainId = ovfDisk.getStorageIds().get(0);
    Guid diskId = ovfDisk.getId();
    Guid volumeId = ovfDisk.getImageId();
    storageDomainOvfInfo.setStoredOvfIds(null);
    try {
        setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, generateOvfStoreDescription(storageDomainOvfInfo.getLastUpdated(), false, null));
        getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ovfData);
        Long size = Long.valueOf(ovfData.length);
        UploadStreamParameters uploadStreamParameters = new UploadStreamParameters(storagePoolId, storageDomainId, diskId, volumeId, byteArrayInputStream, size);
        if (hasParentCommand()) {
            uploadStreamParameters.setParentCommand(getParameters().getParentCommand());
            uploadStreamParameters.setParentParameters(getParameters().getParentParameters());
        } else {
            uploadStreamParameters.setParentCommand(getActionType());
            uploadStreamParameters.setParentParameters(getParameters());
        }
        VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.UploadStream, uploadStreamParameters);
        if (vdcReturnValueBase.getSucceeded()) {
            storageDomainOvfInfo.setStatus(StorageDomainOvfInfoStatus.UPDATED);
            storageDomainOvfInfo.setStoredOvfIds(vmAndTemplatesIds);
            storageDomainOvfInfo.setLastUpdated(updateDate);
            setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, getPostUpdateOvfStoreDescription(size));
            getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
            if (hasParentCommand()) {
                getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
            } else {
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
            }
            return true;
        }
    } catch (VdcBLLException e) {
        log.warn("failed to update domain '{}' ovf store disk '{}'", storageDomainId, diskId);
    }
    failedOvfDisks.add(diskId);
    return false;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    int missingDiskCount = Config.<Integer>getValue(ConfigValues.StorageDomainOvfStoreCount) - ovfDiskCount;
    if (missingDiskCount > 0) {
        CreateOvfStoresForStorageDomainCommandParameters parameters = new CreateOvfStoresForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), missingDiskCount);
        parameters.setParentParameters(getParameters().getParentParameters());
        parameters.setParentCommand(getParameters().getParentCommand());
        VdcReturnValueBase returnValueBase = runInternalAction(VdcActionType.CreateOvfStoresForStorageDomain, parameters, cloneContextAndDetachFromParent());
        if (hasParentCommand()) {
            getReturnValue().getInternalVdsmTaskIdList().addAll(returnValueBase.getInternalVdsmTaskIdList());
        } else {
            getReturnValue().getVdsmTaskIdList().addAll(returnValueBase.getInternalVdsmTaskIdList());
        }
    } else {
        updateOvfStoreContent();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    int missingDiskCount = Config.<Integer>getValue(ConfigValues.StorageDomainOvfStoreCount) - ovfDiskCount;
    if (missingDiskCount > 0) {
        CreateOvfStoresForStorageDomainCommandParameters parameters = new CreateOvfStoresForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), missingDiskCount);
        parameters.setParentParameters(getParameters().getParentParameters());
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setSkipDomainChecks(getParameters().isSkipDomainChecks());
        VdcReturnValueBase returnValueBase = runInternalAction(VdcActionType.CreateOvfStoresForStorageDomain, parameters, cloneContextAndDetachFromParent());
        if (hasParentCommand()) {
            getReturnValue().getInternalVdsmTaskIdList().addAll(returnValueBase.getInternalVdsmTaskIdList());
        } else {
            getReturnValue().getVdsmTaskIdList().addAll(returnValueBase.getInternalVdsmTaskIdList());
        }
    } else {
        updateOvfStoreContent();
    }
    setSucceeded(true);
}
#end_block

#method_before
protected void buildFilesForOvfs(List<Pair<Guid, String>> ovfs, InMemoryTar inMemoryTar) throws Exception {
    for (Pair<Guid, String> pair : ovfs) {
        if (pair.getSecond() != null) {
            inMemoryTar.addTarEntry(pair.getSecond().getBytes(), pair.getFirst() + ".ovf");
        }
    }
}
#method_after
protected Set<Guid> buildFilesForOvfs(List<Pair<Guid, String>> ovfs, InMemoryTar inMemoryTar) throws Exception {
    Set<Guid> addedOvfIds = new HashSet<>();
    for (Pair<Guid, String> pair : ovfs) {
        if (pair.getSecond() != null) {
            inMemoryTar.addTarEntry(pair.getSecond().getBytes(), pair.getFirst() + ".ovf");
            addedOvfIds.add(pair.getFirst());
        }
    }
    return addedOvfIds;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getStoragePoolId());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(targetstorageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    List<DiskImage> disksForExport = getDisksBasedOnImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(disksForExport);
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (getDbFacade().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!checkTemplateInStorageDomain(getVm().getStoragePoolId(), getParameters().getStorageDomainId(), getVm().getVmtGuid(), getContext().getEngineContext())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN, String.format("$TemplateName %1$s", getVm().getVmtName()));
        }
    }
    // check that the images requested format are valid (COW+Sparse)
    if (!ImagesHandler.checkImagesConfiguration(getParameters().getStorageDomainId(), disksForExport, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : disksForExport) {
            if (images.containsKey(img.getId())) {
                // check that no RAW format exists (we are in collapse mode)
                if (((DiskImage) images.get(img.getId())).getVolumeFormat() == VolumeFormat.RAW && img.getVolumeFormat() != VolumeFormat.RAW) {
                    addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN, String.format("$storageDomainName %1$s", getStorageDomainName()));
    }
    // get the snapshot that are going to be exported and have memory
    snapshotsWithMemory = getSnapshotsToBeExportedWithMemory();
    // check destination storage have free space
    int sizeInGB = (int) ImagesHandler.sumImagesTotalSizeWithSnapshotSize(disksForExport) + getTotalMemoryStatesSizeGb();
    if (!doesStorageDomainhaveSpaceForRequest(getStorageDomain(), sizeInGB)) {
        return false;
    }
    SnapshotsValidator snapshotValidator = new SnapshotsValidator();
    if (!(checkVmInStorageDomain() && validate(new StoragePoolValidator(getStoragePool()).isUp()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(new VmValidator(getVm()).vmDown()) && validate(new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), ImagesHandler.getAllStorageIdsForImageIds(disksForExport)).allDomainsExistAndActive()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getStoragePoolId());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(targetstorageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    List<DiskImage> disksForExport = getDisksBasedOnImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(disksForExport);
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (getDbFacade().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!checkTemplateInStorageDomain(getVm().getStoragePoolId(), getParameters().getStorageDomainId(), getVm().getVmtGuid(), getContext().getEngineContext())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN, String.format("$TemplateName %1$s", getVm().getVmtName()));
        }
    }
    // check that the images requested format are valid (COW+Sparse)
    if (!ImagesHandler.checkImagesConfiguration(getParameters().getStorageDomainId(), disksForExport, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : disksForExport) {
            if (images.containsKey(img.getId())) {
                // check that no RAW format exists (we are in collapse mode)
                if (((DiskImage) images.get(img.getId())).getVolumeFormat() == VolumeFormat.RAW && img.getVolumeFormat() != VolumeFormat.RAW) {
                    addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN, String.format("$storageDomainName %1$s", getStorageDomainName()));
    }
    // get the snapshots that are going to be exported and have memory
    snapshotsWithMemory = getSnapshotsToBeExportedWithMemory();
    // check destination storage have free space
    if (!handleDestStorageDomain(disksForExport)) {
        return false;
    }
    SnapshotsValidator snapshotValidator = new SnapshotsValidator();
    if (!(checkVmInStorageDomain() && validate(new StoragePoolValidator(getStoragePool()).isUp()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(new VmValidator(getVm()).vmDown()) && validate(new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), ImagesHandler.getAllStorageIdsForImageIds(disksForExport)).allDomainsExistAndActive()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> AllVmImages = new ArrayList<DiskImage>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setvolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        AllVmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = getDbFacade().getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    String vmMeta = ovfManager.ExportVm(vm, AllVmImages, ClusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return runVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#method_after
private boolean updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> AllVmImages = new ArrayList<DiskImage>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setvolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        AllVmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = getDbFacade().getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    String vmMeta = ovfManager.ExportVm(vm, AllVmImages, ClusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return runVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#end_block

#method_before
protected void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
private DiskImage getDiskForVolumeInfo(DiskImage disk) {
    if (getParameters().getCopyCollapse()) {
        DiskImage ancestor = getDiskImageDao().getAncestor(disk.getImageId());
        if (ancestor == null) {
            log.warnFormat("Can't find ancestor of Disk with ID {0}, using original disk for volume info.", disk.getImageId());
            ancestor = disk;
        }
        return ancestor;
    } else {
        return disk;
    }
}
#method_after
private DiskImage getDiskForVolumeInfo(DiskImage disk) {
    if (getParameters().getCopyCollapse()) {
        DiskImage ancestor = getDiskImageDao().getAncestor(disk.getImageId());
        if (ancestor == null) {
            log.warn("Can't find ancestor of Disk with ID '{}', using original disk for volume info.", disk.getImageId());
            ancestor = disk;
        }
        return ancestor;
    } else {
        return disk;
    }
}
#end_block

#method_before
private void endCopyCollapseOperations(VM vm) {
    vm.setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    vm.setVmtName(null);
    Snapshot activeSnapshot = getDbFacade().getSnapshotDao().get(getDbFacade().getSnapshotDao().getId(vm.getId(), SnapshotType.ACTIVE));
    vm.setSnapshots(Arrays.asList(activeSnapshot));
    updateCopyVmInSpm(getVm().getStoragePoolId(), vm, getParameters().getStorageDomainId());
}
#method_after
private void endCopyCollapseOperations(VM vm) {
    vm.setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    vm.setVmtName(null);
    Snapshot activeSnapshot = getDbFacade().getSnapshotDao().get(getDbFacade().getSnapshotDao().getId(vm.getId(), SnapshotType.ACTIVE));
    vm.setSnapshots(Arrays.asList(activeSnapshot));
    try {
        updateCopyVmInSpm(getVm().getStoragePoolId(), vm, getParameters().getStorageDomainId());
    } catch (VdcBLLException e) {
        log.error("Updating VM OVF in export domain failed.", e);
        AuditLogDirector.log(this, AuditLogType.IMPORTEXPORT_IMPORT_VM_FAILED_UPDATING_OVF);
    }
}
#end_block

#method_before
public void updateOvfData(List<StoragePool> storagePools) {
    log.info("Attempting to update VMs/Templates Ovf.");
    for (StoragePool pool : storagePools) {
        VdcReturnValueBase returnValueBase = performOvfUpdateForStoragePool(pool.getId());
        if (!returnValueBase.getSucceeded()) {
            log.errorFormat("Exception while trying to update or remove VMs/Templates ovf in Data Center {0}.", pool.getName());
        }
        if (ovfOnAnyDomainSupported(pool)) {
            log.infoFormat("Attempting to update ovfs in domain in Data Center {0}", pool.getName());
            Set<Guid> domainsToUpdate = (Set<Guid>) returnValueBase.getActionReturnValue();
            if (domainsToUpdate != null) {
                for (Guid id : domainsToUpdate) {
                    performOvfUpdateForDomain(pool.getId(), id);
                }
            }
        }
    }
}
#method_after
public void updateOvfData(List<StoragePool> storagePools) {
    log.info("Attempting to update VMs/Templates Ovf.");
    for (StoragePool pool : storagePools) {
        VdcReturnValueBase returnValueBase = performOvfUpdateForStoragePool(pool.getId());
        if (!returnValueBase.getSucceeded()) {
            log.error("Exception while trying to update or remove VMs/Templates ovf in Data Center '{}'.", pool.getName());
        }
        if (ovfOnAnyDomainSupported(pool)) {
            log.debug("Attempting to update ovfs in domain in Data Center '{}'", pool.getName());
            Set<Guid> domainsToUpdate = (Set<Guid>) returnValueBase.getActionReturnValue();
            if (domainsToUpdate != null) {
                for (Guid id : domainsToUpdate) {
                    performOvfUpdateForDomain(pool.getId(), id);
                }
            } else {
                log.error("Data Center '{}' domains list for OVF update returned as NULL");
            }
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    itemsCountPerUpdate = loadConfigValue();
    proccessedDomains = new HashSet<>();
    StoragePool pool = getStoragePool();
    if (ovfOnAnyDomainSupported(pool)) {
        proccessDomainsForOvfUpdate(pool);
    }
    logInfoIfNeeded(pool, "Attempting to update VM OVFs in Data Center {0}", pool.getName());
    initProcessedInfoLists();
    updateOvfForVmsOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully updated VM OVFs in Data Center {0}", pool.getName());
    logInfoIfNeeded(pool, "Attempting to update template OVFs in Data Center {0}", pool.getName());
    updateOvfForTemplatesOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully updated templates OVFs in Data Center {0}", pool.getName());
    logInfoIfNeeded(pool, "Attempting to remove unneeded template/vm OVFs in Data Center {0}", pool.getName());
    removeOvfForTemplatesAndVmsOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully removed unneeded template/vm OVFs in Data Center {0}", pool.getName());
    getReturnValue().setActionReturnValue(proccessedDomains);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    itemsCountPerUpdate = loadConfigValue();
    proccessedDomains = new HashSet<>();
    StoragePool pool = getStoragePool();
    if (ovfOnAnyDomainSupported(pool)) {
        proccessDomainsForOvfUpdate(pool);
    }
    logInfoIfNeeded(pool, "Attempting to update VM OVFs in Data Center '{}'", pool.getName());
    initProcessedInfoLists();
    updateOvfForVmsOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully updated VM OVFs in Data Center '{}'", pool.getName());
    logInfoIfNeeded(pool, "Attempting to update template OVFs in Data Center '{}'", pool.getName());
    updateOvfForTemplatesOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully updated templates OVFs in Data Center '{}'", pool.getName());
    logInfoIfNeeded(pool, "Attempting to remove unneeded template/vm OVFs in Data Center '{}'", pool.getName());
    removeOvfForTemplatesAndVmsOfStoragePool(pool);
    logInfoIfNeeded(pool, "Successfully removed unneeded template/vm OVFs in Data Center '{}'", pool.getName());
    getReturnValue().setActionReturnValue(proccessedDomains);
    setSucceeded(true);
}
#end_block

#method_before
private void logInfoIfNeeded(StoragePool pool, String message, Object... args) {
    // if supported, the info would be logged when executing for each domain
    if (!ovfOnAnyDomainSupported(pool)) {
        log.infoFormat(message, args);
    }
}
#method_after
private void logInfoIfNeeded(StoragePool pool, String message, Object... args) {
    // if supported, the info would be logged when executing for each domain
    if (!ovfOnAnyDomainSupported(pool)) {
        log.info(message, args);
    }
}
#end_block

#method_before
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VM> vms = getVmDAO().getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            if (!verifyImagesStatus(vm.getDiskList())) {
                continue;
            }
            ArrayList<DiskImage> vmImages = getOvfUpdateProcessHelper().getVmImagesFromDb(vm);
            if (!verifyImagesStatus(vmImages)) {
                continue;
            }
            vm.setSnapshots(getSnapshotDAO().getAllWithConfiguration(vm.getId()));
            if (!verifySnapshotsStatus(vm.getSnapshots())) {
                continue;
            }
            getOvfUpdateProcessHelper().loadVmData(vm);
            Long currentDbGeneration = getVmStaticDAO().getDbGeneration(vm.getId());
            if (currentDbGeneration == null) {
                log.warnFormat("currentDbGeneration of VM (name: {0}, id: {1}) is null, probably because the VM was deleted during the run of OvfDataUpdater.", vm.getName(), vm.getId());
                continue;
            }
            if (vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                proccessedOvfConfigurationsInfo.add(getOvfUpdateProcessHelper().buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata, vmImages));
                proccessedIdsInfo.add(vm.getId());
                proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                proccessDisksDomains(vm.getDiskList());
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#method_after
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VM> vms = getVmDAO().getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            if (!verifyImagesStatus(vm.getDiskList())) {
                continue;
            }
            ArrayList<DiskImage> vmImages = getOvfUpdateProcessHelper().getVmImagesFromDb(vm);
            if (!verifyImagesStatus(vmImages)) {
                continue;
            }
            vm.setSnapshots(getSnapshotDAO().getAllWithConfiguration(vm.getId()));
            if (!verifySnapshotsStatus(vm.getSnapshots())) {
                continue;
            }
            getOvfUpdateProcessHelper().loadVmData(vm);
            Long currentDbGeneration = getVmStaticDAO().getDbGeneration(vm.getId());
            if (currentDbGeneration == null) {
                log.warn("currentDbGeneration of VM (name: '{}', id: '{}') is null, probably because the VM was deleted during the run of OvfDataUpdater.", vm.getName(), vm.getId());
                continue;
            }
            if (vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                proccessedOvfConfigurationsInfo.add(getOvfUpdateProcessHelper().buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata, vmImages));
                proccessedIdsInfo.add(vm.getId());
                proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                proccessDisksDomains(vm.getDiskList());
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#end_block

#method_before
protected VDS getVds() {
    if (mVds == null && ((mVdsId != null && !Guid.Empty.equals(mVdsId)) || (getVm() != null && getVm().getRunOnVds() != null))) {
        if (mVdsId == null || Guid.Empty.equals(mVdsId)) {
            mVdsId = getVm().getRunOnVds();
        }
        try {
            mVds = getVdsDAO().get(getVdsId());
        } catch (final RuntimeException e) {
            log.infoFormat("Failed to get vds {0}\n{1}", mVdsId, e.getMessage());
        }
    }
    return mVds;
}
#method_after
protected VDS getVds() {
    if (mVds == null && ((mVdsId != null && !Guid.Empty.equals(mVdsId)) || (getVm() != null && getVm().getRunOnVds() != null))) {
        if (mVdsId == null || Guid.Empty.equals(mVdsId)) {
            mVdsId = getVm().getRunOnVds();
        }
        try {
            mVds = getVdsDAO().get(getVdsId());
        } catch (final RuntimeException e) {
            log.info("Failed to get vds '{}', error {}", mVdsId, e.getMessage());
            log.debug("Exception", e);
        }
    }
    return mVds;
}
#end_block

#method_before
protected VdsStatic getVdsStatic() {
    if (cachedVdsStatic == null && ((mVdsId != null && !Guid.Empty.equals(mVdsId)) || (getVm() != null && getVm().getRunOnVds() != null))) {
        if (mVdsId == null || Guid.Empty.equals(mVdsId)) {
            mVdsId = getVm().getRunOnVds();
        }
        try {
            cachedVdsStatic = getVdsStaticDAO().get(getVdsId());
        } catch (final RuntimeException e) {
            log.infoFormat("Failed to get vds {0}\n{1}", mVdsId, e.getMessage());
        }
    }
    return cachedVdsStatic;
}
#method_after
protected VdsStatic getVdsStatic() {
    if (cachedVdsStatic == null && ((mVdsId != null && !Guid.Empty.equals(mVdsId)) || (getVm() != null && getVm().getRunOnVds() != null))) {
        if (mVdsId == null || Guid.Empty.equals(mVdsId)) {
            mVdsId = getVm().getRunOnVds();
        }
        try {
            cachedVdsStatic = getVdsStaticDAO().get(getVdsId());
        } catch (final RuntimeException e) {
            log.info("Failed to get vds '{}', error: {}", mVdsId, e.getMessage());
            log.debug("Exception", e);
        }
    }
    return cachedVdsStatic;
}
#end_block

#method_before
public VM getVm() {
    if (mVm == null && mVmId != null && !mVmId.equals(Guid.Empty)) {
        try {
            mVm = getVmDAO().get(mVmId);
            // It should probably be removed, but some research is required
            if (mVm != null) {
                mVm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(mVmId));
            }
        } catch (final Exception e) {
            log.infoFormat("Failed to get vm {0}", mVmId);
            log.debug(e);
        }
    }
    return mVm;
}
#method_after
public VM getVm() {
    if (mVm == null && mVmId != null && !mVmId.equals(Guid.Empty)) {
        try {
            mVm = getVmDAO().get(mVmId);
            // It should probably be removed, but some research is required
            if (mVm != null) {
                mVm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(mVmId));
            }
        } catch (final Exception e) {
            log.info("Failed to get vm '{}', error {}", mVmId, e.getMessage());
            log.debug("Exception", e);
        }
    }
    return mVm;
}
#end_block

#method_before
protected void log() {
    final Transaction transaction = TransactionSupport.suspend();
    try {
        try {
            AuditLogDirector.log(this);
        } catch (final RuntimeException ex) {
            log.errorFormat("Error during log command: {0}. Exception {1}", getClass().getName(), ex);
        }
    } finally {
        TransactionSupport.resume(transaction);
    }
}
#method_after
protected void log() {
    final Transaction transaction = TransactionSupport.suspend();
    try {
        try {
            AuditLogDirector.log(this);
        } catch (final RuntimeException ex) {
            log.error("Error during log command: {}. Exception {}", getClass().getName(), ex.getMessage());
            log.debug("Exception", ex);
        }
    } finally {
        TransactionSupport.resume(transaction);
    }
}
#end_block

#method_before
protected DbFacade getDbFacade() {
    return DbFacade.getInstance();
}
#method_after
public DbFacade getDbFacade() {
    return DbFacade.getInstance();
}
#end_block

#method_before
private boolean detachUsers() {
    // check if this is a VM from a VM pool
    if (getVm().getVmPoolId() == null) {
        return false;
    }
    List<DbUser> users = getDbUserDAO().getAllForVm(getVmId());
    // check if this VM is attached to a user
    if (users == null || users.isEmpty()) {
        return false;
    }
    VmPool pool = getVmPoolDAO().get(getVm().getVmPoolId());
    if (pool != null && pool.getVmPoolType() == VmPoolType.Automatic) {
        // should be only one user in the collection
        for (DbUser dbUser : users) {
            runInternalActionWithTasksContext(VdcActionType.DetachUserFromVmFromPool, new VmPoolSimpleUserParameters(getVm().getVmPoolId(), dbUser.getId(), getVmId()), getLock());
        }
        return true;
    }
    return false;
}
#method_after
private boolean detachUsers() {
    // check if this is a VM from a VM pool
    if (getVm().getVmPoolId() == null) {
        return false;
    }
    List<DbUser> users = getDbUserDAO().getAllForVm(getVmId());
    // check if this VM is attached to a user
    if (users == null || users.isEmpty()) {
        // if not, check if new version or need to restore stateless
        runInternalActionWithTasksContext(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), getLock());
        return true;
    }
    VmPool pool = getVmPoolDAO().get(getVm().getVmPoolId());
    if (pool != null && pool.getVmPoolType() == VmPoolType.Automatic) {
        // should be only one user in the collection
        for (DbUser dbUser : users) {
            runInternalActionWithTasksContext(VdcActionType.DetachUserFromVmFromPool, new VmPoolSimpleUserParameters(getVm().getVmPoolId(), dbUser.getId(), getVmId()), getLock());
        }
        return true;
    }
    return false;
}
#end_block

#method_before
private VmManagementParametersBase createUpdateVmParameters() {
    // clear non updateable fields got from config
    getVm().setExportDate(null);
    getVm().setOvfVersion(null);
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getVm());
    updateVmParams.setUpdateWatchdog(true);
    updateVmParams.setSoundDeviceEnabled(false);
    updateVmParams.setBalloonEnabled(false);
    updateVmParams.setVirtioScsiEnabled(false);
    updateVmParams.setClearPayload(true);
    for (VmDevice device : getVm().getManagedVmDeviceMap().values()) {
        switch(device.getType()) {
            case WATCHDOG:
                updateVmParams.setWatchdog(new VmWatchdog(device));
                break;
            case SOUND:
                updateVmParams.setSoundDeviceEnabled(true);
                break;
            case BALLOON:
                updateVmParams.setBalloonEnabled(true);
                break;
            case CONTROLLER:
                if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    updateVmParams.setVirtioScsiEnabled(true);
                }
                break;
            case DISK:
                if (VmPayload.isPayload(device.getSpecParams())) {
                    updateVmParams.setVmPayload(new VmPayload(VmDeviceType.getByName(device.getDevice()), device.getSpecParams()));
                }
                break;
            case CONSOLE:
                updateVmParams.setConsoleEnabled(true);
                break;
            default:
        }
    }
    // clear these fields as these are non updatable
    getVm().getManagedVmDeviceMap().clear();
    getVm().getVmUnamagedDeviceList().clear();
    return updateVmParams;
}
#method_after
private VmManagementParametersBase createUpdateVmParameters() {
    // clear non updateable fields got from config
    getVm().setExportDate(null);
    getVm().setOvfVersion(null);
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getVm());
    updateVmParams.setUpdateWatchdog(true);
    updateVmParams.setSoundDeviceEnabled(false);
    updateVmParams.setBalloonEnabled(false);
    updateVmParams.setVirtioScsiEnabled(false);
    updateVmParams.setClearPayload(true);
    for (VmDevice device : getVm().getManagedVmDeviceMap().values()) {
        switch(device.getType()) {
            case WATCHDOG:
                updateVmParams.setWatchdog(new VmWatchdog(device));
                break;
            case SOUND:
                updateVmParams.setSoundDeviceEnabled(true);
                break;
            case BALLOON:
                updateVmParams.setBalloonEnabled(true);
                break;
            case CONTROLLER:
                if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    updateVmParams.setVirtioScsiEnabled(true);
                }
                break;
            case DISK:
                if (VmPayload.isPayload(device.getSpecParams())) {
                    updateVmParams.setVmPayload(new VmPayload(device));
                }
                break;
            case CONSOLE:
                updateVmParams.setConsoleEnabled(true);
                break;
            default:
        }
    }
    // clear these fields as these are non updatable
    getVm().getManagedVmDeviceMap().clear();
    getVm().getVmUnamagedDeviceList().clear();
    return updateVmParams;
}
#end_block

#method_before
private void removeVmStatelessImages() {
    if (getSnapshotDAO().exists(getVmId(), SnapshotType.STATELESS)) {
        log.infoFormat("Deleting snapshot for stateless vm {0}", getVmId());
        runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    }
}
#method_after
private void removeVmStatelessImages() {
    if (getSnapshotDAO().exists(getVmId(), SnapshotType.STATELESS)) {
        log.info("Deleting snapshot for stateless vm '{}'", getVmId());
        runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    }
}
#end_block

#method_before
protected void loadVmData(VM vm) {
    if (vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            VmTemplate t = getVmTemplateDao().get(vm.getVmtGuid());
            vm.setVmtName(t.getName());
        } else {
            vm.setVmtName(VmTemplateHandler.BLANK_VM_TEMPLATE_NAME);
        }
    }
}
#method_after
protected void loadVmData(VM vm) {
    setManagedVideoDevices(vm.getStaticData());
    if (vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            VmTemplate t = getVmTemplateDao().get(vm.getVmtGuid());
            vm.setVmtName(t.getName());
        } else {
            vm.setVmtName(VmTemplateHandler.BLANK_VM_TEMPLATE_NAME);
        }
    }
}
#end_block

#method_before
protected void loadTemplateData(VmTemplate template) {
    if (template.getInterfaces() == null || template.getInterfaces().isEmpty()) {
        template.setInterfaces(getVmNetworkInterfaceDao().getAllForTemplate(template.getId()));
    }
}
#method_after
protected void loadTemplateData(VmTemplate template) {
    setManagedVideoDevices(template);
    if (template.getInterfaces() == null || template.getInterfaces().isEmpty()) {
        template.setInterfaces(getVmNetworkInterfaceDao().getAllForTemplate(template.getId()));
    }
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", vds.getId(), vds.getName());
                }
                vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(vds.getId());
                log.debug("vds '{}' ({}) firing up event.", vds.getName(), vds.getId());
                vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.debug("Exception", ex);
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error("Exception", ex);
        }
    }
}
#end_block

#method_before
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.PreparingForMaintenance || vds.getStatus() == VDSStatus.Error || vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (vdsManager.getRefreshStatistics() || vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = vdsManager.refreshCapabilities(processHardwareNeededAtomic, vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                vdsManager.setStatus(VDSStatus.Up, vds);
            }
            saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        vmsMonitoring.refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", vds.getName(), vds.getVdsGroupName()), cce);
        if (vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.PreparingForMaintenance || vds.getStatus() == VDSStatus.Error || vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (vdsManager.getRefreshStatistics() || vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = vdsManager.refreshCapabilities(processHardwareNeededAtomic, vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                vdsManager.setStatus(VDSStatus.Up, vds);
            }
            saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        vmsMonitoring.refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error("Failure to refresh Vds '{}' runtime info. Incorrect vdsm version for cluster '{}': {}", vds.getName(), vds.getVdsGroupName(), cce.getMessage());
        log.debug("Exception", cce);
        if (vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info: {}", t.getMessage());
        log.error("Exception", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getusage_mem_percent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(vds.getVersion()) <= 0) || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getUsageMemPercent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(vds.getVersion()) <= 0) || stat.getUsageMemPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getUsageMemPercent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() != null && stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#method_after
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getUsageCpuPercent() != null && stat.getUsageCpuPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("UsedCpu", stat.getUsageCpuPercent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    final double THRESHOLD = 0.98;
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getSwapTotal() == null || stat.getSwapFree() == null || stat.getSwapTotal() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getSwapTotal() - stat.getSwapFree()) / stat.getSwapTotal();
    // Allow the space to be up to 2% lower than as defined in configuration
    Long allowedMinAvailableThreshold = Math.round(minAvailableThreshold.doubleValue() * THRESHOLD);
    AuditLogType valueToLog = stat.getSwapFree() < allowedMinAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getSwapFree() < allowedMinAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getSwapFree().toString());
        logable.addCustomValue("Threshold", stat.getSwapFree() < allowedMinAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void logFailureMessage(String messagePrefix, RuntimeException ex) {
    log.errorFormat("{0} Error: {1}, vds = {2} : {3}", messagePrefix, ExceptionUtils.getMessage(ex), vds.getId(), vds.getName());
}
#method_after
private void logFailureMessage(String messagePrefix, RuntimeException ex) {
    log.error("{} vds={}({}): {}", messagePrefix, vds.getName(), vds.getId(), ex.getMessage());
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (vds.getStatus() == VDSStatus.NonOperational && firstStatus != VDSStatus.NonOperational) {
            if (!vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(vds.getId(), vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", vds.getId(), vds.getName(), (vds.getNonOperationalReason() != null) ? vds.getNonOperationalReason().name() : "unknown");
            }
        }
        vmsMonitoring.afterVMsRefreshTreatment();
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(vds);
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode, probably error during " + "disconnecting it from pool. The Host will stay in Maintenance: {}", ex.getMessage());
                log.debug("Exception", ex);
            }
        } else if (vds.getStatus() == VDSStatus.NonOperational && firstStatus != VDSStatus.NonOperational) {
            if (!vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(vds.getId(), vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.info("Host '{}'({}) is already in NonOperational status for reason '{}'. SetNonOperationalVds command is skipped.", vds.getName(), vds.getId(), (vds.getNonOperationalReason() != null) ? vds.getNonOperationalReason().name() : "unknown");
            }
        }
        vmsMonitoring.afterVMsRefreshTreatment();
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.debug("Exception", ex);
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error("Exception", ex);
    }
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", vds.getId(), vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    VDSReturnValue statsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
    getResourceManager().getEventListener().updateSchedulingStats(vds);
    if (!statsReturnValue.getSucceeded() && statsReturnValue.getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((statsReturnValue.getExceptionObject() instanceof VDSNetworkException) ? statsReturnValue.getExceptionObject() : null);
        if (ex != null) {
            if (vdsManager.handleNetworkException(ex, vds)) {
                saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", vds.getId(), vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", vds.getId(), vds.getName(), statsReturnValue.getExceptionString());
        }
        throw statsReturnValue.getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    saveVdsDynamic = true;
    saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, vds='{}'({})", vds.getName(), vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    VDSReturnValue statsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
    getVdsEventListener().updateSchedulingStats(vds);
    if (!statsReturnValue.getSucceeded() && statsReturnValue.getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((statsReturnValue.getExceptionObject() instanceof VDSNetworkException) ? statsReturnValue.getExceptionObject() : null);
        if (ex != null) {
            if (vdsManager.handleNetworkException(ex, vds)) {
                saveVdsDynamic = true;
            }
            log.error("vds::refreshVdsStats Failed getVdsStats,  vds='{}'({}): {}", vds.getName(), vds.getId(), ex.getMessage());
        } else {
            log.error("vds::refreshVdsStats Failed getVdsStats,  vds='{}'({}): {}", vds.getName(), vds.getId(), statsReturnValue.getExceptionString());
        }
        throw statsReturnValue.getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    saveVdsDynamic = true;
    saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVdsStats\n{0}", this);
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", vds.getName()), e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(vds.getId())) {
                hostDownTimes.put(vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                vdsManager.setStatus(VDSStatus.NonOperational, vds);
                log.infoFormat("Host '{0}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{1}'", vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error("Failure on checkInterfaces on update runtimeinfo for vds: '{}': {}", vds.getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(vds.getId())) {
                hostDownTimes.put(vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                vdsManager.setStatus(VDSStatus.NonOperational, vds);
                log.info("Host '{}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{}'", vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error("checkInterface: Failure on moving host: '{}' to non-operational: {}", vds.getName(), e.getMessage());
                log.error("Exception", e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(vds.getId());
        }
    }
}
#end_block

#method_before
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(vds.getId())) {
        VdsNetworkInterface iface = monitoredInterfaces.get(oldIface.getName());
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#method_after
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (Map.Entry<String, InterfaceStatus> entry : oldInterfaceStatus.entrySet()) {
        VdsNetworkInterface iface = monitoredInterfaces.get(entry.getKey());
        InterfaceStatus oldStatus = entry.getValue();
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldStatus != InterfaceStatus.NONE && oldStatus != status) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(vds)) {
            vdsManager.setStatus(VDSStatus.Maintenance, vds);
            saveVdsDynamic = true;
            saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", vds.getId(), vds.getName());
        } else {
            vdsMaintenanceTimeoutOccurred = vdsManager.isTimeToRetryMaintenance();
        }
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(vds)) {
            vdsManager.setStatus(VDSStatus.Maintenance, vds);
            saveVdsDynamic = true;
            saveVdsStatistics = true;
            log.info("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds '{}'({})", vds.getName(), vds.getId());
        } else {
            vdsMaintenanceTimeoutOccurred = vdsManager.isTimeToRetryMaintenance();
        }
    }
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
        // Initialize Power Management Health Check
        PmHealthCheckManager.getInstance().initialize();
        // recover from engine failure
        PmHealthCheckManager.getInstance().recover(hosts);
        // Create authentication profiles for all the domains that exist in the database:
        // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
        DbUserCacheManager.getInstance().init();
        CommandCoordinatorUtil.initAsyncTaskManager();
        Injector.get(ResourceManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        ExternalTrustStoreInitializer.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        new DwhHeartBeat().init();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
        // Initialize Power Management Health Check
        PmHealthCheckManager.getInstance().initialize();
        // recover from engine failure
        PmHealthCheckManager.getInstance().recover(hosts);
        // Create authentication profiles for all the domains that exist in the database:
        // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
        DbUserCacheManager.getInstance().init();
        CommandCoordinatorUtil.initAsyncTaskManager();
        Injector.get(ResourceManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        new DwhHeartBeat().init();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#end_block

#method_before
private void removeMemoryVolumes() {
    Set<String> memoryStates = MemoryUtils.getMemoryVolumesFromSnapshots(getDbFacade().getSnapshotDao().getAll(getVmId()));
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            log.errorFormat("Failed to remove memory volumes whie removing vm {0} (volumes: {1})", getVmId(), memoryState);
        }
    }
}
#method_after
private void removeMemoryVolumes() {
    Set<String> memoryStates = MemoryUtils.getMemoryVolumesFromSnapshots(getDbFacade().getSnapshotDao().getAll(getVmId()));
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            log.error("Failed to remove memory volumes while removing vm '{}' (volumes: '{}')", getVmId(), memoryState);
        }
    }
}
#end_block

#method_before
private RemoveMemoryVolumesParameters buildRemoveMemoryVolumesParameters(String memoryState, Guid vmId) {
    RemoveMemoryVolumesParameters parameters = new RemoveMemoryVolumesParameters(memoryState, getVmId());
    parameters.setRemoveOnlyIfNotUsedAtAll(true);
    return parameters;
}
#method_after
private RemoveMemoryVolumesParameters buildRemoveMemoryVolumesParameters(String memoryState, Guid vmId) {
    RemoveMemoryVolumesParameters params = new RemoveMemoryVolumesParameters(memoryState, vmId);
    params.setEntityInfo(getParameters().getEntityInfo());
    return params;
}
#end_block

#method_before
public void succededToHibernate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            VmDynamic vmDynamic = db().getVmDynamicDao().get(id);
            vmDynamic.setStatus(VMStatus.SavingState);
            update(vmDynamic);
            return null;
        }
    });
}
#method_after
public void succededToHibernate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            VmDynamic vmDynamic = getVmDynamicDao().get(id);
            vmDynamic.setStatus(VMStatus.SavingState);
            update(vmDynamic);
            return null;
        }
    });
}
#end_block

#method_before
@PostConstruct
private void init() {
    // init the singleton. TODO remove once all code is using CDI
    instance = this;
    log.info("Start initializing " + getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getStatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Is there any VM that is not fully Up or fully Down?
    boolean runningVmsInTransition = false;
    // Cleanup all vms dynamic data. This is defensive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            if (vm.getRunOnVds() != null) {
                MultiValueMapUtils.addToMap(vm.getRunOnVds(), vm.getId(), vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
            }
            if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                SetVmUnknown(vm);
            }
        }
        if (!runningVmsInTransition && vm.isRunning() && vm.getStatus() != VMStatus.Up) {
            runningVmsInTransition = true;
        }
    }
    // Clean pending memory and CPUs if there is no VM in transition on a given Host
    // (meaning we tried to start a VM and the engine crashed before telling VDSM about it)
    List<VdsDynamic> updatedEntities = new ArrayList<>();
    for (VDS _vds : allVdsList) {
        boolean _saveVdsDynamic = false;
        if (_vds.getPendingVcpusCount() != 0 && !runningVmsInTransition) {
            _vds.setPendingVcpusCount(0);
            _saveVdsDynamic = true;
        }
        if (_vds.getPendingVmemSize() != 0 && !runningVmsInTransition) {
            _vds.setPendingVmemSize(0);
            _saveVdsDynamic = true;
        }
        if (_saveVdsDynamic) {
            updatedEntities.add(_vds.getDynamicData());
        }
    }
    DbFacade.getInstance().getVdsDynamicDao().updateAllInBatch(updatedEntities);
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.init();
    log.info("Finished initializing " + getClass().getSimpleName());
}
#method_after
@PostConstruct
private void init() {
    // init the singleton. TODO remove once all code is using CDI
    instance = this;
    log.info("Start initializing {}", getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getStatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Is there any VM that is not fully Up or fully Down?
    boolean runningVmsInTransition = false;
    // Cleanup all vms dynamic data. This is defensive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            if (vm.getRunOnVds() != null) {
                MultiValueMapUtils.addToMap(vm.getRunOnVds(), vm.getId(), vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
            }
            if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                SetVmUnknown(vm);
            }
        }
        if (!runningVmsInTransition && vm.isRunning() && vm.getStatus() != VMStatus.Up) {
            runningVmsInTransition = true;
        }
    }
    // Clean pending memory and CPUs if there is no VM in transition on a given Host
    // (meaning we tried to start a VM and the engine crashed before telling VDSM about it)
    List<VdsDynamic> updatedEntities = new ArrayList<>();
    for (VDS _vds : allVdsList) {
        boolean _saveVdsDynamic = false;
        if (_vds.getPendingVcpusCount() != 0 && !runningVmsInTransition) {
            _vds.setPendingVcpusCount(0);
            _saveVdsDynamic = true;
        }
        if (_vds.getPendingVmemSize() != 0 && !runningVmsInTransition) {
            _vds.setPendingVmemSize(0);
            _saveVdsDynamic = true;
        }
        if (_saveVdsDynamic) {
            updatedEntities.add(_vds.getDynamicData());
        }
    }
    DbFacade.getInstance().getVdsDynamicDao().updateAllInBatch(updatedEntities);
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.init();
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
public void AddVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = VdsManager.buildVdsManager(vds);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.updateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.updateDynamicData(vds.getDynamicData());
    }
    vdsManager.schedulJobs();
    vdsManagersDict.put(vds.getId(), vdsManager);
    log.infoFormat("VDS {0} was added to the Resource Manager", vds.getId());
}
#method_after
public void AddVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = VdsManager.buildVdsManager(vds);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.updateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.updateDynamicData(vds.getDynamicData());
    }
    vdsManager.schedulJobs();
    vdsManagersDict.put(vds.getId(), vdsManager);
    log.info("VDS '{}' was added to the Resource Manager", vds.getId());
}
#end_block

#method_before
public VdsManager GetVdsManager(Guid vdsId, boolean newHost) {
    VdsManager vdsManger = vdsManagersDict.get(vdsId);
    if (vdsManger == null) {
        if (!newHost) {
            log.errorFormat("Cannot get vdsManager for vdsid={0}", vdsId);
        }
    }
    return vdsManger;
}
#method_after
public VdsManager GetVdsManager(Guid vdsId, boolean newHost) {
    VdsManager vdsManger = vdsManagersDict.get(vdsId);
    if (vdsManger == null) {
        if (!newHost) {
            log.error("Cannot get vdsManager for vdsid='{}'.", vdsId);
        }
    }
    return vdsManger;
}
#end_block

#method_before
private void resetVmAttributes(VM vm) {
    vm.setUsageNetworkPercent(0);
    vm.setElapsedTime(0D);
    vm.setCpuSys(0D);
    vm.setCpuUser(0D);
    vm.setUsageCpuPercent(0);
    vm.setUsageMemPercent(0);
    vm.setMemoryUsageHistory(null);
    vm.setCpuUsageHistory(null);
    vm.setNetworkUsageHistory(null);
    vm.setMigratingToVds(null);
    vm.setRunOnVdsName("");
    vm.setGuestCurrentUserName(null);
    vm.setConsoleCurrentUserName(null);
    vm.setConsoleUserId(null);
    vm.setGuestOs(null);
    vm.setVmIp(null);
    vm.setVmFQDN(null);
    vm.setCpuName(null);
    vm.setMigrationProgressPercent(0);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    for (VmNetworkInterface ifc : interfaces) {
        NetworkStatistics statistics = ifc.getStatistics();
        statistics.setTransmitDropRate(0D);
        statistics.setTransmitRate(0D);
        statistics.setReceiveRate(0D);
        statistics.setReceiveDropRate(0D);
    }
}
#method_after
private void resetVmAttributes(VM vm) {
    vm.setUsageNetworkPercent(0);
    vm.setElapsedTime(0D);
    vm.setCpuSys(0D);
    vm.setCpuUser(0D);
    vm.setUsageCpuPercent(0);
    vm.setUsageMemPercent(0);
    vm.setMemoryUsageHistory(null);
    vm.setCpuUsageHistory(null);
    vm.setNetworkUsageHistory(null);
    vm.setMigratingToVds(null);
    vm.setRunOnVdsName("");
    vm.setGuestCurrentUserName(null);
    vm.setConsoleCurrentUserName(null);
    vm.setConsoleUserId(null);
    vm.setGuestOs(null);
    vm.setVmIp(null);
    vm.setVmFQDN(null);
    vm.setCpuName(null);
    vm.setEmulatedMachine(null);
    vm.setMigrationProgressPercent(0);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    for (VmNetworkInterface ifc : interfaces) {
        NetworkStatistics statistics = ifc.getStatistics();
        statistics.setTransmitDropRate(0D);
        statistics.setTransmitRate(0D);
        statistics.setReceiveRate(0D);
        statistics.setReceiveDropRate(0D);
    }
    List<VmNumaNode> vmNumaNodes = vm.getvNumaNodeList();
    for (VmNumaNode node : vmNumaNodes) {
        node.getVdsNumaNodeList().clear();
    }
}
#end_block

#method_before
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed: {}", e.getCause().getMessage());
            log.error("Exception", e);
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed: {}", e.getMessage());
        log.debug("Exception", e);
    }
    return null;
}
#end_block

#method_before
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateFutureCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateFutureCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateFutureCommand failed: {}", e.getCause().getMessage());
            log.debug("Exception", e);
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateFutureCommand failed: {}", e.getMessage());
        log.debug("Exception", e);
    }
    return null;
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", vds.getId(), vds.getName());
                }
                vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(vds.getId());
                log.debug("vds '{}' ({}) firing up event.", vds.getName(), vds.getId());
                vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.debug("Exception", ex);
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error("Exception", ex);
        }
    }
}
#end_block

#method_before
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.PreparingForMaintenance || vds.getStatus() == VDSStatus.Error || vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (vdsManager.getRefreshStatistics() || vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = vdsManager.refreshCapabilities(processHardwareNeededAtomic, vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                vdsManager.setStatus(VDSStatus.Up, vds);
            }
            saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        vmsMonitoring.refreshVmStats();
        updateVirtualMemAndCpu();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", vds.getName(), vds.getVdsGroupName()), cce);
        if (vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.PreparingForMaintenance || vds.getStatus() == VDSStatus.Error || vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (vdsManager.getRefreshStatistics() || vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = vdsManager.refreshCapabilities(processHardwareNeededAtomic, vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                vdsManager.setStatus(VDSStatus.Up, vds);
            }
            saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        vmsMonitoring.refreshVmStats();
        updateVirtualMemAndCpu();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error("Failure to refresh Vds '{}' runtime info. Incorrect vdsm version for cluster '{}': {}", vds.getName(), vds.getVdsGroupName(), cce.getMessage());
        log.debug("Exception", cce);
        if (vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info: {}", t.getMessage());
        log.error("Exception", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getusage_mem_percent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(vds.getVersion()) <= 0) || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getUsageMemPercent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(vds.getVersion()) <= 0) || stat.getUsageMemPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getUsageMemPercent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() != null && stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#method_after
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getUsageCpuPercent() != null && stat.getUsageCpuPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("UsedCpu", stat.getUsageCpuPercent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    final double THRESHOLD = 0.98;
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getSwapTotal() == null || stat.getSwapFree() == null || stat.getSwapTotal() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getSwapTotal() - stat.getSwapFree()) / stat.getSwapTotal();
    // Allow the space to be up to 2% lower than as defined in configuration
    Long allowedMinAvailableThreshold = Math.round(minAvailableThreshold.doubleValue() * THRESHOLD);
    AuditLogType valueToLog = stat.getSwapFree() < allowedMinAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getSwapFree() < allowedMinAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getSwapFree().toString());
        logable.addCustomValue("Threshold", stat.getSwapFree() < allowedMinAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void logFailureMessage(String messagePrefix, RuntimeException ex) {
    log.errorFormat("{0} Error: {1}, vds = {2} : {3}", messagePrefix, ExceptionUtils.getMessage(ex), vds.getId(), vds.getName());
}
#method_after
private void logFailureMessage(String messagePrefix, RuntimeException ex) {
    log.error("{} vds={}({}): {}", messagePrefix, vds.getName(), vds.getId(), ex.getMessage());
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (vds.getStatus() == VDSStatus.NonOperational && firstStatus != VDSStatus.NonOperational) {
            if (!vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", vds.getId(), vds.getName(), (vds.getNonOperationalReason() != null) ? vds.getNonOperationalReason().name() : "unknown");
            }
        }
        vmsMonitoring.afterVMsRefreshTreatment();
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(vds);
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode, probably error during " + "disconnecting it from pool. The Host will stay in Maintenance: {}", ex.getMessage());
                log.debug("Exception", ex);
            }
        } else if (vds.getStatus() == VDSStatus.NonOperational && firstStatus != VDSStatus.NonOperational) {
            if (!vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(vds.getId(), vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.info("Host '{}'({}) is already in NonOperational status for reason '{}'. SetNonOperationalVds command is skipped.", vds.getName(), vds.getId(), (vds.getNonOperationalReason() != null) ? vds.getNonOperationalReason().name() : "unknown");
            }
        }
        vmsMonitoring.afterVMsRefreshTreatment();
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.debug("Exception", ex);
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error("Exception", ex);
    }
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", vds.getId(), vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    ResourceManager.getInstance().getEventListener().updateSchedulingStats(vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (vdsManager.handleNetworkException(ex, vds)) {
                saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", vds.getId(), vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", vds.getId(), vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    saveVdsDynamic = true;
    saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, vds='{}'({})", vds.getName(), vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    VDSReturnValue statsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
    getVdsEventListener().updateSchedulingStats(vds);
    if (!statsReturnValue.getSucceeded() && statsReturnValue.getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((statsReturnValue.getExceptionObject() instanceof VDSNetworkException) ? statsReturnValue.getExceptionObject() : null);
        if (ex != null) {
            if (vdsManager.handleNetworkException(ex, vds)) {
                saveVdsDynamic = true;
            }
            log.error("vds::refreshVdsStats Failed getVdsStats,  vds='{}'({}): {}", vds.getName(), vds.getId(), ex.getMessage());
        } else {
            log.error("vds::refreshVdsStats Failed getVdsStats,  vds='{}'({}): {}", vds.getName(), vds.getId(), statsReturnValue.getExceptionString());
        }
        throw statsReturnValue.getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    saveVdsDynamic = true;
    saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVdsStats\n{0}", this);
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(vds.getId())) {
                hostDownTimes.put(vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", vds.getName(), nicNames, networkNames);
                vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                vdsManager.setStatus(VDSStatus.NonOperational, vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error("Failure on checkInterfaces on update runtimeinfo for vds: '{}': {}", vds.getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(vds.getId())) {
                hostDownTimes.put(vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                vdsManager.setStatus(VDSStatus.NonOperational, vds);
                log.info("Host '{}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{}'", vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error("checkInterface: Failure on moving host: '{}' to non-operational: {}", vds.getName(), e.getMessage());
                log.error("Exception", e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(vds.getId());
        }
    }
}
#end_block

#method_before
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(vds.getId())) {
        VdsNetworkInterface iface = monitoredInterfaces.get(oldIface.getName());
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#method_after
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (Map.Entry<String, InterfaceStatus> entry : oldInterfaceStatus.entrySet()) {
        VdsNetworkInterface iface = monitoredInterfaces.get(entry.getKey());
        InterfaceStatus oldStatus = entry.getValue();
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldStatus != InterfaceStatus.NONE && oldStatus != status) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(vds)) {
            vdsManager.setStatus(VDSStatus.Maintenance, vds);
            saveVdsDynamic = true;
            saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", vds.getId(), vds.getName());
        } else {
            if (vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(vds);
                vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(vds)) {
            vdsManager.setStatus(VDSStatus.Maintenance, vds);
            saveVdsDynamic = true;
            saveVdsStatistics = true;
            log.info("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds '{}'({})", vds.getName(), vds.getId());
        } else {
            vdsMaintenanceTimeoutOccurred = vdsManager.isTimeToRetryMaintenance();
        }
    }
}
#end_block

#method_before
public void refreshVmStats() {
    log.debug("refresh VMs list entered");
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#method_after
public void refreshVmStats() {
    log.debug("refresh VMs list entered");
    // Retrieve the list of existing jobs and/or job placeholders.  Only these jobs
    // are allowed to be updated by updateVmJobs()
    refreshExistingVmJobList();
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
        updateVmJobs();
    }
}
#end_block

#method_before
public boolean fetchRunningVms() {
    VDSCommandType commandType = vdsManager.getRefreshStatistics() ? VDSCommandType.GetAllVmStats : VDSCommandType.List;
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(commandType, new VdsIdAndVdsVDSCommandParametersBase(vds));
    runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (!vdsReturnValue.getSucceeded()) {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", vds.getId(), vds.getName(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = vdsManager.handleNetworkException((VDSNetworkException) callException, vds);
            } else if (callException instanceof VDSProtocolException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", vds.getId(), vds.getName(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.errorFormat("{0} failed with no exception!", commandType.name());
        }
    }
    return vdsReturnValue.getSucceeded();
}
#method_after
public boolean fetchRunningVms() {
    VDSCommandType commandType = vdsManager.getRefreshStatistics() ? VDSCommandType.GetAllVmStats : VDSCommandType.List;
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(commandType, new VdsIdAndVdsVDSCommandParametersBase(vds));
    runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (!vdsReturnValue.getSucceeded()) {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.error("Failed vds listing,  vds='{}'({}): {}", vds.getName(), vds.getId(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = vdsManager.handleNetworkException((VDSNetworkException) callException, vds);
            } else if (callException instanceof VDSProtocolException) {
                log.error("Failed vds listing,  vds='{}'({}): {}", vds.getName(), vds.getId(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.error("{} failed with no exception!", commandType.name());
        }
    }
    return vdsReturnValue.getSucceeded();
}
#end_block

#method_before
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.errorFormat("failed to fetch {0} stats. status remain unchanged ({1})", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#method_after
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.error("failed to fetch '{}' stats. status remain unchanged '{}'", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (vds.isBalloonEnabled()) {
        for (VmInternalData vmInternalData : runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            // save the current value for the next time we check it
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : runningVms.values()) {
        VM currentVmData = vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : runningVms.values()) {
        VM currentVmData = vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            externalVmsToAdd.add(vmStatic);
            log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!succededToRunVms.contains(vmToUpdate.getId())) {
                        succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                if ((vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.Up) || (vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp)) {
                    poweringUpVms.add(runningVm);
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debug("removing VM '{}' from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!succededToRunVms.contains(vmToUpdate.getId())) {
                        succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!vdsManager.isInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == Disk.DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        updateVmNumaNodeRuntimeInfo(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == Disk.DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#end_block

#method_before
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            if (lunsMap.isEmpty()) {
                // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
                continue;
            }
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != Disk.DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                // Hence, verify before updating.
                if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.infoFormat("Updated LUN device size - ID: {0}, previous size: {1}, new size: {2}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#method_after
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            if (lunsMap.isEmpty()) {
                // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
                continue;
            }
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != Disk.DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                // Hence, verify before updating.
                if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.info("Updated LUN device size - ID: {}, previous size: {}, new size: {}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#end_block

#method_before
void saveVmsToDb() {
    getDbFacade().getVmDynamicDao().updateAllInBatch(vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(externalVmsToAdd);
}
#method_after
void saveVmsToDb() {
    getDbFacade().getVmDynamicDao().updateAllInBatch(vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
    saveVmNumaNodeRuntimeData();
}
#end_block

#method_before
void afterVMsRefreshTreatment() {
    // rerun all vms from rerun list
    for (Guid vm_guid : vmsToRerun) {
        log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, vds.getName());
        ResourceManager.getInstance().RerunFailedCommand(vm_guid, vds.getId());
    }
    for (Guid vm_guid : succededToRunVms) {
        vdsManager.succededToRunVm(vm_guid);
    }
    // Refrain from auto-start HA VM during its re-run attempts.
    autoVmsToRun.removeAll(vmsToRerun);
    // run all vms that crushed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // process all vms that their ip changed.
    for (Map.Entry<VM, VmDynamic> pair : vmsClientIpChanged.entrySet()) {
        getVdsEventListener().processOnClientIpChange(vds, pair.getValue().getId());
    }
    // process all vms that powering up.
    for (VmDynamic runningVm : poweringUpVms) {
        ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
    }
    // process all vms that went down
    for (Guid vm_guid : vmsMovedToDown) {
        getVdsEventListener().processOnVmStop(vm_guid);
    }
    for (Guid vm_guid : vmsToRemoveFromAsync) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
    }
}
#method_after
void afterVMsRefreshTreatment() {
    // destroy
    getVdsEventListener().destroyVms(vmsToDestroy);
    // rerun all vms from rerun list
    for (Guid vm_guid : vmsToRerun) {
        log.error("Rerun VM '{}'. Called from VDS '{}'", vm_guid, vds.getName());
        ResourceManager.getInstance().RerunFailedCommand(vm_guid, vds.getId());
    }
    for (Guid vm_guid : succededToRunVms) {
        vdsManager.succededToRunVm(vm_guid);
    }
    getVdsEventListener().updateSlaPolicies(succededToRunVms, vds.getId());
    // Refrain from auto-start HA VM during its re-run attempts.
    autoVmsToRun.removeAll(vmsToRerun);
    // run all vms that crushed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // process all vms that their ip changed.
    for (Map.Entry<VM, VmDynamic> pair : vmsClientIpChanged.entrySet()) {
        getVdsEventListener().processOnClientIpChange(vds, pair.getValue().getId());
    }
    // process all vms that powering up.
    for (VmDynamic runningVm : poweringUpVms) {
        getVdsEventListener().processOnVmPoweringUp(runningVm.getId());
    }
    // process all vms that went down
    getVdsEventListener().processOnVmStop(vmsMovedToDown);
    for (Guid vm_guid : vmsToRemoveFromAsync) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
    }
}
#end_block

#method_before
private boolean isBalloonDeviceActiveOnVm(VmInternalData vmInternalData) {
    VM savedVm = vmDict.get(vmInternalData.getVmDynamic().getId());
    if (savedVm != null) {
        VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
        return // minimum allocated mem of VM == total mem, ballooning is impossible
        savedVm.getMinAllocatedMem() < savedVm.getMemSizeMb() && balloonInfo.isBalloonDeviceEnabled() && // ballooning was not requested/enabled on this VM
        balloonInfo.getBalloonTargetMemory().intValue() != balloonInfo.getBalloonMaxMemory().intValue();
    }
    return false;
}
#method_after
// ***** Helpers and sub-methods *****
private boolean isBalloonDeviceActiveOnVm(VmInternalData vmInternalData) {
    VM savedVm = vmDict.get(vmInternalData.getVmDynamic().getId());
    if (savedVm != null) {
        VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
        return // minimum allocated mem of VM == total mem, ballooning is impossible
        savedVm.getMinAllocatedMem() < savedVm.getMemSizeMb() && balloonInfo.isBalloonDeviceEnabled() && // ballooning was not requested/enabled on this VM
        balloonInfo.getBalloonTargetMemory().intValue() != balloonInfo.getBalloonMaxMemory().intValue();
    }
    return false;
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    // which is different than the one it should be running on (must be in migration process)
    if (cacheVm != null) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
    }
    if (exitStatus != VmExitStatus.Normal) {
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.info("Running on vds during rerun failed vm: '{}'", vmDynamic.getRunOnVds());
                vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage(), vmDynamic.getExitReason());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.info("Stopped migrating vm: '{}' on vds: '{}'", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.info("Could not stop migrating vm: '{0}' on vds: '{}', Error: '{}'", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage(), vmDynamic.getExitReason());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        String logicalName = null;
        if (deviceId != null && FeatureSupported.reportedDisksLogicalNames(vds.getVdsGroupCompatibilityVersion()) && VmDeviceType.DISK.getName().equals(device.get(VdsProperties.Device))) {
            try {
                logicalName = getDeviceLogicalName((Map<?, ?>) vm.get(VdsProperties.GuestDiskMapping), deviceId);
            } catch (Exception e) {
                log.error("error while getting device name when processing, vm '{}', device info '{}' with exception, skipping '{}'", vmId, device, e.getMessage());
                log.error("Exception", e);
            }
        }
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device, logicalName);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            vmDevice.setLogicalName(logicalName);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void handleRemovedDevices(Guid vmId, Set<Guid> processedDevices, List<VmDevice> devices) {
    for (VmDevice device : devices) {
        if (processedDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setAddress("");
                addVmDeviceToList(device);
                log.debugFormat("VM {0} managed pluggable device was unplugged : {1}", vmId, device);
            } else if (!devicePluggable(device)) {
                log.errorFormat("VM {0} managed non pluggable device was removed unexpectedly from libvirt: {1}", vmId, device);
            }
        } else {
            removedDeviceIds.add(device.getId());
            log.debugFormat("VM {0} unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#method_after
private void handleRemovedDevices(Guid vmId, Set<Guid> processedDevices, List<VmDevice> devices) {
    for (VmDevice device : devices) {
        if (processedDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setAddress("");
                addVmDeviceToList(device);
                log.debug("VM '{}' managed pluggable device was unplugged : '{}'", vmId, device);
            } else if (!devicePluggable(device)) {
                log.error("VM '{}' managed non pluggable device was removed unexpectedly from libvirt: '{}'", vmId, device);
            }
        } else {
            removedDeviceIds.add(device.getId());
            log.debug("VM '{}' unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, Map device, String logicalName) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.error("Empty or NULL values were passed for a VM '{}' device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null, logicalName);
        newVmDevices.add(newDevice);
        log.debug("New device was marked for adding to VM '{}' Devices : '{}'", vmId, newDevice);
    }
    return newDeviceId;
}
#end_block

#method_before
private static void logVmStatusTransition(VM vmToUpdate, VmDynamic runningVm) {
    if (vmToUpdate.getStatus() != runningVm.getStatus()) {
        log.infoFormat("VM {0} {1} moved from {2} --> {3}", vmToUpdate.getName(), vmToUpdate.getId(), vmToUpdate.getStatus().name(), runningVm.getStatus().name());
        if (vmToUpdate.getStatus() == VMStatus.Unknown) {
            logVmStatusTransionFromUnknown(vmToUpdate, runningVm);
        }
    }
}
#method_after
private static void logVmStatusTransition(VM vmToUpdate, VmDynamic runningVm) {
    if (vmToUpdate.getStatus() != runningVm.getStatus()) {
        log.info("VM {} {} moved from {} --> {}", vmToUpdate.getName(), vmToUpdate.getId(), vmToUpdate.getStatus().name(), runningVm.getStatus().name());
        if (vmToUpdate.getStatus() == VMStatus.Unknown) {
            logVmStatusTransionFromUnknown(vmToUpdate, runningVm);
        }
    }
}
#end_block

#method_before
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !autoVmsToRun.contains(vmGuid) && (!runningVms.containsKey(vmGuid) || (runningVms.containsKey(vmGuid) && runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean migrating = vmToRemove.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.info("VM '{}'({}) is running in db and not running in VDS '{}'", vmToRemove.getName(), vmToRemove.getId(), vds.getName());
        vmGuid = vmToRemove.getId();
        if (!migrating && !vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            vmsToRerun.add(vmGuid);
            log.info("add VM '{}' to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !autoVmsToRun.contains(vmGuid) && (!runningVms.containsKey(vmGuid) || runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            autoVmsToRun.add(vmGuid);
            log.info("add VM '{}' to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.infoFormat("Handing over VM {0} {1} to Host {2}. Setting VM to status {3}", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    addVmDynamicToList(vmToRemove.getDynamicData());
    addVmStatisticsToList(vmToRemove.getStatisticsData());
    addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
}
#method_after
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.info("Handing over VM '{}'({}) to Host '{}'. Setting VM to status '{}'", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    addVmDynamicToList(vmToRemove.getDynamicData());
    addVmStatisticsToList(vmToRemove.getStatisticsData());
    addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), vds.getName());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.info("RefreshVmList vm id '{}' is migrating to vds '{}' ignoring it in the refresh until migration is done", runningVm.getId(), vds.getName());
        returnValue = true;
    } else if (vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.info("RefreshVmList vm id '{}' status = '{}' on vds '{}' ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        vmsToRerun.add(runningVm.getId());
        log.info("Adding VM '{}' to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {} Device without an address when processing VM {} devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.info(message + ": {}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.info(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#end_block

#method_before
@Before
public void setup() {
    initVds();
    initConditions();
    when(vdsManager.getRefreshStatistics()).thenReturn(false);
    vmsMonitoring = Mockito.spy(new VmsMonitoring(vdsManager, vds) {

        @Override
        public DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected void auditLog(AuditLogableBase auditLogable, AuditLogType logType) {
            AuditLog al = new AuditLog();
            al.setlog_type(logType);
            mockAuditLogDao.save(al);
        }

        @Override
        protected Map[] getVmInfo(List<String> vmsToUpdate) {
            return vmInfo;
        }

        @Override
        protected List<VmDynamic> getPoweringUpVms() {
            return poweringUpVms;
        }
    });
}
#method_after
@Before
public void setup() {
    initVds();
    initConditions();
    when(vdsManager.getRefreshStatistics()).thenReturn(false);
    vmsMonitoring = Mockito.spy(new VmsMonitoring(vdsManager, vds) {

        @Override
        public DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected void auditLog(AuditLogableBase auditLogable, AuditLogType logType) {
            AuditLog al = new AuditLog();
            al.setLogType(logType);
            mockAuditLogDao.save(al);
        }

        @Override
        protected Map[] getVmInfo(List<String> vmsToUpdate) {
            return vmInfo;
        }

        @Override
        protected List<VmDynamic> getPoweringUpVms() {
            return poweringUpVms;
        }
    });
}
#end_block

#method_before
@Test
public void updateVmDevicesNotNull() {
    Guid vmGuid = Guid.newGuid();
    when(vmDeviceDAO.getVmDeviceByVmId(vmGuid)).thenReturn(Collections.<VmDevice>emptyList());
    HashMap vm = new HashMap();
    vm.put(VdsProperties.vm_guid, vmGuid.toString());
    Map<String, Object> deviceProperties = new HashMap<String, Object>();
    Guid deviceID = Guid.newGuid();
    deviceProperties.put(VdsProperties.DeviceId, deviceID.toString());
    deviceProperties.put(VdsProperties.Address, Collections.emptyMap());
    deviceProperties.put(VdsProperties.Device, "aDevice");
    deviceProperties.put(VdsProperties.Type, VmDeviceGeneralType.DISK.getValue());
    vm.put(VdsProperties.Devices, new HashMap[] { new HashMap(deviceProperties) });
    vmInfo = new HashMap[] { vm };
    vmsMonitoring.updateVmDevices(Collections.singletonList(vmGuid.toString()));
    assertEquals("wrong number of new devices", 1, vmsMonitoring.getNewVmDevices().size());
    assertEquals("wrong number of removed devices", 0, vmsMonitoring.getRemovedVmDevices().size());
}
#method_after
@Test
public void updateVmDevicesNotNull() {
    Guid vmGuid = Guid.newGuid();
    when(vmDeviceDAO.getVmDeviceByVmId(vmGuid)).thenReturn(Collections.<VmDevice>emptyList());
    HashMap vm = new HashMap();
    String testLogicalName = "TestName";
    vm.put(VdsProperties.vm_guid, vmGuid.toString());
    Map<String, Object> deviceProperties = new HashMap<String, Object>();
    Guid deviceID = Guid.newGuid();
    deviceProperties.put(VdsProperties.DeviceId, deviceID.toString());
    deviceProperties.put(VdsProperties.Address, Collections.emptyMap());
    deviceProperties.put(VdsProperties.Device, VmDeviceType.DISK.getName());
    deviceProperties.put(VdsProperties.Type, VmDeviceGeneralType.DISK.getValue());
    vm.put(VdsProperties.GuestDiskMapping, Collections.singletonMap(deviceID.toString().substring(0, 20), Collections.singletonMap(VdsProperties.Name, testLogicalName)));
    vm.put(VdsProperties.Devices, new HashMap[] { new HashMap(deviceProperties) });
    vmInfo = new HashMap[] { vm };
    vmsMonitoring.updateVmDevices(Collections.singletonList(vmGuid.toString()));
    assertEquals("wrong number of new devices", 1, vmsMonitoring.getNewVmDevices().size());
    VmDevice device = vmsMonitoring.getNewVmDevices().get(0);
    assertEquals(testLogicalName, device.getLogicalName());
    assertEquals("wrong number of removed devices", 0, vmsMonitoring.getRemovedVmDevices().size());
}
#end_block

#method_before
private void initVds() {
    vds = new VDS();
    vds.setId(new Guid("00000000-0000-0000-0000-000000000012"));
    vds.setVdsGroupCompatibilityVersion(Version.v3_4);
}
#method_after
private void initVds() {
    vds = new VDS();
    vds.setId(new Guid("00000000-0000-0000-0000-000000000012"));
    vds.setVdsGroupCompatibilityVersion(vdsCompVersion);
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                log.debug("vds '{}' ({}) firing up event.", _vds.getName(), _vds.getId());
                _vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.debug("Exception", ex);
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error("Exception", ex);
        }
    }
}
#end_block

#method_before
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        vmsMonitoring.refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        vmsMonitoring.refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error("Failure to refresh Vds '{}' runtime info. Incorrect vdsm version for cluster '{}': {}", _vds.getName(), _vds.getVdsGroupName(), cce.getMessage());
        log.debug("Exception", cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info: {}", t.getMessage());
        log.error("Exception", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getusage_mem_percent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(_vds.getVersion()) <= 0) || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getUsageMemPercent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(_vds.getVersion()) <= 0) || stat.getUsageMemPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getUsageMemPercent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() != null && stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#method_after
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getUsageCpuPercent() != null && stat.getUsageCpuPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedCpu", stat.getUsageCpuPercent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    final double THRESHOLD = 0.98;
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getSwapTotal() == null || stat.getSwapFree() == null || stat.getSwapTotal() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getSwapTotal() - stat.getSwapFree()) / stat.getSwapTotal();
    // Allow the space to be up to 2% lower than as defined in configuration
    Long allowedMinAvailableThreshold = Math.round(minAvailableThreshold.doubleValue() * THRESHOLD);
    AuditLogType valueToLog = stat.getSwapFree() < allowedMinAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getSwapFree() < allowedMinAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getSwapFree().toString());
        logable.addCustomValue("Threshold", stat.getSwapFree() < allowedMinAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void logFailureMessage(String messagePrefix, RuntimeException ex) {
    log.errorFormat("{0} Error: {1}, vds = {2} : {3}", messagePrefix, ExceptionUtils.getMessage(ex), _vds.getId(), _vds.getName());
}
#method_after
private void logFailureMessage(String messagePrefix, RuntimeException ex) {
    log.error("{} vds={}({}): {}", messagePrefix, _vds.getName(), _vds.getId(), ex.getMessage());
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        vmsMonitoring.afterVMsRefreshTreatment();
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode, probably error during " + "disconnecting it from pool. The Host will stay in Maintenance: {}", ex.getMessage());
                log.debug("Exception", ex);
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.info("Host '{}'({}) is already in NonOperational status for reason '{}'. SetNonOperationalVds command is skipped.", _vds.getName(), _vds.getId(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        vmsMonitoring.afterVMsRefreshTreatment();
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.debug("Exception", ex);
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error("Exception", ex);
    }
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    ResourceManager.getInstance().getEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, vds='{}'({})", _vds.getName(), _vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    VDSReturnValue statsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(_vds));
    getVdsEventListener().updateSchedulingStats(_vds);
    if (!statsReturnValue.getSucceeded() && statsReturnValue.getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((statsReturnValue.getExceptionObject() instanceof VDSNetworkException) ? statsReturnValue.getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.error("vds::refreshVdsStats Failed getVdsStats,  vds='{}'({}): {}", _vds.getName(), _vds.getId(), ex.getMessage());
        } else {
            log.error("vds::refreshVdsStats Failed getVdsStats,  vds='{}'({}): {}", _vds.getName(), _vds.getId(), statsReturnValue.getExceptionString());
        }
        throw statsReturnValue.getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVdsStats\n{0}", this);
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.infoFormat("Host '{0}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{1}'", _vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error("Failure on checkInterfaces on update runtimeinfo for vds: '{}': {}", _vds.getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info("Host '{}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{}'", _vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error("checkInterface: Failure on moving host: '{}' to non-operational: {}", _vds.getName(), e.getMessage());
                log.error("Exception", e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(_vds.getId())) {
        VdsNetworkInterface iface = monitoredInterfaces.get(oldIface.getName());
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#method_after
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (Map.Entry<String, InterfaceStatus> entry : oldInterfaceStatus.entrySet()) {
        VdsNetworkInterface iface = monitoredInterfaces.get(entry.getKey());
        InterfaceStatus oldStatus = entry.getValue();
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldStatus != InterfaceStatus.NONE && oldStatus != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.info("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds '{}'({})", _vds.getName(), _vds.getId());
        } else {
            vdsMaintenanceTimeoutOccurred = _vdsManager.isTimeToRetryMaintenance();
        }
    }
}
#end_block

#method_before
@Before
public void setup() {
    initVds();
    initConditions();
    when(vdsManager.getRefreshStatistics()).thenReturn(false);
    updater = Mockito.spy(new HostMonitoring(vdsManager, vds, mock(MonitoringStrategy.class)) {

        @Override
        public DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected void auditLog(AuditLogableBase auditLogable, AuditLogType logType) {
            AuditLog al = new AuditLog();
            al.setlog_type(logType);
            mockAuditLogDao.save(al);
        }
    });
}
#method_after
@Before
public void setup() {
    initVds();
    initConditions();
    when(vdsManager.getRefreshStatistics()).thenReturn(false);
    updater = Mockito.spy(new HostMonitoring(vdsManager, vds, mock(MonitoringStrategy.class)) {

        @Override
        public DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected void auditLog(AuditLogableBase auditLogable, AuditLogType logType) {
            AuditLog al = new AuditLog();
            al.setLogType(logType);
            mockAuditLogDao.save(al);
        }
    });
}
#end_block

#method_before
public boolean fetchRunningVms() {
    VDSCommandType commandType = vdsManager.getRefreshStatistics() ? VDSCommandType.GetAllVmStats : VDSCommandType.List;
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(commandType, new VdsIdAndVdsVDSCommandParametersBase(vds));
    runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (!vdsReturnValue.getSucceeded()) {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", vds.getId(), vds.getName(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = vdsManager.handleNetworkException((VDSNetworkException) callException, vds);
            } else if (callException instanceof VDSProtocolException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", vds.getId(), vds.getName(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.errorFormat("{0} failed with no exception!", commandType.name());
        }
    }
    return vdsReturnValue.getSucceeded();
}
#method_after
public boolean fetchRunningVms() {
    VDSCommandType commandType = vdsManager.getRefreshStatistics() ? VDSCommandType.GetAllVmStats : VDSCommandType.List;
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(commandType, new VdsIdAndVdsVDSCommandParametersBase(vds));
    runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (!vdsReturnValue.getSucceeded()) {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.error("Failed vds listing,  vds='{}'({}): {}", vds.getName(), vds.getId(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = vdsManager.handleNetworkException((VDSNetworkException) callException, vds);
            } else if (callException instanceof VDSProtocolException) {
                log.error("Failed vds listing,  vds='{}'({}): {}", vds.getName(), vds.getId(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.error("{} failed with no exception!", commandType.name());
        }
    }
    return vdsReturnValue.getSucceeded();
}
#end_block

#method_before
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.errorFormat("failed to fetch {0} stats. status remain unchanged ({1})", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#method_after
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.error("failed to fetch '{}' stats. status remain unchanged '{}'", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (vds.isBalloonEnabled()) {
        for (VmInternalData vmInternalData : runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            // save the current value for the next time we check it
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : runningVms.values()) {
        VM currentVmData = vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : runningVms.values()) {
        VM currentVmData = vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                if ((vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.Up) || (vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp)) {
                    _poweringUpVms.add(runningVm);
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debug("removing VM '{}' from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!vdsManager.isInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == Disk.DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        updateVmNumaNodeRuntimeInfo(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == Disk.DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#end_block

#method_before
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            if (lunsMap.isEmpty()) {
                // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
                continue;
            }
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != Disk.DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                // Hence, verify before updating.
                if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.infoFormat("Updated LUN device size - ID: {0}, previous size: {1}, new size: {2}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#method_after
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            if (lunsMap.isEmpty()) {
                // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
                continue;
            }
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != Disk.DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                // Hence, verify before updating.
                if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.info("Updated LUN device size - ID: {}, previous size: {}, new size: {}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#end_block

#method_before
protected void updateVmJobs() {
    // The database vmJob records are synced with the vmJobs returned from each VM.
    vmJobIdsToRemove.clear();
    vmJobsToUpdate.clear();
    for (Map.Entry<Guid, VmInternalData> vmInternalData : runningVms.entrySet()) {
        Set<Guid> vmJobIdsToIgnore = new HashSet<>();
        Map<Guid, VmJob> jobsFromDb = new HashMap<>();
        for (VmJob job : getDbFacade().getVmJobDao().getAllForVm(vmInternalData.getKey())) {
            // others are completely ignored for the time being
            if (existingVmJobIds.contains(job.getId())) {
                jobsFromDb.put(job.getId(), job);
            }
        }
        if (vmInternalData.getValue().getVmStatistics().getVmJobs() == null) {
            // If no vmJobs key was returned, we can't presume anything about the jobs; save them all
            log.debug("No vmJob data returned from VDSM, preserving existing jobs");
            continue;
        }
        for (VmJob jobFromVds : vmInternalData.getValue().getVmStatistics().getVmJobs()) {
            if (jobsFromDb.containsKey(jobFromVds.getId())) {
                if (jobsFromDb.get(jobFromVds.getId()).equals(jobFromVds)) {
                    // Same data, no update needed.  It would be nice if a caching
                    // layer would take care of this for us.
                    vmJobIdsToIgnore.add(jobFromVds.getId());
                    log.infoFormat("VM job {0}: In progress (no change)", jobFromVds.getId());
                } else {
                    vmJobsToUpdate.put(jobFromVds.getId(), jobFromVds);
                    log.infoFormat("VM job {0}: In progress, updating", jobFromVds.getId());
                }
            }
        }
        // Any existing jobs not saved need to be removed
        for (Guid id : jobsFromDb.keySet()) {
            if (!vmJobsToUpdate.containsKey(id) && !vmJobIdsToIgnore.contains(id)) {
                vmJobIdsToRemove.add(id);
                log.infoFormat("VM job {0}: Deleting", id);
            }
        }
    }
}
#method_after
protected void updateVmJobs() {
    // The database vmJob records are synced with the vmJobs returned from each VM.
    vmJobIdsToRemove.clear();
    vmJobsToUpdate.clear();
    for (Map.Entry<Guid, VmInternalData> vmInternalData : runningVms.entrySet()) {
        Set<Guid> vmJobIdsToIgnore = new HashSet<>();
        Map<Guid, VmJob> jobsFromDb = new HashMap<>();
        for (VmJob job : getDbFacade().getVmJobDao().getAllForVm(vmInternalData.getKey())) {
            // others are completely ignored for the time being
            if (existingVmJobIds.contains(job.getId())) {
                jobsFromDb.put(job.getId(), job);
            }
        }
        if (vmInternalData.getValue().getVmStatistics().getVmJobs() == null) {
            // If no vmJobs key was returned, we can't presume anything about the jobs; save them all
            log.debug("No vmJob data returned from VDSM, preserving existing jobs");
            continue;
        }
        for (VmJob jobFromVds : vmInternalData.getValue().getVmStatistics().getVmJobs()) {
            if (jobsFromDb.containsKey(jobFromVds.getId())) {
                if (jobsFromDb.get(jobFromVds.getId()).equals(jobFromVds)) {
                    // Same data, no update needed.  It would be nice if a caching
                    // layer would take care of this for us.
                    vmJobIdsToIgnore.add(jobFromVds.getId());
                    log.info("VM job {}: In progress (no change)", jobFromVds.getId());
                } else {
                    vmJobsToUpdate.put(jobFromVds.getId(), jobFromVds);
                    log.info("VM job {}: In progress, updating", jobFromVds.getId());
                }
            }
        }
        // Any existing jobs not saved need to be removed
        for (Guid id : jobsFromDb.keySet()) {
            if (!vmJobsToUpdate.containsKey(id) && !vmJobIdsToIgnore.contains(id)) {
                vmJobIdsToRemove.add(id);
                log.info("VM job {}: Deleting", id);
            }
        }
    }
}
#end_block

#method_before
void saveVmsToDb() {
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmJobsToDb();
}
#method_after
void saveVmsToDb() {
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
    saveVmNumaNodeRuntimeData();
}
#end_block

#method_before
void afterVMsRefreshTreatment() {
    // rerun all vms from rerun list
    for (Guid vm_guid : _vmsToRerun) {
        log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, vds.getName());
        ResourceManager.getInstance().RerunFailedCommand(vm_guid, vds.getId());
    }
    for (Guid vm_guid : _succededToRunVms) {
        vdsManager.succededToRunVm(vm_guid);
    }
    // Refrain from auto-start HA VM during its re-run attempts.
    _autoVmsToRun.removeAll(_vmsToRerun);
    // run all vms that crushed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
    // process all vms that their ip changed.
    for (Map.Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
        getVdsEventListener().processOnClientIpChange(vds, pair.getValue().getId());
    }
    // process all vms that powering up.
    for (VmDynamic runningVm : _poweringUpVms) {
        ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
    }
    // process all vms that went down
    getVdsEventListener().processOnVmStop(_vmsMovedToDown);
    for (Guid vm_guid : _vmsToRemoveFromAsync) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
    }
}
#method_after
void afterVMsRefreshTreatment() {
    // destroy
    getVdsEventListener().destroyVms(vmsToDestroy);
    // rerun all vms from rerun list
    for (Guid vm_guid : _vmsToRerun) {
        log.error("Rerun VM '{}'. Called from VDS '{}'", vm_guid, vds.getName());
        ResourceManager.getInstance().RerunFailedCommand(vm_guid, vds.getId());
    }
    for (Guid vm_guid : _succededToRunVms) {
        vdsManager.succededToRunVm(vm_guid);
    }
    getVdsEventListener().updateSlaPolicies(_succededToRunVms, vds.getId());
    // Refrain from auto-start HA VM during its re-run attempts.
    _autoVmsToRun.removeAll(_vmsToRerun);
    // run all vms that crushed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
    // process all vms that their ip changed.
    for (Map.Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
        getVdsEventListener().processOnClientIpChange(vds, pair.getValue().getId());
    }
    // process all vms that powering up.
    for (VmDynamic runningVm : _poweringUpVms) {
        getVdsEventListener().processOnVmPoweringUp(runningVm.getId());
    }
    // process all vms that went down
    getVdsEventListener().processOnVmStop(_vmsMovedToDown);
    for (Guid vm_guid : _vmsToRemoveFromAsync) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
    }
}
#end_block

#method_before
private boolean isBalloonDeviceActiveOnVm(VmInternalData vmInternalData) {
    VM savedVm = vmDict.get(vmInternalData.getVmDynamic().getId());
    if (savedVm != null) {
        VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
        return // minimum allocated mem of VM == total mem, ballooning is impossible
        savedVm.getMinAllocatedMem() < savedVm.getMemSizeMb() && balloonInfo.isBalloonDeviceEnabled() && // ballooning was not requested/enabled on this VM
        balloonInfo.getBalloonTargetMemory().intValue() != balloonInfo.getBalloonMaxMemory().intValue();
    }
    return false;
}
#method_after
// ***** Helpers and sub-methods *****
private boolean isBalloonDeviceActiveOnVm(VmInternalData vmInternalData) {
    VM savedVm = vmDict.get(vmInternalData.getVmDynamic().getId());
    if (savedVm != null) {
        VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
        return // minimum allocated mem of VM == total mem, ballooning is impossible
        savedVm.getMinAllocatedMem() < savedVm.getMemSizeMb() && balloonInfo.isBalloonDeviceEnabled() && // ballooning was not requested/enabled on this VM
        balloonInfo.getBalloonTargetMemory().intValue() != balloonInfo.getBalloonMaxMemory().intValue();
    }
    return false;
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    // which is different than the one it should be running on (must be in migration process)
    if (cacheVm != null) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
    }
    if (exitStatus != VmExitStatus.Normal) {
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.info("Running on vds during rerun failed vm: '{}'", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage(), vmDynamic.getExitReason());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.info("Stopped migrating vm: '{}' on vds: '{}'", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.info("Could not stop migrating vm: '{0}' on vds: '{}', Error: '{}'", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage(), vmDynamic.getExitReason());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        String logicalName = null;
        if (deviceId != null && FeatureSupported.reportedDisksLogicalNames(vds.getVdsGroupCompatibilityVersion()) && VmDeviceType.DISK.getName().equals(device.get(VdsProperties.Device))) {
            try {
                logicalName = getDeviceLogicalName((Map<?, ?>) vm.get(VdsProperties.GuestDiskMapping), deviceId);
            } catch (Exception e) {
                log.error("error while getting device name when processing, vm '{}', device info '{}' with exception, skipping '{}'", vmId, device, e.getMessage());
                log.error("Exception", e);
            }
        }
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device, logicalName);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            vmDevice.setLogicalName(logicalName);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void handleRemovedDevices(Guid vmId, Set<Guid> processedDevices, List<VmDevice> devices) {
    for (VmDevice device : devices) {
        if (processedDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setAddress("");
                addVmDeviceToList(device);
                log.debugFormat("VM {0} managed pluggable device was unplugged : {1}", vmId, device);
            } else if (!devicePluggable(device)) {
                log.errorFormat("VM {0} managed non pluggable device was removed unexpectedly from libvirt: {1}", vmId, device);
            }
        } else {
            removedDeviceIds.add(device.getId());
            log.debugFormat("VM {0} unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#method_after
private void handleRemovedDevices(Guid vmId, Set<Guid> processedDevices, List<VmDevice> devices) {
    for (VmDevice device : devices) {
        if (processedDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setAddress("");
                addVmDeviceToList(device);
                log.debug("VM '{}' managed pluggable device was unplugged : '{}'", vmId, device);
            } else if (!devicePluggable(device)) {
                log.error("VM '{}' managed non pluggable device was removed unexpectedly from libvirt: '{}'", vmId, device);
            }
        } else {
            removedDeviceIds.add(device.getId());
            log.debug("VM '{}' unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, Map device, String logicalName) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.error("Empty or NULL values were passed for a VM '{}' device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null, logicalName);
        newVmDevices.add(newDevice);
        log.debug("New device was marked for adding to VM '{}' Devices : '{}'", vmId, newDevice);
    }
    return newDeviceId;
}
#end_block

#method_before
private static void logVmStatusTransition(VM vmToUpdate, VmDynamic runningVm) {
    if (vmToUpdate.getStatus() != runningVm.getStatus()) {
        log.infoFormat("VM {0} {1} moved from {2} --> {3}", vmToUpdate.getName(), vmToUpdate.getId(), vmToUpdate.getStatus().name(), runningVm.getStatus().name());
        if (vmToUpdate.getStatus() == VMStatus.Unknown) {
            logVmStatusTransionFromUnknown(vmToUpdate, runningVm);
        }
    }
}
#method_after
private static void logVmStatusTransition(VM vmToUpdate, VmDynamic runningVm) {
    if (vmToUpdate.getStatus() != runningVm.getStatus()) {
        log.info("VM {} {} moved from {} --> {}", vmToUpdate.getName(), vmToUpdate.getId(), vmToUpdate.getStatus().name(), runningVm.getStatus().name());
        if (vmToUpdate.getStatus() == VMStatus.Unknown) {
            logVmStatusTransionFromUnknown(vmToUpdate, runningVm);
        }
    }
}
#end_block

#method_before
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!runningVms.containsKey(vmGuid) || (runningVms.containsKey(vmGuid) && runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean migrating = vmToRemove.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.info("VM '{}'({}) is running in db and not running in VDS '{}'", vmToRemove.getName(), vmToRemove.getId(), vds.getName());
        vmGuid = vmToRemove.getId();
        if (!migrating && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.info("add VM '{}' to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!runningVms.containsKey(vmGuid) || runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            _autoVmsToRun.add(vmGuid);
            log.info("add VM '{}' to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.infoFormat("Handing over VM {0} {1} to Host {2}. Setting VM to status {3}", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    addVmDynamicToList(vmToRemove.getDynamicData());
    addVmStatisticsToList(vmToRemove.getStatisticsData());
    addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
}
#method_after
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.info("Handing over VM '{}'({}) to Host '{}'. Setting VM to status '{}'", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    addVmDynamicToList(vmToRemove.getDynamicData());
    addVmStatisticsToList(vmToRemove.getStatisticsData());
    addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), vds.getName());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.info("RefreshVmList vm id '{}' is migrating to vds '{}' ignoring it in the refresh until migration is done", runningVm.getId(), vds.getName());
        returnValue = true;
    } else if (vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.info("RefreshVmList vm id '{}' status = '{}' on vds '{}' ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.info("Adding VM '{}' to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {} Device without an address when processing VM {} devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.info(message + ": {}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.info(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#end_block

#method_before
public void updateStatisticsData(VdsStatistics statisticsData) {
    DbFacade.getInstance().getVdsStatisticsDao().update(statisticsData);
}
#method_after
public void updateStatisticsData(VdsStatistics statisticsData) {
    DbFacade.getInstance().getVdsStatisticsDao().update(statisticsData);
    cachedVds.setStatisticsData(statisticsData);
}
#end_block

#method_before
@Override
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.InstallFailed) {
            setStatus(VDSStatus.NonResponsive, vds);
            updateDynamicData(vds.getDynamicData());
        }
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = new AuditLogableBase(vdsId);
        AuditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#method_after
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.InstallFailed) {
            setStatus(VDSStatus.NonResponsive, vds);
            updateDynamicData(vds.getDynamicData());
        }
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = new AuditLogableBase(vdsId);
        AuditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#end_block

#method_before
@Override
public void handlePreviousStatus() {
    if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        vds.setPreviousStatus(vds.getStatus());
    } else {
        vds.setPreviousStatus(VDSStatus.Up);
    }
}
#method_after
public void handlePreviousStatus() {
    if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        vds.setPreviousStatus(vds.getStatus());
    } else {
        vds.setPreviousStatus(VDSStatus.Up);
    }
}
#end_block

#method_before
@Override
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    // start with refresh statistics
    refreshIteration = numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS);
}
#method_after
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    // start with refresh statistics
    refreshIteration = numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public void updateVmDynamic(VmDynamic vmDynamic) {
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#method_after
public void updateVmDynamic(VmDynamic vmDynamic) {
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
                if (vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (refreshIteration == numberRefreshesBeforeSave) {
                        refreshIteration = 1;
                    } else {
                        refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(VdsManager.this, vds, monitoringStrategy);
                        hostMonitoring.refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && vds.getStatus() != VDSStatus.NonResponsive && vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (vds != null && vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = vds.getStoragePoolId();
                            domainsList = vds.getDomains();
                        }
                    }
                    vds = null;
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
                if (vds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    if (refreshIteration == numberRefreshesBeforeSave) {
                        refreshIteration = 1;
                    } else {
                        refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(VdsManager.this, vds, monitoringStrategy);
                        hostMonitoring.refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!isInitialized() && vds.getStatus() != VDSStatus.NonResponsive && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
                        log.info("Initializing Host: '{}'", vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (vds != null && vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = vds.getStoragePoolId();
                            domainsList = vds.getDomains();
                        }
                    }
                    vds = null;
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
private void logFailureMessage(RuntimeException ex) {
    log.warnFormat("Failed to refresh VDS , vds = {0} : {1}, error = '{2}', continuing.", vds.getId(), vds.getName(), ex);
}
#method_after
private void logFailureMessage(RuntimeException ex) {
    log.warn("Failed to refresh VDS, continuing, vds ='{}' ('{}'): {}", vds.getName(), vds.getId(), ex.getMessage());
    log.error("Exception", ex);
}
#end_block

#method_before
private void logAfterRefreshFailureMessage(RuntimeException ex) {
    log.warnFormat("Failed to AfterRefreshTreatment VDS  error = '{0}', continuing.", ExceptionUtils.getMessage(ex));
}
#method_after
private void logAfterRefreshFailureMessage(RuntimeException ex) {
    log.warn("Failed to AfterRefreshTreatment VDS, continuing: {}", ex.getMessage());
    log.debug("Exception", ex);
}
#end_block

#method_before
@Override
public boolean isMonitoringNeeded() {
    return (monitoringStrategy.isMonitoringNeeded(vds) && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.InstallFailed && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.Down);
}
#method_after
public boolean isMonitoringNeeded() {
    return (monitoringStrategy.isMonitoringNeeded(vds) && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.InstallFailed && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS && vds.getStatus() != VDSStatus.Down && vds.getStatus() != VDSStatus.Kdumping);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimerHandleVdsRecovering")
public void onTimerHandleVdsRecovering() {
    recoveringJobIdMap.remove(getVdsId());
    VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
    if (vds.getStatus() == VDSStatus.Initializing) {
        try {
            ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH, true, Guid.Empty);
            setIsSetNonOperationalExecuted(true);
        } catch (RuntimeException exp) {
            log.errorFormat("HandleVdsRecoveringException::Error in recovery timer treatment, vds = {0} : {1}, error = {2}.", vds.getId(), vds.getName(), exp.getMessage());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimerHandleVdsRecovering")
public void onTimerHandleVdsRecovering() {
    recoveringJobIdMap.remove(getVdsId());
    VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
    if (vds.getStatus() == VDSStatus.Initializing) {
        try {
            ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH, true, Guid.Empty);
            setIsSetNonOperationalExecuted(true);
        } catch (RuntimeException exp) {
            log.error("HandleVdsRecoveringException::Error in recovery timer treatment, vds='{}'({}): {}", vds.getName(), vds.getId(), exp.getMessage());
            log.debug("Exception", exp);
        }
    }
}
#end_block

#method_before
@Override
public void updateDynamicData(VdsDynamic dynamicData) {
    DbFacade.getInstance().getVdsDynamicDao().updateIfNeeded(dynamicData);
}
#method_after
public void updateDynamicData(VdsDynamic dynamicData) {
    DbFacade.getInstance().getVdsDynamicDao().updateIfNeeded(dynamicData);
}
#end_block

#method_before
@Override
public void updateStatisticsData(VdsStatistics statisticsData) {
    DbFacade.getInstance().getVdsStatisticsDao().update(statisticsData);
}
#method_after
public void updateStatisticsData(VdsStatistics statisticsData) {
    DbFacade.getInstance().getVdsStatisticsDao().update(statisticsData);
}
#end_block

#method_before
public void updateNumaData(final VDS vds) {
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = NumaUtils.getVdsNumaNodeByIndex(dbVdsNumaNodes, node.getIndex());
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    if (!numaNodesToRemove.isEmpty()) {
        DbFacade.getInstance().getVdsNumaNodeDAO().massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
    }
    if (!numaNodesToUpdate.isEmpty()) {
        DbFacade.getInstance().getVdsNumaNodeDAO().massUpdateNumaNode(numaNodesToUpdate);
    }
    if (!numaNodesToSave.isEmpty()) {
        DbFacade.getInstance().getVdsNumaNodeDAO().massSaveNumaNode(numaNodesToSave, vds.getId(), null);
    }
}
#method_after
public void updateNumaData(final VDS vds) {
    if (vds.getNumaNodeList() == null || vds.getNumaNodeList().isEmpty()) {
        return;
    }
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = NumaUtils.getVdsNumaNodeByIndex(dbVdsNumaNodes, node.getIndex());
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    // The database operation should be in one transaction
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!numaNodesToRemove.isEmpty()) {
                DbFacade.getInstance().getVdsNumaNodeDAO().massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
            }
            if (!numaNodesToUpdate.isEmpty()) {
                DbFacade.getInstance().getVdsNumaNodeDAO().massUpdateNumaNode(numaNodesToUpdate);
            }
            if (!numaNodesToSave.isEmpty()) {
                DbFacade.getInstance().getVdsNumaNodeDAO().massSaveNumaNode(numaNodesToSave, vds.getId(), null);
            }
            return null;
        }
    });
}
#end_block

#method_before
@Override
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getPreviousStatus() != vds.getStatus()) {
            vds.setPreviousStatus(vds.getStatus());
            if (vds != null) {
                vds.setPreviousStatus(vds.getStatus());
                if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                    calculateNextMaintenanceAttemptTime();
                }
            }
        }
        // update to new status
        vds.setStatus(status);
        if (this.vds != null) {
            this.vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (this.vds != null) {
                    this.vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (this.vds != null) {
                    this.vds.setCpuSys(Double.valueOf(0));
                    this.vds.setCpuUser(Double.valueOf(0));
                    this.vds.setCpuIdle(Double.valueOf(0));
                    this.vds.setCpuLoad(Double.valueOf(0));
                    this.vds.setUsageCpuPercent(0);
                    this.vds.setUsageMemPercent(0);
                    this.vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#method_after
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getStatus() != status) {
            if (status == VDSStatus.PreparingForMaintenance) {
                calculateNextMaintenanceAttemptTime();
            }
            vds.setPreviousStatus(vds.getStatus());
            if (this.vds != null) {
                this.vds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (this.vds != null) {
            this.vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (this.vds != null) {
                    this.vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (this.vds != null) {
                    this.vds.setCpuSys(Double.valueOf(0));
                    this.vds.setCpuUser(Double.valueOf(0));
                    this.vds.setCpuIdle(Double.valueOf(0));
                    this.vds.setCpuLoad(Double.valueOf(0));
                    this.vds.setUsageCpuPercent(0);
                    this.vds.setUsageMemPercent(0);
                    this.vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("recoverFromError")
public void recoverFromError() {
    VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
    /**
     * Move vds to Up status from error
     */
    if (vds != null && vds.getStatus() == VDSStatus.Error) {
        setStatus(VDSStatus.Up, vds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(getVdsId(), VDSStatus.Up);
        log.infoFormat("Settings host {0} to up after {1} failed attempts to run a VM", vds.getName(), mFailedToRunVmAttempts);
        mFailedToRunVmAttempts.set(0);
    }
}
#method_after
@OnTimerMethodAnnotation("recoverFromError")
public void recoverFromError() {
    VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
    /**
     * Move vds to Up status from error
     */
    if (vds != null && vds.getStatus() == VDSStatus.Error) {
        setStatus(VDSStatus.Up, vds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(getVdsId(), VDSStatus.Up);
        log.info("Settings host '{}' to up after {} failed attempts to run a VM", vds.getName(), mFailedToRunVmAttempts);
        mFailedToRunVmAttempts.set(0);
    }
}
#end_block

#method_before
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes), TimeUnit.MINUTES);
        AuditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString()), AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#method_after
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes), TimeUnit.MINUTES);
        AuditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString()), AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.info("Vds '{}' moved to Error mode after {} attempts. Time: {}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#end_block

#method_before
@Override
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debugFormat("monitoring: refresh {0} capabilities", vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED)) {
            AuditLogDirector.log(new AuditLogableBase(vds.getId()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warnFormat("Host {0} is running with disabled SELinux.", vds.getName());
            } else {
                log.warnFormat("Host {0} does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            DbFacade.getInstance().getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED)) {
            AuditLogDirector.log(new AuditLogableBase(vds.getId()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warn("Host '{}' is running with disabled SELinux.", vds.getName());
            } else {
                log.warn("Host '{}' does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debug("monitoring: vds '{}' networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            DbFacade.getInstance().getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
@Override
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        log.warnFormat("Host {0} is not responding. It will stay in Connecting state for a grace period of ${1} seconds and after that an attempt to fence the host will be issued.", vds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(vds.getId());
        logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
        AuditLogDirector.log(logable, AuditLogType.VDS_HOST_IN_CONNECTING_STATE);
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing);
    }
    return true;
}
#method_after
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        log.warn("Host '{}' is not responding. It will stay in Connecting state for a grace period " + "of {} seconds and after that an attempt to fence the host will be issued.", vds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(vds.getId());
        logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
        AuditLogDirector.log(logable, AuditLogType.VDS_HOST_NOT_RESPONDING_CONNECTING);
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        moveVMsToUnknown();
        log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing, lastUpdate);
    }
    return true;
}
#end_block

#method_before
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    XmlRpcUtils.shutDownConnection(((VdsServerWrapper) vdsProxy).getHttpClient());
}
#method_after
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    vdsProxy.close();
}
#end_block

#method_before
@Override
public void logNetworkException(VDSNetworkException e) {
    switch(vds.getStatus()) {
        case Down:
            break;
        case NonResponsive:
            log.debugFormat("Failed to refresh VDS , vds = {0} : {1}, VDS Network Error, continuing.\n{2}", vds.getId(), vds.getName(), e.getMessage());
            break;
        default:
            log.warnFormat("Failed to refresh VDS , vds = {0} : {1}, VDS Network Error, continuing.\n{2}", vds.getId(), vds.getName(), e.getMessage());
    }
}
#method_after
private void logNetworkException(VDSNetworkException e) {
    switch(vds.getStatus()) {
        case Down:
            break;
        case NonResponsive:
            log.debug("Failed to refresh VDS, network error, continuing, vds='{}'({}): {}", vds.getName(), vds.getId(), e.getMessage());
            break;
        default:
            log.warn("Failed to refresh VDS, network error, continuing, vds='{}'({}): {}", vds.getName(), vds.getId(), e.getMessage());
    }
    log.debug("Exception", e);
}
#end_block

#method_before
@Override
public void finishSshSoftFencingExecution(VDS vds) {
    // reset the unresponded counter to wait if VDSM restart helps
    mUnrespondedAttempts.set(0);
    // change VDS state to connecting
    setStatus(VDSStatus.Connecting, vds);
    updateDynamicData(vds.getDynamicData());
}
#method_after
public void finishSshSoftFencingExecution(VDS vds) {
    // reset the unresponded counter to wait if VDSM restart helps
    mUnrespondedAttempts.set(0);
    // change VDS state to connecting
    setStatus(VDSStatus.Connecting, vds);
    updateDynamicData(vds.getDynamicData());
}
#end_block

#method_before
public void setInitialized(boolean value) {
    privateInitialized = value;
}
#method_after
public void setInitialized(boolean value) {
    initialized = value;
}
#end_block

#method_before
public static void cancelRecoveryJob(Guid vdsId) {
    String jobId = recoveringJobIdMap.remove(vdsId);
    if (jobId != null) {
        log.infoFormat("Cancelling the recovery from crash timer for VDS {0} because vds started initializing", vdsId);
        try {
            SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
        } catch (Exception e) {
            log.warnFormat("Failed deleting job {0} at cancelRecoveryJob", jobId);
        }
    }
}
#method_after
public static void cancelRecoveryJob(Guid vdsId) {
    String jobId = recoveringJobIdMap.remove(vdsId);
    if (jobId != null) {
        log.info("Cancelling the recovery from crash timer for VDS '{}' because vds started initializing", vdsId);
        try {
            SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
        } catch (Exception e) {
            log.warn("Failed deleting job '{}' at cancelRecoveryJob: {}", jobId, e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                log.debug("vds '{}' ({}) firing up event.", _vds.getName(), _vds.getId());
                _vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.debug("Exception", ex);
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error("Exception", ex);
        }
    }
}
#end_block

#method_before
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error("Failure to refresh Vds '{}' runtime info. Incorrect vdsm version for cluster '{}': {}", _vds.getName(), _vds.getVdsGroupName(), cce.getMessage());
        log.debug("Exception", cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info: {}", t.getMessage());
        log.error("Exception", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void saveVmsToDb() {
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveVmsToDb() {
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
}
#end_block

#method_before
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getusage_mem_percent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(_vds.getVersion()) <= 0) || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getUsageMemPercent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(_vds.getVersion()) <= 0) || stat.getUsageMemPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getUsageMemPercent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() != null && stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#method_after
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getUsageCpuPercent() != null && stat.getUsageCpuPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedCpu", stat.getUsageCpuPercent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    final double THRESHOLD = 0.98;
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getSwapTotal() == null || stat.getSwapFree() == null || stat.getSwapTotal() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getSwapTotal() - stat.getSwapFree()) / stat.getSwapTotal();
    // Allow the space to be up to 2% lower than as defined in configuration
    Long allowedMinAvailableThreshold = Math.round(minAvailableThreshold.doubleValue() * THRESHOLD);
    AuditLogType valueToLog = stat.getSwapFree() < allowedMinAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getSwapFree() < allowedMinAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getSwapFree().toString());
        logable.addCustomValue("Threshold", stat.getSwapFree() < allowedMinAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void logFailureMessage(String messagePrefix, RuntimeException ex) {
    log.errorFormat("{0} Error: {1}, vds = {2} : {3}", messagePrefix, ExceptionUtils.getMessage(ex), _vds.getId(), _vds.getName());
}
#method_after
private void logFailureMessage(String messagePrefix, RuntimeException ex) {
    log.error("{} vds={}({}): {}", messagePrefix, _vds.getName(), _vds.getId(), ex.getMessage());
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        afterVMsRefreshTreatment();
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode, probably error during " + "disconnecting it from pool. The Host will stay in Maintenance: {}", ex.getMessage());
                log.debug("Exception", ex);
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.info("Host '{}'({}) is already in NonOperational status for reason '{}'. SetNonOperationalVds command is skipped.", _vds.getName(), _vds.getId(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        afterVMsRefreshTreatment();
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.debug("Exception", ex);
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error("Exception", ex);
    }
}
#end_block

#method_before
private void afterVMsRefreshTreatment() {
    // rerun all vms from rerun list
    for (Guid vm_guid : _vmsToRerun) {
        log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
        ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
    }
    for (Guid vm_guid : _succededToRunVms) {
        _vdsManager.succededToRunVm(vm_guid);
    }
    // Refrain from auto-start HA VM during its re-run attempts.
    _autoVmsToRun.removeAll(_vmsToRerun);
    // run all vms that crushed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
    // process all vms that their ip changed.
    for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
        getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
    }
    // process all vms that powering up.
    for (VmDynamic runningVm : _poweringUpVms) {
        ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
    }
    // process all vms that went down
    for (Guid vm_guid : _vmsMovedToDown) {
        getVdsEventListener().processOnVmStop(vm_guid);
    }
    for (Guid vm_guid : _vmsToRemoveFromAsync) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
    }
}
#method_after
private void afterVMsRefreshTreatment() {
    // destroy
    getVdsEventListener().destroyVms(vmsToDestroy);
    // rerun all vms from rerun list
    for (Guid vm_guid : _vmsToRerun) {
        log.error("Rerun vm '{}'. Called from vds '{}'", vm_guid, _vds.getName());
        ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
    }
    for (Guid vm_guid : _succededToRunVms) {
        _vdsManager.succededToRunVm(vm_guid);
    }
    getVdsEventListener().updateSlaPolicies(_succededToRunVms, _vds.getId());
    // Refrain from auto-start HA VM during its re-run attempts.
    _autoVmsToRun.removeAll(_vmsToRerun);
    // run all vms that crushed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
    // process all vms that their ip changed.
    for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
        getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
    }
    // process all vms that powering up.
    for (VmDynamic runningVm : _poweringUpVms) {
        getVdsEventListener().processOnVmPoweringUp(runningVm.getId());
    }
    // process all vms that went down
    getVdsEventListener().processOnVmStop(_vmsMovedToDown);
    for (Guid vm_guid : _vmsToRemoveFromAsync) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
    }
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    ResourceManager.getInstance().getEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, vds='{}'({})", _vds.getName(), _vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    getVdsEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.error("vds::refreshVdsStats Failed getVdsStats,  vds='{}'({}): {}", _vds.getName(), _vds.getId(), ex.getMessage());
        } else {
            log.error("vds::refreshVdsStats Failed getVdsStats,  vds='{}'({}): {}", _vds.getName(), _vds.getId(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVdsStats\n{0}", this);
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error("Failure on checkInterfaces on update runtimeinfo for vds: '{}': {}", _vds.getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info("Host '{}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{}'", _vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error("checkInterface: Failure on moving host: '{}' to non-operational: {}", _vds.getName(), e.getMessage());
                log.error("Exception", e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(_vds.getId())) {
        VdsNetworkInterface iface = monitoredInterfaces.get(oldIface.getName());
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#method_after
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (Map.Entry<String, InterfaceStatus> entry : oldInterfaceStatus.entrySet()) {
        VdsNetworkInterface iface = monitoredInterfaces.get(entry.getKey());
        InterfaceStatus oldStatus = entry.getValue();
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldStatus != InterfaceStatus.NONE && oldStatus != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#end_block

#method_before
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    // Retrieve the list of existing jobs and/or job placeholders.  Only these jobs
    // are allowed to be updated by updateVmJobs()
    refreshExistingVmJobList();
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
        updateVmJobs();
    }
}
#end_block

#method_before
protected boolean fetchRunningVms() {
    VDSCommandType commandType = _vdsManager.getRefreshStatistics() ? VDSCommandType.GetAllVmStats : VDSCommandType.List;
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(commandType, new VdsIdAndVdsVDSCommandParametersBase(_vds));
    _runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (!vdsReturnValue.getSucceeded()) {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) callException, _vds);
            } else if (callException instanceof VDSProtocolException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.errorFormat("{0} failed with no exception!", commandType.name());
        }
    }
    return vdsReturnValue.getSucceeded();
}
#method_after
protected boolean fetchRunningVms() {
    VDSCommandType commandType = _vdsManager.getRefreshStatistics() ? VDSCommandType.GetAllVmStats : VDSCommandType.List;
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(commandType, new VdsIdAndVdsVDSCommandParametersBase(_vds));
    _runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (!vdsReturnValue.getSucceeded()) {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.error("Failed vds listing,  vds='{}'({}): {}", _vds.getName(), _vds.getId(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) callException, _vds);
            } else if (callException instanceof VDSProtocolException) {
                log.error("Failed vds listing,  vds='{}'({}): {}", _vds.getName(), _vds.getId(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.error("{} failed with no exception!", commandType.name());
        }
    }
    return vdsReturnValue.getSucceeded();
}
#end_block

#method_before
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            if (lunsMap.isEmpty()) {
                // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
                continue;
            }
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                // Hence, verify before updating.
                if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.infoFormat("Updated LUN device size - ID: {0}, previous size: {1}, new size: {2}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#method_after
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            if (lunsMap.isEmpty()) {
                // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
                continue;
            }
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                // Hence, verify before updating.
                if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.info("Updated LUN device size - ID: '{}', previous size: {}, new size: {}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a '{}' Device without an address when processing VM '{}' devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.info(message + ": '{}'", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.info(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#end_block

#method_before
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device, deviceMap);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        String logicalName = null;
        if (deviceId != null && FeatureSupported.reportedDisksLogicalNames(_vds.getVdsGroupCompatibilityVersion()) && VmDeviceType.DISK.getName().equals(device.get(VdsProperties.Device))) {
            try {
                logicalName = getDeviceLogicalName((Map<?, ?>) vm.get(VdsProperties.GuestDiskMapping), deviceId);
            } catch (Exception e) {
                log.error("error while getting device name when processing, vm '{}', device info '{}' with exception, skipping: {}", vmId, device, e.getMessage());
                log.error("Exception", e);
            }
        }
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device, logicalName);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            vmDevice.setLogicalName(logicalName);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void handleRemovedDevices(Guid vmId, Set<Guid> processedDevices, List<VmDevice> devices) {
    for (VmDevice device : devices) {
        if (processedDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setAddress("");
                addVmDeviceToList(device);
                log.debugFormat("VM {0} managed pluggable device was unplugged : {1}", vmId, device);
            } else if (!devicePluggable(device)) {
                log.errorFormat("VM {0} managed non pluggable device was removed unexpectedly from libvirt: {1}", vmId, device);
            }
        } else {
            removedDeviceIds.add(device.getId());
            log.debugFormat("VM {0} unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#method_after
private void handleRemovedDevices(Guid vmId, Set<Guid> processedDevices, List<VmDevice> devices) {
    for (VmDevice device : devices) {
        if (processedDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setAddress("");
                addVmDeviceToList(device);
                log.debug("VM '{}' managed pluggable device was unplugged: '{}'", vmId, device);
            } else if (!devicePluggable(device)) {
                log.error("VM '{}' managed non pluggable device was removed unexpectedly from libvirt: '{}'", vmId, device);
            }
        } else {
            removedDeviceIds.add(device.getId());
            log.debug("VM '{}' unmanaged device was marked for remove: '{}'", vmId, device);
        }
    }
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, Map device, String logicalName) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.error("Empty or NULL values were passed for a VM '{}' device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null, logicalName);
        newVmDevices.add(newDevice);
        log.debug("New device was marked for adding to VM '{}' Devices: '{}'", vmId, newDevice);
    }
    return newDeviceId;
}
#end_block

#method_before
private static Guid getDeviceId(Map device) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    return deviceId == null ? null : new Guid(deviceId);
}
#method_after
private static Guid getDeviceId(Map device, Map<VmDeviceId, VmDevice> deviceMap) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    if (deviceId != null) {
        return new Guid(deviceId);
    }
    if (VdsProperties.VirtioSerial.equals(device.get(VdsProperties.Device))) {
        for (VmDevice dev : deviceMap.values()) {
            if (VmDeviceType.VIRTIOSERIAL.getName().equals(dev.getDevice())) {
                return dev.getDeviceId();
            }
        }
    }
    return null;
}
#end_block

#method_before
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.errorFormat("failed to fetch {0} stats. status remain unchanged ({1})", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                _runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#method_after
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.error("failed to fetch '{}' stats. status remain unchanged '{}'", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                _runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (_vds.isBalloonEnabled()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (balloonInfo.getBalloonLastMemory() == 0) {
                // first time we check, so we don't have enough data yet
                balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            // save the current value for the next time we check it
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    // which is different than the one it should be running on (must be in migration process)
    if (cacheVm != null) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
    }
    if (exitStatus != VmExitStatus.Normal) {
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.info("Running on vds during rerun failed vm: '{}'", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage(), vmDynamic.getExitReason());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        vmsToDestroy.add(new Pair(curVm, curVm.getMigratingToVds()));
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage(), vmDynamic.getExitReason());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                if ((vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.Up) || (vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp)) {
                    _poweringUpVms.add(runningVm);
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // Vm moved to Up status - remove its record from Async
                    // reportedAndUnchangedVms handling
                    log.debug("removing VM '{}' from successful run VMs list", vmToUpdate.getId());
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.isInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private static void logVmStatusTransition(VM vmToUpdate, VmDynamic runningVm) {
    if (vmToUpdate.getStatus() != runningVm.getStatus()) {
        log.infoFormat("VM {0} {1} moved from {2} --> {3}", vmToUpdate.getName(), vmToUpdate.getId(), vmToUpdate.getStatus().name(), runningVm.getStatus().name());
        if (vmToUpdate.getStatus() == VMStatus.Unknown) {
            logVmStatusTransionFromUnknown(vmToUpdate, runningVm);
        }
    }
}
#method_after
private static void logVmStatusTransition(VM vmToUpdate, VmDynamic runningVm) {
    if (vmToUpdate.getStatus() != runningVm.getStatus()) {
        log.info("VM {} {} moved from {} --> {}", vmToUpdate.getName(), vmToUpdate.getId(), vmToUpdate.getStatus().name(), runningVm.getStatus().name());
        if (vmToUpdate.getStatus() == VMStatus.Unknown) {
            logVmStatusTransionFromUnknown(vmToUpdate, runningVm);
        }
    }
}
#end_block

#method_before
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean migrating = vmToRemove.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.info("VM '{}'({}) is running in db and not running in VDS '{}'", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        Guid vmGuid = vmToRemove.getId();
        if (!migrating && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.info("add VM '{}' to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            _autoVmsToRun.add(vmGuid);
            log.info("add VM '{}' to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.infoFormat("Handing over VM {0} {1} to Host {2}. Setting VM to status {3}", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    addVmDynamicToList(vmToRemove.getDynamicData());
    addVmStatisticsToList(vmToRemove.getStatisticsData());
    addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
}
#method_after
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.info("Handing over VM '{}'({}) to Host '{}'. Setting VM to status '{}'", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    addVmDynamicToList(vmToRemove.getDynamicData());
    addVmStatisticsToList(vmToRemove.getStatisticsData());
    addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.info("RefreshVmList vm id '{}' is migrating to vds '{}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if (vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.info("RefreshVmList vm id '{}' status '{}' on vds '{}' ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.info("Adding VM '{}' to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.info("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds '{}'({})", _vds.getName(), _vds.getId());
        } else {
            vdsMaintenanceTimeoutOccurred = _vdsManager.isTimeToRetryMaintenance();
        }
    }
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : _runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        updateVmNumaNodeRuntimeInfo(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        Guid vmId = vmToUpdate.getId();
        Collection<DiskImageDynamic> vmDisksDynamic = _runningVms.get(vmId).getVmDynamic().getDisks();
        for (DiskImageDynamic diskImageDynamic : vmDisksDynamic) {
            _vmDiskImageDynamicToSave.add(new Pair<>(vmId, diskImageDynamic));
        }
    }
}
#end_block

#method_before
@Override
public void rerun() {
    decreasePendingVms();
    setSucceeded(false);
    setVm(null);
    // by default, if rerun is called then rerun process is about to start so log the result of the
    // previous run as if rerun is about to begin (and change it later in case rerun isn't going to happen)
    _isRerun = true;
    log();
    // set _isRerun flag to false so that we'll be able to know if
    // there is another rerun attempt within the method
    _isRerun = false;
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>getValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getStatus() != VMStatus.Paused) {
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        insertAsyncTaskPlaceHolders();
        executeAction();
        // wasn't done because canDoAction check returned false..
        if (!_isRerun && !getReturnValue().getCanDoAction()) {
            runningFailed();
        }
        // signal the caller that a rerun was made
        _isRerun = true;
    } else {
        runningFailed();
    }
}
#method_after
@Override
public void rerun() {
    decreasePendingVm();
    setSucceeded(false);
    setVm(null);
    // by default, if rerun is called then rerun process is about to start so log the result of the
    // previous run as if rerun is about to begin (and change it later in case rerun isn't going to happen)
    _isRerun = true;
    log();
    // set _isRerun flag to false so that we'll be able to know if
    // there is another rerun attempt within the method
    _isRerun = false;
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>getValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getStatus() != VMStatus.Paused) {
        reexecuteCommand();
        // wasn't done because canDoAction check returned false..
        if (!_isRerun && !getReturnValue().getCanDoAction()) {
            runningFailed();
        }
        // signal the caller that a rerun was made
        _isRerun = true;
    } else {
        runningFailed();
    }
}
#end_block

#method_before
protected void runningFailed() {
    try {
        decreasePendingVms();
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        setCommandShouldBeLogged(false);
        _isRerun = false;
        setSucceeded(false);
        log();
        processVmPoolOnStopVm();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), false);
    } finally {
        freeLock();
    }
}
#method_after
protected void runningFailed() {
    try {
        decreasePendingVm();
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        setCommandShouldBeLogged(false);
        _isRerun = false;
        setSucceeded(false);
        log();
        processVmPoolOnStopVm();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), false);
    } finally {
        freeLock();
    }
}
#end_block

#method_before
protected void processVmPoolOnStopVm() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            VmPoolHandler.processVmPoolOnStopVm(getVm().getId(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        }
    });
}
#method_after
protected void processVmPoolOnStopVm() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            runInternalActionWithTasksContext(VdcActionType.ProcessDownVm, new IdParameters(getVm().getId()));
        }
    });
}
#end_block

#method_before
@Override
public void runningSucceded() {
    try {
        decreasePendingVms();
        setSucceeded(true);
        setActionReturnValue(VMStatus.Up);
        log();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), true);
        notifyHostsVmFailed();
        if (getVm().getLastVdsRunOn() == null || !getVm().getLastVdsRunOn().equals(getCurrentVdsId())) {
            getVm().setLastVdsRunOn(getCurrentVdsId());
        }
        if (StringUtils.isNotEmpty(getVm().getHibernationVolHandle())) {
            removeVmHibernationVolumes();
            // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
            // this method (which is a part of the cached VM command,
            // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
            // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
            // status to up.
            getVm().setStatus(VMStatus.Up);
            getVm().setHibernationVolHandle(null);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
        }
    } finally {
        freeLock();
    }
}
#method_after
@Override
public void runningSucceded() {
    try {
        decreasePendingVm();
        setSucceeded(true);
        setActionReturnValue(VMStatus.Up);
        log();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), true);
        notifyHostsVmFailed();
        if (getVm().getLastVdsRunOn() == null || !getVm().getLastVdsRunOn().equals(getCurrentVdsId())) {
            getVm().setLastVdsRunOn(getCurrentVdsId());
        }
        if (StringUtils.isNotEmpty(getVm().getHibernationVolHandle())) {
            removeVmHibernationVolumes();
            // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
            // this method (which is a part of the cached VM command,
            // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
            // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
            // status to up.
            getVm().setStatus(VMStatus.Up);
            getVm().setHibernationVolHandle(null);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
        }
    } finally {
        freeLock();
    }
}
#end_block

#method_before
private void removeVmHibernationVolumes() {
    RemoveVmHibernationVolumesParameters removeVmHibernationVolumesParameters = new RemoveVmHibernationVolumesParameters(getVmId());
    removeVmHibernationVolumesParameters.setParentCommand(getActionType());
    removeVmHibernationVolumesParameters.setEntityInfo(getParameters().getEntityInfo());
    removeVmHibernationVolumesParameters.setParentParameters(getParameters());
    VdcReturnValueBase vdcRetValue = getBackend().runInternalAction(VdcActionType.RemoveVmHibernationVolumes, removeVmHibernationVolumesParameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    for (Guid taskId : vdcRetValue.getInternalVdsmTaskIdList()) {
        AsyncTaskManager.getInstance().startPollingTask(taskId);
    }
}
#method_after
private void removeVmHibernationVolumes() {
    RemoveVmHibernationVolumesParameters removeVmHibernationVolumesParameters = new RemoveVmHibernationVolumesParameters(getVmId());
    removeVmHibernationVolumesParameters.setParentCommand(getActionType());
    removeVmHibernationVolumesParameters.setEntityInfo(getParameters().getEntityInfo());
    removeVmHibernationVolumesParameters.setParentParameters(getParameters());
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.RemoveVmHibernationVolumes, removeVmHibernationVolumesParameters);
    for (Guid taskId : vdcRetValue.getInternalVdsmTaskIdList()) {
        CommandCoordinatorUtil.startPollingTask(taskId);
    }
}
#end_block

#method_before
private void notifyHostsVmFailed() {
    if (!getRunVdssList().isEmpty()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                for (Guid vdsId : getRunVdssList()) {
                    if (!getCurrentVdsId().equals(vdsId)) {
                        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FailedToRunVm, new FailedToRunVmVDSCommandParameters(vdsId));
                    }
                }
            }
        });
    }
}
#method_after
private void notifyHostsVmFailed() {
    if (!getRunVdssList().isEmpty()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                for (Guid vdsId : getRunVdssList()) {
                    if (!vdsId.equals(getCurrentVdsId())) {
                        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FailedToRunVm, new FailedToRunVmVDSCommandParameters(vdsId));
                    }
                }
            }
        });
    }
}
#end_block

#method_before
@Override
public final void reportCompleted() {
    try {
        ExecutionContext executionContext = getExecutionContext();
        if (executionContext != null && executionContext.isMonitored() && !executionContext.isCompleted()) {
            endExecutionMonitoring();
        }
    } finally {
        freeLock();
    }
}
#method_after
@Override
public final void reportCompleted() {
    try {
        // decrease pending resources if they were not decreased already
        decreasePendingVm();
        // end the execution job if needed
        ExecutionContext executionContext = getExecutionContext();
        if (executionContext != null && executionContext.isMonitored() && !executionContext.isCompleted()) {
            endExecutionMonitoring();
        }
    } finally {
        freeLock();
    }
}
#end_block

#method_before
protected Guid getCurrentVdsId() {
    return getVds().getId();
}
#method_after
protected Guid getCurrentVdsId() {
    VDS vds = getVds();
    return vds != null ? vds.getId() : null;
}
#end_block

#method_before
protected boolean connectLunDisks(Guid hostId) {
    if (getVm().getDiskMap().isEmpty()) {
        VmHandler.updateDisksFromDb(getVm());
    }
    List<LunDisk> lunDisks = ImagesHandler.filterDiskBasedOnLuns(getVm().getDiskMap().values());
    for (LunDisk lunDisk : lunDisks) {
        LUNs lun = lunDisk.getLun();
        lun.setLunConnections(new ArrayList<StorageServerConnections>(DbFacade.getInstance().getStorageServerConnectionDao().getAllForLun(lun.getLUN_id())));
        if (!lun.getLunConnections().isEmpty() && !StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getstorage_type()).connectStorageToLunByVdsId(null, hostId, lun, getVm().getStoragePoolId())) {
            log.infoFormat("Failed to connect  a lun disk to vdsm {0} skiping it", hostId);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean connectLunDisks(Guid hostId) {
    if (getVm().getDiskMap().isEmpty()) {
        VmHandler.updateDisksFromDb(getVm());
    }
    List<LunDisk> lunDisks = ImagesHandler.filterDiskBasedOnLuns(getVm().getDiskMap().values());
    for (LunDisk lunDisk : lunDisks) {
        LUNs lun = lunDisk.getLun();
        lun.setLunConnections(new ArrayList<StorageServerConnections>(DbFacade.getInstance().getStorageServerConnectionDao().getAllForLun(lun.getLUN_id())));
        if (!lun.getLunConnections().isEmpty() && !StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getstorage_type()).connectStorageToLunByVdsId(null, hostId, lun, getVm().getStoragePoolId())) {
            log.info("Failed to connect  a lun disk to vdsm '{}' skiping it", hostId);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void delay(Guid vdsId) {
    log.debug("try to wait for te engine update the host memory and cpu stats");
    try {
        // time out waiting for an update is the highest between the refresh rate and the last update elapsed time
        // but still no higher than a configurable max to prevent very long updates to stall command.
        long t = Math.max(ResourceManager.getInstance().GetVdsManager(vdsId).getLastUpdateElapsed(), TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(VdsRefreshRate)));
        t = Math.max(Config.<Integer>getValue(ConfigValues.ThrottlerMaxWaitForVdsUpdateInMillis), t);
        // wait for the run-time refresh to decrease any current powering-up VMs
        getBlockingQueue(vdsId).poll(t, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
    // ignore
    }
}
#method_after
@Override
public void delay(Guid vdsId) {
    log.debug("Try to wait for te engine update the host memory and cpu stats");
    try {
        // time out waiting for an update is the highest between the refresh rate and the last update elapsed time
        // but still no higher than a configurable max to prevent very long updates to stall command.
        long t = Math.max(ResourceManager.getInstance().GetVdsManager(vdsId).getLastUpdateElapsed(), TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(VdsRefreshRate)));
        t = Math.max(Config.<Integer>getValue(ConfigValues.ThrottlerMaxWaitForVdsUpdateInMillis), t);
        // wait for the run-time refresh to decrease any current powering-up VMs
        getBlockingQueue(vdsId).poll(t, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
    // ignore
    }
}
#end_block

#method_before
@Before
public void setup() {
    initVds();
    initConditions();
    when(vdsManager.getRefreshStatistics()).thenReturn(false);
    updater = Mockito.spy(new HostMonitoring(vdsManager, vds, mock(MonitoringStrategy.class)) {

        @Override
        public DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected void auditLog(AuditLogableBase auditLogable, AuditLogType logType) {
            AuditLog al = new AuditLog();
            al.setlog_type(logType);
            mockAuditLogDao.save(al);
        }

        @Override
        protected Map[] getVmInfo(List<String> vmsToUpdate) {
            return vmInfo;
        }

        @Override
        protected List<VmDynamic> getPoweringUpVms() {
            return poweringUpVms;
        }
    });
}
#method_after
@Before
public void setup() {
    initVds();
    initConditions();
    when(vdsManager.getRefreshStatistics()).thenReturn(false);
    updater = Mockito.spy(new HostMonitoring(vdsManager, vds, mock(MonitoringStrategy.class)) {

        @Override
        public DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected void auditLog(AuditLogableBase auditLogable, AuditLogType logType) {
            AuditLog al = new AuditLog();
            al.setLogType(logType);
            mockAuditLogDao.save(al);
        }

        @Override
        protected Map[] getVmInfo(List<String> vmsToUpdate) {
            return vmInfo;
        }

        @Override
        protected List<VmDynamic> getPoweringUpVms() {
            return poweringUpVms;
        }
    });
}
#end_block

#method_before
@Test
public void updateVmDevicesNotNull() {
    Guid vmGuid = Guid.newGuid();
    when(vmDeviceDAO.getVmDeviceByVmId(vmGuid)).thenReturn(Collections.<VmDevice>emptyList());
    HashMap vm = new HashMap();
    vm.put(VdsProperties.vm_guid, vmGuid.toString());
    Map<String, Object> deviceProperties = new HashMap<String, Object>();
    Guid deviceID = Guid.newGuid();
    deviceProperties.put(VdsProperties.DeviceId, deviceID.toString());
    deviceProperties.put(VdsProperties.Address, Collections.emptyMap());
    deviceProperties.put(VdsProperties.Device, "aDevice");
    deviceProperties.put(VdsProperties.Type, VmDeviceGeneralType.DISK.getValue());
    vm.put(VdsProperties.Devices, new HashMap[] { new HashMap(deviceProperties) });
    vmInfo = new HashMap[] { vm };
    updater.updateVmDevices(Collections.singletonList(vmGuid.toString()));
    assertEquals("wrong number of new devices", 1, updater.getNewVmDevices().size());
    assertEquals("wrong number of removed devices", 0, updater.getRemovedVmDevices().size());
}
#method_after
@Test
public void updateVmDevicesNotNull() {
    Guid vmGuid = Guid.newGuid();
    when(vmDeviceDAO.getVmDeviceByVmId(vmGuid)).thenReturn(Collections.<VmDevice>emptyList());
    HashMap vm = new HashMap();
    String testLogicalName = "TestName";
    vm.put(VdsProperties.vm_guid, vmGuid.toString());
    Map<String, Object> deviceProperties = new HashMap<String, Object>();
    Guid deviceID = Guid.newGuid();
    deviceProperties.put(VdsProperties.DeviceId, deviceID.toString());
    deviceProperties.put(VdsProperties.Address, Collections.emptyMap());
    deviceProperties.put(VdsProperties.Device, VmDeviceType.DISK.getName());
    deviceProperties.put(VdsProperties.Type, VmDeviceGeneralType.DISK.getValue());
    vm.put(VdsProperties.GuestDiskMapping, Collections.singletonMap(deviceID.toString().substring(0, 20), Collections.singletonMap(VdsProperties.Name, testLogicalName)));
    vm.put(VdsProperties.Devices, new HashMap[] { new HashMap(deviceProperties) });
    vmInfo = new HashMap[] { vm };
    updater.updateVmDevices(Collections.singletonList(vmGuid.toString()));
    assertEquals("wrong number of new devices", 1, updater.getNewVmDevices().size());
    VmDevice device = updater.getNewVmDevices().get(0);
    assertEquals(testLogicalName, device.getLogicalName());
    assertEquals("wrong number of removed devices", 0, updater.getRemovedVmDevices().size());
}
#end_block

#method_before
private void initVds() {
    vds = new VDS();
    vds.setId(new Guid("00000000-0000-0000-0000-000000000012"));
    vds.setVdsGroupCompatibilityVersion(Version.v3_4);
}
#method_after
private void initVds() {
    vds = new VDS();
    vds.setId(new Guid("00000000-0000-0000-0000-000000000012"));
    vds.setVdsGroupCompatibilityVersion(vdsCompVersion);
}
#end_block

#method_before
private void removeMemoryVolumes() {
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            log.errorFormat("Failed to remove memory volumes whie removing vm {0} (volumes: {1})", getVmId(), memoryState);
        }
    }
}
#method_after
private void removeMemoryVolumes() {
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()));
        if (!retVal.getSucceeded()) {
            log.errorFormat("Failed to remove memory volumes whie removing vm {0} (volumes: {1})", getVmId(), memoryState);
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isDeleteProtected()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    VmHandler.updateDisksFromDb(getVm());
    if (!getParameters().isRemoveDisks() && !canRemoveVmWithDetachDisks()) {
        return false;
    }
    if (getVm().isRunningOrPaused() || getVm().getStatus() == VMStatus.Unknown || getVm().getStatus() == VMStatus.NotResponding) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    if (getVm().getStatus() == VMStatus.Suspended) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_REMOVE_VM_WHEN_STATUS_IS_NOT_DOWN);
    }
    if (getVm().getVmPoolId() != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    }
    // enable to remove vms without images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    if (!validate(snapshotsValidator.vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!validate(snapshotsValidator.vmNotInPreview(getVmId()))) {
        return false;
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    Collection<Disk> vmDisks = getVm().getDiskMap().values();
    List<DiskImage> vmImages = ImagesHandler.filterImageDisks(vmDisks, true, false, true);
    if (!vmImages.isEmpty()) {
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(vmImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
        if (!getParameters().getForce() && !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    // Handle VM status with ImageLocked
    VmValidator vmValidator = new VmValidator(getVm());
    ValidationResult vmLockedValidatorResult = vmValidator.vmNotLocked();
    if (!vmLockedValidatorResult.isValid()) {
        // without force remove, we can't remove the VM
        if (!getParameters().getForce()) {
            return failCanDoAction(vmLockedValidatorResult.getMessage());
        }
        // If it is force, we cannot remove if there are task
        if (TaskManagerUtil.hasTasksByStoragePoolId(getVm().getStoragePoolId())) {
            return failCanDoAction(VdcBllMessages.VM_CANNOT_REMOVE_HAS_RUNNING_TASKS);
        }
    }
    if (getParameters().isRemoveDisks() && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isDeleteProtected()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    VmHandler.updateDisksFromDb(getVm());
    if (!getParameters().isRemoveDisks() && !canRemoveVmWithDetachDisks()) {
        return false;
    }
    return (super.canDoAction() && canRemoveVm());
}
#end_block

#method_before
protected VdcReturnValueBase removeVmImages(List<DiskImage> images) {
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.RemoveAllVmImages, buildRemoveAllVmImagesParameters(images));
    if (vdcRetValue.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
    return vdcRetValue;
}
#method_after
protected VdcReturnValueBase removeVmImages(List<DiskImage> images) {
    VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmImages, buildRemoveAllVmImagesParameters(images), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (vdcRetValue.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
    return vdcRetValue;
}
#end_block

#method_before
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.InstallFailed) {
            setStatus(VDSStatus.NonResponsive, vds);
            updateDynamicData(vds.getDynamicData());
        }
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = new AuditLogableBase(vdsId);
        AuditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#method_after
@Override
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.InstallFailed) {
            setStatus(VDSStatus.NonResponsive, vds);
            updateDynamicData(vds.getDynamicData());
        }
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = new AuditLogableBase(vdsId);
        AuditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#end_block

#method_before
public void handlePreviousStatus() {
    if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        vds.setPreviousStatus(vds.getStatus());
    } else {
        vds.setPreviousStatus(VDSStatus.Up);
    }
}
#method_after
@Override
public void handlePreviousStatus() {
    if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        vds.setPreviousStatus(vds.getStatus());
    } else {
        vds.setPreviousStatus(VDSStatus.Up);
    }
}
#end_block

#method_before
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    // start with refresh statistics
    refreshIteration = numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS);
    vmsMonitoringJobId = sched.scheduleAFixedDelayJob(this, "vmsMonitoring", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS);
}
#method_after
@Override
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    // start with refresh statistics
    refreshIteration = numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS);
    vmsMonitoringJobId = sched.scheduleAFixedDelayJob(this, "vmsMonitoring", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
public void updateVmDynamic(VmDynamic vmDynamic) {
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#method_after
@Override
public void updateVmDynamic(VmDynamic vmDynamic) {
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                cacheVds();
                tmpVds = vds;
                if (vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (refreshIteration == numberRefreshesBeforeSave) {
                        refreshIteration = 1;
                    } else {
                        refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(VdsManager.this, vds, monitoringStrategy);
                        hostMonitoring.refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && vds.getStatus() != VDSStatus.NonResponsive && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
                        log.infoFormat("Initializing Host: {0}", vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (vds != null && vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = vds.getStoragePoolId();
                            domainsList = vds.getDomains();
                        }
                    }
                    vds = null;
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
                if (vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (refreshIteration == numberRefreshesBeforeSave) {
                        refreshIteration = 1;
                    } else {
                        refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(VdsManager.this, vds, monitoringStrategy);
                        hostMonitoring.refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && vds.getStatus() != VDSStatus.NonResponsive && vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (vds != null && vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = vds.getStoragePoolId();
                            domainsList = vds.getDomains();
                        }
                    }
                    vds = null;
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("vmsMonitoring")
public void vmsMonitoring() {
    if (isMonitoringNeeded()) {
        new VmsMonitoring(this).begin();
    }
}
#method_after
@OnTimerMethodAnnotation("vmsMonitoring")
public void vmsMonitoring() {
    new VmsMonitoring(this).begin();
}
#end_block

#method_before
public boolean isMonitoringNeeded() {
    return monitoringNeeded;
}
#method_after
@Override
public boolean isMonitoringNeeded() {
    return (monitoringStrategy.isMonitoringNeeded(vds) && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.InstallFailed && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.Down);
}
#end_block

#method_before
public void handleVdsRecoveringException(VDSRecoveringException ex) {
    if (vds.getStatus() != VDSStatus.Initializing && vds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, vds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(vds.getId(), VDSStatus.Initializing);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warnFormat("Failed to refresh VDS , vds = {0} : {1}, error = {2}, continuing.", vds.getId(), vds.getName(), ex.getMessage());
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMinutes);
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(vds.getId(), jobId);
    }
}
#method_after
@Override
public void handleVdsRecoveringException(VDSRecoveringException ex) {
    if (vds.getStatus() != VDSStatus.Initializing && vds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, vds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(vds.getId(), VDSStatus.Initializing);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warnFormat("Failed to refresh VDS , vds = {0} : {1}, error = {2}, continuing.", vds.getId(), vds.getName(), ex.getMessage());
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMintues);
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(vds.getId(), jobId);
    }
}
#end_block

#method_before
public void updateDynamicData(VdsDynamic dynamicData) {
    DbFacade.getInstance().getVdsDynamicDao().updateIfNeeded(dynamicData);
}
#method_after
@Override
public void updateDynamicData(VdsDynamic dynamicData) {
    DbFacade.getInstance().getVdsDynamicDao().updateIfNeeded(dynamicData);
}
#end_block

#method_before
public void updateStatisticsData(VdsStatistics statisticsData) {
    DbFacade.getInstance().getVdsStatisticsDao().update(statisticsData);
}
#method_after
@Override
public void updateStatisticsData(VdsStatistics statisticsData) {
    DbFacade.getInstance().getVdsStatisticsDao().update(statisticsData);
}
#end_block

#method_before
public void updateNumaData(final VDS vds) {
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = NumaUtils.getVdsNumaNodeByIndex(dbVdsNumaNodes, node.getIndex());
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    // The database operation should be in one transaction
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!numaNodesToRemove.isEmpty()) {
                DbFacade.getInstance().getVdsNumaNodeDAO().massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
            }
            if (!numaNodesToUpdate.isEmpty()) {
                DbFacade.getInstance().getVdsNumaNodeDAO().massUpdateNumaNode(numaNodesToUpdate);
            }
            if (!numaNodesToSave.isEmpty()) {
                DbFacade.getInstance().getVdsNumaNodeDAO().massSaveNumaNode(numaNodesToSave, vds.getId(), null);
            }
            return null;
        }
    });
}
#method_after
public void updateNumaData(final VDS vds) {
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = NumaUtils.getVdsNumaNodeByIndex(dbVdsNumaNodes, node.getIndex());
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    if (!numaNodesToRemove.isEmpty()) {
        DbFacade.getInstance().getVdsNumaNodeDAO().massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
    }
    if (!numaNodesToUpdate.isEmpty()) {
        DbFacade.getInstance().getVdsNumaNodeDAO().massUpdateNumaNode(numaNodesToUpdate);
    }
    if (!numaNodesToSave.isEmpty()) {
        DbFacade.getInstance().getVdsNumaNodeDAO().massSaveNumaNode(numaNodesToSave, vds.getId(), null);
    }
}
#end_block

#method_before
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getStatus() != status) {
            if (status == VDSStatus.PreparingForMaintenance) {
                calculateNextMaintenanceAttemptTime();
            }
            vds.setPreviousStatus(vds.getStatus());
            if (this.vds != null) {
                this.vds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (this.vds != null) {
            this.vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (this.vds != null) {
                    this.vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (this.vds != null) {
                    this.vds.setCpuSys(Double.valueOf(0));
                    this.vds.setCpuUser(Double.valueOf(0));
                    this.vds.setCpuIdle(Double.valueOf(0));
                    this.vds.setCpuLoad(Double.valueOf(0));
                    this.vds.setUsageCpuPercent(0);
                    this.vds.setUsageMemPercent(0);
                    this.vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#method_after
@Override
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getPreviousStatus() != vds.getStatus()) {
            vds.setPreviousStatus(vds.getStatus());
            if (vds != null) {
                vds.setPreviousStatus(vds.getStatus());
                if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                    calculateNextMaintenanceAttemptTime();
                }
            }
        }
        // update to new status
        vds.setStatus(status);
        if (this.vds != null) {
            this.vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (this.vds != null) {
                    this.vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (this.vds != null) {
                    this.vds.setCpuSys(Double.valueOf(0));
                    this.vds.setCpuUser(Double.valueOf(0));
                    this.vds.setCpuIdle(Double.valueOf(0));
                    this.vds.setCpuLoad(Double.valueOf(0));
                    this.vds.setUsageCpuPercent(0);
                    this.vds.setUsageMemPercent(0);
                    this.vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debugFormat("monitoring: refresh {0} capabilities", vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED)) {
            AuditLogDirector.log(new AuditLogableBase(vds.getId()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warnFormat("Host {0} is running with disabled SELinux.", vds.getName());
            } else {
                log.warnFormat("Host {0} does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            DbFacade.getInstance().getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
@Override
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debugFormat("monitoring: refresh {0} capabilities", vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED)) {
            AuditLogDirector.log(new AuditLogableBase(vds.getId()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warnFormat("Host {0} is running with disabled SELinux.", vds.getName());
            } else {
                log.warnFormat("Host {0} does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            DbFacade.getInstance().getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        log.warnFormat("Host {0} is not responding. It will stay in Connecting state for a grace period of ${1} seconds and after that an attempt to fence the host will be issued.", vds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(vds.getId());
        logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
        AuditLogDirector.log(logable, AuditLogType.VDS_HOST_IN_CONNECTING_STATE);
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        moveVMsToUnknown();
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing);
    }
    return true;
}
#method_after
@Override
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        log.warnFormat("Host {0} is not responding. It will stay in Connecting state for a grace period of ${1} seconds and after that an attempt to fence the host will be issued.", vds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(vds.getId());
        logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
        AuditLogDirector.log(logable, AuditLogType.VDS_HOST_IN_CONNECTING_STATE);
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing);
    }
    return true;
}
#end_block

#method_before
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    SchedulerUtilQuartzImpl.getInstance().deleteJob(vmsMonitoringJobId);
    if (VdsServerWrapper.class.isInstance(vdsProxy)) {
        XmlRpcUtils.shutDownConnection(((VdsServerWrapper) vdsProxy).getHttpClient());
    } else {
        ((JsonRpcVdsServer) vdsProxy).close();
    }
}
#method_after
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    SchedulerUtilQuartzImpl.getInstance().deleteJob(vmsMonitoringJobId);
    XmlRpcUtils.shutDownConnection(((VdsServerWrapper) vdsProxy).getHttpClient());
}
#end_block

#method_before
public void logNetworkException(VDSNetworkException e) {
    switch(vds.getStatus()) {
        case Down:
            break;
        case NonResponsive:
            log.debugFormat("Failed to refresh VDS , vds = {0} : {1}, VDS Network Error, continuing.\n{2}", vds.getId(), vds.getName(), e.getMessage());
            break;
        default:
            log.warnFormat("Failed to refresh VDS , vds = {0} : {1}, VDS Network Error, continuing.\n{2}", vds.getId(), vds.getName(), e.getMessage());
    }
}
#method_after
@Override
public void logNetworkException(VDSNetworkException e) {
    switch(vds.getStatus()) {
        case Down:
            break;
        case NonResponsive:
            log.debugFormat("Failed to refresh VDS , vds = {0} : {1}, VDS Network Error, continuing.\n{2}", vds.getId(), vds.getName(), e.getMessage());
            break;
        default:
            log.warnFormat("Failed to refresh VDS , vds = {0} : {1}, VDS Network Error, continuing.\n{2}", vds.getId(), vds.getName(), e.getMessage());
    }
}
#end_block

#method_before
public void finishSshSoftFencingExecution(VDS vds) {
    // reset the unresponded counter to wait if VDSM restart helps
    mUnrespondedAttempts.set(0);
    // change VDS state to connecting
    setStatus(VDSStatus.Connecting, vds);
    updateDynamicData(vds.getDynamicData());
}
#method_after
@Override
public void finishSshSoftFencingExecution(VDS vds) {
    // reset the unresponded counter to wait if VDSM restart helps
    mUnrespondedAttempts.set(0);
    // change VDS state to connecting
    setStatus(VDSStatus.Connecting, vds);
    updateDynamicData(vds.getDynamicData());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final DestroyVmVDSCommandParameters parameters = getParameters();
    ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
    final VM curVm = DbFacade.getInstance().getVmDao().get(parameters.getVmId());
    curVm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(curVm.getId()));
    DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<>(parameters);
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        if (curVm.getStatus() == VMStatus.Down) {
            getVDSReturnValue().setReturnValue(VMStatus.Down);
        }
        changeStatus(parameters, curVm);
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                curVm.guestLogoutTimeTreatmentAfterDestroy();
                curVm.setStopReason(getParameters().getReason());
                vmManager.update(curVm.getDynamicData());
                vmManager.update(curVm.getStatisticsData());
                List<VmNetworkInterface> interfaces = curVm.getInterfaces();
                if (interfaces != null && interfaces.size() > 0) {
                    for (VmNetworkInterface ifc : interfaces) {
                        VmNetworkStatistics stats = ifc.getStatistics();
                        vmManager.update(stats);
                    }
                }
                return null;
            }
        });
        // will not be called from UpdateRunTimeInfo
        if (!parameters.getGracefully()) {
            ResourceManager.getInstance().getEventListener().processOnVmStop(Collections.singleton(curVm.getId()));
        }
        getVDSReturnValue().setReturnValue(curVm.getStatus());
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        log.errorFormat("VDS::destroy Failed destroying vm '{0}' in vds = {1} , error = {2}", parameters.getVmId(), getParameters().getVdsId(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        getVDSReturnValue().setSucceeded(false);
        getVDSReturnValue().setExceptionString(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        getVDSReturnValue().setExceptionObject(vdsBrokerCommand.getVDSReturnValue().getExceptionObject());
        getVDSReturnValue().setVdsError(vdsBrokerCommand.getVDSReturnValue().getVdsError());
    }
}
#method_after
@Override
protected void executeVmCommand() {
    final DestroyVmVDSCommandParameters parameters = getParameters();
    ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
    final VM curVm = DbFacade.getInstance().getVmDao().get(parameters.getVmId());
    curVm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(curVm.getId()));
    DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(parameters);
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        if (curVm.getStatus() == VMStatus.Down) {
            getVDSReturnValue().setReturnValue(VMStatus.Down);
        }
        changeStatus(parameters, curVm);
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                curVm.guestLogoutTimeTreatmentAfterDestroy();
                curVm.setStopReason(getParameters().getReason());
                // SaveVmDynamicToDBThreaded(curVm);
                vmManager.update(curVm.getDynamicData());
                vmManager.update(curVm.getStatisticsData());
                List<VmNetworkInterface> interfaces = curVm.getInterfaces();
                if (interfaces != null && interfaces.size() > 0) {
                    for (VmNetworkInterface ifc : interfaces) {
                        VmNetworkStatistics stats = ifc.getStatistics();
                        vmManager.update(stats);
                    }
                }
                DbFacade.getInstance().getVdsDynamicDao().updatePartialVdsDynamicCalc(getParameters().getVdsId(), 0, 0, 0, -curVm.getVmMemSizeMb(), -curVm.getNumOfCpus());
                return null;
            }
        });
        // will not be called from UpdateRunTimeInfo
        if (!parameters.getGracefully()) {
            onVmStop(curVm);
        }
        getVDSReturnValue().setReturnValue(curVm.getStatus());
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        log.errorFormat("VDS::destroy Failed destroying vm '{0}' in vds = {1} , error = {2}", parameters.getVmId(), getParameters().getVdsId(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        getVDSReturnValue().setSucceeded(false);
        getVDSReturnValue().setExceptionString(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        getVDSReturnValue().setExceptionObject(vdsBrokerCommand.getVDSReturnValue().getExceptionObject());
        getVDSReturnValue().setVdsError(vdsBrokerCommand.getVDSReturnValue().getVdsError());
    }
}
#end_block

#method_before
protected void executeVDSCommand() {
    vmManager.lock();
    try {
        executeVmCommand();
    } finally {
        vmManager.unlock();
    }
}
#method_after
protected void executeVDSCommand() {
    try {
        vmManager.lock();
        executeVmCommand();
    } finally {
        vmManager.unlock();
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final VM vm = getParameters().getVm();
    vm.setLastStartTime(new Date());
    // if the VM is not suspended, it means that if there is 'hibernation volume'
    // set, it is actually memory from snapshot, thus it should be cleared right
    // after the VM started
    final boolean clearHibernationVolume = vm.getStatus() != VMStatus.Suspended;
    if (canExecute() && ResourceManager.getInstance().AddAsyncRunningVm(vm.getId())) {
        CreateVDSCommand<?> command = null;
        try {
            command = initCreateVDSCommand(vm);
            command.execute();
            if (command.getVDSReturnValue().getSucceeded()) {
                saveSetInitializedToDb(vm.getId());
                vm.setStopReason(null);
                vm.setInitialized(true);
                vm.setRunOnVds(getParameters().getVdsId());
                if (clearHibernationVolume) {
                    vm.setHibernationVolHandle(StringUtils.EMPTY);
                }
                vmManager.update(vm.getDynamicData());
            } else {
                handleCommandResult(command);
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
        } catch (Exception e) {
            log.error("Error in excuting CreateVmVDSCommand", e);
            if (command != null && !command.getVDSReturnValue().getSucceeded()) {
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
            throw new RuntimeException(e);
        }
    }
    getVDSReturnValue().setReturnValue(vm.getStatus());
}
#method_after
@Override
protected void executeVmCommand() {
    final VM vm = getParameters().getVm();
    vm.setLastStartTime(new Date());
    // if the VM is not suspended, it means that if there is 'hibernation volume'
    // set, it is actually memory from snapshot, thus it should be cleared right
    // after the VM started
    final boolean clearHibernationVolume = vm.getStatus() != VMStatus.Suspended;
    if (canExecute() && ResourceManager.getInstance().AddAsyncRunningVm(vm.getId())) {
        CreateVDSCommand<?> command = null;
        try {
            command = initCreateVDSCommand(vm);
            command.execute();
            if (command.getVDSReturnValue().getSucceeded()) {
                saveSetInitializedToDb(vm.getId());
                vm.setInitialized(true);
                vm.setRunOnVds(getParameters().getVdsId());
                if (clearHibernationVolume) {
                    vm.setHibernationVolHandle(StringUtils.EMPTY);
                }
                vmManager.update(vm.getDynamicData());
            } else {
                handleCommandResult(command);
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
        } catch (Exception e) {
            log.error("Error in excuting CreateVmVDSCommand", e);
            if (command != null && !command.getVDSReturnValue().getSucceeded()) {
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
            throw new RuntimeException(e);
        }
    }
    getVDSReturnValue().setReturnValue(vm.getStatus());
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", vds.getName()), e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(vds.getId())) {
                hostDownTimes.put(vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                vdsManager.setStatus(VDSStatus.NonOperational, vds);
                log.infoFormat("Host '{0}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{1}'", vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(vds.getId())) {
                hostDownTimes.put(vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", vds.getName(), nicNames, networkNames);
                vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                vdsManager.setStatus(VDSStatus.NonOperational, vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(vds.getId());
        }
    }
}
#end_block

#method_before
public void HandleVdsFinishedInit(Guid vdsId) {
    HashSet<Guid> vms = vdsAndVmsList.get(vdsId);
    if (vms != null) {
        getEventListener().processOnVmStop(vms);
        vdsAndVmsList.remove(vdsId);
    }
}
#method_after
public void HandleVdsFinishedInit(Guid vdsId) {
    HashSet<Guid> vms = vdsAndVmsList.get(vdsId);
    if (vms != null) {
        for (Guid vmId : vms) {
            getEventListener().processOnVmStop(vmId);
            log.info("Procceed on vm stop entered: " + vmId.toString());
        }
        vdsAndVmsList.remove(vdsId);
    }
}
#end_block

#method_before
private void refreshVmStats() {
    log.debug("refresh VMs list entered");
    // Retrieve the list of existing jobs and/or job placeholders.  Only these jobs
    // are allowed to be updated by updateVmJobs()
    refreshExistingVmJobList();
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        filterVmsFromMonitoringCycle();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
        updateVmJobs();
    }
}
#method_after
private void refreshVmStats() {
    log.debug("refresh VMs list entered");
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        filterVmsFromMonitoringCycle();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
    saveVmsToDb();
}
#end_block

#method_before
private void saveVmsToDb() {
    getDbFacade().getVmDynamicDao().updateAllInBatch(vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(externalVmsToAdd);
    saveVmJobsToDb();
}
#method_after
private void saveVmsToDb() {
    getDbFacade().getVmDynamicDao().updateAllInBatch(vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(externalVmsToAdd);
}
#end_block

#method_before
private void afterVMsRefreshTreatment() {
    // rerun all vms from rerun list
    for (Guid vm_guid : vmsToRerun) {
        log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, vds.getName());
        ResourceManager.getInstance().RerunFailedCommand(vm_guid, vds.getId());
    }
    for (Guid vm_guid : succededToRunVms) {
        vdsManager.succededToRunVm(vm_guid);
    }
    // Refrain from auto-start HA VM during its re-run attempts.
    autoVmsToRun.removeAll(vmsToRerun);
    // run all vms that crushed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // process all vms that their ip changed.
    for (Map.Entry<VM, VmDynamic> pair : vmsClientIpChanged.entrySet()) {
        getVdsEventListener().processOnClientIpChange(vds, pair.getValue().getId());
    }
    // process all vms that powering up.
    for (VmDynamic runningVm : poweringUpVms) {
        ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
    }
    // process all vms that went down
    getVdsEventListener().processOnVmStop(vmsMovedToDown);
    for (Guid vm_guid : vmsToRemoveFromAsync) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
    }
}
#method_after
private void afterVMsRefreshTreatment() {
    // rerun all vms from rerun list
    for (Guid vm_guid : vmsToRerun) {
        log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, vds.getName());
        ResourceManager.getInstance().RerunFailedCommand(vm_guid, vds.getId());
    }
    for (Guid vm_guid : succededToRunVms) {
        vdsManager.succededToRunVm(vm_guid);
    }
    // Refrain from auto-start HA VM during its re-run attempts.
    autoVmsToRun.removeAll(vmsToRerun);
    // run all vms that crushed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // process all vms that their ip changed.
    for (Map.Entry<VM, VmDynamic> pair : vmsClientIpChanged.entrySet()) {
        getVdsEventListener().processOnClientIpChange(vds, pair.getValue().getId());
    }
    // process all vms that powering up.
    for (VmDynamic runningVm : poweringUpVms) {
        ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
    }
    // process all vms that went down
    for (Guid vm_guid : vmsMovedToDown) {
        getVdsEventListener().processOnVmStop(vm_guid);
    }
    for (Guid vm_guid : vmsToRemoveFromAsync) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
    }
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                log.debug("vds '{}' ({}) firing up event.", _vds.getName(), _vds.getId());
                _vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.debug("Exception", ex);
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error("Exception", ex);
        }
    }
}
#end_block

#method_before
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error("Failure to refresh Vds '{}' runtime info. Incorrect vdsm version for cluster '{}': {}", _vds.getName(), _vds.getVdsGroupName(), cce.getMessage());
        log.debug("Exception", cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info: {}", t.getMessage());
        log.error("Exception", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void saveVmsToDb() {
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveVmsToDb() {
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
}
#end_block

#method_before
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getusage_mem_percent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(_vds.getVersion()) <= 0) || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getUsageMemPercent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(_vds.getVersion()) <= 0) || stat.getUsageMemPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getUsageMemPercent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() != null && stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#method_after
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getUsageCpuPercent() != null && stat.getUsageCpuPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedCpu", stat.getUsageCpuPercent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    final double THRESHOLD = 0.98;
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getSwapTotal() == null || stat.getSwapFree() == null || stat.getSwapTotal() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getSwapTotal() - stat.getSwapFree()) / stat.getSwapTotal();
    // Allow the space to be up to 2% lower than as defined in configuration
    Long allowedMinAvailableThreshold = Math.round(minAvailableThreshold.doubleValue() * THRESHOLD);
    AuditLogType valueToLog = stat.getSwapFree() < allowedMinAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getSwapFree() < allowedMinAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getSwapFree().toString());
        logable.addCustomValue("Threshold", stat.getSwapFree() < allowedMinAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void logFailureMessage(String messagePrefix, RuntimeException ex) {
    log.errorFormat("{0} Error: {1}, vds = {2} : {3}", messagePrefix, ExceptionUtils.getMessage(ex), _vds.getId(), _vds.getName());
}
#method_after
private void logFailureMessage(String messagePrefix, RuntimeException ex) {
    log.error("{} vds={}({}): {}", messagePrefix, _vds.getName(), _vds.getId(), ex.getMessage());
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        afterVMsRefreshTreatment();
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode, probably error during " + "disconnecting it from pool. The Host will stay in Maintenance: {}", ex.getMessage());
                log.debug("Exception", ex);
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.info("Host '{}'({}) is already in NonOperational status for reason '{}'. SetNonOperationalVds command is skipped.", _vds.getName(), _vds.getId(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        afterVMsRefreshTreatment();
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.debug("Exception", ex);
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error("Exception", ex);
    }
}
#end_block

#method_before
private void afterVMsRefreshTreatment() {
    // rerun all vms from rerun list
    for (Guid vm_guid : _vmsToRerun) {
        log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
        ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
    }
    for (Guid vm_guid : _succededToRunVms) {
        _vdsManager.succededToRunVm(vm_guid);
    }
    // Refrain from auto-start HA VM during its re-run attempts.
    _autoVmsToRun.removeAll(_vmsToRerun);
    // run all vms that crushed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
    // process all vms that their ip changed.
    for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
        getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
    }
    // process all vms that powering up.
    for (VmDynamic runningVm : _poweringUpVms) {
        ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
    }
    // process all vms that went down
    for (Guid vm_guid : _vmsMovedToDown) {
        getVdsEventListener().processOnVmStop(vm_guid);
    }
    for (Guid vm_guid : _vmsToRemoveFromAsync) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
    }
}
#method_after
private void afterVMsRefreshTreatment() {
    // destroy
    getVdsEventListener().destroyVms(vmsToDestroy);
    // rerun all vms from rerun list
    for (Guid vm_guid : _vmsToRerun) {
        log.error("Rerun vm '{}'. Called from vds '{}'", vm_guid, _vds.getName());
        ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
    }
    for (Guid vm_guid : _succededToRunVms) {
        _vdsManager.succededToRunVm(vm_guid);
    }
    getVdsEventListener().updateSlaPolicies(_succededToRunVms, _vds.getId());
    // Refrain from auto-start HA VM during its re-run attempts.
    _autoVmsToRun.removeAll(_vmsToRerun);
    // run all vms that crushed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
    // process all vms that their ip changed.
    for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
        getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
    }
    // process all vms that powering up.
    for (VmDynamic runningVm : _poweringUpVms) {
        getVdsEventListener().processOnVmPoweringUp(runningVm.getId());
    }
    // process all vms that went down
    getVdsEventListener().processOnVmStop(_vmsMovedToDown);
    for (Guid vm_guid : _vmsToRemoveFromAsync) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
    }
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    ResourceManager.getInstance().getEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, vds='{}'({})", _vds.getName(), _vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    getVdsEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.error("vds::refreshVdsStats Failed getVdsStats,  vds='{}'({}): {}", _vds.getName(), _vds.getId(), ex.getMessage());
        } else {
            log.error("vds::refreshVdsStats Failed getVdsStats,  vds='{}'({}): {}", _vds.getName(), _vds.getId(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVdsStats\n{0}", this);
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error("Failure on checkInterfaces on update runtimeinfo for vds: '{}': {}", _vds.getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info("Host '{}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{}'", _vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error("checkInterface: Failure on moving host: '{}' to non-operational: {}", _vds.getName(), e.getMessage());
                log.error("Exception", e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(_vds.getId())) {
        VdsNetworkInterface iface = monitoredInterfaces.get(oldIface.getName());
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#method_after
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (Map.Entry<String, InterfaceStatus> entry : oldInterfaceStatus.entrySet()) {
        VdsNetworkInterface iface = monitoredInterfaces.get(entry.getKey());
        InterfaceStatus oldStatus = entry.getValue();
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldStatus != InterfaceStatus.NONE && oldStatus != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#end_block

#method_before
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    // Retrieve the list of existing jobs and/or job placeholders.  Only these jobs
    // are allowed to be updated by updateVmJobs()
    refreshExistingVmJobList();
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
        updateVmJobs();
    }
}
#end_block

#method_before
protected boolean fetchRunningVms() {
    VDSCommandType commandType = _vdsManager.getRefreshStatistics() ? VDSCommandType.GetAllVmStats : VDSCommandType.List;
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(commandType, new VdsIdAndVdsVDSCommandParametersBase(_vds));
    _runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (!vdsReturnValue.getSucceeded()) {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) callException, _vds);
            } else if (callException instanceof VDSProtocolException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.errorFormat("{0} failed with no exception!", commandType.name());
        }
    }
    return vdsReturnValue.getSucceeded();
}
#method_after
protected boolean fetchRunningVms() {
    VDSCommandType commandType = _vdsManager.getRefreshStatistics() ? VDSCommandType.GetAllVmStats : VDSCommandType.List;
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(commandType, new VdsIdAndVdsVDSCommandParametersBase(_vds));
    _runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (!vdsReturnValue.getSucceeded()) {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.error("Failed vds listing,  vds='{}'({}): {}", _vds.getName(), _vds.getId(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) callException, _vds);
            } else if (callException instanceof VDSProtocolException) {
                log.error("Failed vds listing,  vds='{}'({}): {}", _vds.getName(), _vds.getId(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.error("{} failed with no exception!", commandType.name());
        }
    }
    return vdsReturnValue.getSucceeded();
}
#end_block

#method_before
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            if (lunsMap.isEmpty()) {
                // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
                continue;
            }
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                // Hence, verify before updating.
                if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.infoFormat("Updated LUN device size - ID: {0}, previous size: {1}, new size: {2}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#method_after
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            if (lunsMap.isEmpty()) {
                // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
                continue;
            }
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                // Hence, verify before updating.
                if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.info("Updated LUN device size - ID: '{}', previous size: {}, new size: {}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a '{}' Device without an address when processing VM '{}' devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.info(message + ": '{}'", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.info(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#end_block

#method_before
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device, deviceMap);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        String logicalName = null;
        if (deviceId != null && FeatureSupported.reportedDisksLogicalNames(_vds.getVdsGroupCompatibilityVersion()) && VmDeviceType.DISK.getName().equals(device.get(VdsProperties.Device))) {
            try {
                logicalName = getDeviceLogicalName((Map<?, ?>) vm.get(VdsProperties.GuestDiskMapping), deviceId);
            } catch (Exception e) {
                log.error("error while getting device name when processing, vm '{}', device info '{}' with exception, skipping: {}", vmId, device, e.getMessage());
                log.error("Exception", e);
            }
        }
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device, logicalName);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            vmDevice.setLogicalName(logicalName);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void handleRemovedDevices(Guid vmId, Set<Guid> processedDevices, List<VmDevice> devices) {
    for (VmDevice device : devices) {
        if (processedDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setAddress("");
                addVmDeviceToList(device);
                log.debugFormat("VM {0} managed pluggable device was unplugged : {1}", vmId, device);
            } else if (!devicePluggable(device)) {
                log.errorFormat("VM {0} managed non pluggable device was removed unexpectedly from libvirt: {1}", vmId, device);
            }
        } else {
            removedDeviceIds.add(device.getId());
            log.debugFormat("VM {0} unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#method_after
private void handleRemovedDevices(Guid vmId, Set<Guid> processedDevices, List<VmDevice> devices) {
    for (VmDevice device : devices) {
        if (processedDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setAddress("");
                addVmDeviceToList(device);
                log.debug("VM '{}' managed pluggable device was unplugged: '{}'", vmId, device);
            } else if (!devicePluggable(device)) {
                log.error("VM '{}' managed non pluggable device was removed unexpectedly from libvirt: '{}'", vmId, device);
            }
        } else {
            removedDeviceIds.add(device.getId());
            log.debug("VM '{}' unmanaged device was marked for remove: '{}'", vmId, device);
        }
    }
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, Map device, String logicalName) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.error("Empty or NULL values were passed for a VM '{}' device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null, logicalName);
        newVmDevices.add(newDevice);
        log.debug("New device was marked for adding to VM '{}' Devices: '{}'", vmId, newDevice);
    }
    return newDeviceId;
}
#end_block

#method_before
private static Guid getDeviceId(Map device) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    return deviceId == null ? null : new Guid(deviceId);
}
#method_after
private static Guid getDeviceId(Map device, Map<VmDeviceId, VmDevice> deviceMap) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    if (deviceId != null) {
        return new Guid(deviceId);
    }
    if (VdsProperties.VirtioSerial.equals(device.get(VdsProperties.Device))) {
        for (VmDevice dev : deviceMap.values()) {
            if (VmDeviceType.VIRTIOSERIAL.getName().equals(dev.getDevice())) {
                return dev.getDeviceId();
            }
        }
    }
    return null;
}
#end_block

#method_before
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.errorFormat("failed to fetch {0} stats. status remain unchanged ({1})", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                _runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#method_after
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.error("failed to fetch '{}' stats. status remain unchanged '{}'", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                _runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (_vds.isBalloonEnabled()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (balloonInfo.getBalloonLastMemory() == 0) {
                // first time we check, so we don't have enough data yet
                balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            // save the current value for the next time we check it
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    // which is different than the one it should be running on (must be in migration process)
    if (cacheVm != null) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
    }
    if (exitStatus != VmExitStatus.Normal) {
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.info("Running on vds during rerun failed vm: '{}'", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage(), vmDynamic.getExitReason());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        vmsToDestroy.add(new Pair(curVm, curVm.getMigratingToVds()));
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage(), vmDynamic.getExitReason());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                if ((vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.Up) || (vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp)) {
                    _poweringUpVms.add(runningVm);
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // Vm moved to Up status - remove its record from Async
                    // reportedAndUnchangedVms handling
                    log.debug("removing VM '{}' from successful run VMs list", vmToUpdate.getId());
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.isInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private static void logVmStatusTransition(VM vmToUpdate, VmDynamic runningVm) {
    if (vmToUpdate.getStatus() != runningVm.getStatus()) {
        log.infoFormat("VM {0} {1} moved from {2} --> {3}", vmToUpdate.getName(), vmToUpdate.getId(), vmToUpdate.getStatus().name(), runningVm.getStatus().name());
        if (vmToUpdate.getStatus() == VMStatus.Unknown) {
            logVmStatusTransionFromUnknown(vmToUpdate, runningVm);
        }
    }
}
#method_after
private static void logVmStatusTransition(VM vmToUpdate, VmDynamic runningVm) {
    if (vmToUpdate.getStatus() != runningVm.getStatus()) {
        log.info("VM {} {} moved from {} --> {}", vmToUpdate.getName(), vmToUpdate.getId(), vmToUpdate.getStatus().name(), runningVm.getStatus().name());
        if (vmToUpdate.getStatus() == VMStatus.Unknown) {
            logVmStatusTransionFromUnknown(vmToUpdate, runningVm);
        }
    }
}
#end_block

#method_before
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean migrating = vmToRemove.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.info("VM '{}'({}) is running in db and not running in VDS '{}'", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        Guid vmGuid = vmToRemove.getId();
        if (!migrating && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.info("add VM '{}' to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            _autoVmsToRun.add(vmGuid);
            log.info("add VM '{}' to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.infoFormat("Handing over VM {0} {1} to Host {2}. Setting VM to status {3}", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    addVmDynamicToList(vmToRemove.getDynamicData());
    addVmStatisticsToList(vmToRemove.getStatisticsData());
    addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
}
#method_after
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.info("Handing over VM '{}'({}) to Host '{}'. Setting VM to status '{}'", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    addVmDynamicToList(vmToRemove.getDynamicData());
    addVmStatisticsToList(vmToRemove.getStatisticsData());
    addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.info("RefreshVmList vm id '{}' is migrating to vds '{}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if (vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.info("RefreshVmList vm id '{}' status '{}' on vds '{}' ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.info("Adding VM '{}' to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.info("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds '{}'({})", _vds.getName(), _vds.getId());
        } else {
            vdsMaintenanceTimeoutOccurred = _vdsManager.isTimeToRetryMaintenance();
        }
    }
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : _runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        updateVmNumaNodeRuntimeInfo(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        Guid vmId = vmToUpdate.getId();
        Collection<DiskImageDynamic> vmDisksDynamic = _runningVms.get(vmId).getVmDynamic().getDisks();
        for (DiskImageDynamic diskImageDynamic : vmDisksDynamic) {
            _vmDiskImageDynamicToSave.add(new Pair<>(vmId, diskImageDynamic));
        }
    }
}
#end_block

#method_before
public void onError(@Observes final VDSNetworkException vdsException) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            resourceManager.GetVdsManager(vdsException.getVdsError().getVdsId()).handleNetworkException(vdsException);
        }
    });
}
#method_after
public void onError(@Observes final VDSNetworkException vdsException) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            resourceManagerProvider.get().GetVdsManager(vdsException.getVdsError().getVdsId()).handleNetworkException(vdsException);
        }
    });
}
#end_block

#method_before
private void logFailureMessage(RuntimeException ex) {
    log.warn("Failed to refresh VDS , cachedVds = '{}' : '{}', error = '{}', continuing.", cachedVds.getId(), cachedVds.getName());
    log.error("Exception", ex);
}
#method_after
private void logFailureMessage(RuntimeException ex) {
    log.warn("Failed to refresh VDS , vds = '{}' : '{}', error = '{}', continuing.", cachedVds.getName(), cachedVds.getId(), ex.getMessage());
    log.error("Exception", ex);
}
#end_block

#method_before
private void handleVdsRecoveringException(VDSRecoveringException ex) {
    if (cachedVds.getStatus() != VDSStatus.Initializing && cachedVds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, cachedVds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(cachedVds.getId(), VDSStatus.Initializing);
        AuditLogableBase logable = new AuditLogableBase(cachedVds.getId());
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warn("Failed to refresh VDS , cachedVds = {0} : {1}, error = {2}, continuing.", cachedVds.getId(), cachedVds.getName(), ex.getMessage());
        log.debug("Exception", ex);
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMinutes);
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(cachedVds.getId(), jobId);
    }
}
#method_after
private void handleVdsRecoveringException(VDSRecoveringException ex) {
    if (cachedVds.getStatus() != VDSStatus.Initializing && cachedVds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, cachedVds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(cachedVds.getId(), VDSStatus.Initializing);
        AuditLogableBase logable = new AuditLogableBase(cachedVds.getId());
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warn("Failed to refresh VDS, continuing, vds='{}'({}): {}", cachedVds.getName(), cachedVds.getId(), ex.getMessage());
        log.debug("Exception", ex);
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMinutes);
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(cachedVds.getId(), jobId);
    }
}
#end_block

#method_before
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (cachedVds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
        logHostNonResponding(timeoutToFence);
        if (dontFenceYet(timeoutToFence)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
            } else {
                saveToDb = false;
            }
            mUnrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.NonResponsive || cachedVds.getStatus() == VDSStatus.Maintenance) {
                setStatus(VDSStatus.NonResponsive, cachedVds);
            } else {
                setStatus(VDSStatus.NonResponsive, cachedVds);
                moveVMsToUnknown();
                logHostFailToResponde(ex, timeoutToFence);
                ResourceManager.getInstance().getEventListener().vdsNotResponding(cachedVds, !sshSoftFencingExecuted.getAndSet(true), lastUpdate);
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#method_after
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (cachedVds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
        logHostNonResponding(timeoutToFence);
        if (inGracePeriod(timeoutToFence)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
            } else {
                saveToDb = false;
            }
            mUnrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.Maintenance) {
                saveToDb = false;
            } else {
                if (cachedVds.getStatus() != VDSStatus.NonResponsive) {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                    moveVMsToUnknown();
                    logHostFailToResponde(ex, timeoutToFence);
                    ResourceManager.getInstance().getEventListener().vdsNotResponding(cachedVds, !sshSoftFencingExecuted.getAndSet(true), lastUpdate);
                } else {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                }
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#end_block

#method_before
private void logNetworkException(VDSNetworkException e) {
    switch(cachedVds.getStatus()) {
        case Down:
            break;
        case NonResponsive:
            log.debug("Failed to refresh VDS , cachedVds = '{}' : '{}', VDS Network Error, continuing. '{}'", cachedVds.getId(), cachedVds.getName(), e.getMessage());
            break;
        default:
            log.warn("Failed to refresh VDS , cachedVds = '{}' : '{}', VDS Network Error, continuing. '{}'", cachedVds.getId(), cachedVds.getName(), e.getMessage());
    }
    log.debug("Exception", e);
}
#method_after
private void logNetworkException(VDSNetworkException e) {
    switch(cachedVds.getStatus()) {
        case Down:
            break;
        case NonResponsive:
            log.debug("Failed to refresh VDS, network error, continuing, vds='{}'({}): {}", cachedVds.getName(), cachedVds.getId(), e.getMessage());
            break;
        default:
            log.warn("Failed to refresh VDS, network error, continuing, vds='{}'({}): {}", cachedVds.getName(), cachedVds.getId(), e.getMessage());
    }
    log.debug("Exception", e);
}
#end_block

#method_before
public static void cancelRecoveryJob(Guid vdsId) {
    String jobId = recoveringJobIdMap.remove(vdsId);
    if (jobId != null) {
        log.info("Cancelling the recovery from crash timer for VDS '{}' because cachedVds started initializing", vdsId);
        try {
            SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
        } catch (Exception e) {
            log.warn("Failed deleting job '{}' at cancelRecoveryJob: {}", jobId, e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#method_after
public static void cancelRecoveryJob(Guid vdsId) {
    String jobId = recoveringJobIdMap.remove(vdsId);
    if (jobId != null) {
        log.info("Cancelling the recovery from crash timer for VDS '{}' because vds started initializing", vdsId);
        try {
            SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
        } catch (Exception e) {
            log.warn("Failed deleting job '{}' at cancelRecoveryJob: {}", jobId, e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
public Lock getLockObj() {
    return lockObj;
}
#method_after
public Object getLockObj() {
    return lockObj;
}
#end_block

#method_before
protected IVdsEventListener getVdsEventListener() {
    return ResourceManager.getInstance().getEventListener();
}
#method_after
protected IVdsEventListener getVdsEventListener() {
    return getResourceManager().getEventListener();
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, vds='{}'({})", vds.getName(), vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    VDSReturnValue statsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
    getResourceManager().getEventListener().updateSchedulingStats(vds);
    if (!statsReturnValue.getSucceeded() && statsReturnValue.getExceptionObject() != null) {
        log.error(" Failed getting vds stats,  vds='{}'({}): {}", vds.getName(), vds.getId(), statsReturnValue.getExceptionString());
        return;
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    saveVdsDynamic = true;
    saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVdsStats\n{0}", this);
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, vds='{}'({})", vds.getName(), vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    VDSReturnValue statsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
    getVdsEventListener().updateSchedulingStats(vds);
    if (!statsReturnValue.getSucceeded() && statsReturnValue.getExceptionObject() != null) {
        log.error(" Failed getting vds stats,  vds='{}'({}): {}", vds.getName(), vds.getId(), statsReturnValue.getExceptionString());
        throw statsReturnValue.getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    saveVdsDynamic = true;
    saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVdsStats\n{0}", this);
    }
}
#end_block

#method_before
public VmManager getVmManager(Guid vmId) {
    if (vmManagers.containsKey(vmId)) {
        return vmManagers.get(vmId);
    } else {
        VmManager value = new VmManager(vmId);
        vmManagers.put(vmId, value);
        return value;
    }
}
#method_after
public VmManager getVmManager(Guid vmId) {
    if (!vmManagers.containsKey(vmId)) {
        vmManagers.putIfAbsent(vmId, new VmManager(vmId));
    }
    return vmManagers.get(vmId);
}
#end_block

#method_before
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#method_after
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return Collections.<CertificateInfo>emptyList();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#end_block

#method_before
private void onTest() {
    if (!validateConnectionSettings()) {
        getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedInsufficientParams());
        return;
    }
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.TestProviderConnectivity, new ProviderParameters(provider), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase res = result.getReturnValue();
            // If the connection failed on SSL issues, we try to fetch the provider certificate chain, and import it to the engine
            if (isFailedOnSSL(res)) {
                AsyncQuery getCertChainQuery = new AsyncQuery();
                getCertChainQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object result) {
                        if (result != null) {
                            certificate = (String) result;
                            ConfirmationModel confirmationModel = getImportChainConfirmationModel(certificate);
                            sourceListModel.setConfirmWindow(confirmationModel);
                        } else {
                            stopProgress();
                            getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg());
                        }
                    }
                };
                AsyncDataProvider.getInstance().getProviderCertificate(getCertChainQuery, provider);
            } else {
                stopProgress();
                setTestResultValue(res);
            }
        }
    }, null, false);
}
#method_after
private void onTest() {
    if (!validateConnectionSettings()) {
        getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedInsufficientParams());
        return;
    }
    flush();
    startProgress(null);
    if (provider.getUrl().startsWith(Uri.SCHEME_HTTPS)) {
        AsyncDataProvider.getInstance().getProviderCertificateChain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                boolean ok = false;
                certificate = null;
                if (returnValue != null) {
                    List<CertificateInfo> certs = (List<CertificateInfo>) returnValue;
                    if (!certs.isEmpty()) {
                        certificate = certs.get(certs.size() - 1).getPayload();
                        ConfirmationModel confirmationModel = getImportCertificateConfirmationModel(certs.get(0));
                        sourceListModel.setConfirmWindow(confirmationModel);
                        ok = true;
                    }
                }
                if (!ok) {
                    stopProgress();
                    getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg());
                }
            }
        }), provider);
    } else {
        testProviderConnectivity();
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (CMD_SAVE.equals(command.getName())) {
        onSave();
    } else if (CMD_TEST.equals(command.getName())) {
        onTest();
    } else if (CMD_CANCEL.equals(command.getName())) {
        cancel();
    } else if (CMD_IMPORT_CHAIN.equals(command.getName())) {
        importChain();
    } else if (CMD_CANCEL_IMPORT.equals(command.getName())) {
        cancelImport();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (CMD_SAVE.equals(command.getName())) {
        onSave();
    } else if (CMD_TEST.equals(command.getName())) {
        onTest();
    } else if (CMD_CANCEL.equals(command.getName())) {
        cancel();
    } else if (CMD_IMPORT_CERTIFICATE.equals(command.getName())) {
        importCertificate();
    } else if (CMD_CANCEL_IMPORT.equals(command.getName())) {
        cancelImport();
    }
}
#end_block

#method_before
@Override
public void initialize() {
    lockObj.writeLock().lock();
    try {
        if (initialized) {
            log.error("Trying to initialized " + getClass().getName() + " multiple times.");
            return;
        }
        log.infoFormat("Start initializing " + getClass().getSimpleName());
        this.macsStorage = createMacsStorage(rangesString);
        List<VmNic> interfaces = getVmNicInterfacesFromDb();
        for (VmNic iface : interfaces) {
            if (iface.getMacAddress() != null) {
                forceAddMacWithoutLocking(iface.getMacAddress());
            }
        }
        initialized = true;
        log.infoFormat("Finished initializing. Available MACs in pool: {0}", macsStorage.getAvailableMacsCount());
    } catch (Exception ex) {
        log.errorFormat("Error in initializing MAC Addresses pool manager.", ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void initialize() {
    lockObj.writeLock().lock();
    try {
        if (initialized) {
            log.error("Trying to initialized " + getClass().getName() + " multiple times.");
            return;
        }
        log.infoFormat("Start initializing " + getClass().getSimpleName());
        this.macsStorage = createMacsStorage(rangesString);
        addMacsFromDbToPool();
        logWhenMacPoolIsEmpty();
        initialized = true;
        log.infoFormat("Finished initializing. Available MACs in pool: {0}", macsStorage.getAvailableMacsCount());
    } catch (Exception ex) {
        log.errorFormat("Error in initializing MAC Addresses pool manager.", ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
@Override
public void forceAddMac(String mac) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        forceAddMacWithoutLocking(mac);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void forceAddMac(String mac) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        forceAddMacWithoutLocking(mac);
        logWhenMacPoolIsEmpty();
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
private void forceAddMacWithoutLocking(String mac) {
    macsStorage.useMacNoDuplicityCheck(MacAddressRangeUtils.macToLong(mac));
    logWhenMacPoolIsEmpty();
}
#method_after
private void forceAddMacWithoutLocking(String mac) {
    macsStorage.useMacNoDuplicityCheck(MacAddressRangeUtils.macToLong(mac));
}
#end_block

#method_before
public static List<String[]> rangeStringToStringBoundaries(String rangeString) {
    if (StringUtils.isEmpty(rangeString)) {
        return Collections.emptyList();
    }
    List<String[]> result = new ArrayList<>();
    String[] rangesArray = rangeString.split("[,]", -1);
    for (int i = 0; i < rangesArray.length; i++) {
        String[] startEndArray = rangesArray[i].split("[-]", -1);
        if (startEndArray.length == 2) {
            result.add(new String[] { startEndArray[0], startEndArray[1] });
        } else {
            throw new IllegalArgumentException("Failed to initialize Mac Pool range. Please fix Mac Pool range: rangesArray[i]");
        }
    }
    return result;
}
#method_after
public static List<String[]> rangeStringToStringBoundaries(String rangeString) {
    if (StringUtils.isEmpty(rangeString)) {
        return Collections.emptyList();
    }
    List<String[]> result = new ArrayList<>();
    String[] rangesArray = rangeString.split("[,]", -1);
    for (int i = 0; i < rangesArray.length; i++) {
        String[] startEndArray = rangesArray[i].split("[" + BOUNDARIES_DELIMITER + "]", -1);
        if (startEndArray.length == 2) {
            result.add(new String[] { startEndArray[0], startEndArray[1] });
        } else {
            throw new IllegalArgumentException("Failed to initialize Mac Pool range. Please fix Mac Pool range: rangesArray[i]");
        }
    }
    return result;
}
#end_block

#method_before
private ValidationResult validateRangesSyntax(List<String[]> rangesBoundaries) {
    for (String[] rangeBoundaries : rangesBoundaries) {
        for (String rangeBoundary : rangeBoundaries) {
            ValidationResult startPartValidation = validateRangePart(rangeBoundary);
            if (!startPartValidation.isOk()) {
                return startPartValidation;
            }
        }
    }
    return new ValidationResult(true);
}
#method_after
private ValidationResult validateRangesSyntax(List<String[]> rangesBoundaries) {
    for (String[] rangeBoundaries : rangesBoundaries) {
        for (String rangeBoundary : rangeBoundaries) {
            ValidationResult startPartValidation = validateRangePart(rangeBoundary);
            if (!startPartValidation.isOk()) {
                return startPartValidation;
            }
        }
        long from = MacAddressRangeUtils.macToLong(rangeBoundaries[0]);
        long to = MacAddressRangeUtils.macToLong(rangeBoundaries[1]);
        if (from > to) {
            return new ValidationResult(false, String.format("The entered range is invalid. " + "Range should be specified as " + "<lowerBoundMAC>" + MacAddressRangeUtils.BOUNDARIES_DELIMITER + "<upperBoundMAC>." + " Did you mean %s?", MacAddressRangeUtils.boundariesToRangeString(to, from)));
        }
    }
    return new ValidationResult(true);
}
#end_block

#method_before
private ValidationResult validateRangePart(String rangePart) {
    rangePart.toLowerCase();
    boolean matches = MAC_ADDRESS_PATTERN.matcher(rangePart).matches();
    if (!matches) {
        return new ValidationResult(false, "The range start/end is an invalid MAC address. " + rangePart + " should be in a format of AA:AA:AA:AA:AA:AA");
    } else {
        return new ValidationResult(true);
    }
}
#method_after
private ValidationResult validateRangePart(String rangePart) {
    boolean matches = MAC_ADDRESS_PATTERN.matcher(rangePart).matches();
    if (!matches) {
        return new ValidationResult(false, "The range start/end is an invalid MAC address. " + rangePart + " should be in a format of AA:AA:AA:AA:AA:AA");
    } else {
        return new ValidationResult(true);
    }
}
#end_block

#method_before
@Parameterized.Parameters
public static Collection<Object[]> ipAddressParams() {
    return Arrays.asList(new Object[][] { { "00:00:00:00:00:00-00:00:00:00:00:FF", true }, { "00:1A:4A:16:88:FD-00:1A:4A:16:88:FD", true }, { "AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB", true }, { "AA:AA:AA:AA:AA:AA-aa:aa:aa:aa:aa:ab", true }, { "aa:aa:aa:aa:aa:aa-AA:AA:AA:AA:AA:AB", true }, { "AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB,AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB", true }, { "AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB,CC:CC:CC:CC:CC:CC-CC:CC:CC:CC:CC:CD", true }, { "CC:CC:CC:CC:CC:CC-CC:CC:CC:CC:CC:CD,AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB", true }, { "BB:BB:BB:BB:BB:BA,BB:BB:BB:BB:BB:BB", false }, { "AA:AA:AA:AA:AA,BB:BB:BB:BB:BB:BB", false }, { "AA-AA-AA-AA-AA-AA-BB-BB-BB-BB-BB-BB", false }, { "AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB,XA:AA:AA:AA:AA:AA-BB:BB:BB:BB:BB:BB", false }, { "01:00:00:00:00:00-01:FF:FF:FF:FF:FF", false }, { null, false }, { "", false }, { " ", false } });
}
#method_after
@Parameterized.Parameters
public static Collection<Object[]> ipAddressParams() {
    return Arrays.asList(new Object[][] { { "00:00:00:00:00:00-00:00:00:00:00:FF", true }, { "00:1A:4A:16:88:FD-00:1A:4A:16:88:FD", true }, { "AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB", true }, { "AA:AA:AA:AA:AA:AA-aa:aa:aa:aa:aa:ab", true }, { "aa:aa:aa:aa:aa:aa-AA:AA:AA:AA:AA:AB", true }, { "AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB,AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB", true }, { "AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB,CC:CC:CC:CC:CC:CC-CC:CC:CC:CC:CC:CD", true }, { "CC:CC:CC:CC:CC:CC-CC:CC:CC:CC:CC:CD,AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB", true }, { "BB:BB:BB:BB:BB:BA,BB:BB:BB:BB:BB:BB", false }, { "AA:AA:AA:AA:AA,BB:BB:BB:BB:BB:BB", false }, { "AA-AA-AA-AA-AA-AA-BB-BB-BB-BB-BB-BB", false }, { "AA:AA:AA:AA:AA:AA-AA:AA:AA:AA:AA:AB,XA:AA:AA:AA:AA:AA-BB:BB:BB:BB:BB:BB", false }, { "01:00:00:00:00:00-01:FF:FF:FF:FF:FF", false }, { null, false }, { "", false }, { " ", false }, { "BB:BB:BB:BB:BB:BB-AA:AA:AA:AA:AA:AA", false }, { "BB:BB:BB:BB:BB:BB-aa:aa:aa:aa:aa:aa", false }, { "bb:bb:bb:bb:bb:bb-AA:AA:AA:AA:AA:AA", false } });
}
#end_block

#method_before
private void updateProperties() {
    VDS vds = getEntity();
    setHardwareManufacturer(vds.getHardwareManufacturer());
    setHardwareVersion(vds.getHardwareVersion());
    setHardwareProductName(vds.getHardwareProductName());
    setHardwareUUID(vds.getHardwareUUID());
    setHardwareSerialNumber(vds.getHardwareSerialNumber());
    setHardwareFamily(vds.getHardwareFamily());
    setCpuType(vds.getCpuName() != null ? vds.getCpuName().getCpuName() : null);
    setCpuModel(vds.getCpuModel());
    setNumberOfSockets(vds.getCpuSockets());
    if (vds.getCpuCores() != null && vds.getCpuSockets() != null && vds.getCpuSockets() != 0) {
        int coresPerSocket = vds.getCpuCores() / vds.getCpuSockets();
        String fieldValue = String.valueOf(coresPerSocket);
        if (vds.getCountThreadsAsCores()) {
            fieldValue = ConstantsManager.getInstance().getMessages().threadsAsCoresPerSocket(coresPerSocket, vds.getCpuThreads());
        }
        setCoresPerSocket(fieldValue);
    } else {
        setCoresPerSocket(null);
    }
    if (vds.getVdsGroupCompatibilityVersion() != null && Version.v3_2.compareTo(vds.getVdsGroupCompatibilityVersion()) > 0) {
        // Members of pre-3.2 clusters don't support SMT; here we act like a 3.1 engine
        setThreadsPerCore(constants.unsupported());
    } else if (vds.getCpuThreads() == null || vds.getCpuCores() == null || vds.getCpuCores() == 0) {
        setThreadsPerCore(constants.unknown());
    } else {
        Integer threads = vds.getCpuThreads() / vds.getCpuCores();
        setThreadsPerCore(messages.commonMessageWithBrackets(threads.toString(), threads > 1 ? constants.smtEnabled() : constants.smtDisabled()));
    }
    /* Go through the list of HBA devices and transfer the necessary info
           to the GWT host hardware model */
    List<EnumMap<HbaDeviceKeys, String>> hbaDevices = new ArrayList<EnumMap<HbaDeviceKeys, String>>();
    // $NON-NLS-1$
    List<Map<String, String>> fcDevices = vds.getHBAs().get("FC");
    if (fcDevices != null) {
        for (Map<String, String> device : fcDevices) {
            EnumMap<HbaDeviceKeys, String> deviceModel = new EnumMap<HbaDeviceKeys, String>(HbaDeviceKeys.class);
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.MODEL_NAME, device.get("model"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNN, device.get("wwnn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNPS, device.get("wwpn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.TYPE, "FC");
            hbaDevices.add(deviceModel);
        }
    }
    setHbaDevices(hbaDevices);
}
#method_after
private void updateProperties() {
    VDS vds = getEntity();
    setHardwareManufacturer(vds.getHardwareManufacturer());
    setHardwareVersion(vds.getHardwareVersion());
    setHardwareProductName(vds.getHardwareProductName());
    setHardwareUUID(vds.getHardwareUUID());
    setHardwareSerialNumber(vds.getHardwareSerialNumber());
    setHardwareFamily(vds.getHardwareFamily());
    setCpuType(vds.getCpuName() != null ? vds.getCpuName().getCpuName() : null);
    setCpuModel(vds.getCpuModel());
    setNumberOfSockets(vds.getCpuSockets());
    if (vds.getCpuCores() != null && vds.getCpuSockets() != null && vds.getCpuThreads() != null && vds.getCpuSockets() != 0) {
        int coresPerSocket = vds.getCpuCores() / vds.getCpuSockets();
        String fieldValue = String.valueOf(coresPerSocket);
        if (vds.getCountThreadsAsCores()) {
            fieldValue = ConstantsManager.getInstance().getMessages().threadsAsCoresPerSocket(coresPerSocket, vds.getCpuThreads());
        }
        setCoresPerSocket(fieldValue);
    } else {
        setCoresPerSocket(null);
    }
    if (vds.getVdsGroupCompatibilityVersion() != null && Version.v3_2.compareTo(vds.getVdsGroupCompatibilityVersion()) > 0) {
        // Members of pre-3.2 clusters don't support SMT; here we act like a 3.1 engine
        setThreadsPerCore(constants.unsupported());
    } else if (vds.getCpuThreads() == null || vds.getCpuCores() == null || vds.getCpuCores() == 0) {
        setThreadsPerCore(constants.unknown());
    } else {
        Integer threads = vds.getCpuThreads() / vds.getCpuCores();
        setThreadsPerCore(messages.commonMessageWithBrackets(threads.toString(), threads > 1 ? constants.smtEnabled() : constants.smtDisabled()));
    }
    /* Go through the list of HBA devices and transfer the necessary info
           to the GWT host hardware model */
    List<EnumMap<HbaDeviceKeys, String>> hbaDevices = new ArrayList<EnumMap<HbaDeviceKeys, String>>();
    // $NON-NLS-1$
    List<Map<String, String>> fcDevices = vds.getHBAs().get("FC");
    if (fcDevices != null) {
        for (Map<String, String> device : fcDevices) {
            EnumMap<HbaDeviceKeys, String> deviceModel = new EnumMap<HbaDeviceKeys, String>(HbaDeviceKeys.class);
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.MODEL_NAME, device.get("model"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNN, device.get("wwnn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNPS, device.get("wwpn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.TYPE, "FC");
            hbaDevices.add(deviceModel);
        }
    }
    setHbaDevices(hbaDevices);
}
#end_block

#method_before
protected void executeRegisterVdsCommand() {
    synchronized (doubleRegistrationLock) {
        // force to reload vdss by unique ID used later on
        _vdssByUniqueId = null;
        VDS vdsByUniqueId = getVdssByUniqueId().size() != 0 ? getVdssByUniqueId().get(0) : null;
        String registeredVdsName = getParameters().getVdsName().split("\\.")[0];
        VDS provisionedVds = DbFacade.getInstance().getVdsDao().getByName(registeredVdsName);
        if (provisionedVds != null && provisionedVds.getStatus() != VDSStatus.InstallingOS) {
            // if not in InstallingOS status, this host is not provisioned.
            provisionedVds = null;
        }
        // in case oVirt host was added for the second time - perform approval
        if (vdsByUniqueId != null && vdsByUniqueId.getStatus() == VDSStatus.PendingApproval) {
            getQueryReturnValue().setSucceeded(dispatchOvirtApprovalCommand(vdsByUniqueId.getId()));
            return;
        }
        log.debug("RegisterVdsQuery::ExecuteCommand - Entering");
        if (StringUtils.isEmpty(getParameters().getVdsName())) {
            getParameters().setVdsName(getParameters().getVdsUniqueId());
            log.debug("RegisterVdsQuery::ExecuteCommand - VdsName empty, using VdsUnique ID as name");
        }
        logable.addCustomValue("VdsName1", getParameters().getVdsName());
        Guid vdsGroupId;
        if (Guid.Empty.equals(getParameters().getVdsGroupId())) {
            vdsGroupId = Guid.createGuidFromStringDefaultEmpty(Config.<String>getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID));
            log.debug("RegisterVdsQuery::ExecuteCommand - VdsGroupId received as -1, using AutoRegistrationDefaultVdsGroupID: '{}'", vdsGroupId);
        } else {
            vdsGroupId = getParameters().getVdsGroupId();
        }
        if (provisionedVds != null) {
            getQueryReturnValue().setSucceeded(Register(provisionedVds, vdsGroupId, false));
        } else {
            // TODO: always add in pending state, and if auto approve call
            // approve command action after registration
            RefObject<Boolean> isPending = new RefObject<Boolean>(Boolean.FALSE);
            getQueryReturnValue().setSucceeded(HandleOldVdssWithSameHostName(vdsByUniqueId) && HandleOldVdssWithSameName(vdsByUniqueId) && CheckAutoApprovalDefinitions(isPending) && Register(vdsByUniqueId, vdsGroupId, isPending.argvalue.booleanValue()));
        }
        log.debug("RegisterVdsQuery::ExecuteCommand - Leaving Succeded value is '{}'", getQueryReturnValue().getSucceeded());
    }
}
#method_after
protected void executeRegisterVdsCommand() {
    synchronized (doubleRegistrationLock) {
        List<VDS> hostsByHostName = DbFacade.getInstance().getVdsDao().getAllForHostname(getParameters().getVdsName());
        VDS provisionedVds = hostsByHostName.size() != 0 ? hostsByHostName.get(0) : null;
        if (provisionedVds != null && provisionedVds.getStatus() != VDSStatus.InstallingOS) {
            // if not in InstallingOS status, this host is not provisioned.
            provisionedVds = null;
        }
        // force to reload vdss by unique ID used later on
        _vdssByUniqueId = null;
        VDS vdsByUniqueId = getVdssByUniqueId().size() != 0 ? getVdssByUniqueId().get(0) : null;
        // in case oVirt host was added for the second time - perform approval
        if (vdsByUniqueId != null && vdsByUniqueId.getStatus() == VDSStatus.PendingApproval) {
            getQueryReturnValue().setSucceeded(dispatchOvirtApprovalCommand(vdsByUniqueId.getId()));
            return;
        }
        log.debug("RegisterVdsQuery::ExecuteCommand - Entering");
        if (StringUtils.isEmpty(getParameters().getVdsName())) {
            getParameters().setVdsName(getParameters().getVdsUniqueId());
            log.debug("RegisterVdsQuery::ExecuteCommand - VdsName empty, using VdsUnique ID as name");
        }
        logable.addCustomValue("VdsName1", getParameters().getVdsName());
        Guid vdsGroupId;
        if (Guid.Empty.equals(getParameters().getVdsGroupId())) {
            vdsGroupId = Guid.createGuidFromStringDefaultEmpty(Config.<String>getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID));
            log.debug("RegisterVdsQuery::ExecuteCommand - VdsGroupId received as -1, using AutoRegistrationDefaultVdsGroupID: '{}'", vdsGroupId);
        } else {
            vdsGroupId = getParameters().getVdsGroupId();
        }
        if (provisionedVds != null) {
            // In provision don't set host on pending - isPending = false
            getQueryReturnValue().setSucceeded(Register(provisionedVds, vdsGroupId, false));
        } else {
            // TODO: always add in pending state, and if auto approve call
            // approve command action after registration
            RefObject<Boolean> isPending = new RefObject<Boolean>(Boolean.FALSE);
            getQueryReturnValue().setSucceeded(HandleOldVdssWithSameHostName(vdsByUniqueId) && HandleOldVdssWithSameName(vdsByUniqueId) && CheckAutoApprovalDefinitions(isPending) && Register(vdsByUniqueId, vdsGroupId, isPending.argvalue.booleanValue()));
        }
        log.debug("RegisterVdsQuery::ExecuteCommand - Leaving Succeded value is '{}'", getQueryReturnValue().getSucceeded());
    }
}
#end_block

#method_before
private boolean updateExistingHost(VDS vds, boolean IsPending) {
    boolean returnValue = true;
    vds.setHostName(vds.getHostName());
    vds.setPort(getParameters().getVdsPort());
    log.debug("RegisterVdsQuery::Register - Will try now to update VDS with existing unique id; Name: '{}', Hostname: '{}', Unique: '{}', VdsPort: '{}', IsPending: '{}' with force synchronize", getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
    UpdateVdsActionParameters p = new UpdateVdsActionParameters(vds.getStaticData(), "", false);
    p.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    VdcReturnValueBase rc = Backend.getInstance().runInternalAction(VdcActionType.UpdateVds, p);
    if (rc == null || !rc.getSucceeded()) {
        error = AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED;
        log.debug("RegisterVdsQuery::Register - Failed to update existing VDS Name: '{}', Hostname: '{}', Unique: '{}', VdsPort: '{}', IsPending: '{}'", getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
        CaptureCommandErrorsToLogger(rc, "RegisterVdsQuery::Register");
        returnValue = false;
    } else {
        log.info("RegisterVdsQuery::Register - Updated a '{}' registered VDS - Name: '{}', Hostname: '{}', UniqueID: '{}'", vds.getStatus() == VDSStatus.PendingApproval ? "Pending " : "", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId());
    }
    return returnValue;
}
#method_after
private boolean updateExistingHost(VDS vds, boolean IsPending) {
    boolean returnValue = true;
    vds.setHostName(vds.getHostName());
    vds.setPort(getParameters().getVdsPort());
    log.debug("RegisterVdsQuery::Register - Will try now to update VDS with existing unique id; Name: '{}', Hostname: '{}', Unique: '{}', VdsPort: '{}', IsPending: '{}' with force synchronize", getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
    UpdateVdsActionParameters p = new UpdateVdsActionParameters(vds.getStaticData(), "", false);
    p.setInstallVds(!IsPending);
    p.setIsReinstallOrUpgrade(!IsPending);
    p.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.PublicKey);
    p.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    VdcReturnValueBase rc = Backend.getInstance().runInternalAction(VdcActionType.UpdateVds, p);
    if (rc == null || !rc.getSucceeded()) {
        error = AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED;
        log.debug("RegisterVdsQuery::Register - Failed to update existing VDS Name: '{}', Hostname: '{}', Unique: '{}', VdsPort: '{}', IsPending: '{}'", getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
        CaptureCommandErrorsToLogger(rc, "RegisterVdsQuery::Register");
        returnValue = false;
    } else {
        log.info("RegisterVdsQuery::Register - Updated a '{}' registered VDS - Name: '{}', Hostname: '{}', UniqueID: '{}'", vds.getStatus() == VDSStatus.PendingApproval ? "Pending " : "", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId());
    }
    return returnValue;
}
#end_block

#method_before
protected static RoleNode createVmRoleTree() {
    return new RoleNode(getConstants().vmRoleTree(), new RoleNode[] { new RoleNode(getConstants().basicOperationsRoleTree(), new RoleNode[] { new RoleNode(ActionGroup.REBOOT_VM, getConstants().allowBasicVmOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.STOP_VM, getConstants().allowBasicVmOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.SHUT_DOWN_VM, getConstants().allowBasicVmOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.PAUSE_VM, getConstants().allowBasicVmOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.HIBERNATE_VM, getConstants().allowBasicVmOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.RUN_VM, getConstants().allowBasicVmOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.CHANGE_VM_CD, getConstants().allowToAttachCdToTheVmRoleTreeTooltip()), new RoleNode(ActionGroup.CONNECT_TO_VM, getConstants().allowViewingTheVmConsoleScreenRoleTreeTooltip()) }), new RoleNode(getConstants().provisioningOperationsRoleTree(), getConstants().notePermissionsContainigTheseOperationsShuoldAssociatSdOrAboveRoleTreeTooltip(), new RoleNode[] { new RoleNode(ActionGroup.EDIT_VM_PROPERTIES, getConstants().allowChangeVmPropertiesRoleTreeTooltip()), new RoleNode(ActionGroup.CREATE_VM, getConstants().allowToCreateNewVmsRoleTreeTooltip()), new RoleNode(ActionGroup.CREATE_INSTANCE, getConstants().allowToCreateNewInstnaceRoleTreeTooltip()), new RoleNode(ActionGroup.DELETE_VM, getConstants().allowToRemoveVmsFromTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.IMPORT_EXPORT_VM, getConstants().allowImportExportOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.CONFIGURE_VM_STORAGE, getConstants().allowToAddRemoveDiskToTheVmRoleTreeTooltip()), new RoleNode(ActionGroup.MANIPULATE_VM_SNAPSHOTS, getConstants().allowToCreateDeleteSnapshotsOfTheVmRoleTreeTooltip()) }), new RoleNode(getConstants().administrationOperationsRoleTree(), getConstants().notePermissionsContainigTheseOperationsShuoldAssociatDcOrEqualRoleTreeTooltip(), new RoleNode[] { new RoleNode(ActionGroup.MOVE_VM, getConstants().allowToMoveVmImageToAnotherStorageDomainRoleTreeTooltip()), new RoleNode(ActionGroup.MIGRATE_VM, getConstants().allowMigratingVmBetweenHostsInClusterRoleTreeTooltip()), new RoleNode(ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES, getConstants().allowToChangeVmCustomPropertiesRoleTreeTooltip()), new RoleNode(ActionGroup.EDIT_ADMIN_VM_PROPERTIES, getConstants().allowChangingVmAdminPropertiesRoleTreeTooltip()), new RoleNode(ActionGroup.RECONNECT_TO_VM, getConstants().allowReconnectToVmRoleTreeTooltip()) }) });
}
#method_after
protected static RoleNode createVmRoleTree() {
    return new RoleNode(getConstants().vmRoleTree(), new RoleNode[] { new RoleNode(getConstants().basicOperationsRoleTree(), new RoleNode[] { new RoleNode(ActionGroup.REBOOT_VM, getConstants().allowBasicVmOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.STOP_VM, getConstants().allowBasicVmOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.SHUT_DOWN_VM, getConstants().allowBasicVmOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.HIBERNATE_VM, getConstants().allowBasicVmOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.RUN_VM, getConstants().allowBasicVmOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.CHANGE_VM_CD, getConstants().allowToAttachCdToTheVmRoleTreeTooltip()), new RoleNode(ActionGroup.CONNECT_TO_VM, getConstants().allowViewingTheVmConsoleScreenRoleTreeTooltip()) }), new RoleNode(getConstants().provisioningOperationsRoleTree(), getConstants().notePermissionsContainigTheseOperationsShuoldAssociatSdOrAboveRoleTreeTooltip(), new RoleNode[] { new RoleNode(ActionGroup.EDIT_VM_PROPERTIES, getConstants().allowChangeVmPropertiesRoleTreeTooltip()), new RoleNode(ActionGroup.CREATE_VM, getConstants().allowToCreateNewVmsRoleTreeTooltip()), new RoleNode(ActionGroup.CREATE_INSTANCE, getConstants().allowToCreateNewInstnaceRoleTreeTooltip()), new RoleNode(ActionGroup.DELETE_VM, getConstants().allowToRemoveVmsFromTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.IMPORT_EXPORT_VM, getConstants().allowImportExportOperationsRoleTreeTooltip()), new RoleNode(ActionGroup.CONFIGURE_VM_STORAGE, getConstants().allowToAddRemoveDiskToTheVmRoleTreeTooltip()), new RoleNode(ActionGroup.MANIPULATE_VM_SNAPSHOTS, getConstants().allowToCreateDeleteSnapshotsOfTheVmRoleTreeTooltip()) }), new RoleNode(getConstants().administrationOperationsRoleTree(), getConstants().notePermissionsContainigTheseOperationsShuoldAssociatDcOrEqualRoleTreeTooltip(), new RoleNode[] { new RoleNode(ActionGroup.MOVE_VM, getConstants().allowToMoveVmImageToAnotherStorageDomainRoleTreeTooltip()), new RoleNode(ActionGroup.MIGRATE_VM, getConstants().allowMigratingVmBetweenHostsInClusterRoleTreeTooltip()), new RoleNode(ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES, getConstants().allowToChangeVmCustomPropertiesRoleTreeTooltip()), new RoleNode(ActionGroup.EDIT_ADMIN_VM_PROPERTIES, getConstants().allowChangingVmAdminPropertiesRoleTreeTooltip()), new RoleNode(ActionGroup.RECONNECT_TO_VM, getConstants().allowReconnectToVmRoleTreeTooltip()) }) });
}
#end_block

#method_before
public void detach() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachStorageTitle());
    model.setHelpTag(HelpTag.detach_storage);
    // $NON-NLS-1$
    model.setHashName("detach_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDetachFollowingStoragesMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (StorageDomain item : Linq.<StorageDomain>cast(getSelectedItems())) {
        list.add(item.getStorageName());
    }
    model.setItems(list);
    if (containsLocalStorage(model)) {
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangable(true);
        model.setNote(ConstantsManager.getInstance().getMessages().detachNote(getLocalStoragesFormattedString()));
    }
    model.setNote(ConstantsManager.getInstance().getConstants().detachWarnningNote());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnDetach", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void detach() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachStorageTitle());
    model.setHelpTag(HelpTag.detach_storage);
    // $NON-NLS-1$
    model.setHashName("detach_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDetachFollowingStoragesMsg());
    ArrayList<String> list = new ArrayList<String>();
    boolean shouldAddressWarnning = false;
    for (StorageDomain item : Linq.<StorageDomain>cast(getSelectedItems())) {
        list.add(item.getStorageName());
        if (item.getStorageDomainType().isDataDomain()) {
            shouldAddressWarnning = true;
            break;
        }
    }
    model.setItems(list);
    if (containsLocalStorage(model)) {
        shouldAddressWarnning = false;
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangable(true);
        model.setNote(ConstantsManager.getInstance().getMessages().detachNote(getLocalStoragesFormattedString()));
    }
    if (shouldAddressWarnning) {
        model.setNote(ConstantsManager.getInstance().getConstants().detachWarnningNote());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnDetach", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void detach() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachStorageTitle());
    model.setHelpTag(HelpTag.detach_storage);
    // $NON-NLS-1$
    model.setHashName("detach_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDetachStorageFromDcsMsg());
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        StorageDomain a = (StorageDomain) item;
        items.add(a.getStoragePoolName());
    }
    model.setItems(items);
    if (containsLocalStorage(model)) {
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangable(true);
        model.setNote(ConstantsManager.getInstance().getMessages().detachNote(getLocalStoragesFormattedString()));
    }
    model.setNote(ConstantsManager.getInstance().getConstants().detachWarnningNote());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnDetach", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void detach() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachStorageTitle());
    model.setHelpTag(HelpTag.detach_storage);
    // $NON-NLS-1$
    model.setHashName("detach_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDetachStorageFromDcsMsg());
    ArrayList<String> items = new ArrayList<String>();
    boolean shouldAddressWarnning = false;
    for (Object item : getSelectedItems()) {
        StorageDomain a = (StorageDomain) item;
        items.add(a.getStoragePoolName());
        if (a.getStorageDomainType().isDataDomain()) {
            shouldAddressWarnning = true;
            break;
        }
    }
    model.setItems(items);
    if (containsLocalStorage(model)) {
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangable(true);
        shouldAddressWarnning = false;
        model.setNote(ConstantsManager.getInstance().getMessages().detachNote(getLocalStoragesFormattedString()));
    }
    if (shouldAddressWarnning) {
        model.setNote(ConstantsManager.getInstance().getConstants().detachWarnningNote());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnDetach", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds().getStatus() == VDSStatus.Maintenance) {
        // nothing to do
        setSucceeded(true);
    } else {
        orderListOfRunningVmsOnVds(getVdsId());
        if (getVds().getHighlyAvailableIsConfigured()) {
            try {
                SetHaMaintenanceModeVDSCommandParameters params = new SetHaMaintenanceModeVDSCommandParameters(getVds(), HaMaintenanceMode.LOCAL, true);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, params).getSucceeded()) {
                    // HA maintenance failure is fatal only if the Hosted Engine vm is running on this host
                    setSucceeded(isHostedEngineOnVds());
                    haMaintenanceFailed = true;
                }
            } catch (VdcBLLException e) {
                /* if there is hosted engine running on the VDS, it's fatal, so rethrow the exception */
                if (isHostedEngineOnVds())
                    throw e;
                setSucceeded(false);
                haMaintenanceFailed = true;
            }
        }
        setSucceeded(migrateAllVms(getExecutionContext()));
        // if non responsive move directly to maintenance
        if (getVds().getStatus() == VDSStatus.NonResponsive || getVds().getStatus() == VDSStatus.Connecting || getVds().getStatus() == VDSStatus.Down) {
            runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Maintenance));
        }
    }
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isVmsExist()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds().getStatus() == VDSStatus.Maintenance) {
        // nothing to do
        setSucceeded(true);
    } else {
        orderListOfRunningVmsOnVds(getVdsId());
        if (getVds().getHighlyAvailableIsConfigured()) {
            SetHaMaintenanceModeVDSCommandParameters params = new SetHaMaintenanceModeVDSCommandParameters(getVds(), HaMaintenanceMode.LOCAL, true);
            if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, params).getSucceeded()) {
                haMaintenanceFailed = true;
                // HA maintenance failure is fatal only if the Hosted Engine vm is running on this host
                if (isHostedEngineOnVds()) {
                    setSucceeded(false);
                    return;
                }
            }
        }
        setSucceeded(migrateAllVms(getExecutionContext()));
        // if non responsive move directly to maintenance
        if (getVds().getStatus() == VDSStatus.NonResponsive || getVds().getStatus() == VDSStatus.Connecting || getVds().getStatus() == VDSStatus.Down) {
            runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Maintenance));
        }
    }
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isVmsExist()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
protected boolean migrateAllVms(ExecutionContext parentContext, boolean HAOnly) {
    boolean succeeded = true;
    for (VM vm : vms) {
        if (vm.isHostedEngine()) {
            // The Hosted Engine vm is migrated by the HA agent
            continue;
        }
        // if HAOnly is true check that vm is HA (auto_startup should be true)
        if (vm.getStatus() != VMStatus.MigratingFrom && (!HAOnly || (HAOnly && vm.isAutoStartup()))) {
            VdcReturnValueBase result = runInternalAction(VdcActionType.InternalMigrateVm, new InternalMigrateVmParameters(vm.getId(), getActionType()), createMigrateVmContext(parentContext, vm));
            if (!result.getCanDoAction() || !(((Boolean) result.getActionReturnValue()).booleanValue())) {
                succeeded = false;
                appendCustomValue("failedVms", vm.getName(), ",");
                log.error("ResourceManager::vdsMaintenance - Failed migrating desktop '{}'", vm.getName());
            }
        }
    }
    return succeeded;
}
#method_after
protected boolean migrateAllVms(ExecutionContext parentContext, boolean HAOnly) {
    boolean succeeded = true;
    for (VM vm : vms) {
        if (vm.isHostedEngine()) {
            // check if there is host which can be used for HE
            if (!canScheduleVm(vm)) {
                succeeded = false;
                appendCustomValue("failedVms", vm.getName(), ",");
                log.error("ResourceManager::vdsMaintenance - There is not host capable of running the hosted engine VM");
            }
        }
        // if HAOnly is true check that vm is HA (auto_startup should be true)
        if (vm.getStatus() != VMStatus.MigratingFrom && (!HAOnly || (HAOnly && vm.isAutoStartup()))) {
            VdcReturnValueBase result = runInternalAction(VdcActionType.InternalMigrateVm, new InternalMigrateVmParameters(vm.getId(), getActionType()), createMigrateVmContext(parentContext, vm));
            if (!result.getCanDoAction() || !(((Boolean) result.getActionReturnValue()).booleanValue())) {
                succeeded = false;
                appendCustomValue("failedVms", vm.getName(), ",");
                log.error("ResourceManager::vdsMaintenance - Failed migrating desktop '{}'", vm.getName());
            }
        }
    }
    return succeeded;
}
#end_block

#method_before
@Override
public void provisionHost(VDS vds, ExternalHostGroup hg, ExternalComputeResource computeResource, String mac, String discoverName, String rootPassword) {
    final String entityBody = "{\n" + "    \"discovered_host\": {\n" + "        \"name\": \"" + vds.getName() + "\",\n" + "        \"hostgroup_id\": \"" + hg.getHostgroupId() + "\",\n" + "        \"environment_id\": \"" + hg.getEnvironmentId() + "\",\n" + "        \"mac\": \"" + mac + "\",\n" + "        \"domain_id\": \"" + hg.getDomainId() + "\",\n" + "        \"subnet_id\": \"" + hg.getSubnetId() + "\",\n" + "        \"ip\": \"" + vds.getHostName() + "\",\n" + "        \"architecture_id\": \"" + hg.getArchitectureId() + "\",\n" + "        \"operatingsystem_id\": \"" + hg.getOsId() + "\",\n" + "        \"medium_id\": \"" + hg.getMediumId() + "\",\n" + "        \"ptable_id\": \"" + hg.getPtableId() + "\",\n" + "        \"root_pass\": \"" + rootPassword + "\",\n" + "        \"host_parameters_attributes\": [\n" + "           {\n" + "                \"name\": \"host_ovirt_id\",\n" + "                \"value\": \"" + vds.getStaticData().getId() + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"compute_resource_id\",\n" + "                \"value\": \"" + computeResource.getId() + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"pass\",\n" + "                \"value\": \"" + CryptMD5.crypt(rootPassword) + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"management\",\n" + "                \"value\": \"" + computeResource.getUrl().replaceAll("(http://|/api)", "") + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            }\n" + "        ]\n" + "    }\n" + "}";
    PutMethod httpMethod = new PutMethod(DISCOVERED_HOSTS_ENTRY_POINT + "/" + discoverName);
    RequestEntity entity = new RequestEntity() {

        @Override
        public boolean isRepeatable() {
            return false;
        }

        @Override
        public void writeRequest(OutputStream outputStream) throws IOException {
            PrintWriter pr = new PrintWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));
            pr.println(entityBody);
            pr.flush();
        }

        @Override
        public long getContentLength() {
            return entityBody.getBytes(StandardCharsets.UTF_8).length;
        }

        @Override
        public String getContentType() {
            return "application/json";
        }
    };
    httpMethod.setRequestEntity(entity);
    runHttpMethod(httpClient, httpMethod);
}
#method_after
@Override
public void provisionHost(VDS vds, ExternalHostGroup hg, ExternalComputeResource computeResource, String mac, String discoverName, String rootPassword) {
    final String entityBody = "{\n" + "    \"discovered_host\": {\n" + "        \"name\": \"" + vds.getName() + "\",\n" + "        \"hostgroup_id\": \"" + hg.getHostgroupId() + "\",\n" + "        \"environment_id\": \"" + hg.getEnvironmentId() + "\",\n" + "        \"mac\": \"" + mac + "\",\n" + "        \"domain_id\": \"" + hg.getDomainId() + "\",\n" + "        \"subnet_id\": \"" + hg.getSubnetId() + "\",\n" + "        \"ip\": \"" + vds.getHostName() + "\",\n" + "        \"architecture_id\": \"" + hg.getArchitectureId() + "\",\n" + "        \"operatingsystem_id\": \"" + hg.getOsId() + "\",\n" + "        \"medium_id\": \"" + hg.getMediumId() + "\",\n" + "        \"ptable_id\": \"" + hg.getPtableId() + "\",\n" + "        \"root_pass\": \"" + rootPassword + "\",\n" + "        \"host_parameters_attributes\": [\n" + "           {\n" + "                \"name\": \"host_ovirt_id\",\n" + "                \"value\": \"" + vds.getStaticData().getId() + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"compute_resource_id\",\n" + "                \"value\": \"" + computeResource.getId() + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"pass\",\n" + "                \"value\": \"" + CryptMD5.crypt(rootPassword) + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"management\",\n" + "                \"value\": \"" + computeResource.getUrl().replaceAll("(http://|/api|/ovirt-engine)", "") + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            }\n" + "        ]\n" + "    }\n" + "}";
    PutMethod httpMethod = new PutMethod(DISCOVERED_HOSTS_ENTRY_POINT + "/" + discoverName);
    RequestEntity entity = new RequestEntity() {

        @Override
        public boolean isRepeatable() {
            return false;
        }

        @Override
        public void writeRequest(OutputStream outputStream) throws IOException {
            PrintWriter pr = new PrintWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));
            pr.println(entityBody);
            pr.flush();
        }

        @Override
        public long getContentLength() {
            return entityBody.getBytes(StandardCharsets.UTF_8).length;
        }

        @Override
        public String getContentType() {
            return "application/json";
        }
    };
    httpMethod.setRequestEntity(entity);
    runHttpMethod(httpClient, httpMethod);
}
#end_block

#method_before
private boolean canScheduleVm(VM vm) {
    return SchedulingManager.getInstance().canSchedule(getVdsGroup(), vm, // no blacklist
    new ArrayList<Guid>(), // no whitelist
    new ArrayList<Guid>(), vm.getDedicatedVmForVds(), new ArrayList<String>());
}
#method_after
private boolean canScheduleVm(VM vm) {
    List<Guid> blacklist = new ArrayList<Guid>();
    if (getVdsId() != null) {
        blacklist.add(getVdsId());
    }
    return SchedulingManager.getInstance().canSchedule(getVdsGroup(), vm, // blacklist only contains the host we're putting to maintenance
    blacklist, // no whitelist
    Collections.<Guid>emptyList(), vm.getDedicatedVmForVds(), new ArrayList<String>());
}
#end_block

#method_before
protected Collection<DiskImage> getDiskImagesToBeCloned() {
    return getDiskImagesFromConfiguration();
}
#method_after
protected Collection<DiskImage> getDiskImagesToBeCloned() {
    return getAdjustedDiskImagesFromConfiguration();
}
#end_block

#method_before
@Override
protected boolean addVmImages() {
    int numberOfStartedCopyTasks = 0;
    try {
        if (!getDiskImagesFromConfiguration().isEmpty()) {
            lockEntities();
            for (DiskImage diskImage : getDiskImagesFromConfiguration()) {
                // query returned to UI an illegal image)
                if (diskImage.getImageStatus() == ImageStatus.ILLEGAL) {
                    DiskImage snapshotImageInDb = getDiskImageDao().getSnapshotById(diskImage.getImageId());
                    if (snapshotImageInDb == null) {
                        // If the snapshot diskImage is null, it means the disk was probably
                        // erased after the snapshot was created.
                        // Create a disk to reflect the fact the disk existed during snapshot
                        saveIllegalDisk(diskImage);
                    }
                } else {
                    // Only legal images can be copied
                    copyDiskImage(diskImage, diskImage.getStorageIds().get(0), diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0), diskInfoDestinationMap.get(diskImage.getId()).getDiskProfileId(), getActionType());
                    numberOfStartedCopyTasks++;
                }
            }
        }
    } finally {
        // it is still needed to unlock the entities
        if (numberOfStartedCopyTasks == 0) {
            unlockEntities();
        }
    }
    return true;
}
#method_after
@Override
protected boolean addVmImages() {
    int numberOfStartedCopyTasks = 0;
    try {
        if (!getAdjustedDiskImagesFromConfiguration().isEmpty()) {
            lockEntities();
            for (DiskImage diskImage : getAdjustedDiskImagesFromConfiguration()) {
                // query returned to UI an illegal image)
                if (diskImage.getImageStatus() == ImageStatus.ILLEGAL) {
                    DiskImage snapshotImageInDb = getDiskImageDao().getSnapshotById(diskImage.getImageId());
                    if (snapshotImageInDb == null) {
                        // If the snapshot diskImage is null, it means the disk was probably
                        // erased after the snapshot was created.
                        // Create a disk to reflect the fact the disk existed during snapshot
                        saveIllegalDisk(diskImage);
                    }
                } else {
                    // Only legal images can be copied
                    copyDiskImage(diskImage, diskImage.getStorageIds().get(0), diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0), diskInfoDestinationMap.get(diskImage.getId()).getDiskProfileId(), getActionType());
                    numberOfStartedCopyTasks++;
                }
            }
        }
    } finally {
        // it is still needed to unlock the entities
        if (numberOfStartedCopyTasks == 0) {
            unlockEntities();
        }
    }
    return true;
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            setCommandStatus(CommandStatus.SUCCEEDED);
            internalEndSuccessfully();
        } else {
            setCommandStatus(CommandStatus.FAILED);
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            if (getCallBack() == null) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            internalEndSuccessfully();
        } else {
            if (getCallBack() == null) {
                setCommandStatus(CommandStatus.FAILED);
            }
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        if (validationResult.getVariableReplacements() != null) {
            for (String variableReplacement : validationResult.getVariableReplacements()) {
                addCanDoActionMessage(variableReplacement);
            }
        }
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            addCanDoActionMessage(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#end_block

#method_before
public ValidationResult validateSpaceRequirements(Collection<DiskImage> diskImages) {
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(diskImages);
    ValidationResult result = sdValidator.allDomainsExistAndActive();
    if (!result.isValid()) {
        return result;
    }
    result = sdValidator.allDomainsWithinThresholds();
    if (!result.isValid()) {
        return result;
    }
    if (params.getCopyCollapse()) {
        return sdValidator.allDomainsHaveSpaceForClonedDisks(diskImages);
    }
    result = sdValidator.allDomainsHaveSpaceForDisksWithSnapshots(diskImages);
    if (!result.isValid()) {
        return result;
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateSpaceRequirements(Collection<DiskImage> diskImages) {
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(diskImages);
    ValidationResult result = sdValidator.allDomainsExistAndActive();
    if (!result.isValid()) {
        return result;
    }
    result = sdValidator.allDomainsWithinThresholds();
    if (!result.isValid()) {
        return result;
    }
    if (params.getCopyCollapse()) {
        return sdValidator.allDomainsHaveSpaceForClonedDisks(diskImages);
    }
    return sdValidator.allDomainsHaveSpaceForDisksWithSnapshots(diskImages);
}
#end_block

#method_before
protected ImportValidator getImportValidator() {
    return new ImportValidator(getParameters());
}
#method_after
protected ImportValidator getImportValidator() {
    if (importValidator == null) {
        importValidator = new ImportValidator(getParameters());
    }
    return importValidator;
}
#end_block

#method_before
protected void fillMacAddressIfMissing(VmNic iface) {
    if (StringUtils.isEmpty(iface.getMacAddress()) && getMacPool().getAvailableMacsCount() > 0) {
        iface.setMacAddress(getMacPool().allocateNewMac());
    }
}
#method_after
private void fillMacAddressIfMissing(VmNic iface) {
    if (StringUtils.isEmpty(iface.getMacAddress()) && getMacPool().getAvailableMacsCount() > 0) {
        iface.setMacAddress(getMacPool().allocateNewMac());
    }
}
#end_block

#method_before
@Test
public void testImportVMFromConfigurationWhenStorageDomainIsInMaintenance() {
    initCommand(getOvfEntityData());
    StorageDomain storageDomain = createStorageDomain();
    storageDomain.setStatus(StorageDomainStatus.Maintenance);
    // Mock Storage Domain.
    final StorageDomainDAO dao = mock(StorageDomainDAO.class);
    doReturn(dao).when(cmd).getStorageDomainDAO();
    when(dao.getForStoragePool(storageDomainId, storagePoolId)).thenReturn(storageDomain);
    doReturn(storageDomain).when(cmd).getStorageDomain();
    when(validator.validateUnregisteredEntity(any(IVdcQueryable.class), any(OvfEntityData.class), any(List.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
}
#method_after
@Test
public void testImportVMFromConfigurationWhenStorageDomainIsInMaintenance() {
    initCommand(getOvfEntityData());
    StorageDomain storageDomain = createStorageDomain();
    storageDomain.setStatus(StorageDomainStatus.Maintenance);
    // Mock Storage Domain.
    final StorageDomainDAO dao = mock(StorageDomainDAO.class);
    doReturn(dao).when(cmd).getStorageDomainDAO();
    when(dao.getForStoragePool(storageDomainId, storagePoolId)).thenReturn(storageDomain);
    doReturn(storageDomain).when(cmd).getStorageDomain();
    when(validator.validateUnregisteredEntity(any(IVdcQueryable.class), any(OvfEntityData.class), anyList())).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
}
#end_block

#method_before
@Test
public void testImportVMFromConfigurationWhenStorageDomainIsInactive() {
    initCommand(getOvfEntityData());
    StorageDomain storageDomain = createStorageDomain();
    storageDomain.setStatus(StorageDomainStatus.Inactive);
    // Mock Storage Domain.
    final StorageDomainDAO dao = mock(StorageDomainDAO.class);
    when(validator.validateUnregisteredEntity(any(IVdcQueryable.class), any(OvfEntityData.class), any(List.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2));
    when(dao.getForStoragePool(storageDomainId, storagePoolId)).thenReturn(storageDomain);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
}
#method_after
@Test
public void testImportVMFromConfigurationWhenStorageDomainIsInactive() {
    initCommand(getOvfEntityData());
    StorageDomain storageDomain = createStorageDomain();
    storageDomain.setStatus(StorageDomainStatus.Inactive);
    // Mock Storage Domain.
    final StorageDomainDAO dao = mock(StorageDomainDAO.class);
    when(validator.validateUnregisteredEntity(any(IVdcQueryable.class), any(OvfEntityData.class), anyList())).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2));
    when(dao.getForStoragePool(storageDomainId, storagePoolId)).thenReturn(storageDomain);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
}
#end_block

#method_before
@Test
public void testImportVMFromConfigurationXMLCouldNotGetParsed() {
    OvfEntityData ovfEntity = getOvfEntityData();
    ovfEntity.setOvfData("This is not a valid XML");
    initCommand(ovfEntity);
    when(unregisteredOVFDataDao.getByEntityIdAndStorageDomain(vmId, storageDomainId)).thenReturn(ovfEntity);
    when(validator.validateUnregisteredEntity(any(IVdcQueryable.class), any(OvfEntityData.class), any(List.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
}
#method_after
@Test
public void testImportVMFromConfigurationXMLCouldNotGetParsed() {
    OvfEntityData ovfEntity = getOvfEntityData();
    ovfEntity.setOvfData("This is not a valid XML");
    initCommand(ovfEntity);
    when(unregisteredOVFDataDao.getByEntityIdAndStorageDomain(vmId, storageDomainId)).thenReturn(ovfEntity);
    when(validator.validateUnregisteredEntity(any(IVdcQueryable.class), any(OvfEntityData.class), anyList())).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    executeVmCommand();
}
#method_after
@Override
protected void executeCommand() {
    if (shouldSkipCommandExecutionCached()) {
        setSucceeded(true);
        return;
    }
    executeVmCommand();
}
#end_block

