322
#method_before
private OutboundPacket createOutBoundLldp(Long port) {
    if (port == null) {
        return null;
    }
    ONOSLLDP lldp = remoteProbes ? factory.interDomainLLDP(port.intValue()) : factory.onosLLDP(port.intValue());
    ethPacket.setSourceMACAddress(SRC_MAC).setPayload(lldp);
    return new DefaultOutboundPacket(device.id(), builder().setOutput(portNumber(port)).build(), ByteBuffer.wrap(ethPacket.serialize()));
}
#method_after
private OutboundPacket createOutBoundLldp(Long port) {
    if (port == null) {
        return null;
    }
    ONOSLLDP lldp = getLinkProbe(port);
    ethPacket.setSourceMACAddress(SRC_MAC).setPayload(lldp);
    return new DefaultOutboundPacket(device.id(), builder().setOutput(portNumber(port)).build(), ByteBuffer.wrap(ethPacket.serialize()));
}
#end_block

#method_before
private OutboundPacket createOutBoundBddp(Long port) {
    if (port == null) {
        return null;
    }
    ONOSLLDP lldp = remoteProbes ? factory.interDomainLLDP(port.intValue()) : factory.onosLLDP(port.intValue());
    bddpEth.setSourceMACAddress(SRC_MAC).setPayload(lldp);
    return new DefaultOutboundPacket(device.id(), builder().setOutput(portNumber(port)).build(), ByteBuffer.wrap(bddpEth.serialize()));
}
#method_after
private OutboundPacket createOutBoundBddp(Long port) {
    if (port == null) {
        return null;
    }
    ONOSLLDP lldp = getLinkProbe(port);
    bddpEth.setSourceMACAddress(SRC_MAC).setPayload(lldp);
    return new DefaultOutboundPacket(device.id(), builder().setOutput(portNumber(port)).build(), ByteBuffer.wrap(bddpEth.serialize()));
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    appId = coreService.registerApplication(PROVIDER_NAME);
    cfgRegistry.addListener(cfgListener);
    factories.forEach(cfgRegistry::registerConfigFactory);
    SuppressionConfig cfg = cfgRegistry.getConfig(appId, SuppressionConfig.class);
    if (cfg == null) {
        // If no configuration is found, register default.
        cfg = cfgRegistry.addConfig(appId, SuppressionConfig.class);
        cfg.deviceTypes(DEFAULT_RULES.getSuppressedDeviceType()).annotation(DEFAULT_RULES.getSuppressedAnnotation()).apply();
    }
    cfgListener.reconfigureSuppressionRules(cfg);
    modified(context);
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    appId = coreService.registerApplication(PROVIDER_NAME);
    cfgRegistry.addListener(cfgListener);
    factories.forEach(cfgRegistry::registerConfigFactory);
    SuppressionConfig cfg = cfgRegistry.getConfig(appId, SuppressionConfig.class);
    if (cfg == null) {
        // If no configuration is found, register default.
        cfg = Tools.retryable(this::setDefaultSuppressionConfig, ConsistentMapException.class, MAX_RETRIES, RETRY_DELAY).get();
    }
    cfgListener.reconfigureSuppressionRules(cfg);
    modified(context);
    log.info("Started");
}
#end_block

#method_before
private Optional<LinkDiscovery> updateDevice(Device device) {
    if (device == null) {
        return Optional.empty();
    }
    if (rules.isSuppressed(device) || isBlacklisted(device.id())) {
        log.trace("LinkDiscovery from {} disabled by configuration", device.id());
        removeDevice(device.id());
        return Optional.empty();
    }
    LinkDiscovery ld = discoverers.computeIfAbsent(device.id(), did -> new LinkDiscovery(device, context));
    if (!ld.isFederated() && isFederated(device.id())) {
        ld.enableRemoteProbes();
    } else if (ld.isFederated() && !isFederated(device.id())) {
        ld.disableRemoteProbes();
    }
    if (ld.isStopped()) {
        ld.start();
    }
    return Optional.of(ld);
}
#method_after
private Optional<LinkDiscovery> updateDevice(Device device) {
    if (device == null) {
        return Optional.empty();
    }
    if (rules.isSuppressed(device) || isBlacklisted(device.id())) {
        log.trace("LinkDiscovery from {} disabled by configuration", device.id());
        removeDevice(device.id());
        return Optional.empty();
    }
    LinkDiscovery ld = discoverers.computeIfAbsent(device.id(), did -> new LinkDiscovery(device, context));
    if (isFingerprinted(device.id())) {
        ld.enableFingerprint();
    } else {
        ld.disableFingerprint();
    }
    if (ld.isStopped()) {
        ld.start();
    }
    return Optional.of(ld);
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    if (event.configClass() == LinkDiscoveryFromDevice.class && CONFIG_CHANGED.contains(event.type())) {
        if (event.subject() instanceof DeviceId) {
            final DeviceId did = (DeviceId) event.subject();
            Device device = deviceService.getDevice(did);
            updateDevice(device).ifPresent(ld -> updatePorts(ld, did));
        }
    } else if (event.configClass() == LinkDiscoveryFromPort.class && CONFIG_CHANGED.contains(event.type())) {
        if (event.subject() instanceof ConnectPoint) {
            ConnectPoint cp = (ConnectPoint) event.subject();
            if (cp.elementId() instanceof DeviceId) {
                final DeviceId did = (DeviceId) cp.elementId();
                Device device = deviceService.getDevice(did);
                Port port = deviceService.getPort(did, cp.port());
                updateDevice(device).ifPresent(ld -> updatePort(ld, port));
            }
        }
    } else if (event.configClass() == RemoteProbeFromDevice.class && CONFIG_CHANGED.contains(event.type())) {
        if (event.subject() instanceof DeviceId) {
            final DeviceId did = (DeviceId) event.subject();
            Device device = deviceService.getDevice(did);
            updateDevice(device);
        }
    } else if (event.configClass().equals(SuppressionConfig.class) && (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED)) {
        SuppressionConfig cfg = cfgRegistry.getConfig(appId, SuppressionConfig.class);
        reconfigureSuppressionRules(cfg);
        log.trace("Network config reconfigured");
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (event.configClass() == LinkDiscoveryFromDevice.class && CONFIG_CHANGED.contains(event.type())) {
        if (event.subject() instanceof DeviceId) {
            final DeviceId did = (DeviceId) event.subject();
            Device device = deviceService.getDevice(did);
            updateDevice(device).ifPresent(ld -> updatePorts(ld, did));
        }
    } else if (event.configClass() == LinkDiscoveryFromPort.class && CONFIG_CHANGED.contains(event.type())) {
        if (event.subject() instanceof ConnectPoint) {
            ConnectPoint cp = (ConnectPoint) event.subject();
            if (cp.elementId() instanceof DeviceId) {
                final DeviceId did = (DeviceId) cp.elementId();
                Device device = deviceService.getDevice(did);
                Port port = deviceService.getPort(did, cp.port());
                updateDevice(device).ifPresent(ld -> updatePort(ld, port));
            }
        }
    } else if (event.configClass() == FingerprintProbeFromDevice.class && CONFIG_CHANGED.contains(event.type())) {
        if (event.subject() instanceof DeviceId) {
            final DeviceId did = (DeviceId) event.subject();
            Device device = deviceService.getDevice(did);
            updateDevice(device);
        }
    } else if (event.configClass().equals(SuppressionConfig.class) && (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED)) {
        SuppressionConfig cfg = cfgRegistry.getConfig(appId, SuppressionConfig.class);
        reconfigureSuppressionRules(cfg);
        log.trace("Network config reconfigured");
    }
}
#end_block

#method_before
@Override
public InboundPacket inPacket() {
    LinkProbeFactory factory = new LinkProbeFactory(deviceService.getDevice(DID1).id().toString(), device.chassisId(), "testdomain");
    ONOSLLDP lldp = factory.onosLLDP((int) pd1.number().toLong());
    Ethernet ethPacket = new Ethernet();
    ethPacket.setEtherType(Ethernet.TYPE_LLDP);
    ethPacket.setDestinationMACAddress(ONOSLLDP.LLDP_NICIRA);
    ethPacket.setPayload(lldp);
    ethPacket.setPad(true);
    ethPacket.setSourceMACAddress("DE:AD:BE:EF:BA:11");
    ConnectPoint cp = new ConnectPoint(device.id(), pd3.number());
    return new DefaultInboundPacket(cp, ethPacket, ByteBuffer.wrap(ethPacket.serialize()));
}
#method_after
@Override
public InboundPacket inPacket() {
    ONOSLLDP lldp = ONOSLLDP.onosLLDP(deviceService.getDevice(DID1).id().toString(), device.chassisId(), (int) pd1.number().toLong());
    Ethernet ethPacket = new Ethernet();
    ethPacket.setEtherType(Ethernet.TYPE_LLDP);
    ethPacket.setDestinationMACAddress(ONOSLLDP.LLDP_NICIRA);
    ethPacket.setPayload(lldp);
    ethPacket.setPad(true);
    ethPacket.setSourceMACAddress("DE:AD:BE:EF:BA:11");
    ConnectPoint cp = new ConnectPoint(device.id(), pd3.number());
    return new DefaultInboundPacket(cp, ethPacket, ByteBuffer.wrap(ethPacket.serialize()));
}
#end_block

#method_before
@Override
public void initNode(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist, add node first", node.hostname());
        return;
    }
    NodeState state = getNodeState(node);
    if (state == null) {
        return;
    } else if (state.equals(NodeState.INCOMPLETE)) {
        state = checkNodeState(node);
    }
    state.process(this, node);
}
#method_after
@Override
public void initNode(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist, add node first", node.hostname());
        return;
    }
    NodeState state = checkNodeState(node);
    state.process(this, node);
}
#end_block

#method_before
@Override
public void createServiceDependency(ServiceId tenantServiceId, Set<ServiceId> providerServiceIds) {
}
#method_after
@Override
public void createServiceDependency(CordServiceId tenantCordServiceId, CordServiceId providerCordServiceId) {
    CordService tenantService = getCordService(tenantCordServiceId);
    CordService providerService = getCordService(providerCordServiceId);
// TODO populate flow rules to create service dependency
}
#end_block

#method_before
@Override
public void removeServiceDependency(ServiceId tenantServiceId) {
}
#method_after
@Override
public void removeServiceDependency(CordServiceId tenantCordServiceId) {
    CordService tenantService = getCordService(tenantCordServiceId);
// TODO uninstall flow rules to remove service dependency
}
#end_block

#method_before
private void connect(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (!getOvsdbConnectionState(node)) {
        // FIXME remove existing OVSDB device to work around OVSDB device re-connect issue
        if (deviceService.getDevice(node.ovsdbId()) != null) {
            adminService.removeDevice(node.ovsdbId());
        }
        controller.connect(node.ovsdbIp(), node.ovsdbPort());
    }
}
#method_after
private void connect(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (!getOvsdbConnectionState(node)) {
        controller.connect(node.ovsdbIp(), node.ovsdbPort());
    }
}
#end_block

#method_before
private void disconnect(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (getOvsdbConnectionState(node)) {
        OvsdbClientService ovsdbClient = getOvsdbClient(node);
        ovsdbClient.disconnect();
    }
    // FIXME remove existing OVSDB device to work around OVSDB device re-connect issue
    if (deviceService.getDevice(node.ovsdbId()) != null) {
        adminService.removeDevice(node.ovsdbId());
    }
}
#method_after
private void disconnect(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (getOvsdbConnectionState(node)) {
        OvsdbClientService ovsdbClient = getOvsdbClient(node);
        ovsdbClient.disconnect();
    }
}
#end_block

#method_before
@Override
public void disconnected(Device device) {
    log.info("OVSDB {} is disconnected", device.id());
}
#method_after
@Override
public void disconnected(Device device) {
    if (!deviceService.isAvailable(device.id())) {
        adminService.removeDevice(device.id());
    }
}
#end_block

#method_before
@POST
@Path("{serviceId}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response createServiceDependency(@PathParam("serviceId") String serviceId, InputStream stream) {
    return Response.status(Response.Status.OK).build();
}
#method_after
@POST
@Path("{tenantServiceId}/{providerServiceId}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response createServiceDependency(@PathParam("tenantServiceId") String tServiceId, @PathParam("providerServiceId") String pServiceId) {
    service.createServiceDependency(CordServiceId.of(tServiceId), CordServiceId.of(pServiceId));
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@DELETE
@Path("{serviceId}")
@Produces(MediaType.APPLICATION_JSON)
public Response removeServiceDependency(@PathParam("serviceId") String serviceId) {
    return Response.status(Response.Status.OK).build();
}
#method_after
@DELETE
@Path("{serviceId}")
@Produces(MediaType.APPLICATION_JSON)
public Response removeServiceDependency(@PathParam("serviceId") String serviceId) {
    service.removeServiceDependency(CordServiceId.of(serviceId));
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@PUT
@Path("{serviceId}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updateServiceDependency(@PathParam("serviceId") String serviceId, InputStream stream) {
    return Response.status(Response.Status.OK).build();
}
#method_after
@PUT
@Path("{serviceId}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updateServiceDependency(@PathParam("serviceId") String serviceId, InputStream stream) {
    // TODO define input stream
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@Test
public void testIntentSync() throws TestUtilsException {
    // 
    // Construct routes and intents.
    // This test simulates the following cases during the master change
    // time interval:
    // 1. RouteEntry1 did not change and the intent also did not change.
    // 2. RouteEntry2 was deleted, but the intent was not deleted.
    // 3. RouteEntry3 was newly added, and the intent was also submitted.
    // 4. RouteEntry4 was updated to RouteEntry4Update, and the intent was
    // also updated to a new one.
    // 5. RouteEntry5 did not change, but its intent id changed.
    // 6. RouteEntry6 was newly added, but the intent was not submitted.
    // 
    RouteEntry routeEntry1 = new RouteEntry(Ip4Prefix.valueOf("1.1.1.0/24"), Ip4Address.valueOf("192.168.10.1"));
    RouteEntry routeEntry2 = new RouteEntry(Ip4Prefix.valueOf("2.2.2.0/24"), Ip4Address.valueOf("192.168.20.1"));
    RouteEntry routeEntry3 = new RouteEntry(Ip4Prefix.valueOf("3.3.3.0/24"), Ip4Address.valueOf("192.168.30.1"));
    RouteEntry routeEntry4 = new RouteEntry(Ip4Prefix.valueOf("4.4.4.0/24"), Ip4Address.valueOf("192.168.30.1"));
    RouteEntry routeEntry4Update = new RouteEntry(Ip4Prefix.valueOf("4.4.4.0/24"), Ip4Address.valueOf("192.168.20.1"));
    RouteEntry routeEntry5 = new RouteEntry(Ip4Prefix.valueOf("5.5.5.0/24"), Ip4Address.valueOf("192.168.10.1"));
    RouteEntry routeEntry6 = new RouteEntry(Ip4Prefix.valueOf("6.6.6.0/24"), Ip4Address.valueOf("192.168.10.1"));
    RouteEntry routeEntry7 = new RouteEntry(Ip4Prefix.valueOf("7.7.7.0/24"), Ip4Address.valueOf("192.168.10.1"));
    MultiPointToSinglePointIntent intent1 = intentBuilder(routeEntry1.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    MultiPointToSinglePointIntent intent2 = intentBuilder(routeEntry2.prefix(), "00:00:00:00:00:02", SW2_ETH1);
    MultiPointToSinglePointIntent intent3 = intentBuilder(routeEntry3.prefix(), "00:00:00:00:00:03", SW3_ETH1);
    MultiPointToSinglePointIntent intent4 = intentBuilder(routeEntry4.prefix(), "00:00:00:00:00:03", SW3_ETH1);
    MultiPointToSinglePointIntent intent4Update = intentBuilder(routeEntry4Update.prefix(), "00:00:00:00:00:02", SW2_ETH1);
    MultiPointToSinglePointIntent intent5 = intentBuilder(routeEntry5.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    MultiPointToSinglePointIntent intent7 = intentBuilder(routeEntry7.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    // Compose a intent, which is equal to intent5 but the id is different.
    MultiPointToSinglePointIntent intent5New = staticIntentBuilder(intent5, routeEntry5, "00:00:00:00:00:01");
    assertThat(IntentUtils.equals(intent5, intent5New), is(true));
    assertFalse(intent5.equals(intent5New));
    MultiPointToSinglePointIntent intent6 = intentBuilder(routeEntry6.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    // Set up expectation
    Set<Intent> intents = new HashSet<>();
    intents.add(intent1);
    expect(intentService.getIntentState(intent1.key())).andReturn(IntentState.INSTALLED).anyTimes();
    intents.add(intent2);
    expect(intentService.getIntentState(intent2.key())).andReturn(IntentState.INSTALLED).anyTimes();
    intents.add(intent4);
    expect(intentService.getIntentState(intent4.key())).andReturn(IntentState.INSTALLED).anyTimes();
    intents.add(intent5);
    expect(intentService.getIntentState(intent5.key())).andReturn(IntentState.INSTALLED).anyTimes();
    intents.add(intent7);
    expect(intentService.getIntentState(intent7.key())).andReturn(IntentState.WITHDRAWING).anyTimes();
    expect(intentService.getIntents()).andReturn(intents).anyTimes();
    // These are the operations that should be done to the intentService
    // during synchronization
    intentService.withdraw(intent2);
    intentService.submit(intent3);
    intentService.submit(intent4Update);
    intentService.submit(intent6);
    intentService.submit(intent7);
    replay(intentService);
    // Start the test
    // Simulate some input from the clients. The intent synchronizer has not
    // gained the global leadership yet, but it will remember this input for
    // when it does.
    intentSynchronizer.submit(intent1);
    intentSynchronizer.submit(intent2);
    intentSynchronizer.withdraw(intent2);
    intentSynchronizer.submit(intent3);
    intentSynchronizer.submit(intent4);
    intentSynchronizer.submit(intent4Update);
    intentSynchronizer.submit(intent5);
    intentSynchronizer.submit(intent6);
    intentSynchronizer.submit(intent7);
    // Give the leadership to the intent synchronizer. It will now attempt
    // to synchronize the intents in the store with the intents it has
    // recorded based on the earlier user input.
    intentSynchronizer.modifyPrimary(true);
    verify(intentService);
}
#method_after
@Test
public void testIntentSync() throws TestUtilsException {
    // 
    // Construct routes and intents.
    // This test simulates the following cases during the master change
    // time interval:
    // 1. RouteEntry1 did not change and the intent also did not change.
    // 2. RouteEntry2 was deleted, but the intent was not deleted.
    // 3. RouteEntry3 was newly added, and the intent was also submitted.
    // 4. RouteEntry4 was updated to RouteEntry4Update, and the intent was
    // also updated to a new one.
    // 5. RouteEntry5 did not change, but its intent id changed.
    // 6. RouteEntry6 was newly added, but the intent was not submitted.
    // 
    RouteEntry routeEntry1 = new RouteEntry(Ip4Prefix.valueOf("1.1.1.0/24"), Ip4Address.valueOf("192.168.10.1"));
    RouteEntry routeEntry2 = new RouteEntry(Ip4Prefix.valueOf("2.2.2.0/24"), Ip4Address.valueOf("192.168.20.1"));
    RouteEntry routeEntry3 = new RouteEntry(Ip4Prefix.valueOf("3.3.3.0/24"), Ip4Address.valueOf("192.168.30.1"));
    RouteEntry routeEntry4 = new RouteEntry(Ip4Prefix.valueOf("4.4.4.0/24"), Ip4Address.valueOf("192.168.30.1"));
    RouteEntry routeEntry4Update = new RouteEntry(Ip4Prefix.valueOf("4.4.4.0/24"), Ip4Address.valueOf("192.168.20.1"));
    RouteEntry routeEntry5 = new RouteEntry(Ip4Prefix.valueOf("5.5.5.0/24"), Ip4Address.valueOf("192.168.10.1"));
    RouteEntry routeEntry6 = new RouteEntry(Ip4Prefix.valueOf("6.6.6.0/24"), Ip4Address.valueOf("192.168.10.1"));
    RouteEntry routeEntry7 = new RouteEntry(Ip4Prefix.valueOf("7.7.7.0/24"), Ip4Address.valueOf("192.168.10.1"));
    MultiPointToSinglePointIntent intent1 = intentBuilder(routeEntry1.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    MultiPointToSinglePointIntent intent2 = intentBuilder(routeEntry2.prefix(), "00:00:00:00:00:02", SW2_ETH1);
    MultiPointToSinglePointIntent intent3 = intentBuilder(routeEntry3.prefix(), "00:00:00:00:00:03", SW3_ETH1);
    MultiPointToSinglePointIntent intent4 = intentBuilder(routeEntry4.prefix(), "00:00:00:00:00:03", SW3_ETH1);
    MultiPointToSinglePointIntent intent4Update = intentBuilder(routeEntry4Update.prefix(), "00:00:00:00:00:02", SW2_ETH1);
    MultiPointToSinglePointIntent intent5 = intentBuilder(routeEntry5.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    MultiPointToSinglePointIntent intent7 = intentBuilder(routeEntry7.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    // Compose a intent, which is equal to intent5 but the id is different.
    MultiPointToSinglePointIntent intent5New = staticIntentBuilder(intent5, routeEntry5, "00:00:00:00:00:01");
    assertThat(IntentUtils.intentsAreEqual(intent5, intent5New), is(true));
    assertFalse(intent5.equals(intent5New));
    MultiPointToSinglePointIntent intent6 = intentBuilder(routeEntry6.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    // Set up expectation
    Set<Intent> intents = new HashSet<>();
    intents.add(intent1);
    expect(intentService.getIntentState(intent1.key())).andReturn(IntentState.INSTALLED).anyTimes();
    intents.add(intent2);
    expect(intentService.getIntentState(intent2.key())).andReturn(IntentState.INSTALLED).anyTimes();
    intents.add(intent4);
    expect(intentService.getIntentState(intent4.key())).andReturn(IntentState.INSTALLED).anyTimes();
    intents.add(intent5);
    expect(intentService.getIntentState(intent5.key())).andReturn(IntentState.INSTALLED).anyTimes();
    intents.add(intent7);
    expect(intentService.getIntentState(intent7.key())).andReturn(IntentState.WITHDRAWING).anyTimes();
    expect(intentService.getIntents()).andReturn(intents).anyTimes();
    // These are the operations that should be done to the intentService
    // during synchronization
    intentService.withdraw(intent2);
    intentService.submit(intent3);
    intentService.submit(intent4Update);
    intentService.submit(intent6);
    intentService.submit(intent7);
    replay(intentService);
    // Start the test
    // Simulate some input from the clients. The intent synchronizer has not
    // gained the global leadership yet, but it will remember this input for
    // when it does.
    intentSynchronizer.submit(intent1);
    intentSynchronizer.submit(intent2);
    intentSynchronizer.withdraw(intent2);
    intentSynchronizer.submit(intent3);
    intentSynchronizer.submit(intent4);
    intentSynchronizer.submit(intent4Update);
    intentSynchronizer.submit(intent5);
    intentSynchronizer.submit(intent6);
    intentSynchronizer.submit(intent7);
    // Give the leadership to the intent synchronizer. It will now attempt
    // to synchronize the intents in the store with the intents it has
    // recorded based on the earlier user input.
    intentSynchronizer.modifyPrimary(true);
    verify(intentService);
}
#end_block

#method_before
private void synchronizeIntents() {
    Map<Key, Intent> serviceIntents = new HashMap<>();
    intentService.getIntents().forEach(i -> {
        if (i.appId().equals(appId)) {
            serviceIntents.put(i.key(), i);
        }
    });
    List<Intent> intentsToAdd = new LinkedList<>();
    List<Intent> intentsToRemove = new LinkedList<>();
    for (Intent localIntent : intents.values()) {
        Intent serviceIntent = serviceIntents.remove(localIntent.key());
        if (serviceIntent == null) {
            intentsToAdd.add(localIntent);
        } else {
            IntentState state = intentService.getIntentState(serviceIntent.key());
            if (!IntentUtils.equals(serviceIntent, localIntent) || state == null || state == IntentState.WITHDRAW_REQ || state == IntentState.WITHDRAWING || state == IntentState.WITHDRAWN) {
                intentsToAdd.add(localIntent);
            }
        }
    }
    for (Intent serviceIntent : serviceIntents.values()) {
        IntentState state = intentService.getIntentState(serviceIntent.key());
        if (state != null && state != IntentState.WITHDRAW_REQ && state != IntentState.WITHDRAWING && state != IntentState.WITHDRAWN) {
            intentsToRemove.add(serviceIntent);
        }
    }
    log.debug("Intent Synchronizer: submitting {}, withdrawing {}", intentsToAdd.size(), intentsToRemove.size());
    // Withdraw Intents
    for (Intent intent : intentsToRemove) {
        intentService.withdraw(intent);
        log.trace("Intent Synchronizer: withdrawing intent: {}", intent);
    }
    if (!isElectedLeader) {
        log.debug("Intent Synchronizer: cannot withdraw intents: " + "not elected leader anymore");
        isActivatedLeader = false;
        return;
    }
    // Add Intents
    for (Intent intent : intentsToAdd) {
        intentService.submit(intent);
        log.trace("Intent Synchronizer: submitting intent: {}", intent);
    }
    if (!isElectedLeader) {
        log.debug("Intent Synchronizer: cannot submit intents: " + "not elected leader anymore");
        isActivatedLeader = false;
        return;
    }
    if (isElectedLeader) {
        // Allow push of Intents
        isActivatedLeader = true;
    } else {
        isActivatedLeader = false;
    }
    log.debug("Intent synchronization completed");
}
#method_after
private void synchronizeIntents() {
    Map<Key, Intent> serviceIntents = new HashMap<>();
    intentService.getIntents().forEach(i -> {
        if (i.appId().equals(appId)) {
            serviceIntents.put(i.key(), i);
        }
    });
    List<Intent> intentsToAdd = new LinkedList<>();
    List<Intent> intentsToRemove = new LinkedList<>();
    for (Intent localIntent : intents.values()) {
        Intent serviceIntent = serviceIntents.remove(localIntent.key());
        if (serviceIntent == null) {
            intentsToAdd.add(localIntent);
        } else {
            IntentState state = intentService.getIntentState(serviceIntent.key());
            if (!IntentUtils.intentsAreEqual(serviceIntent, localIntent) || state == null || state == IntentState.WITHDRAW_REQ || state == IntentState.WITHDRAWING || state == IntentState.WITHDRAWN) {
                intentsToAdd.add(localIntent);
            }
        }
    }
    for (Intent serviceIntent : serviceIntents.values()) {
        IntentState state = intentService.getIntentState(serviceIntent.key());
        if (state != null && state != IntentState.WITHDRAW_REQ && state != IntentState.WITHDRAWING && state != IntentState.WITHDRAWN) {
            intentsToRemove.add(serviceIntent);
        }
    }
    log.debug("Intent Synchronizer: submitting {}, withdrawing {}", intentsToAdd.size(), intentsToRemove.size());
    // Withdraw Intents
    for (Intent intent : intentsToRemove) {
        intentService.withdraw(intent);
        log.trace("Intent Synchronizer: withdrawing intent: {}", intent);
    }
    if (!isElectedLeader) {
        log.debug("Intent Synchronizer: cannot withdraw intents: " + "not elected leader anymore");
        isActivatedLeader = false;
        return;
    }
    // Add Intents
    for (Intent intent : intentsToAdd) {
        intentService.submit(intent);
        log.trace("Intent Synchronizer: submitting intent: {}", intent);
    }
    if (!isElectedLeader) {
        log.debug("Intent Synchronizer: cannot submit intents: " + "not elected leader anymore");
        isActivatedLeader = false;
        return;
    }
    if (isElectedLeader) {
        // Allow push of Intents
        isActivatedLeader = true;
    } else {
        isActivatedLeader = false;
    }
    log.debug("Intent synchronization completed");
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}")
public Response getGroupsByDeviceId(@PathParam("deviceId") String deviceId) {
    final Iterable<Group> groups = groupService.getGroups(DeviceId.deviceId(deviceId));
    if (!groups.iterator().hasNext()) {
        throw new ItemNotFoundException(GROUP_NOT_FOUND);
    }
    groups.forEach(group -> groupsNode.add(codec(Group.class).encode(group, this)));
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}")
public Response getGroupsByDeviceId(@PathParam("deviceId") String deviceId) {
    final Iterable<Group> groups = groupService.getGroups(DeviceId.deviceId(deviceId));
    groups.forEach(group -> groupsNode.add(codec(Group.class).encode(group, this)));
    return ok(root).build();
}
#end_block

#method_before
@Override
public Group decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    final JsonCodec<GroupBucket> groupBucketCodec = context.codec(GroupBucket.class);
    CoreService coreService = context.getService(CoreService.class);
    // parse group id
    int groupIdInt = nullIsIllegal(json.get(GROUP_ID), GROUP_ID + MISSING_MEMBER_MESSAGE).asInt();
    GroupId groupId = new DefaultGroupId((short) groupIdInt);
    // parse group key (appCookie)
    String groupKeyStr = nullIsIllegal(json.get(APP_COOKIE), APP_COOKIE + MISSING_MEMBER_MESSAGE).asText();
    GroupKey groupKey = new DefaultGroupKey(groupKeyStr.getBytes());
    // parse device id
    DeviceId deviceId = DeviceId.deviceId(nullIsIllegal(json.get(DEVICE_ID), DEVICE_ID + MISSING_MEMBER_MESSAGE).asText());
    // application id
    ApplicationId appId = coreService.registerApplication(REST_APP_ID);
    // parse group type
    String type = nullIsIllegal(json.get(TYPE), TYPE + MISSING_MEMBER_MESSAGE).asText();
    GroupDescription.Type groupType;
    switch(type) {
        case "SELECT":
            groupType = Group.Type.SELECT;
            break;
        case "INDIRECT":
            groupType = Group.Type.INDIRECT;
            break;
        case "ALL":
            groupType = Group.Type.ALL;
            break;
        case "FAILOVER":
            groupType = Group.Type.FAILOVER;
            break;
        default:
            groupType = Group.Type.ALL;
    }
    // parse group buckets
    // TODO: make sure that INDIRECT group only has one bucket
    GroupBuckets buckets = null;
    List<GroupBucket> groupBucketList = new ArrayList<>();
    JsonNode bucketsJson = json.get(BUCKETS);
    checkNotNull(bucketsJson);
    if (bucketsJson != null) {
        IntStream.range(0, bucketsJson.size()).forEach(i -> {
            ObjectNode bucketJson = get(bucketsJson, i);
            bucketJson.put("type", type);
            groupBucketList.add(groupBucketCodec.decode(bucketJson, context));
        });
        buckets = new GroupBuckets(groupBucketList);
    }
    GroupDescription groupDescription = new DefaultGroupDescription(deviceId, groupType, buckets, groupKey, groupIdInt, appId);
    return new DefaultGroup(groupId, groupDescription);
}
#method_after
@Override
public Group decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    final JsonCodec<GroupBucket> groupBucketCodec = context.codec(GroupBucket.class);
    CoreService coreService = context.getService(CoreService.class);
    // parse group id
    int groupIdInt = nullIsIllegal(json.get(GROUP_ID), GROUP_ID + MISSING_MEMBER_MESSAGE).asInt();
    GroupId groupId = new DefaultGroupId((short) groupIdInt);
    // parse group key (appCookie)
    String groupKeyStr = nullIsIllegal(json.get(APP_COOKIE), APP_COOKIE + MISSING_MEMBER_MESSAGE).asText();
    GroupKey groupKey = new DefaultGroupKey(groupKeyStr.getBytes());
    // parse device id
    DeviceId deviceId = DeviceId.deviceId(nullIsIllegal(json.get(DEVICE_ID), DEVICE_ID + MISSING_MEMBER_MESSAGE).asText());
    // application id
    ApplicationId appId = coreService.registerApplication(REST_APP_ID);
    // parse group type
    String type = nullIsIllegal(json.get(TYPE), TYPE + MISSING_MEMBER_MESSAGE).asText();
    GroupDescription.Type groupType = null;
    switch(type) {
        case "SELECT":
            groupType = Group.Type.SELECT;
            break;
        case "INDIRECT":
            groupType = Group.Type.INDIRECT;
            break;
        case "ALL":
            groupType = Group.Type.ALL;
            break;
        case "FAILOVER":
            groupType = Group.Type.FAILOVER;
            break;
        default:
            log.warn("The requested type {} is not defined for group.", type);
            return null;
    }
    // parse group buckets
    // TODO: make sure that INDIRECT group only has one bucket
    GroupBuckets buckets = null;
    List<GroupBucket> groupBucketList = new ArrayList<>();
    JsonNode bucketsJson = json.get(BUCKETS);
    checkNotNull(bucketsJson);
    if (bucketsJson != null) {
        IntStream.range(0, bucketsJson.size()).forEach(i -> {
            ObjectNode bucketJson = get(bucketsJson, i);
            bucketJson.put("type", type);
            groupBucketList.add(groupBucketCodec.decode(bucketJson, context));
        });
        buckets = new GroupBuckets(groupBucketList);
    }
    GroupDescription groupDescription = new DefaultGroupDescription(deviceId, groupType, buckets, groupKey, groupIdInt, appId);
    return new DefaultGroup(groupId, groupDescription);
}
#end_block

#method_before
public static SortedSet<OchSignal> toFlexGrid(OchSignal ochSignal) {
    checkArgument(ochSignal.gridType() != GridType.FLEX);
    checkArgument(ochSignal.channelSpacing() != ChannelSpacing.CHL_6P25GHZ);
    checkArgument(FIXED_GRID_SLOT_GRANULARITIES.contains(ochSignal.slotGranularity()));
    int startMultiplier = (int) (1 - ochSignal.slotGranularity() + ochSignal.spacingMultiplier() * ochSignal.channelSpacing().frequency().asHz() / ChannelSpacing.CHL_6P25GHZ.frequency().asHz());
    Supplier<SortedSet<OchSignal>> supplier = () -> new TreeSet<>(new DefaultOchSignalComparator());
    return IntStream.range(0, ochSignal.slotGranularity()).mapToObj(i -> new OchSignal(GridType.FLEX, ChannelSpacing.CHL_6P25GHZ, startMultiplier + 2 * i, 1)).collect(Collectors.toCollection(supplier));
}
#method_after
public static SortedSet<OchSignal> toFlexGrid(OchSignal ochSignal) {
    checkArgument(ochSignal.gridType() != GridType.FLEX);
    checkArgument(ochSignal.channelSpacing() != ChannelSpacing.CHL_6P25GHZ);
    checkArgument(FIXED_GRID_SLOT_GRANULARITIES.contains(ochSignal.slotGranularity()));
    int startMultiplier = (int) (1 - ochSignal.slotGranularity() + ochSignal.spacingMultiplier() * ochSignal.channelSpacing().frequency().asHz() / ChannelSpacing.CHL_6P25GHZ.frequency().asHz());
    return IntStream.range(0, ochSignal.slotGranularity()).mapToObj(i -> new OchSignal(GridType.FLEX, ChannelSpacing.CHL_6P25GHZ, startMultiplier + 2 * i, 1)).collect(Collectors.toCollection(DefaultOchSignalComparator::newOchSignalTreeSet));
}
#end_block

#method_before
public static OchSignal toFixedGrid(List<OchSignal> lambdas, ChannelSpacing spacing) {
    // Number of slots of 12.5 GHz that fit into requested spacing
    int ratio = (int) (spacing.frequency().asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz());
    checkArgument(lambdas.size() == ratio);
    lambdas.forEach(x -> checkArgument(x.gridType() == GridType.FLEX));
    lambdas.forEach(x -> checkArgument(x.channelSpacing() == ChannelSpacing.CHL_6P25GHZ));
    lambdas.forEach(x -> checkArgument(x.slotGranularity() == 1));
    // Consecutive lambdas (multiplier increments by 2 because spacing is 6.25 GHz but slot width is 12.5 GHz)
    IntStream.range(1, lambdas.size()).forEach(i -> checkArgument(lambdas.get(i).spacingMultiplier() == lambdas.get(i - 1).spacingMultiplier() + 2));
    // Is center frequency compatible with requested spacing
    Frequency center = lambdas.get(ratio / 2).centralFrequency().subtract(ChannelSpacing.CHL_6P25GHZ.frequency());
    checkArgument(Spectrum.CENTER_FREQUENCY.subtract(center).asHz() % spacing.frequency().asHz() == 0);
    // Multiplier sits in middle of given lambdas, then convert from 6.25 to requested spacing
    int spacingMultiplier = (lambdas.get(ratio / 2).spacingMultiplier() + 1) / (ratio * 2);
    return new OchSignal(GridType.DWDM, spacing, spacingMultiplier, lambdas.size());
}
#method_after
public static OchSignal toFixedGrid(List<OchSignal> lambdas, ChannelSpacing spacing) {
    // Number of slots of 12.5 GHz that fit into requested spacing
    int ratio = (int) (spacing.frequency().asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz());
    checkArgument(lambdas.size() == ratio);
    lambdas.forEach(x -> checkArgument(x.gridType() == GridType.FLEX));
    lambdas.forEach(x -> checkArgument(x.channelSpacing() == ChannelSpacing.CHL_6P25GHZ));
    lambdas.forEach(x -> checkArgument(x.slotGranularity() == 1));
    // Consecutive lambdas (multiplier increments by 2 because spacing is 6.25 GHz but slot width is 12.5 GHz)
    IntStream.range(1, lambdas.size()).forEach(i -> checkArgument(lambdas.get(i).spacingMultiplier() == lambdas.get(i - 1).spacingMultiplier() + 2));
    // Is center frequency compatible with requested spacing
    Frequency center = lambdas.get(ratio / 2).centralFrequency().subtract(ChannelSpacing.CHL_6P25GHZ.frequency());
    checkArgument(Spectrum.CENTER_FREQUENCY.subtract(center).asHz() % spacing.frequency().asHz() == 0);
    // Multiplier sits in middle of given lambdas, then convert from 6.25 to requested spacing
    int spacingMultiplier = lambdas.stream().mapToInt(OchSignal::spacingMultiplier).sum() / lambdas.size() / (int) (spacing.frequency().asHz() / CHL_6P25GHZ.frequency().asHz());
    return new OchSignal(GridType.DWDM, spacing, spacingMultiplier, lambdas.size());
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("%s { %s, center:%.1f%+d*%.5fTHz, width:%.1fGHz }", this.getClass().getSimpleName(), gridType.name(), (double) Spectrum.CENTER_FREQUENCY.asHz() / Frequency.ofTHz(1).asHz(), spacingMultiplier, (double) slotGranularity * channelSpacing.frequency().asHz() / Frequency.ofTHz(1).asHz(), (double) slotGranularity * ChannelSpacing.CHL_12P5GHZ.frequency().asHz() / Frequency.ofGHz(1).asHz());
}
#method_after
@Override
public String toString() {
    return String.format("%s{%+d×%.2fGHz ± %.2fGHz}", this.getClass().getSimpleName(), spacingMultiplier, (double) slotGranularity * channelSpacing.frequency().asHz() / Frequency.ofGHz(1).asHz(), (double) slotGranularity * ChannelSpacing.CHL_12P5GHZ.frequency().asHz() / Frequency.ofGHz(1).asHz() / 2.0);
}
#end_block

#method_before
public FlowEntry build(FlowEntryState... state) {
    FlowRule rule;
    switch(this.type) {
        case STAT:
            rule = DefaultFlowRule.builder().forDevice(DeviceId.deviceId(Dpid.uri(dpid))).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(stat.getPriority()).makeTemporary(stat.getIdleTimeout()).withCookie(stat.getCookie().getValue()).forTable(stat.getTableId().getValue()).build();
            return new DefaultFlowEntry(rule, FlowEntryState.ADDED, stat.getDurationSec(), stat.getPacketCount().getValue(), stat.getByteCount().getValue());
        case REMOVED:
            rule = DefaultFlowRule.builder().forDevice(DeviceId.deviceId(Dpid.uri(dpid))).withSelector(buildSelector()).withPriority(removed.getPriority()).makeTemporary(removed.getIdleTimeout()).withCookie(removed.getCookie().getValue()).forTable(removed.getTableId().getValue()).build();
            return new DefaultFlowEntry(rule, FlowEntryState.REMOVED, removed.getDurationSec(), removed.getPacketCount().getValue(), removed.getByteCount().getValue());
        case MOD:
            FlowEntryState flowState = state.length > 0 ? state[0] : FlowEntryState.FAILED;
            rule = DefaultFlowRule.builder().forDevice(DeviceId.deviceId(Dpid.uri(dpid))).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(flowMod.getPriority()).makeTemporary(flowMod.getIdleTimeout()).withCookie(flowMod.getCookie().getValue()).forTable(flowMod.getTableId().getValue()).build();
            return new DefaultFlowEntry(rule, flowState, 0, 0, 0);
        default:
            log.error("Unknown flow type : {}", this.type);
            return null;
    }
}
#method_after
public FlowEntry build(FlowEntryState... state) {
    FlowRule.Builder builder;
    try {
        switch(this.type) {
            case STAT:
                builder = DefaultFlowRule.builder().forDevice(DeviceId.deviceId(Dpid.uri(dpid))).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(stat.getPriority()).makeTemporary(stat.getIdleTimeout()).withCookie(stat.getCookie().getValue()).forTable(stat.getTableId().getValue());
                return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, stat.getDurationSec(), stat.getPacketCount().getValue(), stat.getByteCount().getValue());
            case REMOVED:
                builder = DefaultFlowRule.builder().forDevice(DeviceId.deviceId(Dpid.uri(dpid))).withSelector(buildSelector()).withPriority(removed.getPriority()).makeTemporary(removed.getIdleTimeout()).withCookie(removed.getCookie().getValue());
                if (removed.getVersion() != OFVersion.OF_10) {
                    builder.forTable(removed.getTableId().getValue());
                }
                return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, removed.getDurationSec(), removed.getPacketCount().getValue(), removed.getByteCount().getValue());
            case MOD:
                FlowEntryState flowState = state.length > 0 ? state[0] : FlowEntryState.FAILED;
                builder = DefaultFlowRule.builder().forDevice(DeviceId.deviceId(Dpid.uri(dpid))).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(flowMod.getPriority()).makeTemporary(flowMod.getIdleTimeout()).withCookie(flowMod.getCookie().getValue());
                if (flowMod.getVersion() != OFVersion.OF_10) {
                    builder.forTable(flowMod.getTableId().getValue());
                }
                return new DefaultFlowEntry(builder.build(), flowState, 0, 0, 0);
            default:
                log.error("Unknown flow type : {}", this.type);
                return null;
        }
    } catch (UnsupportedOperationException e) {
        log.warn("Error building flow entry", e);
        return null;
    }
}
#end_block

#method_before
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SHA_TO_THA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST.type())) {
        MoveExtensionTreatment mov = (MoveExtensionTreatment) extensionTreatment;
        OFActionNiciraMove.Builder action = factory.actions().buildNiciraMove();
        action.setDstOfs(mov.dstOffset());
        action.setSrcOfs(mov.srcOffset());
        action.setNBits(mov.nBits());
        action.setSrc(mov.src());
        action.setDst(mov.dst());
        return action.build();
    }
    return null;
}
#method_after
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        NiciraResubmit resubmit = (NiciraResubmit) extensionTreatment;
        return factory.actions().niciraResubmit((int) resubmit.inPort().toLong(), resubmit.table());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        NiciraResubmitTable resubmitTable = (NiciraResubmitTable) extensionTreatment;
        return factory.actions().niciraResubmitTable((int) resubmitTable.inPort().toLong(), resubmitTable.table());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        NiciraSetNshSpi niciraNshSpi = (NiciraSetNshSpi) extensionTreatment;
        return factory.actions().niciraSetNsp(niciraNshSpi.nshSpi().servicePathId());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
        NiciraSetNshSi niciraNshSi = (NiciraSetNshSi) extensionTreatment;
        return factory.actions().niciraSetNsp(niciraNshSi.nshSi().serviceIndex());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().niciraSetNshc1(niciraNshch.nshCh().nshContextHeader());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().niciraSetNshc2(niciraNshch.nshCh().nshContextHeader());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().niciraSetNshc3(niciraNshch.nshCh().nshContextHeader());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().niciraSetNshc4(niciraNshch.nshCh().nshContextHeader());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SHA_TO_THA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST.type())) {
        MoveExtensionTreatment mov = (MoveExtensionTreatment) extensionTreatment;
        OFActionNiciraMove.Builder action = factory.actions().buildNiciraMove();
        action.setDstOfs(mov.dstOffset());
        action.setSrcOfs(mov.srcOffset());
        action.setNBits(mov.nBits());
        action.setSrc(mov.src());
        action.setDst(mov.dst());
        return action.build();
    }
    return null;
}
#end_block

#method_before
@Override
public ExtensionTreatment mapAction(OFAction action) {
    if (action.getType().equals(OFActionType.SET_FIELD)) {
        OFActionSetField setFieldAction = (OFActionSetField) action;
        OFOxm<?> oxm = setFieldAction.getField();
        switch(oxm.getMatchField().id) {
            case TUNNEL_IPV4_DST:
                OFOxmTunnelIpv4Dst tunnelIpv4Dst = (OFOxmTunnelIpv4Dst) oxm;
                return new NiciraSetTunnelDst(Ip4Address.valueOf(tunnelIpv4Dst.getValue().getInt()));
            default:
                throw new UnsupportedOperationException("Driver does not support extension type " + oxm.getMatchField().id);
        }
    }
    if (action.getType().equals(OFActionType.EXPERIMENTER)) {
        OFActionExperimenter experimenter = (OFActionExperimenter) action;
        switch(Long.valueOf(experimenter.getExperimenter()).intValue()) {
            case 0x2320:
                OFActionNicira nicira = (OFActionNicira) experimenter;
                switch(nicira.getSubtype()) {
                    case 6:
                        OFActionNiciraMove moveAction = (OFActionNiciraMove) nicira;
                        switch(Long.valueOf(moveAction.getSrc()).intValue()) {
                            case 0x00012206:
                                return NiciraMoveTreatmentFactory.createNiciraMovArpShaToTha();
                            case 0x00000406:
                                return NiciraMoveTreatmentFactory.createNiciraMovEthSrcToDst();
                            case 0x00000e04:
                                return NiciraMoveTreatmentFactory.createNiciraMovIpSrcToDst();
                            case 0x00002004:
                                return NiciraMoveTreatmentFactory.createNiciraMovArpSpaToTpa();
                            default:
                                throw new UnsupportedOperationException("Driver does not support move from " + moveAction.getSrc() + " to " + moveAction.getDst());
                        }
                    default:
                        throw new UnsupportedOperationException("Driver does not support extension type " + experimenter.getExperimenter() + " and subtype " + nicira.getSubtype());
                }
            default:
                throw new UnsupportedOperationException("Driver does not support extension type " + experimenter.getExperimenter());
        }
    }
    return null;
}
#method_after
@Override
public ExtensionTreatment mapAction(OFAction action) {
    if (action.getType().equals(OFActionType.SET_FIELD)) {
        OFActionSetField setFieldAction = (OFActionSetField) action;
        OFOxm<?> oxm = setFieldAction.getField();
        switch(oxm.getMatchField().id) {
            case TUNNEL_IPV4_DST:
                OFOxmTunnelIpv4Dst tunnelIpv4Dst = (OFOxmTunnelIpv4Dst) oxm;
                return new NiciraSetTunnelDst(Ip4Address.valueOf(tunnelIpv4Dst.getValue().getInt()));
            default:
                throw new UnsupportedOperationException("Driver does not support extension type " + oxm.getMatchField().id);
        }
    }
    if (action.getType().equals(OFActionType.EXPERIMENTER)) {
        OFActionExperimenter experimenter = (OFActionExperimenter) action;
        if (Long.valueOf(experimenter.getExperimenter()).intValue() == TYPE_NICIRA) {
            OFActionNicira nicira = (OFActionNicira) experimenter;
            if (nicira.getSubtype() == SUB_TYPE_MOVE) {
                OFActionNiciraMove moveAction = (OFActionNiciraMove) nicira;
                switch(Long.valueOf(moveAction.getSrc()).intValue()) {
                    case SRC_ARP_SHA:
                        return NiciraMoveTreatmentFactory.createNiciraMovArpShaToTha();
                    case SRC_ETH:
                        return NiciraMoveTreatmentFactory.createNiciraMovEthSrcToDst();
                    case SRC_IP:
                        return NiciraMoveTreatmentFactory.createNiciraMovIpSrcToDst();
                    case SRC_ARP_SPA:
                        return NiciraMoveTreatmentFactory.createNiciraMovArpSpaToTpa();
                    default:
                        throw new UnsupportedOperationException("Driver does not support move from " + moveAction.getSrc() + " to " + moveAction.getDst());
                }
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public SortedSet<OchSignal> queryLambdas(PortNumber port) {
    // S160 data sheet
    // Wavelength range: 1260 - 1630 nm
    long startSpacingMultiplier = Spectrum.U_BAND_MIN.subtract(Spectrum.CENTER_FREQUENCY).asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz();
    long stopSpacingMultiplier = Spectrum.O_BAND_MAX.subtract(Spectrum.CENTER_FREQUENCY).asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz();
    List<OchSignal> lambdas = IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).mapToObj(x -> new OchSignal(GridType.FLEX, ChannelSpacing.CHL_6P25GHZ, x, 1)).collect(Collectors.toList());
    SortedSet<OchSignal> result = new TreeSet<>(new DefaultOchSignalComparator());
    result.addAll(lambdas);
    return result;
}
#method_after
@Override
public SortedSet<OchSignal> queryLambdas(PortNumber port) {
    // S160 data sheet
    // Wavelength range: 1260 - 1630 nm
    long startSpacingMultiplier = Spectrum.U_BAND_MIN.subtract(Spectrum.CENTER_FREQUENCY).asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz();
    long stopSpacingMultiplier = Spectrum.O_BAND_MAX.subtract(Spectrum.CENTER_FREQUENCY).asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz();
    Supplier<SortedSet<OchSignal>> supplier = () -> new TreeSet<>(new DefaultOchSignalComparator());
    // Only consider odd values for the multiplier (for easy mapping to fixed grid)
    return IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).filter(i -> i % 2 == 1).mapToObj(i -> new OchSignal(GridType.FLEX, ChannelSpacing.CHL_6P25GHZ, i, 1)).collect(Collectors.toCollection(supplier));
}
#end_block

#method_before
private void registerPortResource(Device device, Port port) {
    ResourcePath portPath = ResourcePath.discrete(device.id(), port.number());
    executor.submit(() -> {
        adminService.registerResources(portPath);
        // for VLAN IDs
        if (isVlanEnabled(device.id(), port.number())) {
            adminService.registerResources(Lists.transform(ENTIRE_VLAN_IDS, portPath::child));
        }
        // for MPLS labels
        if (isMplsEnabled(device.id(), port.number())) {
            adminService.registerResources(Lists.transform(ENTIRE_MPLS_LABELS, portPath::child));
        }
        // for Lambdas
        SortedSet<OchSignal> lambdas = queryLambdas(device.id(), port.number());
        // convert lambdas to flex grid layout
        if (!lambdas.isEmpty()) {
            adminService.registerResources(lambdas.stream().map(portPath::child).collect(Collectors.toList()));
        }
        // TODO: need to define Behaviour to make a query about OCh port
        switch(port.type()) {
            case OCH:
                // register ODU TributarySlots against the OCH port
                registerTributarySlotsResources(((OchPort) port).signalType(), portPath);
                break;
            default:
                break;
        }
    });
}
#method_after
private void registerPortResource(Device device, Port port) {
    ResourcePath portPath = ResourcePath.discrete(device.id(), port.number());
    executor.submit(() -> {
        adminService.registerResources(portPath);
        // for VLAN IDs
        if (isVlanEnabled(device.id(), port.number())) {
            adminService.registerResources(Lists.transform(ENTIRE_VLAN_IDS, portPath::child));
        }
        // for MPLS labels
        if (isMplsEnabled(device.id(), port.number())) {
            adminService.registerResources(Lists.transform(ENTIRE_MPLS_LABELS, portPath::child));
        }
        // for Lambdas
        SortedSet<OchSignal> lambdas = queryLambdas(device.id(), port.number());
        if (!lambdas.isEmpty()) {
            adminService.registerResources(lambdas.stream().map(portPath::child).collect(Collectors.toList()));
        }
        // TODO: need to define Behaviour to make a query about OCh port
        switch(port.type()) {
            case OCH:
                // register ODU TributarySlots against the OCH port
                registerTributarySlotsResources(((OchPort) port).signalType(), portPath);
                break;
            default:
                break;
        }
    });
}
#end_block

#method_before
private List<OchSignal> findFirstLambda(Set<OchSignal> lambdas, int count) {
    // Sort available lambdas
    List<OchSignal> lambdaList = new ArrayList<>(lambdas);
    lambdaList.sort(new DefaultOchSignalComparator());
    // Look ahead by count and ensure spacing multiplier is as expected (i.e., no gaps)
    for (int i = 0; i < lambdaList.size() - count; i++) {
        if (lambdaList.get(i).spacingMultiplier() + 2 * count == lambdaList.get(i + count).spacingMultiplier()) {
            final int index = i;
            return IntStream.range(0, count).mapToObj(j -> lambdaList.get(index + j)).collect(Collectors.toList());
        }
    }
    return Collections.emptyList();
}
#method_after
private List<OchSignal> findFirstLambda(Set<OchSignal> lambdas, int count) {
    // Sort available lambdas
    List<OchSignal> lambdaList = new ArrayList<>(lambdas);
    lambdaList.sort(new DefaultOchSignalComparator());
    // Look ahead by count and ensure spacing multiplier is as expected (i.e., no gaps)
    for (int i = 0; i < lambdaList.size() - count; i++) {
        if (lambdaList.get(i).spacingMultiplier() + 2 * count == lambdaList.get(i + count).spacingMultiplier()) {
            return lambdaList.subList(i, i + count);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
public static OchSignal toFixedGrid(List<OchSignal> lambdas, ChannelSpacing spacing) {
    // Number of slots of 12.5 GHz that fit into requested spacing
    int ratio = (int) (spacing.frequency().asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz());
    checkArgument(lambdas.size() == ratio);
    lambdas.forEach(x -> checkArgument(x.gridType() == GridType.FLEX));
    lambdas.forEach(x -> checkArgument(x.channelSpacing() == ChannelSpacing.CHL_6P25GHZ));
    lambdas.forEach(x -> checkArgument(x.slotGranularity() == 1));
    // Consecutive lambdas (multiplier increments by 2 because spacing is 6.25 GHz but slot width is 12.5 GHz)
    IntStream.range(1, lambdas.size()).forEach(i -> checkArgument(lambdas.get(i).spacingMultiplier() == lambdas.get(i - 1).spacingMultiplier() + 2));
    // Is center frequency compatible with requested spacing
    Frequency center = ChannelSpacing.CHL_6P25GHZ.frequency().subtract(lambdas.get(ratio / 2).centralFrequency());
    checkArgument(Spectrum.CENTER_FREQUENCY.subtract(center).asHz() % spacing.frequency().asHz() == 0);
    // Multiplier sits in middle of given lambdas, then convert from 6.25 to requested spacing
    int spacingMultiplier = (lambdas.get(ratio / 2).spacingMultiplier() + 1) / (ratio * 2);
    return new OchSignal(GridType.DWDM, spacing, spacingMultiplier, lambdas.size());
}
#method_after
public static OchSignal toFixedGrid(List<OchSignal> lambdas, ChannelSpacing spacing) {
    // Number of slots of 12.5 GHz that fit into requested spacing
    int ratio = (int) (spacing.frequency().asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz());
    checkArgument(lambdas.size() == ratio);
    lambdas.forEach(x -> checkArgument(x.gridType() == GridType.FLEX));
    lambdas.forEach(x -> checkArgument(x.channelSpacing() == ChannelSpacing.CHL_6P25GHZ));
    lambdas.forEach(x -> checkArgument(x.slotGranularity() == 1));
    // Consecutive lambdas (multiplier increments by 2 because spacing is 6.25 GHz but slot width is 12.5 GHz)
    IntStream.range(1, lambdas.size()).forEach(i -> checkArgument(lambdas.get(i).spacingMultiplier() == lambdas.get(i - 1).spacingMultiplier() + 2));
    // Is center frequency compatible with requested spacing
    Frequency center = lambdas.get(ratio / 2).centralFrequency().subtract(ChannelSpacing.CHL_6P25GHZ.frequency());
    checkArgument(Spectrum.CENTER_FREQUENCY.subtract(center).asHz() % spacing.frequency().asHz() == 0);
    // Multiplier sits in middle of given lambdas, then convert from 6.25 to requested spacing
    int spacingMultiplier = (lambdas.get(ratio / 2).spacingMultiplier() + 1) / (ratio * 2);
    return new OchSignal(GridType.DWDM, spacing, spacingMultiplier, lambdas.size());
}
#end_block

#method_before
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    int forTableId = -1;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip());
        forTableId = UNICAST_ROUTING_TABLE;
        log.debug("processing IPv4 specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
    }
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    boolean popMpls = false;
    if (fwd.treatment() != null) {
        for (Instruction i : fwd.treatment().allInstructions()) {
            tb.add(i);
            if (i instanceof L2ModificationInstruction && ((L2ModificationInstruction) i).subtype() == L2SubType.MPLS_POP) {
                popMpls = true;
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow " + "in this device {}", deviceId);
            // XXX We could convert to forwarding to a single-port, via a
            // MPLS interface, or a MPLS SWAP (with-same) but that would
            // have to be handled in the next-objective. Also the pop-mpls
            // logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
        }
    }
    tb.transition(ACL_TABLE);
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    int forTableId = -1;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip());
        forTableId = UNICAST_ROUTING_TABLE;
        log.debug("processing IPv4 specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
    }
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    boolean popMpls = false;
    if (fwd.treatment() != null) {
        for (Instruction i : fwd.treatment().allInstructions()) {
            /*
                 * NOTE: OF-DPA does not support immediate instruction in
                 * L3 unicast and MPLS table.
                 */
            tb.deferred().add(i);
            if (i instanceof L2ModificationInstruction && ((L2ModificationInstruction) i).subtype() == L2SubType.MPLS_POP) {
                popMpls = true;
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow " + "in this device {}", deviceId);
            // XXX We could convert to forwarding to a single-port, via a
            // MPLS interface, or a MPLS SWAP (with-same) but that would
            // have to be handled in the next-objective. Also the pop-mpls
            // logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
        }
    }
    tb.transition(ACL_TABLE);
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
private GroupInfo createL2L3Chain(TrafficTreatment treatment, int nextId, ApplicationId appId, boolean mpls, TrafficSelector meta) {
    // for the l2interface group, get vlan and port info
    // for the outer group, get the src/dst mac, and vlan info
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    long portNum = 0;
    boolean setVlan = false, popVlan = false;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    outerTtb.setEthDst(((ModEtherInstruction) l2ins).mac());
                    break;
                case ETH_SRC:
                    outerTtb.setEthSrc(((ModEtherInstruction) l2ins).mac());
                    break;
                case VLAN_ID:
                    vlanid = ((ModVlanIdInstruction) l2ins).vlanId();
                    outerTtb.setVlanId(vlanid);
                    setVlan = true;
                    break;
                case VLAN_POP:
                    innerTtb.popVlan();
                    popVlan = true;
                    break;
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_POP:
                case MPLS_PUSH:
                case VLAN_PCP:
                case VLAN_PUSH:
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((OutputInstruction) ins).port().toLong();
            innerTtb.add(ins);
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives:  {}", ins.type());
        }
    }
    if (vlanid == null) {
        // use the vlanid associated with the port
        vlanid = port2Vlan.get(PortNumber.portNumber(portNum));
    }
    if (vlanid == null && meta != null) {
        // use metadata if available
        Criterion vidCriterion = meta.getCriterion(Type.VLAN_VID);
        if (vidCriterion != null) {
            vlanid = ((VlanIdCriterion) vidCriterion).vlanId();
        }
    }
    if (vlanid == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return null;
    }
    if (!setVlan && !popVlan) {
        // untagged outgoing port
        TrafficTreatment.Builder temp = DefaultTrafficTreatment.builder();
        temp.popVlan();
        innerTtb.build().allInstructions().forEach(i -> temp.add(i));
        innerTtb = temp;
    }
    // assemble information for ofdpa l2interface group
    Integer l2groupId = L2INTERFACEMASK | (vlanid.toShort() << 16) | (int) portNum;
    // a globally unique groupkey that is different for ports in the same devices
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = 0x0ffffff & (deviceId.hashCode() << 8 | (int) portNum);
    final GroupKey l2groupkey = new DefaultGroupKey(appKryo.serialize(l2gk));
    // assemble information for outer group
    GroupDescription outerGrpDesc = null;
    if (mpls) {
        // outer group is MPLSInteface
        Integer mplsgroupId = MPLSINTERFACEMASK | (int) portNum;
        // using mplsinterfacemask in groupkey to differentiate from l2interface
        int mplsgk = MPLSINTERFACEMASK | (0x0ffffff & (deviceId.hashCode() << 8 | (int) portNum));
        final GroupKey mplsgroupkey = new DefaultGroupKey(appKryo.serialize(mplsgk));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the mpls-interface group description to wait for the
        // l2 interface group to be processed
        GroupBucket mplsinterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(mplsinterfaceGroupBucket)), mplsgroupkey, mplsgroupId, appId);
        log.debug("Trying MPLS-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(mplsgroupId), mplsgroupkey, nextId);
    } else {
        // outer group is L3Unicast
        Integer l3groupId = L3UNICASTMASK | (int) portNum;
        int l3gk = L3UNICASTMASK | (0x0ffffff & (deviceId.hashCode() << 8 | (int) portNum));
        final GroupKey l3groupkey = new DefaultGroupKey(appKryo.serialize(l3gk));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the l3unicast group description to wait for the
        // l2 interface group to be processed
        GroupBucket l3unicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3unicastGroupBucket)), l3groupkey, l3groupId, appId);
        log.debug("Trying L3Unicast: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextId);
    }
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(outerGrpDesc, 1, false);
    updatePendingGroups(l2groupkey, gce);
    // create group description for the inner l2interfacegroup
    GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(innerTtb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, appId);
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextId);
    return new GroupInfo(l2groupDescription, outerGrpDesc);
}
#method_after
private GroupInfo createL2L3Chain(TrafficTreatment treatment, int nextId, ApplicationId appId, boolean mpls, TrafficSelector meta) {
    // for the l2interface group, get vlan and port info
    // for the outer group, get the src/dst mac, and vlan info
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    long portNum = 0;
    boolean setVlan = false, popVlan = false;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    outerTtb.setEthDst(((ModEtherInstruction) l2ins).mac());
                    break;
                case ETH_SRC:
                    outerTtb.setEthSrc(((ModEtherInstruction) l2ins).mac());
                    break;
                case VLAN_ID:
                    vlanid = ((ModVlanIdInstruction) l2ins).vlanId();
                    outerTtb.setVlanId(vlanid);
                    setVlan = true;
                    break;
                case VLAN_POP:
                    innerTtb.popVlan();
                    popVlan = true;
                    break;
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_POP:
                case MPLS_PUSH:
                case VLAN_PCP:
                case VLAN_PUSH:
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((OutputInstruction) ins).port().toLong();
            innerTtb.add(ins);
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives:  {}", ins.type());
        }
    }
    if (vlanid == null && meta != null) {
        // use metadata if available
        Criterion vidCriterion = meta.getCriterion(Type.VLAN_VID);
        if (vidCriterion != null) {
            vlanid = ((VlanIdCriterion) vidCriterion).vlanId();
        }
        // if vlan is not set, use the vlan in metadata for outerTtb
        if (vlanid != null && !setVlan) {
            outerTtb.setVlanId(vlanid);
        }
    }
    if (vlanid == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return null;
    }
    if (!setVlan && !popVlan) {
        // untagged outgoing port
        TrafficTreatment.Builder temp = DefaultTrafficTreatment.builder();
        temp.popVlan();
        innerTtb.build().allInstructions().forEach(i -> temp.add(i));
        innerTtb = temp;
    }
    // assemble information for ofdpa l2interface group
    Integer l2groupId = L2INTERFACEMASK | (vlanid.toShort() << 16) | (int) portNum;
    // a globally unique groupkey that is different for ports in the same devices
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = 0x0ffffff & (deviceId.hashCode() << 8 | (int) portNum);
    final GroupKey l2groupkey = new DefaultGroupKey(appKryo.serialize(l2gk));
    // assemble information for outer group
    GroupDescription outerGrpDesc = null;
    if (mpls) {
        // outer group is MPLSInteface
        Integer mplsgroupId = MPLSINTERFACEMASK | (int) portNum;
        // using mplsinterfacemask in groupkey to differentiate from l2interface
        int mplsgk = MPLSINTERFACEMASK | (0x0ffffff & (deviceId.hashCode() << 8 | (int) portNum));
        final GroupKey mplsgroupkey = new DefaultGroupKey(appKryo.serialize(mplsgk));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the mpls-interface group description to wait for the
        // l2 interface group to be processed
        GroupBucket mplsinterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(mplsinterfaceGroupBucket)), mplsgroupkey, mplsgroupId, appId);
        log.debug("Trying MPLS-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(mplsgroupId), mplsgroupkey, nextId);
    } else {
        // outer group is L3Unicast
        Integer l3groupId = L3UNICASTMASK | (int) portNum;
        int l3gk = L3UNICASTMASK | (0x0ffffff & (deviceId.hashCode() << 8 | (int) portNum));
        final GroupKey l3groupkey = new DefaultGroupKey(appKryo.serialize(l3gk));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the l3unicast group description to wait for the
        // l2 interface group to be processed
        GroupBucket l3unicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3unicastGroupBucket)), l3groupkey, l3groupId, appId);
        log.debug("Trying L3Unicast: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextId);
    }
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(outerGrpDesc, 1, false);
    updatePendingGroups(l2groupkey, gce);
    // create group description for the inner l2interfacegroup
    GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(innerTtb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, appId);
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextId);
    return new GroupInfo(l2groupDescription, outerGrpDesc);
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if ((ethType == null) || (ethType.ethType().toShort() != Ethernet.TYPE_IPV4) && (ethType.ethType().toShort() != Ethernet.MPLS_UNICAST)) {
        log.warn("processSpecific: Unsupported forwarding objective criteria" + "ethType:{} in dev:{}", ethType, deviceId);
        fail(fwd, ObjectiveError.UNSUPPORTED);
        return Collections.emptySet();
    }
    int forTableId = -1;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip());
        forTableId = UNICAST_ROUTING_TABLE;
        log.debug("processing IPv4 specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
    }
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction i : fwd.treatment().allInstructions()) {
            tb.add(i);
        }
    }
    if (fwd.nextId() != null) {
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
        }
    }
    tb.transition(ACL_TABLE);
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if ((ethType == null) || (ethType.ethType().toShort() != Ethernet.TYPE_IPV4) && (ethType.ethType().toShort() != Ethernet.MPLS_UNICAST)) {
        log.warn("processSpecific: Unsupported forwarding objective criteria" + "ethType:{} in dev:{}", ethType, deviceId);
        fail(fwd, ObjectiveError.UNSUPPORTED);
        return Collections.emptySet();
    }
    int forTableId = -1;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip());
        forTableId = UNICAST_ROUTING_TABLE;
        log.debug("processing IPv4 specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
    }
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction i : fwd.treatment().allInstructions()) {
            /*
                 * NOTE: OF-DPA does not support immediate instruction in
                 * L3 unicast and MPLS table.
                 */
            tb.deferred().add(i);
        }
    }
    if (fwd.nextId() != null) {
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
        }
    }
    tb.transition(ACL_TABLE);
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
@Override
public FlowClassifier decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    FlowClassifier.Builder resultBuilder = new DefaultFlowClassifier.Builder();
    String flowClassifierId = nullIsIllegal(json.get(FLOW_CLASSIFIER_ID), FLOW_CLASSIFIER_ID + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setFlowClassifierId(FlowClassifierId.of(flowClassifierId));
    String tenantId = nullIsIllegal(json.get(TENANT_ID), TENANT_ID + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setTenantId(TenantId.tenantId(tenantId));
    String flowClassiferName = nullIsIllegal(json.get(NAME), NAME + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setName(flowClassiferName);
    String flowClassiferDescription = (json.get(DESCRIPTION)).asText();
    resultBuilder.setDescription(flowClassiferDescription);
    String etherType = nullIsIllegal(json.get(ETHER_TYPE), ETHER_TYPE + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setEtherType(etherType);
    if (json.get(PROTOCOL) != null && !(json.get(PROTOCOL)).asText().equals("null")) {
        String protocol = (json.get(PROTOCOL)).asText();
        resultBuilder.setProtocol(protocol);
    }
    int minSrcPortRange = (json.get(MIN_SRC_PORT_RANGE)).asInt();
    resultBuilder.setMinSrcPortRange(minSrcPortRange);
    int maxSrcPortRange = (json.get(MAX_SRC_PORT_RANGE)).asInt();
    resultBuilder.setMaxSrcPortRange(maxSrcPortRange);
    int minDstPortRange = (json.get(MIN_DST_PORT_RANGE)).asInt();
    resultBuilder.setMinDstPortRange(minDstPortRange);
    int maxDstPortRange = (json.get(MAX_DST_PORT_RANGE)).asInt();
    resultBuilder.setMaxDstPortRange(maxDstPortRange);
    String srcIpPrefix = (json.get(SRC_IP_PREFIX)).asText();
    if (!srcIpPrefix.isEmpty()) {
        resultBuilder.setSrcIpPrefix(IpPrefix.valueOf(srcIpPrefix));
    }
    String dstIpPrefix = (json.get(DST_IP_PREFIX)).asText();
    if (!dstIpPrefix.isEmpty()) {
        resultBuilder.setDstIpPrefix(IpPrefix.valueOf(dstIpPrefix));
    }
    if (json.get(SRC_PORT) != null && !(json.get(SRC_PORT)).asText().equals("null")) {
        String srcPort = (json.get(SRC_PORT)).asText();
        resultBuilder.setSrcPort(VirtualPortId.portId(srcPort));
    }
    if (json.get(DST_PORT) != null && !(json.get(DST_PORT)).asText().equals("null")) {
        String dstPort = (json.get(DST_PORT)).asText();
        resultBuilder.setDstPort(VirtualPortId.portId(dstPort));
    }
    return resultBuilder.build();
}
#method_after
@Override
public FlowClassifier decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    FlowClassifier.Builder resultBuilder = new DefaultFlowClassifier.Builder();
    String flowClassifierId = nullIsIllegal(json.get(FLOW_CLASSIFIER_ID), FLOW_CLASSIFIER_ID + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setFlowClassifierId(FlowClassifierId.of(flowClassifierId));
    String tenantId = nullIsIllegal(json.get(TENANT_ID), TENANT_ID + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setTenantId(TenantId.tenantId(tenantId));
    String flowClassiferName = nullIsIllegal(json.get(NAME), NAME + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setName(flowClassiferName);
    String flowClassiferDescription = (json.get(DESCRIPTION)).asText();
    resultBuilder.setDescription(flowClassiferDescription);
    String etherType = nullIsIllegal(json.get(ETHER_TYPE), ETHER_TYPE + MISSING_MEMBER_MESSAGE).asText();
    resultBuilder.setEtherType(etherType);
    if (json.get(PROTOCOL) != null && !(json.get(PROTOCOL)).asText().equals("null")) {
        String protocol = (json.get(PROTOCOL)).asText();
        resultBuilder.setProtocol(protocol);
    }
    int minSrcPortRange = (json.get(MIN_SRC_PORT_RANGE)).asInt();
    resultBuilder.setMinSrcPortRange(minSrcPortRange);
    int maxSrcPortRange = (json.get(MAX_SRC_PORT_RANGE)).asInt();
    resultBuilder.setMaxSrcPortRange(maxSrcPortRange);
    int minDstPortRange = (json.get(MIN_DST_PORT_RANGE)).asInt();
    resultBuilder.setMinDstPortRange(minDstPortRange);
    int maxDstPortRange = (json.get(MAX_DST_PORT_RANGE)).asInt();
    resultBuilder.setMaxDstPortRange(maxDstPortRange);
    if (json.get(SRC_IP_PREFIX) != null && !(json.get(SRC_IP_PREFIX)).asText().equals("null")) {
        String srcIpPrefix = (json.get(SRC_IP_PREFIX)).asText();
        resultBuilder.setSrcIpPrefix(IpPrefix.valueOf(srcIpPrefix));
    }
    if (json.get(DST_IP_PREFIX) != null && !(json.get(DST_IP_PREFIX)).asText().equals("null")) {
        String dstIpPrefix = (json.get(DST_IP_PREFIX)).asText();
        resultBuilder.setDstIpPrefix(IpPrefix.valueOf(dstIpPrefix));
    }
    if (json.get(SRC_PORT) != null && !(json.get(SRC_PORT)).asText().equals("null")) {
        String srcPort = (json.get(SRC_PORT)).asText();
        resultBuilder.setSrcPort(VirtualPortId.portId(srcPort));
    }
    if (json.get(DST_PORT) != null && !(json.get(DST_PORT)).asText().equals("null")) {
        String dstPort = (json.get(DST_PORT)).asText();
        resultBuilder.setDstPort(VirtualPortId.portId(dstPort));
    }
    return resultBuilder.build();
}
#end_block

#method_before
@Override
public ObjectNode encode(FlowClassifier flowClassifier, CodecContext context) {
    checkNotNull(flowClassifier, "flowClassifier cannot be null");
    ObjectNode result = context.mapper().createObjectNode();
    result.put(FLOW_CLASSIFIER_ID, flowClassifier.flowClassifierId().toString()).put(TENANT_ID, flowClassifier.tenantId().toString()).put(NAME, flowClassifier.name()).put(DESCRIPTION, flowClassifier.description()).put(ETHER_TYPE, flowClassifier.etherType()).put(PROTOCOL, flowClassifier.protocol()).put(MIN_SRC_PORT_RANGE, flowClassifier.minSrcPortRange()).put(MAX_SRC_PORT_RANGE, flowClassifier.maxSrcPortRange()).put(MIN_DST_PORT_RANGE, flowClassifier.minDstPortRange()).put(MAX_DST_PORT_RANGE, flowClassifier.maxDstPortRange()).put(SRC_IP_PREFIX, flowClassifier.srcIpPrefix().toString()).put(DST_IP_PREFIX, flowClassifier.dstIpPrefix().toString());
    if (flowClassifier.srcPort() != null) {
        result.put(SRC_PORT, flowClassifier.srcPort().toString());
    } else {
        result.put(SRC_PORT, "null");
    }
    if (flowClassifier.dstPort() != null) {
        result.put(DST_PORT, flowClassifier.dstPort().toString());
    } else {
        result.put(DST_PORT, "null");
    }
    return result;
}
#method_after
@Override
public ObjectNode encode(FlowClassifier flowClassifier, CodecContext context) {
    checkNotNull(flowClassifier, "flowClassifier cannot be null");
    ObjectNode result = context.mapper().createObjectNode();
    result.put(FLOW_CLASSIFIER_ID, flowClassifier.flowClassifierId().toString()).put(TENANT_ID, flowClassifier.tenantId().toString()).put(NAME, flowClassifier.name()).put(DESCRIPTION, flowClassifier.description()).put(ETHER_TYPE, flowClassifier.etherType()).put(PROTOCOL, flowClassifier.protocol()).put(MIN_SRC_PORT_RANGE, flowClassifier.minSrcPortRange()).put(MAX_SRC_PORT_RANGE, flowClassifier.maxSrcPortRange()).put(MIN_DST_PORT_RANGE, flowClassifier.minDstPortRange()).put(MAX_DST_PORT_RANGE, flowClassifier.maxDstPortRange());
    if (flowClassifier.srcIpPrefix() != null) {
        result.put(SRC_IP_PREFIX, flowClassifier.srcIpPrefix().toString());
    } else {
        result.put(SRC_IP_PREFIX, "null");
    }
    if (flowClassifier.dstIpPrefix() != null) {
        result.put(DST_IP_PREFIX, flowClassifier.dstIpPrefix().toString());
    } else {
        result.put(DST_IP_PREFIX, "null");
    }
    if (flowClassifier.srcPort() != null) {
        result.put(SRC_PORT, flowClassifier.srcPort().toString());
    } else {
        result.put(SRC_PORT, "null");
    }
    if (flowClassifier.dstPort() != null) {
        result.put(DST_PORT, flowClassifier.dstPort().toString());
    } else {
        result.put(DST_PORT, "null");
    }
    return result;
}
#end_block

#method_before
public TrafficTreatment.Builder packTrafficTreatment(DeviceId deviceId, MacAddress srcMacAddress, TpPort nshDstPort, DeviceId deviceIdfromFc, DeviceId deviceIdfromPp, NshServicePathId nshSPI, FlowClassifier flowClassifier) {
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    DriverHandler handler = driverService.createHandler(deviceId);
    ExtensionTreatmentResolver resolver = handler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment nspIdTreatment = resolver.getExtensionInstruction(NICIRA_SET_NSH_SPI.type());
    ExtensionTreatment nsiIdTreatment = resolver.getExtensionInstruction(NICIRA_SET_NSH_SI.type());
    treatmentBuilder.extension(nspIdTreatment, deviceId);
    treatmentBuilder.extension(nsiIdTreatment, deviceId);
    treatmentBuilder.setUdpDst(nshDstPort);
    try {
        nspIdTreatment.setPropertyValue("nshSpi", nshSPI);
    } catch (Exception e) {
        log.error("Failed to get extension instruction to set Nsh Spi Id {}", deviceId);
    }
    try {
        nsiIdTreatment.setPropertyValue("nshSi", NSH_SI_ID);
    } catch (Exception e) {
        log.error("Failed to get extension instruction to set Nsh Si Id {}", deviceId);
    }
    Host host = hostService.getHost(HostId.hostId(srcMacAddress));
    PortNumber port = host.location().port();
    if (deviceIdfromPp != null) {
        treatmentBuilder.setOutput(port);
    } else if (deviceIdfromFc != null) {
        treatmentBuilder.setVlanId((VlanId.vlanId(Short.parseShort((vtnRscService.getL3vni(flowClassifier.tenantId()).toString())))));
    }
    return treatmentBuilder;
}
#method_after
public TrafficTreatment.Builder packTrafficTreatment(DeviceId deviceId, MacAddress srcMacAddress, TpPort nshDstPort, DeviceId deviceIdfromFc, DeviceId deviceIdfromPp, NshServicePathId nshSPI, FlowClassifier flowClassifier) {
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    Host host = hostService.getHost(HostId.hostId(srcMacAddress));
    PortNumber port = host.location().port();
    if (deviceIdfromPp != null) {
        treatmentBuilder.setOutput(port);
    } else if (deviceIdfromFc != null) {
        treatmentBuilder.setVlanId((VlanId.vlanId(Short.parseShort((vtnRscService.getL3vni(flowClassifier.tenantId()).toString())))));
    }
    // Set NSH
    DriverHandler handler = driverService.createHandler(deviceId);
    ExtensionTreatmentResolver resolver = handler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment nspIdTreatment = resolver.getExtensionInstruction(NICIRA_SET_NSH_SPI.type());
    ExtensionTreatment nsiIdTreatment = resolver.getExtensionInstruction(NICIRA_SET_NSH_SI.type());
    treatmentBuilder.extension(nspIdTreatment, deviceId);
    treatmentBuilder.extension(nsiIdTreatment, deviceId);
    treatmentBuilder.setUdpDst(nshDstPort);
    try {
        nspIdTreatment.setPropertyValue("nshSpi", nshSPI);
    } catch (Exception e) {
        log.error("Failed to get extension instruction to set Nsh Spi Id {}", deviceId);
    }
    try {
        nsiIdTreatment.setPropertyValue("nshSi", NSH_SI_ID);
    } catch (Exception e) {
        log.error("Failed to get extension instruction to set Nsh Si Id {}", deviceId);
    }
    return treatmentBuilder;
}
#end_block

#method_before
public synchronized void addOrUpdateFlows(FlowEntry... flowEntries) {
    for (FlowEntry fe : flowEntries) {
        // check if this new rule is an update to an existing entry
        TypedStoredFlowEntry stored = deviceFlowTable.getFlowEntry(fe);
        if (stored != null) {
            // duplicated flow entry is collected!, just skip
            if (fe.bytes() == stored.bytes() && fe.packets() == stored.packets() && fe.life() == stored.life()) {
                log.debug("addOrUpdateFlows:, FlowId=" + Long.toHexString(fe.id().value()) + ",is DUPLICATED stats collection, just skip." + " AdaptiveStats collection thread for {}", sw.getStringId());
                // FIXME modification of "stored" flow entry outside of store
                stored.setLastSeen();
                continue;
            } else if (fe.life() < stored.life()) {
                // Invalid updates the stats values, i.e., bytes, packets, durations ...
                log.debug("addOrUpdateFlows():" + " Invalid Flow Update! The new life is SMALLER than the previous one, jus skip." + " new flowId=" + Long.toHexString(fe.id().value()) + ", old flowId=" + Long.toHexString(stored.id().value()) + ", new bytes=" + fe.bytes() + ", old bytes=" + stored.bytes() + ", new life=" + fe.life() + ", old life=" + stored.life() + ", new lastSeen=" + fe.lastSeen() + ", old lastSeen=" + stored.lastSeen());
                // go next
                // FIXME modification of "stored" flow entry outside of store
                stored.setLastSeen();
                continue;
            }
            // update now
            // FIXME modification of "stored" flow entry outside of store
            stored.setLife(fe.life());
            stored.setPackets(fe.packets());
            stored.setBytes(fe.bytes());
            stored.setLastSeen();
            if (stored.state() == FlowEntry.FlowEntryState.PENDING_ADD) {
                // flow is really RULE_ADDED
                stored.setState(FlowEntry.FlowEntryState.ADDED);
                // TODO remove log
                log.info("Setting rule state to added: {}", stored);
            }
            // deviceFlowTable.calAndSetFlowLiveType(stored);
            continue;
        }
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fe, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
}
#method_after
public synchronized void addOrUpdateFlows(FlowEntry... flowEntries) {
    for (FlowEntry fe : flowEntries) {
        // check if this new rule is an update to an existing entry
        TypedStoredFlowEntry stored = deviceFlowTable.getFlowEntry(fe);
        if (stored != null) {
            // duplicated flow entry is collected!, just skip
            if (fe.bytes() == stored.bytes() && fe.packets() == stored.packets() && fe.life() == stored.life()) {
                log.debug("addOrUpdateFlows:, FlowId=" + Long.toHexString(fe.id().value()) + ",is DUPLICATED stats collection, just skip." + " AdaptiveStats collection thread for {}", sw.getStringId());
                // FIXME modification of "stored" flow entry outside of store
                stored.setLastSeen();
                continue;
            } else if (fe.life() < stored.life()) {
                // Invalid updates the stats values, i.e., bytes, packets, durations ...
                log.debug("addOrUpdateFlows():" + " Invalid Flow Update! The new life is SMALLER than the previous one, jus skip." + " new flowId=" + Long.toHexString(fe.id().value()) + ", old flowId=" + Long.toHexString(stored.id().value()) + ", new bytes=" + fe.bytes() + ", old bytes=" + stored.bytes() + ", new life=" + fe.life() + ", old life=" + stored.life() + ", new lastSeen=" + fe.lastSeen() + ", old lastSeen=" + stored.lastSeen());
                // go next
                // FIXME modification of "stored" flow entry outside of store
                stored.setLastSeen();
                continue;
            }
            // update now
            // FIXME modification of "stored" flow entry outside of store
            stored.setLife(fe.life());
            stored.setPackets(fe.packets());
            stored.setBytes(fe.bytes());
            stored.setLastSeen();
            if (stored.state() == FlowEntry.FlowEntryState.PENDING_ADD) {
                // flow is really RULE_ADDED
                stored.setState(FlowEntry.FlowEntryState.ADDED);
            }
            // deviceFlowTable.calAndSetFlowLiveType(stored);
            continue;
        }
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fe, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
}
#end_block

#method_before
private Set<FlowRuleBatchEntry> updateStoreInternal(FlowRuleBatchOperation operation) {
    return operation.getOperations().stream().map(op -> {
        StoredFlowEntry entry;
        switch(op.operator()) {
            case ADD:
                entry = new DefaultFlowEntry(op.target());
                // always add requested FlowRule
                // Note: 2 equal FlowEntry may have different treatment
                flowTable.remove(entry.deviceId(), entry);
                flowTable.add(entry);
                return op;
            case REMOVE:
                entry = flowTable.getFlowEntry(op.target());
                if (entry != null) {
                    // FIXME modification of "stored" flow entry outside of flow table
                    entry.setState(FlowEntryState.PENDING_REMOVE);
                    log.info("setting state of rule to pending remove: {}", entry, new Throwable());
                    return op;
                }
                break;
            case MODIFY:
                // TODO: figure this out at some point
                break;
            default:
                log.warn("Unknown flow operation operator: {}", op.operator());
        }
        return null;
    }).filter(op -> op != null).collect(Collectors.toSet());
}
#method_after
private Set<FlowRuleBatchEntry> updateStoreInternal(FlowRuleBatchOperation operation) {
    return operation.getOperations().stream().map(op -> {
        StoredFlowEntry entry;
        switch(op.operator()) {
            case ADD:
                entry = new DefaultFlowEntry(op.target());
                // always add requested FlowRule
                // Note: 2 equal FlowEntry may have different treatment
                flowTable.remove(entry.deviceId(), entry);
                flowTable.add(entry);
                return op;
            case REMOVE:
                entry = flowTable.getFlowEntry(op.target());
                if (entry != null) {
                    // FIXME modification of "stored" flow entry outside of flow table
                    entry.setState(FlowEntryState.PENDING_REMOVE);
                    log.debug("Setting state of rule to pending remove: {}", entry);
                    return op;
                }
                break;
            case MODIFY:
                // TODO: figure this out at some point
                break;
            default:
                log.warn("Unknown flow operation operator: {}", op.operator());
        }
        return null;
    }).filter(op -> op != null).collect(Collectors.toSet());
}
#end_block

#method_before
public void add(FlowEntry rule) {
    getFlowEntriesInternal(rule.deviceId(), rule.id()).compute((StoredFlowEntry) rule, (k, stored) -> {
        // TODO the key is not updated
        return (StoredFlowEntry) rule;
    });
    // TODO remove log
    log.info("Rule added {}", rule);
    lastUpdateTimes.put(rule.deviceId(), System.currentTimeMillis());
}
#method_after
public void add(FlowEntry rule) {
    getFlowEntriesInternal(rule.deviceId(), rule.id()).compute((StoredFlowEntry) rule, (k, stored) -> {
        // TODO the key is not updated
        return (StoredFlowEntry) rule;
    });
    lastUpdateTimes.put(rule.deviceId(), System.currentTimeMillis());
}
#end_block

#method_before
public FlowEntry remove(DeviceId deviceId, FlowEntry rule) {
    final AtomicReference<FlowEntry> removedRule = new AtomicReference<>();
    getFlowEntriesInternal(rule.deviceId(), rule.id()).computeIfPresent((StoredFlowEntry) rule, (k, stored) -> {
        if (rule instanceof DefaultFlowEntry) {
            DefaultFlowEntry toRemove = (DefaultFlowEntry) rule;
            if (stored instanceof DefaultFlowEntry) {
                DefaultFlowEntry storedEntry = (DefaultFlowEntry) stored;
                if (toRemove.created() < storedEntry.created()) {
                    log.warn("Trying to remove more recent flow entry {} (stored: {})", toRemove, stored);
                    // the key is not updated, removedRule remains null
                    return stored;
                }
            } else {
                // TODO remove log
                log.warn("Stored rule is not a default flow entry {}", stored);
            }
        } else {
            // TODO remove log
            log.warn("Rule is not a default flow entry {}", rule);
        }
        removedRule.set(stored);
        return null;
    });
    if (removedRule.get() != null) {
        // TODO remove log
        log.info("Rule removed {}", rule);
        lastUpdateTimes.put(deviceId, System.currentTimeMillis());
        return removedRule.get();
    } else {
        log.warn("Failed to remove rule: {}", rule);
        return null;
    }
}
#method_after
public FlowEntry remove(DeviceId deviceId, FlowEntry rule) {
    final AtomicReference<FlowEntry> removedRule = new AtomicReference<>();
    getFlowEntriesInternal(rule.deviceId(), rule.id()).computeIfPresent((StoredFlowEntry) rule, (k, stored) -> {
        if (rule instanceof DefaultFlowEntry) {
            DefaultFlowEntry toRemove = (DefaultFlowEntry) rule;
            if (stored instanceof DefaultFlowEntry) {
                DefaultFlowEntry storedEntry = (DefaultFlowEntry) stored;
                if (toRemove.created() < storedEntry.created()) {
                    log.debug("Trying to remove more recent flow entry {} (stored: {})", toRemove, stored);
                    // the key is not updated, removedRule remains null
                    return stored;
                }
            }
        }
        removedRule.set(stored);
        return null;
    });
    if (removedRule.get() != null) {
        lastUpdateTimes.put(deviceId, System.currentTimeMillis());
        return removedRule.get();
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public void deletePort(String uuid) {
    OpenstackPort openstackPort = restHandler.getPorts().stream().filter(p -> p.id().equals(uuid)).findAny().orElse(null);
    if (openstackPort != null) {
        log.info("Found the information for the port removed...YEHH...");
    } else {
        log.error("No port information for the port removed.. :-( ");
    }
}
#method_after
@Override
public void deletePort(String uuid) {
}
#end_block

#method_before
private void processHostRemoved(Host host) {
    log.debug("host {} was removed", host.toString());
    if (!doNotPushFlows) {
        IpAddress hostIp = host.ipAddresses().stream().filter(ip -> ip.isIp4()).findAny().orElse(null);
        OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
        rulePopulator.removeSwitchingRules(host.location().deviceId(), hostIp.getIp4Address());
    }
    dhcpService.removeStaticMapping(host.mac());
}
#method_after
private void processHostRemoved(Host host) {
    log.debug("host {} was removed", host.toString());
    try {
        if (!doNotPushFlows) {
            IpAddress hostIp = host.ipAddresses().stream().filter(ip -> ip.isIp4()).findAny().orElse(null);
            OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
            rulePopulator.removeSwitchingRules(host.location().deviceId(), hostIp.getIp4Address());
        }
        dhcpService.removeStaticMapping(host.mac());
    } catch (NoSuchElementException e) {
        log.error("No IP address is assigned.");
    }
}
#end_block

#method_before
public void configureNetwork() {
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg == null) {
        log.error("There is no openstack server information in config.");
        return;
    }
    doNotPushFlows = cfg.doNotPushFlows();
    restHandler = new OpenstackRestHandler(cfg);
    arpHandler = new OpenstackArpHandler(restHandler, packetService);
}
#method_after
public void configureNetwork() {
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg == null) {
        log.error("There is no openstack server information in config.");
        return;
    }
    doNotPushFlows = cfg.doNotPushFlows();
    restHandler = new OpenstackRestHandler(cfg);
    arpHandler = new OpenstackArpHandler(restHandler, packetService);
    initializeFlowRules();
}
#end_block

#method_before
public void populateSwitchingRules(Device device, Port port) {
    populateFlowRulesForTrafficToSameCnode(device, port);
    populateFlowRulesForTrafficToDifferentCnode(device, port);
}
#method_after
public void populateSwitchingRules(Device device, Port port) {
    populateFlowRulesForTunnelTag(device, port);
    populateFlowRulesForTrafficToSameCnode(device, port);
    populateFlowRulesForTrafficToDifferentCnode(device, port);
}
#end_block

#method_before
private void populateFlowRulesForTrafficToSameCnode(Device device, Port port) {
    Ip4Address vmIp = getFixedIpAddressForPort(port.annotations().value("portName"));
    if (vmIp != null && port.isEnabled()) {
        setFlowRuleForVMsInSameCnode(vmIp, device.id(), port);
    }
}
#method_after
private void populateFlowRulesForTrafficToSameCnode(Device device, Port port) {
    Ip4Address vmIp = getFixedIpAddressForPort(port.annotations().value("portName"));
    String portName = port.annotations().value("portName");
    String vni = getVniForPort(portName);
    MacAddress vmMacAddress = getVmMacAddressForPort(portName);
    if (vmIp != null) {
        setFlowRuleForVMsInSameCnode(vmIp, device.id(), port, vni, vmMacAddress);
    }
}
#end_block

#method_before
private String getVniForPort(String portName) {
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortList.stream().filter(p -> p.id().startsWith(uuid)).findAny().orElse(null);
    if (port == null) {
        log.warn("No port information for port {}", portName);
        return null;
    }
    OpenstackNetwork network = openstackNetworkList.stream().filter(n -> n.id().equals(port.networkId())).findAny().orElse(null);
    if (network == null) {
        log.warn("No VNI information for network {}", network.id());
        return null;
    }
    return network.segmentId();
}
#method_after
private String getVniForPort(String portName) {
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortList.stream().filter(p -> p.id().startsWith(uuid)).findAny().orElse(null);
    if (port == null) {
        log.debug("No port information for port {}", portName);
        return null;
    }
    OpenstackNetwork network = openstackNetworkList.stream().filter(n -> n.id().equals(port.networkId())).findAny().orElse(null);
    if (network == null) {
        log.warn("No VNI information for network {}", port.networkId());
        return null;
    }
    return network.segmentId();
}
#end_block

#method_before
private void setFlowRuleForVMsInSameCnode(Ip4Address ip4Address, DeviceId id, Port port) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ip4Address.toIpPrefix());
    tBuilder.setOutput(port.number());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(SWITCHING_RULE_PRIORITY).withFlag(ForwardingObjective.Flag.VERSATILE).fromApp(appId).add();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void setFlowRuleForVMsInSameCnode(Ip4Address ip4Address, DeviceId id, Port port, String vni, MacAddress vmMacAddress) {
    // For L2 Switching Case
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ip4Address.toIpPrefix()).matchTunnelId(Long.parseLong(vni));
    tBuilder.setOutput(port.number());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(SWITCHING_RULE_PRIORITY).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(appId).add();
    flowObjectiveService.forward(id, fo);
}
#end_block

#method_before
private void setVxLanFlowRule(String vni, DeviceId id, Ip4Address hostIp, Ip4Address vmIp, MacAddress vmMac) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(vmIp.toIpPrefix());
    tBuilder.setTunnelId(Long.parseLong(vni)).extension(buildNiciraExtenstion(id, hostIp), id).setOutput(getTunnelPort(id));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(SWITCHING_RULE_PRIORITY).withFlag(ForwardingObjective.Flag.VERSATILE).fromApp(appId).add();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void setVxLanFlowRule(String vni, DeviceId id, Ip4Address hostIp, Ip4Address vmIp, MacAddress vmMac) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(vni)).matchIPDst(vmIp.toIpPrefix());
    tBuilder.extension(buildNiciraExtenstion(id, hostIp), id).setOutput(getTunnelPort(id));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(SWITCHING_RULE_PRIORITY).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(appId).add();
    flowObjectiveService.forward(id, fo);
}
#end_block

#method_before
private ExtensionInstruction buildNiciraExtenstion(DeviceId id, Ip4Address hostIp) {
    Driver driver = driverService.getDriver(id);
    DriverHandler driverHandler = new DefaultDriverHandler(new DefaultDriverData(driver, id));
    ExtensionResolver resolver = driverHandler.behaviour(ExtensionResolver.class);
    ExtensionInstruction extensionInstruction = resolver.getExtensionInstruction(ExtensionType.ExtensionTypes.NICIRA_SET_TUNNEL_DST.type());
    try {
        extensionInstruction.setPropertyValue("tunnelDst", hostIp);
    } catch (ExtensionPropertyException e) {
        log.error("Error setting Nicira extension setting {}", e);
    }
    return extensionInstruction;
}
#method_after
private ExtensionTreatment buildNiciraExtenstion(DeviceId id, Ip4Address hostIp) {
    Driver driver = driverService.getDriver(id);
    DriverHandler driverHandler = new DefaultDriverHandler(new DefaultDriverData(driver, id));
    ExtensionTreatmentResolver resolver = driverHandler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment extensionInstruction = resolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type());
    try {
        extensionInstruction.setPropertyValue("tunnelDst", hostIp);
    } catch (ExtensionPropertyException e) {
        log.error("Error setting Nicira extension setting {}", e);
    }
    return extensionInstruction;
}
#end_block

#method_before
protected boolean isMacAddress(String field, FieldPresence presence) {
    JsonNode node = object.path(field);
    boolean isMandatory = presence == FieldPresence.MANDATORY;
    if ((null == node) && !isMandatory) {
        return true;
    } else if ((null == node) && isMandatory) {
        return false;
    }
    return isValid(node, presence, node.isTextual() && MacAddress.valueOf(node.asText()) != null);
}
#method_after
protected boolean isMacAddress(String field, FieldPresence presence) {
    JsonNode node = object.path(field);
    return isValid(node, presence, node.isTextual() && MacAddress.valueOf(node.asText()) != null);
}
#end_block

#method_before
protected boolean isIpAddress(String field, FieldPresence presence) {
    JsonNode node = object.path(field);
    boolean isMandatory = presence == FieldPresence.MANDATORY;
    if ((null == node) && !isMandatory) {
        return true;
    } else if ((null == node) && isMandatory) {
        return false;
    }
    return isValid(node, presence, node.isTextual() && IpAddress.valueOf(node.asText()) != null);
}
#method_after
protected boolean isIpAddress(String field, FieldPresence presence) {
    JsonNode node = object.path(field);
    return isValid(node, presence, node.isTextual() && IpAddress.valueOf(node.asText()) != null);
}
#end_block

#method_before
protected boolean isString(String field, FieldPresence presence, String... pattern) {
    JsonNode node = object.path(field);
    boolean isMandatory = presence == FieldPresence.MANDATORY;
    if ((null == node) && !isMandatory) {
        return true;
    } else if ((null == node) && isMandatory) {
        return false;
    }
    return isValid(node, presence, node.isTextual() && (pattern.length > 0 && node.asText().matches(pattern[0]) || pattern.length < 1));
}
#method_after
protected boolean isString(String field, FieldPresence presence, String... pattern) {
    JsonNode node = object.path(field);
    return isValid(node, presence, node.isTextual() && (pattern.length > 0 && node.asText().matches(pattern[0]) || pattern.length < 1));
}
#end_block

#method_before
protected boolean isNumber(String field, FieldPresence presence, long... minMax) {
    JsonNode node = object.path(field);
    boolean isMandatory = presence == FieldPresence.MANDATORY;
    if ((null == node) && !isMandatory) {
        return true;
    } else if ((null == node) && isMandatory) {
        return false;
    }
    return isValid(node, presence, (node.isLong() || node.isInt()) && (minMax.length > 0 && minMax[0] <= node.asLong() || minMax.length < 1) && (minMax.length > 1 && minMax[1] > node.asLong() || minMax.length < 2));
}
#method_after
protected boolean isNumber(String field, FieldPresence presence, long... minMax) {
    JsonNode node = object.path(field);
    return isValid(node, presence, (node.isLong() || node.isInt()) && (minMax.length > 0 && minMax[0] <= node.asLong() || minMax.length < 1) && (minMax.length > 1 && minMax[1] > node.asLong() || minMax.length < 2));
}
#end_block

#method_before
protected boolean isDecimal(String field, FieldPresence presence, double... minMax) {
    JsonNode node = object.path(field);
    boolean isMandatory = presence == FieldPresence.MANDATORY;
    if ((null == node) && !isMandatory) {
        return true;
    } else if ((null == node) && isMandatory) {
        return false;
    }
    return isValid(node, presence, (node.isDouble() || node.isFloat()) && (minMax.length > 0 && minMax[0] <= node.asDouble() || minMax.length < 1) && (minMax.length > 1 && minMax[1] > node.asDouble() || minMax.length < 2));
}
#method_after
protected boolean isDecimal(String field, FieldPresence presence, double... minMax) {
    JsonNode node = object.path(field);
    return isValid(node, presence, (node.isDouble() || node.isFloat()) && (minMax.length > 0 && minMax[0] <= node.asDouble() || minMax.length < 1) && (minMax.length > 1 && minMax[1] > node.asDouble() || minMax.length < 2));
}
#end_block

#method_before
private boolean isValid(JsonNode node, FieldPresence presence, boolean correctValue) {
    boolean isMandatory = presence == FieldPresence.MANDATORY;
    return isMandatory && correctValue || (!isMandatory && !node.isNull() && correctValue);
}
#method_after
private boolean isValid(JsonNode node, FieldPresence presence, boolean correctValue) {
    boolean isMandatory = presence == FieldPresence.MANDATORY;
    return isMandatory && correctValue || !isMandatory && !node.isNull() || correctValue;
}
#end_block

#method_before
@Override
public boolean assignIP(HostId hostId, Ip4Address ipAddr, int leaseTime, boolean rangeNotEnforced, List<Ip4Address> addressList) {
    IpAssignment assignmentInfo;
    log.debug("Assign IP Called w/ Ip4Address: {}, HostId: {}", ipAddr.toString(), hostId.mac().toString());
    if (allocationMap.containsKey(hostId)) {
        assignmentInfo = allocationMap.get(hostId).value();
        IpAssignment.AssignmentStatus status = assignmentInfo.assignmentStatus();
        if (!Objects.equals(assignmentInfo.ipAddress(), ipAddr) || (!assignmentInfo.rangeNotEnforced() && !ipWithinRange(ipAddr))) {
            return false;
        }
        switch(status) {
            case Option_RangeNotEnforced:
                assignmentInfo = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).rangeNotEnforced(true).assignmentStatus(IpAssignment.AssignmentStatus.Option_RangeNotEnforced).subnetMask(assignmentInfo.subnetMask()).dhcpServer(assignmentInfo.dhcpServer()).routerAddress(assignmentInfo.routerAddress()).domainServer(assignmentInfo.domainServer()).build();
                allocationMap.put(hostId, assignmentInfo);
                return true;
            case Option_Assigned:
            case Option_Requested:
                assignmentInfo = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
                allocationMap.put(hostId, assignmentInfo);
                return true;
            case Option_Expired:
                if (freeIPPool.contains(ipAddr)) {
                    assignmentInfo = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
                    if (freeIPPool.remove(ipAddr)) {
                        allocationMap.put(hostId, assignmentInfo);
                        return true;
                    }
                }
                return false;
            default:
                return false;
        }
    } else if (freeIPPool.contains(ipAddr)) {
        assignmentInfo = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
        if (freeIPPool.remove(ipAddr)) {
            allocationMap.put(hostId, assignmentInfo);
            return true;
        }
    } else if (rangeNotEnforced) {
        assignmentInfo = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).rangeNotEnforced(true).assignmentStatus(IpAssignment.AssignmentStatus.Option_RangeNotEnforced).subnetMask((Ip4Address) addressList.toArray()[0]).dhcpServer((Ip4Address) addressList.toArray()[1]).routerAddress((Ip4Address) addressList.toArray()[2]).domainServer((Ip4Address) addressList.toArray()[3]).build();
        allocationMap.put(hostId, assignmentInfo);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean assignIP(HostId hostId, Ip4Address ipAddr, int leaseTime, boolean rangeNotEnforced, List<Ip4Address> addressList) {
    log.debug("Assign IP Called w/ Ip4Address: {}, HostId: {}", ipAddr.toString(), hostId.mac().toString());
    AtomicBoolean assigned = Tools.retryable(() -> {
        AtomicBoolean result = new AtomicBoolean(false);
        allocationMap.compute(hostId, (h, existingAssignment) -> {
            IpAssignment assignment = existingAssignment;
            if (existingAssignment == null) {
                if (rangeNotEnforced) {
                    assignment = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).rangeNotEnforced(true).assignmentStatus(IpAssignment.AssignmentStatus.Option_RangeNotEnforced).subnetMask((Ip4Address) addressList.toArray()[0]).dhcpServer((Ip4Address) addressList.toArray()[1]).routerAddress((Ip4Address) addressList.toArray()[2]).domainServer((Ip4Address) addressList.toArray()[3]).build();
                    result.set(true);
                } else if (freeIPPool.remove(ipAddr)) {
                    assignment = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
                    result.set(true);
                }
            } else if (Objects.equals(existingAssignment.ipAddress(), ipAddr) && (existingAssignment.rangeNotEnforced() || ipWithinRange(ipAddr))) {
                switch(existingAssignment.assignmentStatus()) {
                    case Option_RangeNotEnforced:
                        assignment = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).rangeNotEnforced(true).assignmentStatus(IpAssignment.AssignmentStatus.Option_RangeNotEnforced).subnetMask(existingAssignment.subnetMask()).dhcpServer(existingAssignment.dhcpServer()).routerAddress(existingAssignment.routerAddress()).domainServer(existingAssignment.domainServer()).build();
                        result.set(true);
                        break;
                    case Option_Assigned:
                    case Option_Requested:
                        assignment = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
                        result.set(true);
                        break;
                    case Option_Expired:
                        if (freeIPPool.remove(ipAddr)) {
                            assignment = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
                            result.set(true);
                        }
                        break;
                    default:
                        break;
                }
            }
            return assignment;
        });
        return result;
    }, ConsistentMapException.class, MAX_RETRIES, MAX_BACKOFF).get();
    return assigned.get();
}
#end_block

#method_before
public void installFlowClassifier(PortChain portChain, int nshSpiId) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    processFlowClassifier(portChain, nshSpiId, Objective.Operation.ADD);
}
#method_after
@Override
public void installFlowClassifier(PortChain portChain, NshServicePathId nshSpiId) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    processFlowClassifier(portChain, nshSpiId, Objective.Operation.ADD);
}
#end_block

#method_before
public void unInstallFlowClassifier(PortChain portChain, int nshSpiId) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    processFlowClassifier(portChain, nshSpiId, Objective.Operation.REMOVE);
}
#method_after
@Override
public void unInstallFlowClassifier(PortChain portChain, NshServicePathId nshSpiId) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    processFlowClassifier(portChain, nshSpiId, Objective.Operation.REMOVE);
}
#end_block

#method_before
public void processFlowClassifier(PortChain portChain, int nshSpiId, Objective.Operation type) {
    // get the portPairGroup
    List<PortPairGroupId> llPortPairGroupIdList = portChain.portPairGroups();
    ListIterator<PortPairGroupId> portPairGroupIdListIterator = llPortPairGroupIdList.listIterator();
    PortPairGroupId portPairGroupId = portPairGroupIdListIterator.next();
    PortPairGroup portPairGroup = portPairGroupService.getPortPairGroup(portPairGroupId);
    List<PortPairId> llPortPairIdList = portPairGroup.portPairs();
    // get port pair
    ListIterator<PortPairId> portPairListIterator = llPortPairIdList.listIterator();
    PortPairId portPairId = portPairListIterator.next();
    PortPair portPair = portPairService.getPortPair(portPairId);
    FlowClassifierInstallerService flowclassifierinstallerService;
    // get flow classifiers
    List<FlowClassifierId> llFlowClassifierList = portChain.flowClassifiers();
    ListIterator<FlowClassifierId> flowClassifierListIterator = llFlowClassifierList.listIterator();
    while (flowClassifierListIterator.hasNext()) {
        FlowClassifierId flowclassifierId = flowClassifierListIterator.next();
        FlowClassifier flowClassifier = flowClassifierService.getFlowClassifier(flowclassifierId);
        programFlowClassification(flowClassifier, portPair, nshSpiId, type);
    }
}
#method_after
public void processFlowClassifier(PortChain portChain, NshServicePathId nshSpiId, Objective.Operation type) {
    // get the portPairGroup
    List<PortPairGroupId> llPortPairGroupIdList = portChain.portPairGroups();
    ListIterator<PortPairGroupId> portPairGroupIdListIterator = llPortPairGroupIdList.listIterator();
    PortPairGroupId portPairGroupId = portPairGroupIdListIterator.next();
    PortPairGroup portPairGroup = portPairGroupService.getPortPairGroup(portPairGroupId);
    List<PortPairId> llPortPairIdList = portPairGroup.portPairs();
    // get port pair
    ListIterator<PortPairId> portPairListIterator = llPortPairIdList.listIterator();
    PortPairId portPairId = portPairListIterator.next();
    PortPair portPair = portPairService.getPortPair(portPairId);
    FlowClassifierInstallerService flowclassifierinstallerService;
    // get flow classifiers
    List<FlowClassifierId> llFlowClassifierList = portChain.flowClassifiers();
    ListIterator<FlowClassifierId> flowClassifierListIterator = llFlowClassifierList.listIterator();
    while (flowClassifierListIterator.hasNext()) {
        FlowClassifierId flowclassifierId = flowClassifierListIterator.next();
        FlowClassifier flowClassifier = flowClassifierService.getFlowClassifier(flowclassifierId);
        prepareFlowClassification(flowClassifier, portPair, nshSpiId, type);
    }
}
#end_block

#method_before
public static PortNumber portNumber(String string) {
    long number;
    try {
        number = UnsignedLongs.decode(string);
    } catch (NumberFormatException e) {
        List<Logical> logicalNames = new ArrayList<>(Arrays.asList(Logical.values()));
        List<Logical> filtered = logicalNames.stream().filter(elem -> elem.instance().decodeLogicalPort().equals(string)).collect(Collectors.toList());
        if (filtered.size() > 0) {
            number = filtered.get(0).number();
        } else {
            throw new NumberFormatException(e.toString());
        }
    }
    return new PortNumber(number);
}
#method_after
public static PortNumber portNumber(String string) {
    return new PortNumber(UnsignedLongs.decode(string));
}
#end_block

#method_before
public Instruction decode() {
    String type = json.get(InstructionCodec.TYPE).asText();
    if (type.equals(Instruction.Type.OUTPUT.name())) {
        PortNumber portNumber;
        try {
            portNumber = PortNumber.portNumber(nullIsIllegal(json.get(InstructionCodec.PORT).asLong(), InstructionCodec.PORT + InstructionCodec.MISSING_MEMBER_MESSAGE));
        } catch (NumberFormatException e) {
            portNumber = PortNumber.portNumber(nullIsIllegal(json.get(InstructionCodec.PORT).textValue(), InstructionCodec.PORT + InstructionCodec.MISSING_MEMBER_MESSAGE));
        }
        return Instructions.createOutput(portNumber);
    } else if (type.equals(Instruction.Type.DROP.name())) {
        return Instructions.createDrop();
    } else if (type.equals(Instruction.Type.L0MODIFICATION.name())) {
        return decodeL0();
    } else if (type.equals(Instruction.Type.L1MODIFICATION.name())) {
        return decodeL1();
    } else if (type.equals(Instruction.Type.L2MODIFICATION.name())) {
        return decodeL2();
    } else if (type.equals(Instruction.Type.L3MODIFICATION.name())) {
        return decodeL3();
    } else if (type.equals(Instruction.Type.L4MODIFICATION.name())) {
        return decodeL4();
    }
    throw new IllegalArgumentException("Instruction type " + type + " is not supported");
}
#method_after
public Instruction decode() {
    String type = json.get(InstructionCodec.TYPE).asText();
    if (type.equals(Instruction.Type.OUTPUT.name())) {
        PortNumber portNumber;
        if (json.get(InstructionCodec.PORT).isLong() || json.get(InstructionCodec.PORT).isInt()) {
            portNumber = PortNumber.portNumber(nullIsIllegal(json.get(InstructionCodec.PORT).asLong(), InstructionCodec.PORT + InstructionCodec.MISSING_MEMBER_MESSAGE));
        } else if (json.get(InstructionCodec.PORT).isTextual()) {
            portNumber = PortNumber.fromString(nullIsIllegal(json.get(InstructionCodec.PORT).textValue(), InstructionCodec.PORT + InstructionCodec.MISSING_MEMBER_MESSAGE));
        } else {
            throw new IllegalArgumentException("Port value " + json.get(InstructionCodec.PORT).toString() + " is not supported");
        }
        return Instructions.createOutput(portNumber);
    } else if (type.equals(Instruction.Type.DROP.name())) {
        return Instructions.createDrop();
    } else if (type.equals(Instruction.Type.L0MODIFICATION.name())) {
        return decodeL0();
    } else if (type.equals(Instruction.Type.L1MODIFICATION.name())) {
        return decodeL1();
    } else if (type.equals(Instruction.Type.L2MODIFICATION.name())) {
        return decodeL2();
    } else if (type.equals(Instruction.Type.L3MODIFICATION.name())) {
        return decodeL3();
    } else if (type.equals(Instruction.Type.L4MODIFICATION.name())) {
        return decodeL4();
    }
    throw new IllegalArgumentException("Instruction type " + type + " is not supported");
}
#end_block

#method_before
private boolean matchOutputInstruction(JsonNode instructionJson, Description description) {
    final String jsonType = instructionJson.get("type").textValue();
    OutputInstruction instructionToMatch = (OutputInstruction) instruction;
    if (!instructionToMatch.type().name().equals(jsonType)) {
        description.appendText("type was " + jsonType);
        return false;
    }
    final String jsonPort = instructionJson.get("port").textValue();
    try {
        Long jsonPortLong = Long.parseLong(jsonPort);
        if (instructionToMatch.port().toLong() != (jsonPortLong)) {
            description.appendText("port was " + jsonPort);
            return false;
        }
    } catch (NumberFormatException e) {
        if (!instructionToMatch.port().toString().equals(jsonPort)) {
            description.appendText("port was " + jsonPort);
            return false;
        }
    }
    description.appendText("instructionToMatch" + instructionToMatch.port().toString());
    description.appendText("jsonPort" + jsonPort);
    return true;
}
#method_after
private boolean matchOutputInstruction(JsonNode instructionJson, Description description) {
    final String jsonType = instructionJson.get("type").textValue();
    OutputInstruction instructionToMatch = (OutputInstruction) instruction;
    if (!instructionToMatch.type().name().equals(jsonType)) {
        description.appendText("type was " + jsonType);
        return false;
    }
    if (instructionJson.get("port").isLong() || instructionJson.get("port").isInt()) {
        final long jsonPort = instructionJson.get("port").asLong();
        if (instructionToMatch.port().toLong() != (jsonPort)) {
            description.appendText("port was " + jsonPort);
            return false;
        }
    } else if (instructionJson.get("port").isTextual()) {
        final String jsonPort = instructionJson.get("port").textValue();
        if (!instructionToMatch.port().toString().equals(jsonPort)) {
            description.appendText("port was " + jsonPort);
            return false;
        }
    } else {
        final String jsonPort = instructionJson.get("port").toString();
        description.appendText("Unmathcing types ");
        description.appendText("instructionToMatch " + instructionToMatch.port().toString());
        description.appendText("jsonPort " + jsonPort);
    }
    return true;
}
#end_block

#method_before
private void processParameters(JavaMethod javaMethod, ObjectNode methodNode, String method, DocletTag tag) {
    ArrayNode parameters = mapper.createArrayNode();
    methodNode.set("parameters", parameters);
    boolean required = true;
    for (JavaParameter javaParameter : javaMethod.getParameters()) {
        ObjectNode individualParameterNode = mapper.createObjectNode();
        Optional<JavaAnnotation> optional = javaParameter.getAnnotations().stream().filter(annotation -> annotation.getType().getName().equals(PATH_PARAM) || annotation.getType().getName().equals(QUERY_PARAM)).findAny();
        JavaAnnotation pathType = optional.isPresent() ? optional.get() : null;
        String annotationName = javaParameter.getName();
        if (pathType != null) {
            // the parameter is a path or query parameter
            individualParameterNode.put("name", pathType.getNamedParameter("value").toString().replace("\"", ""));
            if (pathType.getType().getName().equals(PATH_PARAM)) {
                individualParameterNode.put("in", "path");
            } else if (pathType.getType().getName().equals(QUERY_PARAM)) {
                individualParameterNode.put("in", "query");
            }
            individualParameterNode.put("type", getType(javaParameter.getType()));
        } else {
            // the parameter is a body parameter
            individualParameterNode.put("name", annotationName);
            individualParameterNode.put("in", "body");
            // that goes in the post or put operation
            if (tag != null && (method.toLowerCase().equals("post") || method.toLowerCase().equals("put"))) {
                ObjectNode schema = mapper.createObjectNode();
                tag.getParameters().stream().forEach(param -> {
                    schema.put("$ref", "#/definitions/" + param);
                });
                individualParameterNode.set("schema", schema);
            }
        }
        for (DocletTag p : javaMethod.getTagsByName("param")) {
            if (p.getValue().contains(annotationName)) {
                String description = "";
                if (p.getValue().split(" ", 2).length >= 2) {
                    description = p.getValue().split(" ", 2)[1].trim();
                    if (description.contains("optional")) {
                        required = false;
                    }
                } else {
                    getLog().warn("No description for parameter: " + p.getValue().split(" ", 2)[0]);
                }
                individualParameterNode.put("description", description);
            }
        }
        individualParameterNode.put("required", required);
        parameters.add(individualParameterNode);
    }
}
#method_after
private void processParameters(JavaMethod javaMethod, ObjectNode methodNode, String method, DocletTag tag) {
    ArrayNode parameters = mapper.createArrayNode();
    methodNode.set("parameters", parameters);
    boolean required = true;
    for (JavaParameter javaParameter : javaMethod.getParameters()) {
        ObjectNode individualParameterNode = mapper.createObjectNode();
        Optional<JavaAnnotation> optional = javaParameter.getAnnotations().stream().filter(annotation -> annotation.getType().getName().equals(PATH_PARAM) || annotation.getType().getName().equals(QUERY_PARAM)).findAny();
        JavaAnnotation pathType = optional.isPresent() ? optional.get() : null;
        String annotationName = javaParameter.getName();
        if (pathType != null) {
            // the parameter is a path or query parameter
            individualParameterNode.put("name", pathType.getNamedParameter("value").toString().replace("\"", ""));
            if (pathType.getType().getName().equals(PATH_PARAM)) {
                individualParameterNode.put("in", "path");
            } else if (pathType.getType().getName().equals(QUERY_PARAM)) {
                individualParameterNode.put("in", "query");
            }
            individualParameterNode.put("type", getType(javaParameter.getType()));
        } else {
            // the parameter is a body parameter
            individualParameterNode.put("name", annotationName);
            individualParameterNode.put("in", "body");
            // that goes in the post or put operation
            if (tag != null && (method.toLowerCase().equals("post") || method.toLowerCase().equals("put"))) {
                ObjectNode schema = mapper.createObjectNode();
                tag.getParameters().stream().forEach(param -> {
                    schema.put("$ref", "#/definitions/" + param);
                });
                individualParameterNode.set("schema", schema);
            }
        }
        for (DocletTag p : javaMethod.getTagsByName("param")) {
            if (p.getValue().contains(annotationName)) {
                String description = "";
                if (p.getValue().split(" ", 2).length >= 2) {
                    description = p.getValue().split(" ", 2)[1].trim();
                    if (description.contains("optional")) {
                        required = false;
                    }
                } else {
                    getLog().warn(String.format("No description for parameter \"%s\" in " + "method \"%s\" in %s (line %d)", p.getValue(), javaMethod.getName(), javaMethod.getDeclaringClass().getName(), javaMethod.getLineNumber()));
                }
                individualParameterNode.put("description", description);
            }
        }
        individualParameterNode.put("required", required);
        parameters.add(individualParameterNode);
    }
}
#end_block

#method_before
@Override
public void event(TopologyEvent event) {
    highlightDelay = DELAYMS;
    findAndSendPaths(currentMode);
    highlightDelay = 0;
}
#method_after
@Override
public void event(TopologyEvent event) {
    highlightDelay = DELAY_MS;
    findAndSendPaths(currentMode);
    highlightDelay = 0;
}
#end_block

#method_before
private void initializeFlowRules() {
    OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
    deviceService.getDevices().forEach(device -> {
        log.debug("device {} num of ports {} ", device.id(), deviceService.getPorts(device.id()).size());
        deviceService.getPorts(device.id()).stream().filter(port -> port.annotations().value("portName").startsWith("tap")).forEach(vmPort -> {
            rulePopulator.populateSwitchingRules(device, vmPort);
            if (rulePopulator.openstackPort(vmPort) == null) {
                log.warn("No openstackPort information for port {}", vmPort);
            } else {
                registerDhcpInfo(port(vmPort));
            }
        });
    });
}
#method_after
private void initializeFlowRules() {
    OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
    deviceService.getDevices().forEach(device -> {
        log.debug("device {} num of ports {} ", device.id(), deviceService.getPorts(device.id()).size());
        deviceService.getPorts(device.id()).stream().filter(port -> port.annotations().value("portName").startsWith("tap")).forEach(vmPort -> {
            OpenstackPort osPort = rulePopulator.openstackPort(vmPort);
            if (osPort != null) {
                rulePopulator.populateSwitchingRules(device, vmPort);
                registerDhcpInfo(osPort);
            } else {
                log.warn("No openstackPort information for port {}", vmPort);
            }
        });
    });
}
#end_block

#method_before
private String getVniForPort(String portName) {
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortList.stream().filter(p -> p.id().startsWith(uuid)).findAny().orElse(null);
    if (port == null) {
        log.warn("No port information for port {}", portName);
        return null;
    }
    OpenstackNetwork network = openstackNetworkList.stream().filter(n -> n.id().equals(port.networkId())).findAny().orElse(null);
    if (network == null) {
        log.warn("No VNI information for network {}", network.id());
        return null;
    }
    return network.segmentId();
}
#method_after
private String getVniForPort(String portName) {
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortList.stream().filter(p -> p.id().startsWith(uuid)).findAny().orElse(null);
    if (port == null) {
        log.warn("No port information for port {}", portName);
        return null;
    }
    OpenstackNetwork network = openstackNetworkList.stream().filter(n -> n.id().equals(port.networkId())).findAny().orElse(null);
    if (network == null) {
        log.warn("No VNI information for network {}", port.networkId());
        return null;
    }
    return network.segmentId();
}
#end_block

#method_before
@Override
public void createServiceDependency(long tenantServiceId, long providerServiceId) {
}
#method_after
@Override
public void createServiceDependency(ServiceId tenantServiceId, ServiceId providerServiceId) {
}
#end_block

#method_before
@Override
public void removeServiceDependency(long tenantServiceId, long providerServiceId) {
}
#method_after
@Override
public void removeServiceDependency(ServiceId tenantServiceId, ServiceId providerServiceId) {
}
#end_block

#method_before
@Before
public void setUpTest() {
    ServiceDirectory testDirectory = new TestServiceDirectory().add(PortChainService.class, portChainService);
    BaseResource.setServiceDirectory(testDirectory);
}
#method_after
@Before
public void setUpTest() {
    SfcCodecContext context = new SfcCodecContext();
    ServiceDirectory testDirectory = new TestServiceDirectory().add(PortChainService.class, portChainService).add(CodecService.class, context.codecManager());
    BaseResource.setServiceDirectory(testDirectory);
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getPortChains() {
    Iterable<PortChain> portChains = service.getPortChains();
    ObjectNode result = new ObjectMapper().createObjectNode();
    ArrayNode portChainEntry = result.putArray("port_chains");
    if (portChains != null) {
        for (final PortChain portChain : portChains) {
            portChainEntry.add(new PortChainCodec().encode(portChain, this));
        }
    }
    return ok(result.toString()).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getPortChains() {
    Iterable<PortChain> portChains = get(PortChainService.class).getPortChains();
    ObjectNode result = mapper().createObjectNode();
    ArrayNode portChainEntry = result.putArray("port_chains");
    if (portChains != null) {
        for (final PortChain portChain : portChains) {
            portChainEntry.add(codec(PortChain.class).encode(portChain, this));
        }
    }
    return ok(result.toString()).build();
}
#end_block

#method_before
@GET
@Path("{chain_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPain(@PathParam("chain_id") String id) {
    if (!service.exists(PortChainId.of(id))) {
        return Response.status(NOT_FOUND).entity(PORT_CHAIN_NOT_FOUND).build();
    }
    PortChain portChain = nullIsNotFound(service.getPortChain(PortChainId.of(id)), PORT_CHAIN_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_chain", new PortChainCodec().encode(portChain, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Path("{chain_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPain(@PathParam("chain_id") String id) {
    PortChain portChain = nullIsNotFound(get(PortChainService.class).getPortChain(PortChainId.of(id)), PORT_CHAIN_NOT_FOUND);
    ObjectNode result = mapper().createObjectNode();
    result.set("port_chain", codec(PortChain.class).encode(portChain, this));
    return ok(result.toString()).build();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPortChain(InputStream stream) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode jsonTree = (ObjectNode) mapper.readTree(stream);
        JsonNode port = jsonTree.get("port_chain");
        PortChain portChain = new PortChainCodec().decode((ObjectNode) port, this);
        Boolean issuccess = nullIsNotFound(service.createPortChain(portChain), PORT_CHAIN_NOT_FOUND);
        return Response.status(OK).entity(issuccess.toString()).build();
    } catch (IOException e) {
        log.error("Exception while creating port chain {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPortChain(InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode port = jsonTree.get("port_chain");
        PortChain portChain = codec(PortChain.class).decode((ObjectNode) port, this);
        Boolean issuccess = nullIsNotFound(get(PortChainService.class).createPortChain(portChain), PORT_CHAIN_NOT_FOUND);
        return Response.status(OK).entity(issuccess.toString()).build();
    } catch (IOException e) {
        log.error("Exception while creating port chain {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@PUT
@Path("{chain_id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updatePortPain(@PathParam("chain_id") String id, final InputStream stream) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode jsonTree = (ObjectNode) mapper.readTree(stream);
        JsonNode port = jsonTree.get("port_chain");
        PortChain portChain = new PortChainCodec().decode((ObjectNode) port, this);
        Boolean result = nullIsNotFound(service.updatePortChain(portChain), PORT_CHAIN_NOT_FOUND);
        return Response.status(OK).entity(result.toString()).build();
    } catch (IOException e) {
        log.error("Update port chain failed because of exception {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#method_after
@PUT
@Path("{chain_id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updatePortPain(@PathParam("chain_id") String id, final InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode port = jsonTree.get("port_chain");
        PortChain portChain = codec(PortChain.class).decode((ObjectNode) port, this);
        Boolean result = nullIsNotFound(get(PortChainService.class).updatePortChain(portChain), PORT_CHAIN_NOT_FOUND);
        return Response.status(OK).entity(result.toString()).build();
    } catch (IOException e) {
        log.error("Update port chain failed because of exception {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@Path("{chain_id}")
@DELETE
public void deletePortPain(@PathParam("chain_id") String id) {
    log.debug("Deletes port chain by identifier {}.", id);
    PortChainId portChainId = PortChainId.of(id);
    Boolean issuccess = nullIsNotFound(service.removePortChain(portChainId), PORT_CHAIN_NOT_FOUND);
    if (!issuccess) {
        log.debug("Port Chain identifier {} does not exist", id);
    }
}
#method_after
@Path("{chain_id}")
@DELETE
public void deletePortPain(@PathParam("chain_id") String id) {
    log.debug("Deletes port chain by identifier {}.", id);
    PortChainId portChainId = PortChainId.of(id);
    Boolean issuccess = nullIsNotFound(get(PortChainService.class).removePortChain(portChainId), PORT_CHAIN_NOT_FOUND);
    if (!issuccess) {
        log.debug("Port Chain identifier {} does not exist", id);
    }
}
#end_block

#method_before
@Override
public SortedSet<OchSignal> queryLambdas(PortNumber port) {
    // OCh ports don't have lambdas
    if (isOChPort(port.toLong())) {
        return Collections.emptySortedSet();
    }
    // OMS ports expose 80 lambdas of 50GHz width, centered around the ITU-T center frequency.
    // We report these with a spacing of 12.5 GHz.
    List<OchSignal> lambdas = IntStream.range(0, LAMBDA_COUNT).mapToObj(x -> new OchSignal(GridType.FLEX, ChannelSpacing.CHL_12P5GHZ, x - (LAMBDA_COUNT / 2), 1)).collect(Collectors.toList());
    return new TreeSet<>(lambdas);
}
#method_after
@Override
public SortedSet<OchSignal> queryLambdas(PortNumber port) {
    // OCh ports don't have lambdas
    if (isOChPort(port.toLong())) {
        return Collections.emptySortedSet();
    }
    // OMS ports expose 80 lambdas of 50GHz width, centered around the ITU-T center frequency.
    // We report these with a spacing of 12.5 GHz.
    List<OchSignal> lambdas = IntStream.range(0, LAMBDA_COUNT).mapToObj(x -> new OchSignal(GridType.FLEX, ChannelSpacing.CHL_12P5GHZ, x - (LAMBDA_COUNT / 2), 1)).collect(Collectors.toList());
    SortedSet<OchSignal> result = new TreeSet<>(new DefaultOchSignalComparator());
    result.addAll(lambdas);
    return result;
}
#end_block

#method_before
@Override
public SortedSet<OchSignal> queryLambdas(PortNumber port) {
    // S160 data sheet
    // Wavelength range: 1260 - 1630 nm
    long startSpacingMultiplier = Spectrum.U_BAND_MIN.subtract(Spectrum.CENTER_FREQUENCY).asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz();
    long stopSpacingMultiplier = Spectrum.O_BAND_MAX.subtract(Spectrum.CENTER_FREQUENCY).asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz();
    List<OchSignal> lambdas = IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).mapToObj(x -> new OchSignal(GridType.FLEX, ChannelSpacing.CHL_12P5GHZ, x, 1)).collect(Collectors.toList());
    return new TreeSet<>(lambdas);
}
#method_after
@Override
public SortedSet<OchSignal> queryLambdas(PortNumber port) {
    // S160 data sheet
    // Wavelength range: 1260 - 1630 nm
    long startSpacingMultiplier = Spectrum.U_BAND_MIN.subtract(Spectrum.CENTER_FREQUENCY).asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz();
    long stopSpacingMultiplier = Spectrum.O_BAND_MAX.subtract(Spectrum.CENTER_FREQUENCY).asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz();
    List<OchSignal> lambdas = IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).mapToObj(x -> new OchSignal(GridType.FLEX, ChannelSpacing.CHL_12P5GHZ, x, 1)).collect(Collectors.toList());
    SortedSet<OchSignal> result = new TreeSet<>(new DefaultOchSignalComparator());
    result.addAll(lambdas);
    return result;
}
#end_block

#method_before
@Override
public void installForwardingRule(PortChain portChain, int nshSPI) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    programServiceFunctionForwarder(portChain, nshSPI, Objective.Operation.ADD);
}
#method_after
@Override
public void installForwardingRule(PortChain portChain, NshServicePathId nshSPI) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    prepareServiceFunctionForwarder(portChain, nshSPI, Objective.Operation.ADD);
}
#end_block

#method_before
@Override
public void unInstallForwardingRule(PortChain portChain, int nshSPI) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    programServiceFunctionForwarder(portChain, nshSPI, Objective.Operation.REMOVE);
}
#method_after
@Override
public void unInstallForwardingRule(PortChain portChain, NshServicePathId nshSPI) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    prepareServiceFunctionForwarder(portChain, nshSPI, Objective.Operation.REMOVE);
}
#end_block

#method_before
private double getDouble(Annotations a, String key) {
    String value = a.value(key);
    try {
        return value != null ? Double.parseDouble(value) : MAX_VALUE;
    } catch (NumberFormatException e) {
        return MAX_VALUE;
    }
}
#method_after
private double getDouble(Annotations a, String key) {
    String value = a != null ? a.value(key) : null;
    try {
        return value != null ? Double.parseDouble(value) : MAX_VALUE;
    } catch (NumberFormatException e) {
        return MAX_VALUE;
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    log.info("Classifier service activated");
}
#method_after
@Activate
protected void activate() {
    classifierList = storageService.<DeviceId>setBuilder().withName("classifier").withSerializer(Serializer.using(KryoNamespaces.API)).build();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    classifierList.clear();
    log.info("Classifier service deactivated");
}
#method_after
@Deactivate
protected void deactivate() {
    log.info("Stopped");
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    portPairService.addListener(portPairListener);
    portPairGroupService.addListener(portPairGroupListener);
    flowClassifierService.addListener(flowClassifierListener);
    portChainService.addListener(portChainListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(TenantId.class).register(PortPairId.class).register(PortPairGroupId.class).register(FlowClassifierId.class).register(PortChainId.class);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    vtnRscService.addListener(vtnRscListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(TenantId.class).register(PortPairId.class).register(PortPairGroupId.class).register(FlowClassifierId.class).register(PortChainId.class);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    portPairService.removeListener(portPairListener);
    portPairGroupService.removeListener(portPairGroupListener);
    flowClassifierService.removeListener(flowClassifierListener);
    portChainService.removeListener(portChainListener);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    vtnRscService.removeListener(vtnRscListener);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void onPortChainCreated(PortChain portChain) {
// TODO: call installing Flow-Classifier rules
// TODO: call installing Forwarding rules
}
#method_after
@Override
public void onPortChainCreated(PortChain portChain) {
    log.debug("onPortChainCreated");
// TODO: Apply forwarding rule on port-chain creation.
}
#end_block

#method_before
@Override
public void onPortChainDeleted(PortChain portChain) {
// TODO: call uninstalling Flow-Classifier rules
// TODO: call uninstalling Forwarding rules
}
#method_after
@Override
public void onPortChainDeleted(PortChain portChain) {
    log.debug("onPortChainDeleted");
// TODO: Apply forwarding rule on port-chain deletion.
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    hostService.removeListener(hostListener);
    floatingIpService.removeListener(floatingIpListener);
    routerService.removeListener(routerListener);
    routerInterfaceService.removeListener(routerInterfaceListener);
    portPairService.removeListener(portPairListener);
    portPairGroupService.removeListener(portPairGroupListener);
    flowClassifierService.removeListener(flowClassifierListener);
    portChainService.removeListener(portChainListener);
    l3vniMap.destroy();
    classifierOvsMap.destroy();
    sffOvsMap.destroy();
    listeners.clear();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    hostService.removeListener(hostListener);
    floatingIpService.removeListener(floatingIpListener);
    routerService.removeListener(routerListener);
    routerInterfaceService.removeListener(routerInterfaceListener);
    portPairService.removeListener(portPairListener);
    portPairGroupService.removeListener(portPairGroupListener);
    flowClassifierService.removeListener(flowClassifierListener);
    portChainService.removeListener(portChainListener);
    l3vniMap.destroy();
    classifierOvsMap.destroy();
    sffOvsMap.destroy();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public boolean isServiceFunction(VirtualPortId portId) {
    // TODO Auto-generated method stub
    return false;
}
#method_after
@Override
public boolean isServiceFunction(VirtualPortId portId) {
    return portPairService.exists(PortPairId.of(portId.portId()));
}
#end_block

#method_before
@Override
public DeviceId getSFToSFFMaping(VirtualPortId portId) {
    checkNotNull(portId, "portId cannot be null");
    VirtualPort vmPort = virtualPortService.getPort(portId);
    Set<Host> hostSet = hostService.getHostsByMac(vmPort.macAddress());
    for (Host host : hostSet) {
        if (host.annotations().value(IFACEID).equals(vmPort.portId())) {
            return host.location().deviceId();
        }
    }
    return null;
}
#method_after
@Override
public DeviceId getSFToSFFMaping(VirtualPortId portId) {
    checkNotNull(portId, "portId cannot be null");
    VirtualPort vmPort = virtualPortService.getPort(portId);
    Set<Host> hostSet = hostService.getHostsByMac(vmPort.macAddress());
    for (Host host : hostSet) {
        if (host.annotations().value(IFACEID).equals(vmPort.portId().portId())) {
            return host.location().deviceId();
        }
    }
    return null;
}
#end_block

#method_before
private void notifyListeners(VtnRscEvent event) {
    checkNotNull(event, EVENT_NOT_NULL);
    listeners.forEach(listener -> listener.event(event));
}
#method_after
private void notifyListeners(VtnRscEvent event) {
    checkNotNull(event, EVENT_NOT_NULL);
    post(event);
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    portChainStore.destroy();
    listeners.clear();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    portChainStore.destroy();
    log.info("Stopped");
}
#end_block

#method_before
@Before
public void setUpTest() {
    ServiceDirectory testDirectory = new TestServiceDirectory().add(PortPairGroupService.class, portPairGroupService);
    BaseResource.setServiceDirectory(testDirectory);
}
#method_after
@Before
public void setUpTest() {
    SfcCodecContext context = new SfcCodecContext();
    ServiceDirectory testDirectory = new TestServiceDirectory().add(PortPairGroupService.class, portPairGroupService).add(CodecService.class, context.codecManager());
    BaseResource.setServiceDirectory(testDirectory);
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPairGroups() {
    Iterable<PortPairGroup> portPairGroups = service.getPortPairGroups();
    ObjectNode result = new ObjectMapper().createObjectNode();
    ArrayNode portPairGroupEntry = result.putArray("port_pair_groups");
    if (portPairGroups != null) {
        for (final PortPairGroup portPairGroup : portPairGroups) {
            portPairGroupEntry.add(new PortPairGroupCodec().encode(portPairGroup, this));
        }
    }
    return ok(result.toString()).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPairGroups() {
    Iterable<PortPairGroup> portPairGroups = get(PortPairGroupService.class).getPortPairGroups();
    ObjectNode result = mapper().createObjectNode();
    ArrayNode portPairGroupEntry = result.putArray("port_pair_groups");
    if (portPairGroups != null) {
        for (final PortPairGroup portPairGroup : portPairGroups) {
            portPairGroupEntry.add(codec(PortPairGroup.class).encode(portPairGroup, this));
        }
    }
    return ok(result.toString()).build();
}
#end_block

#method_before
@GET
@Path("{group_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPairGroup(@PathParam("group_id") String id) {
    if (!service.exists(PortPairGroupId.of(id))) {
        return Response.status(NOT_FOUND).entity(PORT_PAIR_GROUP_NOT_FOUND).build();
    }
    PortPairGroup portPairGroup = nullIsNotFound(service.getPortPairGroup(PortPairGroupId.of(id)), PORT_PAIR_GROUP_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port_pair_group", new PortPairGroupCodec().encode(portPairGroup, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Path("{group_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getPortPairGroup(@PathParam("group_id") String id) {
    PortPairGroup portPairGroup = nullIsNotFound(get(PortPairGroupService.class).getPortPairGroup(PortPairGroupId.of(id)), PORT_PAIR_GROUP_NOT_FOUND);
    ObjectNode result = mapper().createObjectNode();
    result.set("port_pair_group", codec(PortPairGroup.class).encode(portPairGroup, this));
    return ok(result.toString()).build();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPortPairGroup(InputStream stream) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode jsonTree = (ObjectNode) mapper.readTree(stream);
        JsonNode port = jsonTree.get("port_pair_group");
        PortPairGroup portPairGroup = new PortPairGroupCodec().decode((ObjectNode) port, this);
        Boolean issuccess = nullIsNotFound(service.createPortPairGroup(portPairGroup), PORT_PAIR_GROUP_NOT_FOUND);
        return Response.status(OK).entity(issuccess.toString()).build();
    } catch (IOException e) {
        log.error("Exception while creating port pair group {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPortPairGroup(InputStream stream) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode jsonTree = (ObjectNode) mapper.readTree(stream);
        JsonNode port = jsonTree.get("port_pair_group");
        PortPairGroup portPairGroup = codec(PortPairGroup.class).decode((ObjectNode) port, this);
        Boolean issuccess = nullIsNotFound(get(PortPairGroupService.class).createPortPairGroup(portPairGroup), PORT_PAIR_GROUP_NOT_FOUND);
        return Response.status(OK).entity(issuccess.toString()).build();
    } catch (IOException e) {
        log.error("Exception while creating port pair group {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@PUT
@Path("{group_id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updatePortPairGroup(@PathParam("group_id") String id, final InputStream stream) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode jsonTree = (ObjectNode) mapper.readTree(stream);
        JsonNode port = jsonTree.get("port_pair_group");
        PortPairGroup portPairGroup = new PortPairGroupCodec().decode((ObjectNode) port, this);
        Boolean isSuccess = nullIsNotFound(service.updatePortPairGroup(portPairGroup), PORT_PAIR_GROUP_NOT_FOUND);
        return Response.status(OK).entity(isSuccess.toString()).build();
    } catch (IOException e) {
        log.error("Update port pair group failed because of exception {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#method_after
@PUT
@Path("{group_id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updatePortPairGroup(@PathParam("group_id") String id, final InputStream stream) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode jsonTree = (ObjectNode) mapper.readTree(stream);
        JsonNode port = jsonTree.get("port_pair_group");
        PortPairGroup portPairGroup = codec(PortPairGroup.class).decode((ObjectNode) port, this);
        Boolean isSuccess = nullIsNotFound(get(PortPairGroupService.class).updatePortPairGroup(portPairGroup), PORT_PAIR_GROUP_NOT_FOUND);
        return Response.status(OK).entity(isSuccess.toString()).build();
    } catch (IOException e) {
        log.error("Update port pair group failed because of exception {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@Path("{group_id}")
@DELETE
public void deletePortPairGroup(@PathParam("group_id") String id) {
    log.debug("Deletes port pair group by identifier {}.", id);
    PortPairGroupId portPairGroupId = PortPairGroupId.of(id);
    Boolean issuccess = nullIsNotFound(service.removePortPairGroup(portPairGroupId), PORT_PAIR_GROUP_NOT_FOUND);
    if (!issuccess) {
        log.debug("Port pair group identifier {} does not exist", id);
    }
}
#method_after
@Path("{group_id}")
@DELETE
public void deletePortPairGroup(@PathParam("group_id") String id) {
    log.debug("Deletes port pair group by identifier {}.", id);
    PortPairGroupId portPairGroupId = PortPairGroupId.of(id);
    Boolean issuccess = nullIsNotFound(get(PortPairGroupService.class).removePortPairGroup(portPairGroupId), PORT_PAIR_GROUP_NOT_FOUND);
    if (!issuccess) {
        log.debug("Port pair group identifier {} does not exist", id);
    }
}
#end_block

#method_before
/**
 * Builds the match for the flow mod.
 *
 * @return the match
 */
protected Match buildMatch() {
    Match.Builder mBuilder = factory.buildMatch();
    Ip6Address ip6Address;
    Ip4Prefix ip4Prefix;
    Ip6Prefix ip6Prefix;
    EthCriterion ethCriterion;
    IPCriterion ipCriterion;
    TcpPortCriterion tcpPortCriterion;
    UdpPortCriterion udpPortCriterion;
    SctpPortCriterion sctpPortCriterion;
    IPv6NDLinkLayerAddressCriterion llAddressCriterion;
    for (Criterion c : selector.criteria()) {
        switch(c.type()) {
            case IN_PORT:
                PortCriterion inPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPort.port().toLong()));
                break;
            case IN_PHY_PORT:
                PortCriterion inPhyPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPhyPort.port().toLong()));
                break;
            case METADATA:
                MetadataCriterion metadata = (MetadataCriterion) c;
                mBuilder.setExact(MatchField.METADATA, OFMetadata.ofRaw(metadata.metadata()));
                break;
            case ETH_DST:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_DST, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_SRC:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_SRC, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_TYPE:
                EthTypeCriterion ethType = (EthTypeCriterion) c;
                mBuilder.setExact(MatchField.ETH_TYPE, EthType.of(ethType.ethType().toShort()));
                break;
            case VLAN_VID:
                VlanIdCriterion vid = (VlanIdCriterion) c;
                if (vid.vlanId().equals(VlanId.ANY)) {
                    mBuilder.setMasked(MatchField.VLAN_VID, OFVlanVidMatch.PRESENT, OFVlanVidMatch.PRESENT);
                } else if (vid.vlanId().equals(VlanId.NONE)) {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.NONE);
                } else {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlanVid(VlanVid.ofVlan(vid.vlanId().toShort())));
                }
                break;
            case VLAN_PCP:
                VlanPcpCriterion vpcp = (VlanPcpCriterion) c;
                mBuilder.setExact(MatchField.VLAN_PCP, VlanPcp.of(vpcp.priority()));
                break;
            case IP_DSCP:
                IPDscpCriterion ipDscpCriterion = (IPDscpCriterion) c;
                mBuilder.setExact(MatchField.IP_DSCP, IpDscp.of(ipDscpCriterion.ipDscp()));
                break;
            case IP_ECN:
                IPEcnCriterion ipEcnCriterion = (IPEcnCriterion) c;
                mBuilder.setExact(MatchField.IP_ECN, IpEcn.of(ipEcnCriterion.ipEcn()));
                break;
            case IP_PROTO:
                IPProtocolCriterion p = (IPProtocolCriterion) c;
                mBuilder.setExact(MatchField.IP_PROTO, IpProtocol.of(p.protocol()));
                break;
            case IPV4_SRC:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_SRC, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IPV4_DST:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_DST, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case TCP_SRC:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_SRC, TransportPort.of(tcpPortCriterion.tcpPort().toInt()));
                break;
            case TCP_DST:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_DST, TransportPort.of(tcpPortCriterion.tcpPort().toInt()));
                break;
            case UDP_SRC:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_SRC, TransportPort.of(udpPortCriterion.udpPort().toInt()));
                break;
            case UDP_DST:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_DST, TransportPort.of(udpPortCriterion.udpPort().toInt()));
                break;
            case SCTP_SRC:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_SRC, TransportPort.of(sctpPortCriterion.sctpPort().toInt()));
                break;
            case SCTP_DST:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_DST, TransportPort.of(sctpPortCriterion.sctpPort().toInt()));
                break;
            case ICMPV4_TYPE:
                IcmpTypeCriterion icmpType = (IcmpTypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_TYPE, ICMPv4Type.of(icmpType.icmpType()));
                break;
            case ICMPV4_CODE:
                IcmpCodeCriterion icmpCode = (IcmpCodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_CODE, ICMPv4Code.of(icmpCode.icmpCode()));
                break;
            case IPV6_SRC:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_SRC, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_DST:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_DST, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_FLABEL:
                IPv6FlowLabelCriterion flowLabelCriterion = (IPv6FlowLabelCriterion) c;
                mBuilder.setExact(MatchField.IPV6_FLABEL, IPv6FlowLabel.of(flowLabelCriterion.flowLabel()));
                break;
            case ICMPV6_TYPE:
                Icmpv6TypeCriterion icmpv6Type = (Icmpv6TypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_TYPE, U8.of(icmpv6Type.icmpv6Type()));
                break;
            case ICMPV6_CODE:
                Icmpv6CodeCriterion icmpv6Code = (Icmpv6CodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_CODE, U8.of(icmpv6Code.icmpv6Code()));
                break;
            case IPV6_ND_TARGET:
                IPv6NDTargetAddressCriterion targetAddressCriterion = (IPv6NDTargetAddressCriterion) c;
                ip6Address = targetAddressCriterion.targetAddress();
                mBuilder.setExact(MatchField.IPV6_ND_TARGET, IPv6Address.of(ip6Address.toOctets()));
                break;
            case IPV6_ND_SLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_SLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case IPV6_ND_TLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_TLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case MPLS_LABEL:
                MplsCriterion mp = (MplsCriterion) c;
                mBuilder.setExact(MatchField.MPLS_LABEL, U32.of(mp.label().toInt()));
                break;
            case IPV6_EXTHDR:
                IPv6ExthdrFlagsCriterion exthdrFlagsCriterion = (IPv6ExthdrFlagsCriterion) c;
                mBuilder.setExact(MatchField.IPV6_EXTHDR, U16.of(exthdrFlagsCriterion.exthdrFlags()));
                break;
            case OCH_SIGID:
                try {
                    OchSignalCriterion ochSignalCriterion = (OchSignalCriterion) c;
                    OchSignal signal = ochSignalCriterion.lambda();
                    byte gridType = OpenFlowValueMapper.lookupGridType(signal.gridType());
                    byte channelSpacing = OpenFlowValueMapper.lookupChannelSpacing(signal.channelSpacing());
                    mBuilder.setExact(MatchField.EXP_OCH_SIG_ID, new CircuitSignalID(gridType, channelSpacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity()));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                }
                break;
            case OCH_SIGTYPE:
                try {
                    OchSignalTypeCriterion sc = (OchSignalTypeCriterion) c;
                    byte signalType = OpenFlowValueMapper.lookupOchSignalType(sc.signalType());
                    mBuilder.setExact(MatchField.EXP_OCH_SIGTYPE, U8.of(signalType));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                }
                break;
            case ODU_SIGID:
                OduSignalIdCriterion oduSignalIdCriterion = (OduSignalIdCriterion) c;
                OduSignalId oduSignalId = oduSignalIdCriterion.oduSignalId();
                mBuilder.setExact(MatchField.EXP_ODU_SIG_ID, new OduSignalID((short) oduSignalId.tributaryPortNumber(), (short) oduSignalId.tributarySlotLength(), oduSignalId.tributarySlotBitmap()));
                break;
            case ODU_SIGTYPE:
                try {
                    OduSignalTypeCriterion oduSignalTypeCriterion = (OduSignalTypeCriterion) c;
                    byte oduSigType = OpenFlowValueMapper.lookupOduSignalType(oduSignalTypeCriterion.signalType());
                    mBuilder.setExact(MatchField.EXP_ODU_SIGTYPE, U8.of(oduSigType));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                }
                break;
            case TUNNEL_ID:
                TunnelIdCriterion tunnelId = (TunnelIdCriterion) c;
                mBuilder.setExact(MatchField.TUNNEL_ID, U64.of(tunnelId.tunnelId()));
                break;
            case MPLS_BOS:
                MplsBosCriterion mplsBos = (MplsBosCriterion) c;
                mBuilder.setExact(MatchField.MPLS_BOS, mplsBos.mplsBos() ? OFBooleanValue.TRUE : OFBooleanValue.FALSE);
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case MPLS_TC:
            case PBB_ISID:
            default:
                log.warn("Match type {} not yet implemented.", c.type());
        }
    }
    return mBuilder.build();
}
#method_after
/**
 * Builds the match for the flow mod.
 *
 * @return the match
 */
protected Match buildMatch() {
    Match.Builder mBuilder = factory.buildMatch();
    Ip6Address ip6Address;
    Ip4Prefix ip4Prefix;
    Ip6Prefix ip6Prefix;
    EthCriterion ethCriterion;
    IPCriterion ipCriterion;
    TcpPortCriterion tcpPortCriterion;
    UdpPortCriterion udpPortCriterion;
    SctpPortCriterion sctpPortCriterion;
    IPv6NDLinkLayerAddressCriterion llAddressCriterion;
    ArpHaCriterion arpHaCriterion;
    ArpPaCriterion arpPaCriterion;
    for (Criterion c : selector.criteria()) {
        switch(c.type()) {
            case IN_PORT:
                PortCriterion inPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPort.port().toLong()));
                break;
            case IN_PHY_PORT:
                PortCriterion inPhyPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPhyPort.port().toLong()));
                break;
            case METADATA:
                MetadataCriterion metadata = (MetadataCriterion) c;
                mBuilder.setExact(MatchField.METADATA, OFMetadata.ofRaw(metadata.metadata()));
                break;
            case ETH_DST:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_DST, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_SRC:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_SRC, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_TYPE:
                EthTypeCriterion ethType = (EthTypeCriterion) c;
                mBuilder.setExact(MatchField.ETH_TYPE, EthType.of(ethType.ethType().toShort()));
                break;
            case VLAN_VID:
                VlanIdCriterion vid = (VlanIdCriterion) c;
                if (vid.vlanId().equals(VlanId.ANY)) {
                    mBuilder.setMasked(MatchField.VLAN_VID, OFVlanVidMatch.PRESENT, OFVlanVidMatch.PRESENT);
                } else if (vid.vlanId().equals(VlanId.NONE)) {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.NONE);
                } else {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlanVid(VlanVid.ofVlan(vid.vlanId().toShort())));
                }
                break;
            case VLAN_PCP:
                VlanPcpCriterion vpcp = (VlanPcpCriterion) c;
                mBuilder.setExact(MatchField.VLAN_PCP, VlanPcp.of(vpcp.priority()));
                break;
            case IP_DSCP:
                IPDscpCriterion ipDscpCriterion = (IPDscpCriterion) c;
                mBuilder.setExact(MatchField.IP_DSCP, IpDscp.of(ipDscpCriterion.ipDscp()));
                break;
            case IP_ECN:
                IPEcnCriterion ipEcnCriterion = (IPEcnCriterion) c;
                mBuilder.setExact(MatchField.IP_ECN, IpEcn.of(ipEcnCriterion.ipEcn()));
                break;
            case IP_PROTO:
                IPProtocolCriterion p = (IPProtocolCriterion) c;
                mBuilder.setExact(MatchField.IP_PROTO, IpProtocol.of(p.protocol()));
                break;
            case IPV4_SRC:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_SRC, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IPV4_DST:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_DST, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case TCP_SRC:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_SRC, TransportPort.of(tcpPortCriterion.tcpPort().toInt()));
                break;
            case TCP_DST:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_DST, TransportPort.of(tcpPortCriterion.tcpPort().toInt()));
                break;
            case UDP_SRC:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_SRC, TransportPort.of(udpPortCriterion.udpPort().toInt()));
                break;
            case UDP_DST:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_DST, TransportPort.of(udpPortCriterion.udpPort().toInt()));
                break;
            case SCTP_SRC:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_SRC, TransportPort.of(sctpPortCriterion.sctpPort().toInt()));
                break;
            case SCTP_DST:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_DST, TransportPort.of(sctpPortCriterion.sctpPort().toInt()));
                break;
            case ICMPV4_TYPE:
                IcmpTypeCriterion icmpType = (IcmpTypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_TYPE, ICMPv4Type.of(icmpType.icmpType()));
                break;
            case ICMPV4_CODE:
                IcmpCodeCriterion icmpCode = (IcmpCodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_CODE, ICMPv4Code.of(icmpCode.icmpCode()));
                break;
            case IPV6_SRC:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_SRC, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_DST:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_DST, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_FLABEL:
                IPv6FlowLabelCriterion flowLabelCriterion = (IPv6FlowLabelCriterion) c;
                mBuilder.setExact(MatchField.IPV6_FLABEL, IPv6FlowLabel.of(flowLabelCriterion.flowLabel()));
                break;
            case ICMPV6_TYPE:
                Icmpv6TypeCriterion icmpv6Type = (Icmpv6TypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_TYPE, U8.of(icmpv6Type.icmpv6Type()));
                break;
            case ICMPV6_CODE:
                Icmpv6CodeCriterion icmpv6Code = (Icmpv6CodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_CODE, U8.of(icmpv6Code.icmpv6Code()));
                break;
            case IPV6_ND_TARGET:
                IPv6NDTargetAddressCriterion targetAddressCriterion = (IPv6NDTargetAddressCriterion) c;
                ip6Address = targetAddressCriterion.targetAddress();
                mBuilder.setExact(MatchField.IPV6_ND_TARGET, IPv6Address.of(ip6Address.toOctets()));
                break;
            case IPV6_ND_SLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_SLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case IPV6_ND_TLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_TLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case MPLS_LABEL:
                MplsCriterion mp = (MplsCriterion) c;
                mBuilder.setExact(MatchField.MPLS_LABEL, U32.of(mp.label().toInt()));
                break;
            case IPV6_EXTHDR:
                IPv6ExthdrFlagsCriterion exthdrFlagsCriterion = (IPv6ExthdrFlagsCriterion) c;
                mBuilder.setExact(MatchField.IPV6_EXTHDR, U16.of(exthdrFlagsCriterion.exthdrFlags()));
                break;
            case OCH_SIGID:
                try {
                    OchSignalCriterion ochSignalCriterion = (OchSignalCriterion) c;
                    OchSignal signal = ochSignalCriterion.lambda();
                    byte gridType = OpenFlowValueMapper.lookupGridType(signal.gridType());
                    byte channelSpacing = OpenFlowValueMapper.lookupChannelSpacing(signal.channelSpacing());
                    mBuilder.setExact(MatchField.EXP_OCH_SIG_ID, new CircuitSignalID(gridType, channelSpacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity()));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                }
                break;
            case OCH_SIGTYPE:
                try {
                    OchSignalTypeCriterion sc = (OchSignalTypeCriterion) c;
                    byte signalType = OpenFlowValueMapper.lookupOchSignalType(sc.signalType());
                    mBuilder.setExact(MatchField.EXP_OCH_SIGTYPE, U8.of(signalType));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                }
                break;
            case ODU_SIGID:
                OduSignalIdCriterion oduSignalIdCriterion = (OduSignalIdCriterion) c;
                OduSignalId oduSignalId = oduSignalIdCriterion.oduSignalId();
                mBuilder.setExact(MatchField.EXP_ODU_SIG_ID, new OduSignalID((short) oduSignalId.tributaryPortNumber(), (short) oduSignalId.tributarySlotLength(), oduSignalId.tributarySlotBitmap()));
                break;
            case ODU_SIGTYPE:
                try {
                    OduSignalTypeCriterion oduSignalTypeCriterion = (OduSignalTypeCriterion) c;
                    byte oduSigType = OpenFlowValueMapper.lookupOduSignalType(oduSignalTypeCriterion.signalType());
                    mBuilder.setExact(MatchField.EXP_ODU_SIGTYPE, U8.of(oduSigType));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                }
                break;
            case TUNNEL_ID:
                TunnelIdCriterion tunnelId = (TunnelIdCriterion) c;
                mBuilder.setExact(MatchField.TUNNEL_ID, U64.of(tunnelId.tunnelId()));
                break;
            case MPLS_BOS:
                MplsBosCriterion mplsBos = (MplsBosCriterion) c;
                mBuilder.setExact(MatchField.MPLS_BOS, mplsBos.mplsBos() ? OFBooleanValue.TRUE : OFBooleanValue.FALSE);
                break;
            case ARP_OP:
                ArpOpCriterion arpOp = (ArpOpCriterion) c;
                mBuilder.setExact(MatchField.ARP_OP, ArpOpcode.of(arpOp.arpOp()));
                break;
            case ARP_SHA:
                arpHaCriterion = (ArpHaCriterion) c;
                mBuilder.setExact(MatchField.ARP_SHA, MacAddress.of(arpHaCriterion.mac().toLong()));
                break;
            case ARP_SPA:
                arpPaCriterion = (ArpPaCriterion) c;
                mBuilder.setExact(MatchField.ARP_SPA, IPv4Address.of(arpPaCriterion.ip().toInt()));
                break;
            case ARP_THA:
                arpHaCriterion = (ArpHaCriterion) c;
                mBuilder.setExact(MatchField.ARP_THA, MacAddress.of(arpHaCriterion.mac().toLong()));
                break;
            case ARP_TPA:
                arpPaCriterion = (ArpPaCriterion) c;
                mBuilder.setExact(MatchField.ARP_TPA, IPv4Address.of(arpPaCriterion.ip().toInt()));
                break;
            case EXTENSION:
                ExtensionCriterion extensionCriterion = (ExtensionCriterion) c;
                OFOxm oxm = buildExtensionOxm(extensionCriterion.extensionSelector());
                if (oxm == null) {
                    log.warn("Unable to build extension selector");
                    break;
                }
                if (oxm.isMasked()) {
                    mBuilder.setMasked(oxm.getMatchField(), oxm.getValue(), oxm.getMask());
                } else {
                    mBuilder.setExact(oxm.getMatchField(), oxm.getValue());
                }
                break;
            case MPLS_TC:
            case PBB_ISID:
            default:
                log.warn("Match type {} not yet implemented.", c.type());
        }
    }
    return mBuilder.build();
}
#end_block

#method_before
private OFAction buildModLambdaInstruction(ModLambdaInstruction instruction) {
    return factory().actions().circuit(factory().oxms().ochSigidBasic(new CircuitSignalID((byte) 1, (byte) 2, instruction.lambda(), (short) 1)));
}
#method_after
private OFAction buildModLambdaInstruction(ModLambdaInstruction instruction) {
    return factory().actions().circuit(factory().oxms().expOchSigId(new CircuitSignalID((byte) 1, (byte) 2, instruction.lambda(), (short) 1)));
}
#end_block

#method_before
private OFAction buildModOchSignalInstruction(ModOchSignalInstruction instruction) {
    OchSignal signal = instruction.lambda();
    byte gridType = OpenFlowValueMapper.lookupGridType(signal.gridType());
    byte channelSpacing = OpenFlowValueMapper.lookupChannelSpacing(signal.channelSpacing());
    return factory().actions().circuit(factory().oxms().ochSigidBasic(new CircuitSignalID(gridType, channelSpacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity())));
}
#method_after
private OFAction buildModOchSignalInstruction(ModOchSignalInstruction instruction) {
    OchSignal signal = instruction.lambda();
    byte gridType = OpenFlowValueMapper.lookupGridType(signal.gridType());
    byte channelSpacing = OpenFlowValueMapper.lookupChannelSpacing(signal.channelSpacing());
    return factory().actions().circuit(factory().oxms().expOchSigId(new CircuitSignalID(gridType, channelSpacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity())));
}
#end_block

#method_before
private OFAction buildL3Modification(Instruction i) {
    L3ModificationInstruction l3m = (L3ModificationInstruction) i;
    ModIPInstruction ip;
    Ip4Address ip4;
    Ip6Address ip6;
    OFOxm<?> oxm = null;
    switch(l3m.subtype()) {
        case IPV4_SRC:
            ip = (ModIPInstruction) i;
            ip4 = ip.ip().getIp4Address();
            oxm = factory().oxms().ipv4Src(IPv4Address.of(ip4.toInt()));
            break;
        case IPV4_DST:
            ip = (ModIPInstruction) i;
            ip4 = ip.ip().getIp4Address();
            oxm = factory().oxms().ipv4Dst(IPv4Address.of(ip4.toInt()));
            break;
        case IPV6_SRC:
            ip = (ModIPInstruction) i;
            ip6 = ip.ip().getIp6Address();
            oxm = factory().oxms().ipv6Src(IPv6Address.of(ip6.toOctets()));
            break;
        case IPV6_DST:
            ip = (ModIPInstruction) i;
            ip6 = ip.ip().getIp6Address();
            oxm = factory().oxms().ipv6Dst(IPv6Address.of(ip6.toOctets()));
            break;
        case IPV6_FLABEL:
            ModIPv6FlowLabelInstruction flowLabelInstruction = (ModIPv6FlowLabelInstruction) i;
            int flowLabel = flowLabelInstruction.flowLabel();
            oxm = factory().oxms().ipv6Flabel(IPv6FlowLabel.of(flowLabel));
            break;
        case DEC_TTL:
            return factory().actions().decNwTtl();
        case TTL_IN:
            return factory().actions().copyTtlIn();
        case TTL_OUT:
            return factory().actions().copyTtlOut();
        default:
            log.warn("Unimplemented action type {}.", l3m.subtype());
            break;
    }
    if (oxm != null) {
        return factory().actions().buildSetField().setField(oxm).build();
    }
    return null;
}
#method_after
private OFAction buildL3Modification(Instruction i) {
    L3ModificationInstruction l3m = (L3ModificationInstruction) i;
    ModIPInstruction ip;
    Ip4Address ip4;
    Ip6Address ip6;
    OFOxm<?> oxm = null;
    switch(l3m.subtype()) {
        case IPV4_SRC:
            ip = (ModIPInstruction) i;
            ip4 = ip.ip().getIp4Address();
            oxm = factory().oxms().ipv4Src(IPv4Address.of(ip4.toInt()));
            break;
        case IPV4_DST:
            ip = (ModIPInstruction) i;
            ip4 = ip.ip().getIp4Address();
            oxm = factory().oxms().ipv4Dst(IPv4Address.of(ip4.toInt()));
            break;
        case IPV6_SRC:
            ip = (ModIPInstruction) i;
            ip6 = ip.ip().getIp6Address();
            oxm = factory().oxms().ipv6Src(IPv6Address.of(ip6.toOctets()));
            break;
        case IPV6_DST:
            ip = (ModIPInstruction) i;
            ip6 = ip.ip().getIp6Address();
            oxm = factory().oxms().ipv6Dst(IPv6Address.of(ip6.toOctets()));
            break;
        case IPV6_FLABEL:
            ModIPv6FlowLabelInstruction flowLabelInstruction = (ModIPv6FlowLabelInstruction) i;
            int flowLabel = flowLabelInstruction.flowLabel();
            oxm = factory().oxms().ipv6Flabel(IPv6FlowLabel.of(flowLabel));
            break;
        case ARP_SPA:
            ModArpIPInstruction aip = (ModArpIPInstruction) i;
            ip4 = aip.ip().getIp4Address();
            oxm = factory().oxms().arpSpa(IPv4Address.of(ip4.toInt()));
            break;
        case ARP_SHA:
            ModArpEthInstruction ei = (ModArpEthInstruction) i;
            oxm = factory().oxms().arpSha(MacAddress.of(ei.mac().toLong()));
            break;
        case ARP_OP:
            ModArpOpInstruction oi = (ModArpOpInstruction) i;
            oxm = factory().oxms().arpOp(ArpOpcode.of((int) oi.op()));
            break;
        case DEC_TTL:
            return factory().actions().decNwTtl();
        case TTL_IN:
            return factory().actions().copyTtlIn();
        case TTL_OUT:
            return factory().actions().copyTtlOut();
        default:
            log.warn("Unimplemented action type {}.", l3m.subtype());
            break;
    }
    if (oxm != null) {
        return factory().actions().buildSetField().setField(oxm).build();
    }
    return null;
}
#end_block

#method_before
private OFAction buildExtensionAction(ExtensionInstruction i) {
    if (!driverService.isPresent()) {
        log.error("No driver service present");
        return null;
    }
    Driver driver = driverService.get().getDriver(deviceId);
    if (driver.hasBehaviour(ExtensionInterpreter.class)) {
        DefaultDriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
        ExtensionInterpreter interpreter = handler.behaviour(ExtensionInterpreter.class);
        return interpreter.mapInstruction(factory(), i);
    }
    return null;
}
#method_after
private OFAction buildExtensionAction(ExtensionTreatment i) {
    if (!driverService.isPresent()) {
        log.error("No driver service present");
        return null;
    }
    Driver driver = driverService.get().getDriver(deviceId);
    if (driver.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        DefaultDriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
        ExtensionTreatmentInterpreter interpreter = handler.behaviour(ExtensionTreatmentInterpreter.class);
        return interpreter.mapInstruction(factory(), i);
    }
    return null;
}
#end_block

#method_before
private void handleSetField(TrafficTreatment.Builder builder, OFActionSetField action) {
    OFOxm<?> oxm = action.getField();
    switch(oxm.getMatchField().id) {
        case VLAN_PCP:
            @SuppressWarnings("unchecked")
            OFOxm<VlanPcp> vlanpcp = (OFOxm<VlanPcp>) oxm;
            builder.setVlanPcp(vlanpcp.getValue().getValue());
            break;
        case VLAN_VID:
            @SuppressWarnings("unchecked")
            OFOxm<OFVlanVidMatch> vlanvid = (OFOxm<OFVlanVidMatch>) oxm;
            builder.setVlanId(VlanId.vlanId(vlanvid.getValue().getVlan()));
            break;
        case ETH_DST:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethdst = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthDst(MacAddress.valueOf(ethdst.getValue().getLong()));
            break;
        case ETH_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethsrc = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthSrc(MacAddress.valueOf(ethsrc.getValue().getLong()));
            break;
        case IPV4_DST:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4dst = (OFOxm<IPv4Address>) oxm;
            builder.setIpDst(Ip4Address.valueOf(ip4dst.getValue().getInt()));
            break;
        case IPV4_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4src = (OFOxm<IPv4Address>) oxm;
            builder.setIpSrc(Ip4Address.valueOf(ip4src.getValue().getInt()));
            break;
        case MPLS_LABEL:
            @SuppressWarnings("unchecked")
            OFOxm<U32> labelId = (OFOxm<U32>) oxm;
            builder.setMpls(MplsLabel.mplsLabel((int) labelId.getValue().getValue()));
            break;
        case MPLS_BOS:
            @SuppressWarnings("unchecked")
            OFOxm<U8> mplsBos = (OFOxm<U8>) oxm;
            builder.setMplsBos(mplsBos.getValue() == U8.ZERO ? false : true);
            break;
        case TUNNEL_ID:
            @SuppressWarnings("unchecked")
            OFOxm<U64> tunnelId = (OFOxm<U64>) oxm;
            builder.setTunnelId(tunnelId.getValue().getValue());
            break;
        case TCP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpdst = (OFOxm<TransportPort>) oxm;
            builder.setTcpDst(TpPort.tpPort(tcpdst.getValue().getPort()));
            break;
        case TCP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpsrc = (OFOxm<TransportPort>) oxm;
            builder.setTcpSrc(TpPort.tpPort(tcpsrc.getValue().getPort()));
            break;
        case UDP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpdst = (OFOxm<TransportPort>) oxm;
            builder.setUdpDst(TpPort.tpPort(udpdst.getValue().getPort()));
            break;
        case UDP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpsrc = (OFOxm<TransportPort>) oxm;
            builder.setUdpSrc(TpPort.tpPort(udpsrc.getValue().getPort()));
            break;
        case TUNNEL_IPV4_DST:
            DriverHandler driver = getDriver(dpid);
            ExtensionInterpreter interpreter = driver.behaviour(ExtensionInterpreter.class);
            if (interpreter != null) {
                builder.extension(interpreter.mapAction(action), DeviceId.deviceId(Dpid.uri(dpid)));
            }
            break;
        case EXP_ODU_SIG_ID:
            @SuppressWarnings("unchecked")
            OFOxm<OduSignalID> oduID = (OFOxm<OduSignalID>) oxm;
            OduSignalID oduSignalID = oduID.getValue();
            OduSignalId oduSignalId = OduSignalId.oduSignalId(oduSignalID.getTpn(), oduSignalID.getTslen(), oduSignalID.getTsmap());
            builder.add(modL1OduSignalId(oduSignalId));
            break;
        case EXP_OCH_SIG_ID:
            try {
                @SuppressWarnings("unchecked")
                OFOxm<CircuitSignalID> ochId = (OFOxm<CircuitSignalID>) oxm;
                CircuitSignalID circuitSignalID = ochId.getValue();
                builder.add(modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
            } catch (NoMappingFoundException e) {
                log.warn(e.getMessage());
                break;
            }
            break;
        case ARP_OP:
        case ARP_SHA:
        case ARP_SPA:
        case ARP_THA:
        case ARP_TPA:
        case BSN_EGR_PORT_GROUP_ID:
        case BSN_GLOBAL_VRF_ALLOWED:
        case BSN_IN_PORTS_128:
        case BSN_L3_DST_CLASS_ID:
        case BSN_L3_INTERFACE_CLASS_ID:
        case BSN_L3_SRC_CLASS_ID:
        case BSN_LAG_ID:
        case BSN_TCP_FLAGS:
        case BSN_UDF0:
        case BSN_UDF1:
        case BSN_UDF2:
        case BSN_UDF3:
        case BSN_UDF4:
        case BSN_UDF5:
        case BSN_UDF6:
        case BSN_UDF7:
        case BSN_VLAN_XLATE_PORT_GROUP_ID:
        case BSN_VRF:
        case ETH_TYPE:
        case ICMPV4_CODE:
        case ICMPV4_TYPE:
        case ICMPV6_CODE:
        case ICMPV6_TYPE:
        case IN_PHY_PORT:
        case IN_PORT:
        case IPV6_DST:
        case IPV6_FLABEL:
        case IPV6_ND_SLL:
        case IPV6_ND_TARGET:
        case IPV6_ND_TLL:
        case IPV6_SRC:
        case IP_DSCP:
        case IP_ECN:
        case IP_PROTO:
        case METADATA:
        case MPLS_TC:
        case OCH_SIGID:
        case OCH_SIGID_BASIC:
        case OCH_SIGTYPE:
        case OCH_SIGTYPE_BASIC:
        case SCTP_DST:
        case SCTP_SRC:
        case EXP_ODU_SIGTYPE:
        case EXP_OCH_SIGTYPE:
        default:
            log.warn("Set field type {} not yet implemented.", oxm.getMatchField().id);
            break;
    }
}
#method_after
private void handleSetField(TrafficTreatment.Builder builder, OFActionSetField action) {
    OFOxm<?> oxm = action.getField();
    switch(oxm.getMatchField().id) {
        case VLAN_PCP:
            @SuppressWarnings("unchecked")
            OFOxm<VlanPcp> vlanpcp = (OFOxm<VlanPcp>) oxm;
            builder.setVlanPcp(vlanpcp.getValue().getValue());
            break;
        case VLAN_VID:
            @SuppressWarnings("unchecked")
            OFOxm<OFVlanVidMatch> vlanvid = (OFOxm<OFVlanVidMatch>) oxm;
            builder.setVlanId(VlanId.vlanId(vlanvid.getValue().getVlan()));
            break;
        case ETH_DST:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethdst = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthDst(MacAddress.valueOf(ethdst.getValue().getLong()));
            break;
        case ETH_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethsrc = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthSrc(MacAddress.valueOf(ethsrc.getValue().getLong()));
            break;
        case IPV4_DST:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4dst = (OFOxm<IPv4Address>) oxm;
            builder.setIpDst(Ip4Address.valueOf(ip4dst.getValue().getInt()));
            break;
        case IPV4_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4src = (OFOxm<IPv4Address>) oxm;
            builder.setIpSrc(Ip4Address.valueOf(ip4src.getValue().getInt()));
            break;
        case MPLS_LABEL:
            @SuppressWarnings("unchecked")
            OFOxm<U32> labelId = (OFOxm<U32>) oxm;
            builder.setMpls(MplsLabel.mplsLabel((int) labelId.getValue().getValue()));
            break;
        case MPLS_BOS:
            @SuppressWarnings("unchecked")
            OFOxm<U8> mplsBos = (OFOxm<U8>) oxm;
            builder.setMplsBos(mplsBos.getValue() == U8.ZERO ? false : true);
            break;
        case TUNNEL_ID:
            @SuppressWarnings("unchecked")
            OFOxm<U64> tunnelId = (OFOxm<U64>) oxm;
            builder.setTunnelId(tunnelId.getValue().getValue());
            break;
        case TCP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpdst = (OFOxm<TransportPort>) oxm;
            builder.setTcpDst(TpPort.tpPort(tcpdst.getValue().getPort()));
            break;
        case TCP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpsrc = (OFOxm<TransportPort>) oxm;
            builder.setTcpSrc(TpPort.tpPort(tcpsrc.getValue().getPort()));
            break;
        case UDP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpdst = (OFOxm<TransportPort>) oxm;
            builder.setUdpDst(TpPort.tpPort(udpdst.getValue().getPort()));
            break;
        case UDP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpsrc = (OFOxm<TransportPort>) oxm;
            builder.setUdpSrc(TpPort.tpPort(udpsrc.getValue().getPort()));
            break;
        case TUNNEL_IPV4_DST:
            DriverHandler driver = getDriver(dpid);
            ExtensionTreatmentInterpreter interpreter = driver.behaviour(ExtensionTreatmentInterpreter.class);
            if (interpreter != null) {
                builder.extension(interpreter.mapAction(action), DeviceId.deviceId(Dpid.uri(dpid)));
            }
            break;
        case EXP_ODU_SIG_ID:
            @SuppressWarnings("unchecked")
            OFOxm<OduSignalID> oduID = (OFOxm<OduSignalID>) oxm;
            OduSignalID oduSignalID = oduID.getValue();
            OduSignalId oduSignalId = OduSignalId.oduSignalId(oduSignalID.getTpn(), oduSignalID.getTslen(), oduSignalID.getTsmap());
            builder.add(modL1OduSignalId(oduSignalId));
            break;
        case EXP_OCH_SIG_ID:
            try {
                @SuppressWarnings("unchecked")
                OFOxm<CircuitSignalID> ochId = (OFOxm<CircuitSignalID>) oxm;
                CircuitSignalID circuitSignalID = ochId.getValue();
                builder.add(modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
            } catch (NoMappingFoundException e) {
                log.warn(e.getMessage());
                break;
            }
            break;
        case ARP_OP:
        case ARP_SHA:
        case ARP_SPA:
        case ARP_THA:
        case ARP_TPA:
        case BSN_EGR_PORT_GROUP_ID:
        case BSN_GLOBAL_VRF_ALLOWED:
        case BSN_IN_PORTS_128:
        case BSN_L3_DST_CLASS_ID:
        case BSN_L3_INTERFACE_CLASS_ID:
        case BSN_L3_SRC_CLASS_ID:
        case BSN_LAG_ID:
        case BSN_TCP_FLAGS:
        case BSN_UDF0:
        case BSN_UDF1:
        case BSN_UDF2:
        case BSN_UDF3:
        case BSN_UDF4:
        case BSN_UDF5:
        case BSN_UDF6:
        case BSN_UDF7:
        case BSN_VLAN_XLATE_PORT_GROUP_ID:
        case BSN_VRF:
        case ETH_TYPE:
        case ICMPV4_CODE:
        case ICMPV4_TYPE:
        case ICMPV6_CODE:
        case ICMPV6_TYPE:
        case IN_PHY_PORT:
        case IN_PORT:
        case IPV6_DST:
        case IPV6_FLABEL:
        case IPV6_ND_SLL:
        case IPV6_ND_TARGET:
        case IPV6_ND_TLL:
        case IPV6_SRC:
        case IP_DSCP:
        case IP_ECN:
        case IP_PROTO:
        case METADATA:
        case MPLS_TC:
        case OCH_SIGID:
        case OCH_SIGID_BASIC:
        case OCH_SIGTYPE:
        case OCH_SIGTYPE_BASIC:
        case SCTP_DST:
        case SCTP_SRC:
        case EXP_ODU_SIGTYPE:
        case EXP_OCH_SIGTYPE:
        default:
            log.warn("Set field type {} not yet implemented.", oxm.getMatchField().id);
            break;
    }
}
#end_block

#method_before
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                builder.matchEthDst(mac);
                break;
            case ETH_SRC:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                builder.matchEthSrc(mac);
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                builder.matchEthType((short) ethType);
                break;
            case VLAN_VID:
                VlanId vlanId = null;
                if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                    Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                    if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                        vlanId = VlanId.ANY;
                    }
                } else {
                    if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                        vlanId = VlanId.NONE;
                    } else {
                        vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                    }
                }
                if (vlanId != null) {
                    builder.matchVlanId(vlanId);
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc(TpPort.tpPort(match.get(MatchField.TCP_SRC).getPort()));
                break;
            case TCP_DST:
                builder.matchTcpDst(TpPort.tpPort(match.get(MatchField.TCP_DST).getPort()));
                break;
            case UDP_SRC:
                builder.matchUdpSrc(TpPort.tpPort(match.get(MatchField.UDP_SRC).getPort()));
                break;
            case UDP_DST:
                builder.matchUdpDst(TpPort.tpPort(match.get(MatchField.UDP_DST).getPort()));
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case MPLS_BOS:
                builder.matchMplsBos(match.get(MatchField.MPLS_BOS).getValue());
                break;
            case SCTP_SRC:
                builder.matchSctpSrc(TpPort.tpPort(match.get(MatchField.SCTP_SRC).getPort()));
                break;
            case SCTP_DST:
                builder.matchSctpDst(TpPort.tpPort(match.get(MatchField.SCTP_DST).getPort()));
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case EXP_OCH_SIG_ID:
                try {
                    CircuitSignalID expSigId = match.get(MatchField.EXP_OCH_SIG_ID);
                    builder.add(matchLambda(Lambda.ochSignal(lookupGridType(expSigId.getGridType()), lookupChannelSpacing(expSigId.getChannelSpacing()), expSigId.getChannelNumber(), expSigId.getSpectralWidth())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_OCH_SIGTYPE:
                try {
                    U8 expOchSigType = match.get(MatchField.EXP_OCH_SIGTYPE);
                    builder.add(matchOchSignalType(lookupOchSignalType((byte) expOchSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_ODU_SIG_ID:
                OduSignalId oduSignalId = OduSignalId.oduSignalId(match.get(MatchField.EXP_ODU_SIG_ID).getTpn(), match.get(MatchField.EXP_ODU_SIG_ID).getTslen(), match.get(MatchField.EXP_ODU_SIG_ID).getTsmap());
                builder.add(matchOduSignalId(oduSignalId));
                break;
            case EXP_ODU_SIGTYPE:
                try {
                    U8 oduSigType = match.get(MatchField.EXP_ODU_SIGTYPE);
                    builder.add(matchOduSignalType(lookupOduSignalType((byte) oduSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#method_after
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    Ip4Address ip;
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                builder.matchEthDst(mac);
                break;
            case ETH_SRC:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                builder.matchEthSrc(mac);
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                builder.matchEthType((short) ethType);
                break;
            case VLAN_VID:
                VlanId vlanId = null;
                if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                    Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                    if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                        vlanId = VlanId.ANY;
                    }
                } else {
                    if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                        vlanId = VlanId.NONE;
                    } else {
                        vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                    }
                }
                if (vlanId != null) {
                    builder.matchVlanId(vlanId);
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc(TpPort.tpPort(match.get(MatchField.TCP_SRC).getPort()));
                break;
            case TCP_DST:
                builder.matchTcpDst(TpPort.tpPort(match.get(MatchField.TCP_DST).getPort()));
                break;
            case UDP_SRC:
                builder.matchUdpSrc(TpPort.tpPort(match.get(MatchField.UDP_SRC).getPort()));
                break;
            case UDP_DST:
                builder.matchUdpDst(TpPort.tpPort(match.get(MatchField.UDP_DST).getPort()));
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case MPLS_BOS:
                builder.matchMplsBos(match.get(MatchField.MPLS_BOS).getValue());
                break;
            case SCTP_SRC:
                builder.matchSctpSrc(TpPort.tpPort(match.get(MatchField.SCTP_SRC).getPort()));
                break;
            case SCTP_DST:
                builder.matchSctpDst(TpPort.tpPort(match.get(MatchField.SCTP_DST).getPort()));
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case EXP_OCH_SIG_ID:
                try {
                    CircuitSignalID expSigId = match.get(MatchField.EXP_OCH_SIG_ID);
                    builder.add(matchLambda(Lambda.ochSignal(lookupGridType(expSigId.getGridType()), lookupChannelSpacing(expSigId.getChannelSpacing()), expSigId.getChannelNumber(), expSigId.getSpectralWidth())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_OCH_SIGTYPE:
                try {
                    U8 expOchSigType = match.get(MatchField.EXP_OCH_SIGTYPE);
                    builder.add(matchOchSignalType(lookupOchSignalType((byte) expOchSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_ODU_SIG_ID:
                OduSignalId oduSignalId = OduSignalId.oduSignalId(match.get(MatchField.EXP_ODU_SIG_ID).getTpn(), match.get(MatchField.EXP_ODU_SIG_ID).getTslen(), match.get(MatchField.EXP_ODU_SIG_ID).getTsmap());
                builder.add(matchOduSignalId(oduSignalId));
                break;
            case EXP_ODU_SIGTYPE:
                try {
                    U8 oduSigType = match.get(MatchField.EXP_ODU_SIGTYPE);
                    builder.add(matchOduSignalType(lookupOduSignalType((byte) oduSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_OP:
                int arpOp = match.get(MatchField.ARP_OP).getOpcode();
                builder.matchArpOp(arpOp);
                break;
            case ARP_SHA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_SHA).getLong());
                builder.matchArpSha(mac);
                break;
            case ARP_SPA:
                ip = Ip4Address.valueOf(match.get(MatchField.ARP_SPA).getInt());
                builder.matchArpSpa(ip);
                break;
            case ARP_THA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_THA).getLong());
                builder.matchArpTha(mac);
                break;
            case ARP_TPA:
                ip = Ip4Address.valueOf(match.get(MatchField.ARP_TPA).getInt());
                builder.matchArpTpa(ip);
                break;
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#end_block

#method_before
private OFAction buildL3Modification(Instruction i) {
    L3ModificationInstruction l3m = (L3ModificationInstruction) i;
    ModIPInstruction ip;
    Ip4Address ip4;
    Ip6Address ip6;
    OFOxm<?> oxm = null;
    switch(l3m.subtype()) {
        case IPV4_SRC:
            ip = (ModIPInstruction) i;
            ip4 = ip.ip().getIp4Address();
            oxm = factory().oxms().ipv4Src(IPv4Address.of(ip4.toInt()));
            break;
        case IPV4_DST:
            ip = (ModIPInstruction) i;
            ip4 = ip.ip().getIp4Address();
            oxm = factory().oxms().ipv4Dst(IPv4Address.of(ip4.toInt()));
            break;
        case IPV6_SRC:
            ip = (ModIPInstruction) i;
            ip6 = ip.ip().getIp6Address();
            oxm = factory().oxms().ipv6Src(IPv6Address.of(ip6.toOctets()));
            break;
        case IPV6_DST:
            ip = (ModIPInstruction) i;
            ip6 = ip.ip().getIp6Address();
            oxm = factory().oxms().ipv6Dst(IPv6Address.of(ip6.toOctets()));
            break;
        case IPV6_FLABEL:
            ModIPv6FlowLabelInstruction flowLabelInstruction = (ModIPv6FlowLabelInstruction) i;
            int flowLabel = flowLabelInstruction.flowLabel();
            oxm = factory().oxms().ipv6Flabel(IPv6FlowLabel.of(flowLabel));
            break;
        case ETH_SRC_ARP:
            ModEthArpInstruction ei = (ModEthArpInstruction) i;
            oxm = factory().oxms().arpSha(MacAddress.of(ei.mac().toLong()));
            break;
        case IPV4_SRC_ARP:
            ip = (ModIPInstruction) i;
            ip4 = ip.ip().getIp4Address();
            oxm = factory().oxms().arpSpa(IPv4Address.of(ip4.toInt()));
            break;
        case ARP_OP:
            ModArpOpInstruction oi = (ModArpOpInstruction) i;
            oxm = factory().oxms().arpOp(ArpOpcode.of((int) oi.op()));
            break;
        case DEC_TTL:
            return factory().actions().decNwTtl();
        case TTL_IN:
            return factory().actions().copyTtlIn();
        case TTL_OUT:
            return factory().actions().copyTtlOut();
        default:
            log.warn("Unimplemented action type {}.", l3m.subtype());
            break;
    }
    if (oxm != null) {
        return factory().actions().buildSetField().setField(oxm).build();
    }
    return null;
}
#method_after
private OFAction buildL3Modification(Instruction i) {
    L3ModificationInstruction l3m = (L3ModificationInstruction) i;
    ModIPInstruction ip;
    Ip4Address ip4;
    Ip6Address ip6;
    OFOxm<?> oxm = null;
    switch(l3m.subtype()) {
        case IPV4_SRC:
            ip = (ModIPInstruction) i;
            ip4 = ip.ip().getIp4Address();
            oxm = factory().oxms().ipv4Src(IPv4Address.of(ip4.toInt()));
            break;
        case IPV4_DST:
            ip = (ModIPInstruction) i;
            ip4 = ip.ip().getIp4Address();
            oxm = factory().oxms().ipv4Dst(IPv4Address.of(ip4.toInt()));
            break;
        case IPV6_SRC:
            ip = (ModIPInstruction) i;
            ip6 = ip.ip().getIp6Address();
            oxm = factory().oxms().ipv6Src(IPv6Address.of(ip6.toOctets()));
            break;
        case IPV6_DST:
            ip = (ModIPInstruction) i;
            ip6 = ip.ip().getIp6Address();
            oxm = factory().oxms().ipv6Dst(IPv6Address.of(ip6.toOctets()));
            break;
        case IPV6_FLABEL:
            ModIPv6FlowLabelInstruction flowLabelInstruction = (ModIPv6FlowLabelInstruction) i;
            int flowLabel = flowLabelInstruction.flowLabel();
            oxm = factory().oxms().ipv6Flabel(IPv6FlowLabel.of(flowLabel));
            break;
        case ARP_SPA:
            ModArpIPInstruction aip = (ModArpIPInstruction) i;
            ip4 = aip.ip().getIp4Address();
            oxm = factory().oxms().arpSpa(IPv4Address.of(ip4.toInt()));
            break;
        case ARP_SHA:
            ModArpEthInstruction ei = (ModArpEthInstruction) i;
            oxm = factory().oxms().arpSha(MacAddress.of(ei.mac().toLong()));
            break;
        case ARP_OP:
            ModArpOpInstruction oi = (ModArpOpInstruction) i;
            oxm = factory().oxms().arpOp(ArpOpcode.of((int) oi.op()));
            break;
        case DEC_TTL:
            return factory().actions().decNwTtl();
        case TTL_IN:
            return factory().actions().copyTtlIn();
        case TTL_OUT:
            return factory().actions().copyTtlOut();
        default:
            log.warn("Unimplemented action type {}.", l3m.subtype());
            break;
    }
    if (oxm != null) {
        return factory().actions().buildSetField().setField(oxm).build();
    }
    return null;
}
#end_block

#method_before
@Override
public boolean supported(ExtensionTreatmentType extensionTreatmentType) {
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SHA_TO_THA)) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA)) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST)) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST)) {
        return true;
    }
    return false;
}
#method_after
@Override
public boolean supported(ExtensionTreatmentType extensionTreatmentType) {
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SHA_TO_THA.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST.type())) {
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SHA_TO_THA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST.type())) {
    // TODO this will be implemented later
    }
    return null;
}
#method_after
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST.type())) {
    // TODO this will be implemented later
    }
    return null;
}
#end_block

#method_before
@Override
public ExtensionTreatment getExtensionInstruction(ExtensionTreatmentType type) {
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return new NiciraSetTunnelDst();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return new NiciraResubmit();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SHA_TO_THA.type())) {
        return new NiciraMovArpShaToTha();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA.type())) {
        return new NiciraMovArpSpaToTpa();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type())) {
        return new NiciraMovEthSrcToDst();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST.type())) {
        return new NiciraMovIpSrcToDst();
    }
    throw new UnsupportedOperationException("Driver does not support extension type " + type.toString());
}
#method_after
@Override
public ExtensionTreatment getExtensionInstruction(ExtensionTreatmentType type) {
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return new NiciraSetTunnelDst();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return new NiciraResubmit();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        return new NiciraResubmitTable();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        return new NiciraSetNshSpi();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
        return new NiciraSetNshSi();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
        return new NiciraSetNshContextHeader(type);
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SHA_TO_THA.type())) {
        return NiciraMoveTreatmentFactory.createNiciraMovArpShaToTha();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA.type())) {
        return NiciraMoveTreatmentFactory.createNiciraMovArpSpaToTpa();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type())) {
        return NiciraMoveTreatmentFactory.createNiciraMovEthSrcToDst();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST.type())) {
        return NiciraMoveTreatmentFactory.createNiciraMovIpSrcToDst();
    }
    throw new UnsupportedOperationException("Driver does not support extension type " + type.toString());
}
#end_block

#method_before
private SinglePointToMultiPointIntent buildBrcIntent(Key key, ConnectPoint src, Set<ConnectPoint> dsts, VlanId vlanId) {
    SinglePointToMultiPointIntent intent;
    TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment();
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).matchVlanId(vlanId);
    TrafficSelector selector = builder.build();
    intent = SinglePointToMultiPointIntent.builder().appId(APPID).key(key).selector(selector).treatment(treatment).ingressPoint(src).egressPoints(dsts).priority(PRIORITY_OFFSET).build();
    return intent;
}
#method_after
private SinglePointToMultiPointIntent buildBrcIntent(Key key, ConnectPoint src, Set<ConnectPoint> dsts, VlanId vlanId) {
    SinglePointToMultiPointIntent intent;
    TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment();
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).matchVlanId(vlanId).build();
    intent = SinglePointToMultiPointIntent.builder().appId(APPID).key(key).selector(selector).treatment(treatment).ingressPoint(src).egressPoints(dsts).priority(PRIORITY_OFFSET).build();
    return intent;
}
#end_block

#method_before
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw, Set<DeviceId> nextHops) {
    boolean result;
    if (nextHops.isEmpty()) {
        nextHops.add(destSw);
    }
    // If both target switch and dest switch are edge routers, then set IP
    // rule for both subnet and router IP.
    boolean targetIsEdge;
    boolean destIsEdge;
    Ip4Address destRouterIp;
    try {
        targetIsEdge = config.isEdgeDevice(targetSw);
        destIsEdge = config.isEdgeDevice(destSw);
        destRouterIp = config.getRouterIp(destSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateEcmpRoutingRulePartial.");
        return false;
    }
    if (targetIsEdge && destIsEdge) {
        Set<Ip4Prefix> subnets = config.getSubnets(destSw);
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for subnets {}", targetSw, destSw, subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw, nextHops);
        if (!result) {
            return false;
        }
        Ip4Address routerIp = destRouterIp;
        IpPrefix routerIpPrefix = IpPrefix.valueOf(routerIp, IpPrefix.MAX_INET_MASK_LENGTH);
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
    // If the target switch is an edge router, then set IP rules for the router IP.
    } else if (targetIsEdge) {
        Ip4Address routerIp = destRouterIp;
        IpPrefix routerIpPrefix = IpPrefix.valueOf(routerIp, IpPrefix.MAX_INET_MASK_LENGTH);
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
    }
    // Populates MPLS rules to all routers
    log.debug("* populateEcmpRoutingRulePartial in device{} towards {} for all MPLS rules", targetSw, destSw);
    result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops);
    if (!result) {
        return false;
    }
    return true;
}
#method_after
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw, Set<DeviceId> nextHops) {
    boolean result;
    if (nextHops.isEmpty()) {
        nextHops.add(destSw);
    }
    // If both target switch and dest switch are edge routers, then set IP
    // rule for both subnet and router IP.
    boolean targetIsEdge;
    boolean destIsEdge;
    Ip4Address destRouterIp;
    try {
        targetIsEdge = config.isEdgeDevice(targetSw);
        destIsEdge = config.isEdgeDevice(destSw);
        destRouterIp = config.getRouterIp(destSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateEcmpRoutingRulePartial.");
        return false;
    }
    if (targetIsEdge && destIsEdge) {
        Set<Ip4Prefix> subnets = config.getSubnets(destSw);
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for subnets {}", targetSw, destSw, subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw, nextHops);
        if (!result) {
            return false;
        }
        Ip4Address routerIp = destRouterIp;
        IpPrefix routerIpPrefix = IpPrefix.valueOf(routerIp, IpPrefix.MAX_INET_MASK_LENGTH);
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
    } else if (targetIsEdge) {
        // If the target switch is an edge router, then set IP rules for the router IP.
        Ip4Address routerIp = destRouterIp;
        IpPrefix routerIpPrefix = IpPrefix.valueOf(routerIp, IpPrefix.MAX_INET_MASK_LENGTH);
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
    }
    // Populates MPLS rules to all routers
    log.debug("* populateEcmpRoutingRulePartial in device{} towards {} for all MPLS rules", targetSw, destSw);
    result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops);
    if (!result) {
        return false;
    }
    return true;
}
#end_block

#method_before
public int getNextObjectiveId(DeviceId deviceId, NeighborSet ns) {
    if (groupHandlerMap.get(deviceId) != null) {
        log.trace("getNextObjectiveId query in device {}", deviceId);
        return groupHandlerMap.get(deviceId).getNextObjectiveId(ns);
    } else {
        log.warn("getNextObjectiveId query in device {} not found", deviceId);
        return -1;
    }
}
#method_after
public int getNextObjectiveId(DeviceId deviceId, NeighborSet ns, TrafficSelector meta) {
    if (groupHandlerMap.get(deviceId) != null) {
        log.trace("getNextObjectiveId query in device {}", deviceId);
        return groupHandlerMap.get(deviceId).getNextObjectiveId(ns, meta);
    } else {
        log.warn("getNextObjectiveId query in device {} not found", deviceId);
        return -1;
    }
}
#end_block

#method_before
private void processLinkAdded(Link link) {
    log.debug("A new link {} was added", link.toString());
    if (!deviceConfiguration.isConfigured(link.src().deviceId())) {
        log.warn("Source device of this link is not configured.");
        return;
    }
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.linkUp(link);
    } else {
        Device device = deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added " + "Notification without Device Added " + "event, still handling it");
            processDeviceAdded(device);
            groupHandler = groupHandlerMap.get(link.src().deviceId());
            groupHandler.linkUp(link);
        }
    }
    log.trace("Starting optimized route population process");
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null);
// log.trace("processLinkAdded: re-starting route population process");
// defaultRoutingHandler.startPopulationProcess();
}
#method_after
private void processLinkAdded(Link link) {
    log.debug("A new link {} was added", link.toString());
    if (!deviceConfiguration.isConfigured(link.src().deviceId())) {
        log.warn("Source device of this link is not configured.");
        return;
    }
    // Irrespective whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules.
    // Because in a multi-instance setup, instances can initiate
    // groups for any devices. Also the default TTP rules are needed
    // to be pushed before inserting any IP table entries for any device
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.linkUp(link, mastershipService.isLocalMaster(link.src().deviceId()));
    } else {
        Device device = deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added " + "Notification without Device Added " + "event, still handling it");
            processDeviceAdded(device);
            groupHandler = groupHandlerMap.get(link.src().deviceId());
            groupHandler.linkUp(link, mastershipService.isLocalMaster(device.id()));
        }
    }
    log.trace("Starting optimized route population process");
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null);
// log.trace("processLinkAdded: re-starting route population process");
// defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
public BasicHostConfig setIps(String ipAddresses) {
    return (BasicHostConfig) setOrClear(LOCATION, ipAddresses);
}
#method_after
public BasicHostConfig setIps(Set<IpAddress> ipAddresses) {
    return (BasicHostConfig) setOrClear(IPS, ipAddresses);
}
#end_block

#method_before
public boolean populateIpRuleForRouter(DeviceId deviceId, IpPrefix ipPrefix, DeviceId destSw, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        segmentId = config.getSegmentId(destSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateIpRuleForRouter.");
        return false;
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    sbuilder.matchIPDst(ipPrefix);
    sbuilder.matchEthType(Ethernet.TYPE_IPV4);
    TrafficSelector selector = sbuilder.build();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    NeighborSet ns;
    TrafficTreatment treatment;
    // is not set.
    if (nextHops.size() == 1 && nextHops.toArray()[0].equals(destSw)) {
        tbuilder.immediate().decNwTtl();
        ns = new NeighborSet(nextHops);
        treatment = tbuilder.build();
    } else {
        ns = new NeighborSet(nextHops, segmentId);
        treatment = null;
    }
    if (srManager.getNextObjectiveId(deviceId, ns) <= 0) {
        log.warn("No next objective in {} for ns: {}", deviceId, ns);
        return false;
    }
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(srManager.appId).makePermanent().nextStep(srManager.getNextObjectiveId(deviceId, ns)).withSelector(selector).withPriority(100).withFlag(ForwardingObjective.Flag.SPECIFIC);
    if (treatment != null) {
        fwdBuilder.withTreatment(treatment);
    }
    log.debug("Installing IPv4 forwarding objective " + "for router IP/subnet {} in switch {}", ipPrefix, deviceId);
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    rulePopulationCounter.incrementAndGet();
    return true;
}
#method_after
public boolean populateIpRuleForRouter(DeviceId deviceId, IpPrefix ipPrefix, DeviceId destSw, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        segmentId = config.getSegmentId(destSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateIpRuleForRouter.");
        return false;
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    sbuilder.matchIPDst(ipPrefix);
    sbuilder.matchEthType(Ethernet.TYPE_IPV4);
    TrafficSelector selector = sbuilder.build();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    NeighborSet ns;
    TrafficTreatment treatment;
    // is not set.
    if (nextHops.size() == 1 && nextHops.toArray()[0].equals(destSw)) {
        tbuilder.immediate().decNwTtl();
        ns = new NeighborSet(nextHops);
        treatment = tbuilder.build();
    } else {
        ns = new NeighborSet(nextHops, segmentId);
        treatment = null;
    }
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since neighbor sets are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    int nextId = srManager.getNextObjectiveId(deviceId, ns, metabuilder.build());
    if (nextId <= 0) {
        log.warn("No next objective in {} for ns: {}", deviceId, ns);
        return false;
    }
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(srManager.appId).makePermanent().nextStep(nextId).withSelector(selector).withPriority(100).withFlag(ForwardingObjective.Flag.SPECIFIC);
    if (treatment != null) {
        fwdBuilder.withTreatment(treatment);
    }
    log.debug("Installing IPv4 forwarding objective " + "for router IP/subnet {} in switch {}", ipPrefix, deviceId);
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    rulePopulationCounter.incrementAndGet();
    return true;
}
#end_block

#method_before
public boolean populateMplsRule(DeviceId deviceId, DeviceId destSwId, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        segmentId = config.getSegmentId(destSwId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateMplsRule.");
        return false;
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    List<ForwardingObjective.Builder> fwdObjBuilders = new ArrayList<>();
    // TODO Handle the case of Bos == false
    sbuilder.matchMplsLabel(MplsLabel.mplsLabel(segmentId));
    sbuilder.matchEthType(Ethernet.MPLS_UNICAST);
    // If the next hop is the destination router, do PHP
    if (nextHops.size() == 1 && destSwId.equals(nextHops.toArray()[0])) {
        log.debug("populateMplsRule: Installing MPLS forwarding objective for " + "label {} in switch {} with PHP", segmentId, deviceId);
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(deviceId, destSwId, nextHops, true, true);
        // TODO: Check with Sangho on why we need this
        ForwardingObjective.Builder fwdObjNoBosBuilder = getMplsForwardingObjective(deviceId, destSwId, nextHops, true, false);
        if (fwdObjBosBuilder != null) {
            fwdObjBuilders.add(fwdObjBosBuilder);
        } else {
            log.warn("Failed to set MPLS rules.");
            return false;
        }
    } else {
        log.debug("Installing MPLS forwarding objective for " + "label {} in switch {} without PHP", segmentId, deviceId);
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(deviceId, destSwId, nextHops, false, true);
        // TODO: Check with Sangho on why we need this
        ForwardingObjective.Builder fwdObjNoBosBuilder = getMplsForwardingObjective(deviceId, destSwId, nextHops, false, false);
        if (fwdObjBosBuilder != null) {
            fwdObjBuilders.add(fwdObjBosBuilder);
        } else {
            log.warn("Failed to set MPLS rules.");
            return false;
        }
    }
    TrafficSelector selector = sbuilder.build();
    for (ForwardingObjective.Builder fwdObjBuilder : fwdObjBuilders) {
        ((Builder) ((Builder) fwdObjBuilder.fromApp(srManager.appId).makePermanent()).withSelector(selector).withPriority(100)).withFlag(ForwardingObjective.Flag.SPECIFIC);
        srManager.flowObjectiveService.forward(deviceId, fwdObjBuilder.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
        rulePopulationCounter.incrementAndGet();
    }
    return true;
}
#method_after
public boolean populateMplsRule(DeviceId deviceId, DeviceId destSwId, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        segmentId = config.getSegmentId(destSwId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateMplsRule.");
        return false;
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    List<ForwardingObjective.Builder> fwdObjBuilders = new ArrayList<>();
    // TODO Handle the case of Bos == false
    sbuilder.matchEthType(Ethernet.MPLS_UNICAST);
    sbuilder.matchMplsLabel(MplsLabel.mplsLabel(segmentId));
    TrafficSelector selector = sbuilder.build();
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since mpls next-hops are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    // If the next hop is the destination router for the segment, do pop
    if (nextHops.size() == 1 && destSwId.equals(nextHops.toArray()[0])) {
        log.debug("populateMplsRule: Installing MPLS forwarding objective for " + "label {} in switch {} with pop", segmentId, deviceId);
        // bos pop case (php)
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(deviceId, nextHops, true, true, metabuilder.build());
        if (fwdObjBosBuilder == null) {
            return false;
        }
        fwdObjBuilders.add(fwdObjBosBuilder);
    // XXX not-bos pop case,  SR app multi-label not implemented yet
    /*ForwardingObjective.Builder fwdObjNoBosBuilder =
                    getMplsForwardingObjective(deviceId,
                                               nextHops,
                                               true,
                                               false);*/
    } else {
        // next hop is not destination, SR CONTINUE case (swap with self)
        log.debug("Installing MPLS forwarding objective for " + "label {} in switch {} without pop", segmentId, deviceId);
        // continue case with bos - this does get triggered in edge routers
        // and in core routers - driver can handle depending on availability
        // of MPLS ECMP or not
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(deviceId, nextHops, false, true, metabuilder.build());
        if (fwdObjBosBuilder == null) {
            return false;
        }
        fwdObjBuilders.add(fwdObjBosBuilder);
    // XXX continue case with not-bos - SR app multi label not implemented yet
    // also requires MPLS ECMP
    /*ForwardingObjective.Builder fwdObjNoBosBuilder =
                    getMplsForwardingObjective(deviceId,
                                               nextHops,
                                               false,
                                               false); */
    }
    for (ForwardingObjective.Builder fwdObjBuilder : fwdObjBuilders) {
        ((Builder) ((Builder) fwdObjBuilder.fromApp(srManager.appId).makePermanent()).withSelector(selector).withPriority(100)).withFlag(ForwardingObjective.Flag.SPECIFIC);
        srManager.flowObjectiveService.forward(deviceId, fwdObjBuilder.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
        rulePopulationCounter.incrementAndGet();
    }
    return true;
}
#end_block

#method_before
private ForwardingObjective.Builder getMplsForwardingObjective(DeviceId deviceId, DeviceId destSw, Set<DeviceId> nextHops, boolean phpRequired, boolean isBos) {
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.SPECIFIC);
    DeviceId nextHop = (DeviceId) nextHops.toArray()[0];
    boolean isEdge;
    MacAddress srcMac;
    MacAddress dstMac;
    try {
        isEdge = config.isEdgeDevice(deviceId);
        srcMac = config.getDeviceMac(deviceId);
        dstMac = config.getDeviceMac(nextHop);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting getMplsForwardingObjective");
        return null;
    }
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    if (phpRequired) {
        log.debug("getMplsForwardingObjective: php required");
        tbuilder.deferred().copyTtlIn();
        if (isBos) {
            tbuilder.deferred().popMpls(Ethernet.TYPE_IPV4).decNwTtl();
        } else {
            tbuilder.deferred().popMpls(Ethernet.MPLS_UNICAST).decMplsTtl();
        }
    } else {
        log.debug("getMplsForwardingObjective: php not required");
        tbuilder.deferred().decMplsTtl();
    }
    if (!isECMPSupportedInTransitRouter() && !isEdge) {
        PortNumber port = selectOnePort(deviceId, nextHops);
        if (port == null) {
            log.warn("No link from {} to {}", deviceId, nextHops);
            return null;
        }
        tbuilder.deferred().setEthSrc(srcMac).setEthDst(dstMac).setOutput(port);
        fwdBuilder.withTreatment(tbuilder.build());
    } else {
        NeighborSet ns = new NeighborSet(nextHops);
        fwdBuilder.withTreatment(tbuilder.build());
        fwdBuilder.nextStep(srManager.getNextObjectiveId(deviceId, ns));
    }
    return fwdBuilder;
}
#method_after
private ForwardingObjective.Builder getMplsForwardingObjective(DeviceId deviceId, Set<DeviceId> nextHops, boolean phpRequired, boolean isBos, TrafficSelector meta) {
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.SPECIFIC);
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    if (phpRequired) {
        // php case - pop should always be flow-action
        log.debug("getMplsForwardingObjective: php required");
        tbuilder.deferred().copyTtlIn();
        if (isBos) {
            tbuilder.deferred().popMpls(EthType.EtherType.IPV4.ethType()).decNwTtl();
        } else {
            tbuilder.deferred().popMpls(EthType.EtherType.MPLS_UNICAST.ethType()).decMplsTtl();
        }
    } else {
        // swap with self case - SR CONTINUE
        log.debug("getMplsForwardingObjective: php not required");
        tbuilder.deferred().decMplsTtl();
    }
    // All forwarding is via ECMP group, the metadata informs the driver
    // that the next-Objective will be used by MPLS flows. In other words,
    // MPLS ECMP is requested. It is up to the driver to decide if these
    // packets will be hashed or not.
    fwdBuilder.withTreatment(tbuilder.build());
    NeighborSet ns = new NeighborSet(nextHops);
    log.debug("Trying to get a nextObjid for mpls rule on device:{} to ns:{}", deviceId, ns);
    int nextId = srManager.getNextObjectiveId(deviceId, ns, meta);
    if (nextId <= 0) {
        log.warn("No next objective in {} for ns: {}", deviceId, ns);
        return null;
    }
    fwdBuilder.nextStep(nextId);
    return fwdBuilder;
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    if (coreService != null) {
        coreService.registerApplication(APP_ID, this::preDeactivate);
    }
    cfgService.registerProperties(getClass());
    ctrl.setConfigParams(context.getProperties());
    ctrl.start(agent, driverService);
}
#method_after
@Activate
public void activate(ComponentContext context) {
    coreService.registerApplication(APP_ID, this::preDeactivate);
    cfgService.registerProperties(getClass());
    ctrl.setConfigParams(context.getProperties());
    ctrl.start(agent, driverService);
}
#end_block

#method_before
@Override
public boolean supported(ExtensionTreatmentType extensionTreatmentType) {
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
        return true;
    }
    return false;
}
#method_after
@Override
public boolean supported(ExtensionTreatmentType extensionTreatmentType) {
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
    // TODO this will be implemented later
    }
    return null;
}
#method_after
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
    // TODO this will be implemented later
    }
    return null;
}
#end_block

#method_before
@Override
public ExtensionTreatment getExtensionInstruction(ExtensionTreatmentType type) {
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return new NiciraSetTunnelDst();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return new NiciraResubmit();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        return new NiciraSetNshSpi();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
        return new NiciraSetNshSi();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
        return new NiciraSetNshCh1();
    }
    throw new UnsupportedOperationException("Driver does not support extension type " + type.toString());
}
#method_after
@Override
public ExtensionTreatment getExtensionInstruction(ExtensionTreatmentType type) {
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return new NiciraSetTunnelDst();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return new NiciraResubmit();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        return new NiciraResubmitTable();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        return new NiciraSetNshSpi();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
        return new NiciraSetNshSi();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
        return new NiciraSetNshContextHeader(type);
    }
    throw new UnsupportedOperationException("Driver does not support extension type " + type.toString());
}
#end_block

#method_before
public static ResourcePath discrete(DeviceId device, Object... components) {
    return new Discrete(ImmutableList.builder().add(device).addAll(ImmutableList.copyOf(components)).build());
}
#method_after
public static ResourcePath discrete(DeviceId device, Object... components) {
    return new Discrete(ImmutableList.builder().add(device).add(components).build());
}
#end_block

#method_before
public static ResourcePath discrete(DeviceId device, PortNumber port, Object... components) {
    return new Discrete(ImmutableList.builder().add(device).add(port).addAll(ImmutableList.copyOf(components)).build());
}
#method_after
public static ResourcePath discrete(DeviceId device, PortNumber port, Object... components) {
    return new Discrete(ImmutableList.builder().add(device).add(port).add(components).build());
}
#end_block

#method_before
public static ResourcePath continuous(double value, DeviceId device, Object... components) {
    checkArgument(components.length > 0, "Length of components must be greater thant 0, but " + components.length);
    return new Continuous(ImmutableList.builder().add(device).addAll(ImmutableList.copyOf(components)).build(), value);
}
#method_after
public static ResourcePath continuous(double value, DeviceId device, Object... components) {
    checkArgument(components.length > 0, "Length of components must be greater thant 0, but " + components.length);
    return new Continuous(ImmutableList.builder().add(device).add(components).build(), value);
}
#end_block

#method_before
public static ResourcePath continuous(double value, DeviceId device, PortNumber port, Object... components) {
    return new Continuous(ImmutableList.builder().add(device).add(port).addAll(ImmutableList.copyOf(components)).build(), value);
}
#method_after
public static ResourcePath continuous(double value, DeviceId device, PortNumber port, Object... components) {
    return new Continuous(ImmutableList.builder().add(device).add(port).add(components).build(), value);
}
#end_block

#method_before
@Test
public void testKeySet() throws Exception {
    DefaultAsyncConsistentMap<TestData, TestData> map;
    String name = "map_name";
    Database database = new TestDatabase();
    Serializer serializer = Serializer.forTypes(TestData.class);
    map = new DefaultAsyncConsistentMap<>(name, APP_ID, database, serializer, false, false, false);
    map.put(KEY1A, VALUE2A);
    map.put(KEY1B, VALUE2A);
    assertEquals("Should contain 2 keys", 2, map.keySet().get().size());
}
#method_after
@Test
public void testKeySet() throws Exception {
    DefaultAsyncConsistentMap<TestData, TestData> map;
    String name = "map_name";
    Database database = new TestDatabase();
    Serializer serializer = Serializer.forTypes(TestData.class);
    map = new DefaultAsyncConsistentMap<>(name, APP_ID, database, serializer, false, false, false);
    map.put(KEY1A, VALUE2A);
    map.put(KEY1B, VALUE2A);
    Set<TestData> set = map.keySet().get();
    assertEquals("Should contain 2 keys", 2, set.size());
    assertThat(set.contains(KEY1A), is(true));
    assertThat(set.contains(KEY1B), is(true));
    assertThat(set.contains(new TestData("One", "a")), is(true));
}
#end_block

#method_before
@Override
public CompletableFuture<Set<K>> keySet() {
    final MeteringAgent.Context timer = monitor.startTimer(KEY_SET);
    return database.mapKeySet(name).thenApply(s -> s.stream().map(this::dK).collect(Collectors.toCollection(Sets::newIdentityHashSet))).whenComplete((r, e) -> timer.stop(e));
}
#method_after
@Override
public CompletableFuture<Set<K>> keySet() {
    final MeteringAgent.Context timer = monitor.startTimer(KEY_SET);
    return database.mapKeySet(name).thenApply(s -> newMappingKeySet(s)).whenComplete((r, e) -> timer.stop(e));
}
#end_block

#method_before
@Override
public CompletableFuture<Set<Entry<K, Versioned<V>>>> entrySet() {
    final MeteringAgent.Context timer = monitor.startTimer(ENTRY_SET);
    return database.mapEntrySet(name).whenComplete((r, e) -> timer.stop(e)).thenApply(s -> s.stream().map(this::mapRawEntry).collect(Collectors.toCollection(Sets::newIdentityHashSet)));
}
#method_after
@Override
public CompletableFuture<Set<Entry<K, Versioned<V>>>> entrySet() {
    final MeteringAgent.Context timer = monitor.startTimer(ENTRY_SET);
    return database.mapEntrySet(name).whenComplete((r, e) -> timer.stop(e)).thenApply(s -> newMappingEntrySet(s));
}
#end_block

#method_before
@Override
public boolean supported(ExtensionTreatmentType extensionTreatmentType) {
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        return true;
    }
    return false;
}
#method_after
@Override
public boolean supported(ExtensionTreatmentType extensionTreatmentType) {
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        return true;
    }
    if (extensionTreatmentType.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
    // TODO this will be implemented later
    }
    return null;
}
#method_after
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
    // TODO this will be implemented later
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
    // TODO this will be implemented later
    }
    return null;
}
#end_block

#method_before
@Override
public ExtensionTreatment getExtensionInstruction(ExtensionTreatmentType type) {
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return new NiciraSetTunnelDst();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return new NiciraResubmit();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        return new NiciraResubmitTable();
    }
    throw new UnsupportedOperationException("Driver does not support extension type " + type.toString());
}
#method_after
@Override
public ExtensionTreatment getExtensionInstruction(ExtensionTreatmentType type) {
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        return new NiciraSetTunnelDst();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        return new NiciraResubmit();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        return new NiciraSetNshSpi();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        return new NiciraResubmitTable();
    }
    throw new UnsupportedOperationException("Driver does not support extension type " + type.toString());
}
#end_block

#method_before
private OFAction buildModLambdaInstruction(ModLambdaInstruction instruction) {
    return factory().actions().circuit(factory().oxms().ochSigid(new CircuitSignalID((byte) 1, (byte) 2, instruction.lambda(), (short) 1)));
}
#method_after
private OFAction buildModLambdaInstruction(ModLambdaInstruction instruction) {
    return factory().actions().circuit(factory().oxms().expOchSigId(new CircuitSignalID((byte) 1, (byte) 2, instruction.lambda(), (short) 1)));
}
#end_block

#method_before
private OFAction buildModOchSignalInstruction(ModOchSignalInstruction instruction) {
    OchSignal signal = instruction.lambda();
    byte gridType = OpenFlowValueMapper.lookupGridType(signal.gridType());
    byte channelSpacing = OpenFlowValueMapper.lookupChannelSpacing(signal.channelSpacing());
    return factory().actions().circuit(factory().oxms().ochSigid(new CircuitSignalID(gridType, channelSpacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity())));
}
#method_after
private OFAction buildModOchSignalInstruction(ModOchSignalInstruction instruction) {
    OchSignal signal = instruction.lambda();
    byte gridType = OpenFlowValueMapper.lookupGridType(signal.gridType());
    byte channelSpacing = OpenFlowValueMapper.lookupChannelSpacing(signal.channelSpacing());
    return factory().actions().circuit(factory().oxms().expOchSigId(new CircuitSignalID(gridType, channelSpacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity())));
}
#end_block

#method_before
private OFAction buildExtensionAction(ExtensionInstruction i) {
    if (!driverService.isPresent()) {
        log.error("No driver service present");
        return null;
    }
    Driver driver = driverService.get().getDriver(deviceId);
    if (driver.hasBehaviour(ExtensionInterpreter.class)) {
        DefaultDriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
        ExtensionInterpreter interpreter = handler.behaviour(ExtensionInterpreter.class);
        return interpreter.mapInstruction(factory(), i);
    }
    return null;
}
#method_after
private OFAction buildExtensionAction(ExtensionTreatment i) {
    if (!driverService.isPresent()) {
        log.error("No driver service present");
        return null;
    }
    Driver driver = driverService.get().getDriver(deviceId);
    if (driver.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        DefaultDriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
        ExtensionTreatmentInterpreter interpreter = handler.behaviour(ExtensionTreatmentInterpreter.class);
        return interpreter.mapInstruction(factory(), i);
    }
    return null;
}
#end_block

#method_before
private HostId parseHost(JsonNode node) {
    MacAddress mac = MacAddress.valueOf(node.get("mac").asText());
    VlanId vlanId = VlanId.vlanId((short) node.get("vlan").asInt(VlanId.UNTAGGED));
    JsonNode locationNode = node.get("location");
    String deviceAndPort = locationNode.get("elementId").asText() + "/" + locationNode.get("port").asText();
    HostLocation hostLocation = new HostLocation(ConnectPoint.deviceConnectPoint(deviceAndPort), 0);
    Iterator<JsonNode> ipStrings = node.get("ipAddresses").elements();
    Set<IpAddress> ips = new HashSet<>();
    while (ipStrings.hasNext()) {
        ips.add(IpAddress.valueOf(ipStrings.next().asText()));
    }
    // try to remove elements from json node after reading them
    String[] removalKeys = { "mac", "vlan", "location", "ipAddresses" };
    SparseAnnotations annotations = annotations(removeElements(node, removalKeys));
    // Update host inventory
    HostId hostId = HostId.hostId(mac, vlanId);
    DefaultHostDescription desc = new DefaultHostDescription(mac, vlanId, hostLocation, ips, annotations);
    hostProviderService.hostDetected(hostId, desc);
    return hostId;
}
#method_after
private HostId parseHost(JsonNode node) {
    MacAddress mac = MacAddress.valueOf(node.get("mac").asText());
    VlanId vlanId = VlanId.vlanId((short) node.get("vlan").asInt(VlanId.UNTAGGED));
    JsonNode locationNode = node.get("location");
    String deviceAndPort = locationNode.get("elementId").asText() + "/" + locationNode.get("port").asText();
    HostLocation hostLocation = new HostLocation(ConnectPoint.deviceConnectPoint(deviceAndPort), 0);
    Iterator<JsonNode> ipStrings = node.get("ipAddresses").elements();
    Set<IpAddress> ips = new HashSet<>();
    while (ipStrings.hasNext()) {
        ips.add(IpAddress.valueOf(ipStrings.next().asText()));
    }
    // try to remove elements from json node after reading them
    SparseAnnotations annotations = annotations(removeElements(node, REMOVAL_KEYS));
    // Update host inventory
    HostId hostId = HostId.hostId(mac, vlanId);
    DefaultHostDescription desc = new DefaultHostDescription(mac, vlanId, hostLocation, ips, annotations);
    hostProviderService.hostDetected(hostId, desc);
    return hostId;
}
#end_block

#method_before
@Override
public void createBridge(String bridgeName) {
    log.debug("create bridge {}", bridgeName);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.warn("The schema is null");
        return;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    if (bridge == null) {
        log.debug("Can not create bridge");
        return;
    }
    Set<String> failModes = new HashSet<>();
    failModes.add("secure");
    bridge.setFailMode(failModes);
    Set<String> protocols = new HashSet<>();
    protocols.add(OvsdbConstant.OPENFLOW13);
    bridge.setProtocols(protocols);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (ovsUuid == null) {
        log.warn("The Open_vSwitch is null");
        return;
    }
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.debug("Create a new bridge");
        bridge.setName(bridgeName);
        bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
        if (bridgeUuid != null) {
            Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
            if (port != null) {
                log.debug("the port is not null");
                port.setName(bridgeName);
                insertConfig(OvsdbConstant.PORT, "_uuid", "Bridge", "ports", bridgeUuid, port.getRow());
            }
        } else {
            log.debug("Create new bridge failed");
            return;
        }
    } else {
        log.info("Update a bridge");
        updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid, bridge.getRow());
    }
    setControllerAuto(bridgeUuid);
    log.info("Create bridge success");
}
#method_after
@Override
public void createBridge(String bridgeName) {
    log.debug("create bridge {}", bridgeName);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.warn("The schema is null");
        return;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    if (bridge == null) {
        log.debug("Can not create bridge");
        return;
    }
    Set<String> failModes = new HashSet<>();
    failModes.add("secure");
    bridge.setFailMode(failModes);
    Set<String> protocols = new HashSet<>();
    protocols.add(OvsdbConstant.OPENFLOW13);
    bridge.setProtocols(protocols);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (ovsUuid == null) {
        log.warn("The Open_vSwitch is null");
        return;
    }
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.debug("Create a new bridge");
        bridge.setName(bridgeName);
        bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
        if (bridgeUuid != null) {
            Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
            if (port != null) {
                log.debug("the port is not null");
                port.setName(bridgeName);
                insertConfig(OvsdbConstant.PORT, "_uuid", "Bridge", "ports", bridgeUuid, port.getRow());
            }
        } else {
            String message = BridgeCreateException.createMessage(ovsUuid);
            throw new BridgeCreateException(message);
        }
    } else {
        log.info("Update a bridge");
        updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid, bridge.getRow());
    }
    setControllerAuto(bridgeUuid);
    log.info("Create bridge success");
}
#end_block

#method_before
@Override
public void createBridge(String bridgeName, String dpid, String exPortName) {
    log.debug("create bridge {}", bridgeName);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.warn("The schema is null");
        return;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    if (bridge == null) {
        log.debug("Can not create bridge");
        return;
    }
    Set<String> failModes = new HashSet<>();
    failModes.add("secure");
    bridge.setFailMode(failModes);
    Set<String> protocols = new HashSet<>();
    protocols.add(OvsdbConstant.OPENFLOW13);
    bridge.setProtocols(protocols);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (ovsUuid == null) {
        log.warn("The Open_vSwitch is null");
        return;
    }
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.debug("Create a new bridge");
        bridge.setName(bridgeName);
        if (dpid != null) {
            Map<String, String> options = new HashMap<>();
            options.put("datapath-id", dpid);
            bridge.setOtherConfig(options);
        }
        bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
        if (bridgeUuid != null) {
            Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
            if (port != null) {
                log.debug("the port is not null");
                port.setName(bridgeName);
                insertConfig(OvsdbConstant.PORT, "_uuid", "Bridge", "ports", bridgeUuid, port.getRow());
            }
        } else {
            log.debug("Create new bridge failed");
            return;
        }
    } else {
        log.info("Update a bridge");
        updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid, bridge.getRow());
    }
    // Create external port
    if (exPortName != null) {
        createPort(bridgeName, exPortName);
    }
    setControllerAuto(bridgeUuid);
    log.info("Create bridge success");
}
#method_after
@Override
public void createBridge(String bridgeName, String dpid, String exPortName) {
    log.debug("create bridge {}", bridgeName);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.warn("The schema is null");
        return;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    if (bridge == null) {
        log.debug("Can not create bridge");
        return;
    }
    Set<String> failModes = new HashSet<>();
    failModes.add("secure");
    bridge.setFailMode(failModes);
    Set<String> protocols = new HashSet<>();
    protocols.add(OvsdbConstant.OPENFLOW13);
    bridge.setProtocols(protocols);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (ovsUuid == null) {
        log.warn("The Open_vSwitch is null");
        return;
    }
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.debug("Create a new bridge");
        bridge.setName(bridgeName);
        if (dpid != null) {
            Map<String, String> options = new HashMap<>();
            options.put("datapath-id", dpid);
            bridge.setOtherConfig(options);
        }
        bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
        if (bridgeUuid != null) {
            Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
            if (port != null) {
                log.debug("the port is not null");
                port.setName(bridgeName);
                insertConfig(OvsdbConstant.PORT, "_uuid", "Bridge", "ports", bridgeUuid, port.getRow());
            }
        } else {
            String message = BridgeCreateException.createMessage(ovsUuid);
            throw new BridgeCreateException(message);
        }
    } else {
        log.info("Update a bridge");
        updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid, bridge.getRow());
    }
    // Create external port
    if (exPortName != null) {
        createPort(bridgeName, exPortName);
    }
    setControllerAuto(bridgeUuid);
    log.info("Create bridge success");
}
#end_block

#method_before
// SctpPortCriterion class
@Test
public void testTcpFlagsCriterionEquals() {
    new EqualsTester().addEqualityGroup(matchTcpFlags1, sameAsmatchTcpFlags1).addEqualityGroup(matchTcpFlags2).testEquals();
}
#method_after
// TcpFlagsCriterion class
@Test
public void testTcpFlagsCriterionEquals() {
    new EqualsTester().addEqualityGroup(matchTcpFlags1, sameAsmatchTcpFlags1).addEqualityGroup(matchTcpFlags2).testEquals();
}
#end_block

#method_before
@Test
public void testMatchSctpSrcMethod() {
    Criterion matchSctpSrc = Criteria.matchSctpSrc(tpPort1);
    SctpPortCriterion sctpPortCriterion = checkAndConvert(matchSctpSrc, Criterion.Type.SCTP_SRC, SctpPortCriterion.class);
    assertThat(sctpPortCriterion.sctpPort(), is(equalTo(tpPort1)));
}
#method_after
// SctpPortCriterion class
@Test
public void testMatchSctpSrcMethod() {
    Criterion matchSctpSrc = Criteria.matchSctpSrc(tpPort1);
    SctpPortCriterion sctpPortCriterion = checkAndConvert(matchSctpSrc, Criterion.Type.SCTP_SRC, SctpPortCriterion.class);
    assertThat(sctpPortCriterion.sctpPort(), is(equalTo(tpPort1)));
}
#end_block

#method_before
@Override
protected void execute() {
    RouterService service = get(RouterService.class);
    if (id == null || routerName == null || tenantId == null) {
        print(null, "id, routerName, tenantId can not be null");
        return;
    }
    try {
        List<String> routes = new ArrayList<String>();
        Router router = new DefaultRouter(RouterId.valueOf(id), routerName, adminStateUp, status == null ? Status.ACTIVE : Status.valueOf(status), distributed, null, VirtualPortId.portId(gatewayPortId), TenantId.tenantId(tenantId), routes);
        Set<Router> routerSet = Sets.newHashSet(router);
        service.createRouters(routerSet);
    } catch (Exception e) {
        print(null, e.getMessage());
    }
}
#method_after
@Override
protected void execute() {
    RouterService service = get(RouterService.class);
    try {
        List<String> routes = new ArrayList<String>();
        Router router = new DefaultRouter(RouterId.valueOf(id), routerName, adminStateUp, status == null ? Status.ACTIVE : Status.valueOf(status), distributed, null, VirtualPortId.portId(gatewayPortId), TenantId.tenantId(tenantId), routes);
        Set<Router> routerSet = Sets.newHashSet(router);
        service.createRouters(routerSet);
    } catch (Exception e) {
        print(null, e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void execute() {
    RouterService service = get(RouterService.class);
    if (id == null) {
        print(null, "id can not be null");
        return;
    }
    RouterId routerId = RouterId.valueOf(id);
    Router router = get(RouterService.class).getRouter(routerId);
    try {
        List<String> routes = new ArrayList<String>();
        Router routerObj = new DefaultRouter(RouterId.valueOf(id), routerName == null ? router.name() : routerName, adminStateUp, status == null ? Status.ACTIVE : Status.valueOf(status), distributed, null, gatewayPortId == null ? router.gatewayPortid() : VirtualPortId.portId(gatewayPortId), tenantId == null ? router.tenantId() : TenantId.tenantId(tenantId), routes);
        Set<Router> routerSet = Sets.newHashSet(routerObj);
        service.createRouters(routerSet);
    } catch (Exception e) {
        print(null, e.getMessage());
    }
}
#method_after
@Override
protected void execute() {
    RouterService service = get(RouterService.class);
    RouterId routerId = RouterId.valueOf(id);
    Router router = get(RouterService.class).getRouter(routerId);
    try {
        List<String> routes = new ArrayList<String>();
        Router routerObj = new DefaultRouter(RouterId.valueOf(id), routerName == null ? router.name() : routerName, adminStateUp, status == null ? Status.ACTIVE : Status.valueOf(status), distributed, null, gatewayPortId == null ? router.gatewayPortid() : VirtualPortId.portId(gatewayPortId), tenantId == null ? router.tenantId() : TenantId.tenantId(tenantId), routes);
        Set<Router> routerSet = Sets.newHashSet(routerObj);
        service.createRouters(routerSet);
    } catch (Exception e) {
        print(null, e.getMessage());
    }
}
#end_block

#method_before
@Override
public int compare(PathAttrNlriDetailsLocalRib pathNlriDetails1, PathAttrNlriDetailsLocalRib pathNlriDetails2) {
    if (pathNlriDetails1 == null) {
        return -1;
    }
    if (pathNlriDetails2 == null) {
        return 1;
    }
    if (pathNlriDetails1.equals(pathNlriDetails2)) {
        return 0;
    }
    log.debug("Decision log");
    LocalPref obj1LocPref = null;
    AsPath obj1Aspath = null;
    Origin obj1Origin = null;
    Med obj1Med = null;
    LocalPref obj2LocPref = null;
    AsPath obj2Aspath = null;
    Origin obj2Origin = null;
    Med obj2Med = null;
    List<BGPValueType> o1 = pathNlriDetails1.localRibNlridetails().pathAttributes();
    List<BGPValueType> o2 = pathNlriDetails2.localRibNlridetails().pathAttributes();
    ListIterator<BGPValueType> listIteratorObj1 = o1.listIterator();
    ListIterator<BGPValueType> listIteratorObj2 = o2.listIterator();
    while (listIteratorObj1.hasNext()) {
        BGPValueType pathAttributeObj1 = listIteratorObj1.next();
        switch(pathAttributeObj1.getType()) {
            case LocalPref.LOCAL_PREF_TYPE:
                obj1LocPref = (LocalPref) pathAttributeObj1;
                break;
            case AsPath.ASPATH_TYPE:
                obj1Aspath = (AsPath) pathAttributeObj1;
                break;
            case Origin.ORIGIN_TYPE:
                obj1Origin = (Origin) pathAttributeObj1;
                break;
            case Med.MED_TYPE:
                obj1Med = (Med) pathAttributeObj1;
                break;
            default:
                log.debug("Got other type, Not required: " + pathAttributeObj1.getType());
        }
    }
    while (listIteratorObj2.hasNext()) {
        BGPValueType pathAttributeObj2 = listIteratorObj2.next();
        switch(pathAttributeObj2.getType()) {
            case LocalPref.LOCAL_PREF_TYPE:
                obj2LocPref = (LocalPref) pathAttributeObj2;
                break;
            case AsPath.ASPATH_TYPE:
                obj2Aspath = (AsPath) pathAttributeObj2;
                break;
            case Origin.ORIGIN_TYPE:
                obj2Origin = (Origin) pathAttributeObj2;
                break;
            case Med.MED_TYPE:
                obj2Med = (Med) pathAttributeObj2;
                break;
            default:
                log.debug("Got other type, Not required: " + pathAttributeObj2.getType());
        }
    }
    // prefer attribute with higher local preference
    if (obj1LocPref != null || obj2LocPref != null && (obj1LocPref != null && !obj1LocPref.equals(obj2LocPref))) {
        return ((Integer) (obj1LocPref.localPref())).compareTo((Integer) (obj2LocPref.localPref()));
    }
    // prefer attribute with shortest Aspath
    if (!obj1Aspath.equals(obj2Aspath)) {
        Integer obj1Size = countASSize(obj1Aspath);
        Integer obj2Size = countASSize(obj2Aspath);
        if (obj1Size != obj2Size) {
            return obj1Size.compareTo(obj2Size);
        }
    }
    // prefer attribute with lowest origin type
    if (!obj1Origin.equals(obj2Origin)) {
        if (obj1Origin.origin() == ORIGINTYPE.IGP) {
            return 1;
        }
        if (obj2Origin.origin() == ORIGINTYPE.IGP) {
            return -1;
        }
        if (obj1Origin.origin() == ORIGINTYPE.EGP) {
            return 1;
        } else {
            return -1;
        }
    }
    // prefer attribute with lowest MED
    if (obj1Med != null || obj2Med != null && (obj1Med != null && !obj1Med.equals(obj2Med))) {
        return ((Integer) (obj2Med.med())).compareTo((Integer) (obj1Med.med()));
    }
    // consider EBGP over IBGP
    if ((pathNlriDetails1 != null || pathNlriDetails2 != null) && (pathNlriDetails1 != null && !pathNlriDetails1.equals(pathNlriDetails2))) {
        if (pathNlriDetails1.isLocalRibIbgpSession() != pathNlriDetails2.isLocalRibIbgpSession()) {
            if (pathNlriDetails1 == null || pathNlriDetails1.isLocalRibIbgpSession()) {
                return -1;
            }
            if (pathNlriDetails2 == null || pathNlriDetails2.isLocalRibIbgpSession()) {
                return 1;
            }
        }
        // prefer lowest BGP identifier value.
        if (pathNlriDetails1.localRibIdentifier() != pathNlriDetails2.localRibIdentifier()) {
            return ((Integer) pathNlriDetails2.localRibIdentifier()).compareTo(pathNlriDetails1.localRibIdentifier());
        }
        // prefer lowest peer address
        if (pathNlriDetails1.localRibIpAddress() != pathNlriDetails2.localRibIpAddress()) {
            return pathNlriDetails2.localRibIpAddress().compareTo(pathNlriDetails1.localRibIpAddress());
        }
    }
    return 0;
}
#method_after
@Override
public int compare(PathAttrNlriDetailsLocalRib pathNlriDetails1, PathAttrNlriDetailsLocalRib pathNlriDetails2) {
    if (pathNlriDetails1 == null) {
        return -1;
    }
    if (pathNlriDetails2 == null) {
        return 1;
    }
    if (pathNlriDetails1.equals(pathNlriDetails2)) {
        return 0;
    }
    List<BgpValueType> o1 = pathNlriDetails1.localRibNlridetails().pathAttributes();
    List<BgpValueType> o2 = pathNlriDetails2.localRibNlridetails().pathAttributes();
    ListIterator<BgpValueType> listIteratorObj1 = o1.listIterator();
    ListIterator<BgpValueType> listIteratorObj2 = o2.listIterator();
    storeAttr(listIteratorObj1, listIteratorObj2);
    // prefer attribute with higher local preference
    if (obj1LocPref != null || obj2LocPref != null && (obj1LocPref != null && !obj1LocPref.equals(obj2LocPref))) {
        return compareLocalPref(obj1LocPref, obj2LocPref);
    }
    // prefer attribute with shortest Aspath
    if (!obj1Aspath.equals(obj2Aspath)) {
        Integer obj1Size = countASSize(obj1Aspath);
        Integer obj2Size = countASSize(obj2Aspath);
        if (obj1Size != obj2Size) {
            return compareAsPath(obj1Size, obj2Size);
        }
    }
    // prefer attribute with lowest origin type
    if (!obj1Origin.equals(obj2Origin)) {
        return compareOrigin(obj1Origin, obj2Origin);
    }
    // prefer attribute with lowest MED
    if (obj1Med != null || obj2Med != null && (obj1Med != null && !obj1Med.equals(obj2Med))) {
        return compareMed(obj1Med, obj2Med);
    }
    if ((pathNlriDetails1 != null || pathNlriDetails2 != null) && (pathNlriDetails1 != null && !pathNlriDetails1.equals(pathNlriDetails2))) {
        return comparePeerDetails(pathNlriDetails1, pathNlriDetails2);
    }
    return 0;
}
#end_block

#method_before
@Activate
public void activate() {
    hostService.addListener(hostListener);
    floatingIpService.addListener(floatingIpListener);
    routerService.addListener(routerListener);
    routerInterfaceService.addListener(routerInterfaceListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(TenantId.class, DeviceId.class);
    l3vniMap = storageService.<TenantId, SegmentationId>eventuallyConsistentMapBuilder().withName("l3vniMap").withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    classifierOvsMap = storageService.<TenantId, Set<DeviceId>>eventuallyConsistentMapBuilder().withName("classifierOvsMap").withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    sffOvsMap = storageService.<TenantId, Set<DeviceId>>eventuallyConsistentMapBuilder().withName("sffOvsMap").withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
}
#method_after
@Activate
public void activate() {
    hostService.addListener(hostListener);
    floatingIpService.addListener(floatingIpListener);
    routerService.addListener(routerListener);
    routerInterfaceService.addListener(routerInterfaceListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(TenantId.class, DeviceId.class);
    l3vniMap = storageService.<TenantId, SegmentationId>eventuallyConsistentMapBuilder().withName(L3VNIMAP).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    classifierOvsMap = storageService.<TenantId, Set<DeviceId>>eventuallyConsistentMapBuilder().withName(CLASSIFIEROVSMAP).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    sffOvsMap = storageService.<TenantId, Set<DeviceId>>eventuallyConsistentMapBuilder().withName(SFFOVSMAP).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    hostService.removeListener(hostListener);
    floatingIpService.removeListener(floatingIpListener);
    routerService.removeListener(routerListener);
    routerInterfaceService.removeListener(routerInterfaceListener);
    l3vniMap.destroy();
    classifierOvsMap.destroy();
    sffOvsMap.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    hostService.removeListener(hostListener);
    floatingIpService.removeListener(floatingIpListener);
    routerService.removeListener(routerListener);
    routerInterfaceService.removeListener(routerInterfaceListener);
    l3vniMap.destroy();
    classifierOvsMap.destroy();
    sffOvsMap.destroy();
    listeners.clear();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void event(HostEvent event) {
    checkNotNull(event, EVENT_NOT_NULL);
    Host host = event.subject();
    String ifaceId = host.annotations().value(IFACEID);
    VirtualPortId hPortId = VirtualPortId.portId(ifaceId);
    TenantId tenantId = virtualPortService.getPort(hPortId).tenantId();
    DeviceId deviceId = host.location().deviceId();
    if (HostEvent.Type.HOST_ADDED == event.type()) {
        if (isServiceFunction(hPortId)) {
            addDeviceIdOfOvsMap(tenantId, deviceId, sffOvsMap);
        } else {
            addDeviceIdOfOvsMap(tenantId, deviceId, classifierOvsMap);
        }
    } else if (HostEvent.Type.HOST_REMOVED == event.type()) {
        if (isLastOneHostOfDevice(host, deviceId)) {
            if (isServiceFunction(hPortId)) {
                removeDeviceIdOfOvsMap(tenantId, deviceId, sffOvsMap);
            } else {
                removeDeviceIdOfOvsMap(tenantId, deviceId, classifierOvsMap);
            }
        }
    }
}
#method_after
@Override
public void event(HostEvent event) {
    checkNotNull(event, EVENT_NOT_NULL);
    Host host = event.subject();
    String ifaceId = host.annotations().value(IFACEID);
    VirtualPortId hPortId = VirtualPortId.portId(ifaceId);
    TenantId tenantId = virtualPortService.getPort(hPortId).tenantId();
    DeviceId deviceId = host.location().deviceId();
    if (HostEvent.Type.HOST_ADDED == event.type()) {
        if (isServiceFunction(hPortId)) {
            addDeviceIdOfOvsMap(tenantId, deviceId, sffOvsMap);
        } else {
            addDeviceIdOfOvsMap(tenantId, deviceId, classifierOvsMap);
        }
    } else if (HostEvent.Type.HOST_REMOVED == event.type()) {
        if (isLastSFHostOfTenant(host, deviceId, tenantId)) {
            removeDeviceIdOfOvsMap(tenantId, deviceId, sffOvsMap);
        }
        if (isLastClassifierHostOfTenant(host, deviceId, tenantId)) {
            removeDeviceIdOfOvsMap(tenantId, deviceId, classifierOvsMap);
        }
    }
}
#end_block

#method_before
@Override
public Iterator<Device> getClassifierOfTenant(TenantId tenantId) {
    checkNotNull(tenantId, TENANTID_NOT_NULL);
    Set<DeviceId> deviceIdSet = classifierOvsMap.get(tenantId);
    if (deviceIdSet != null) {
        Set<Device> deviceSet = new HashSet<>();
        for (DeviceId deviceId : deviceIdSet) {
            deviceSet.add(deviceService.getDevice(deviceId));
        }
        return deviceSet.iterator();
    } else {
        return null;
    }
}
#method_after
@Override
public Iterator<Device> getClassifierOfTenant(TenantId tenantId) {
    checkNotNull(tenantId, TENANTID_NOT_NULL);
    Set<DeviceId> deviceIdSet = classifierOvsMap.get(tenantId);
    Set<Device> deviceSet = new HashSet<>();
    if (deviceIdSet != null) {
        for (DeviceId deviceId : deviceIdSet) {
            deviceSet.add(deviceService.getDevice(deviceId));
        }
    }
    return deviceSet.iterator();
}
#end_block

#method_before
@Override
public Iterator<Device> getSFFOfTenant(TenantId tenantId) {
    checkNotNull(tenantId, TENANTID_NOT_NULL);
    Set<DeviceId> deviceIdSet = sffOvsMap.get(tenantId);
    if (deviceIdSet != null) {
        Set<Device> deviceSet = new HashSet<>();
        for (DeviceId deviceId : deviceIdSet) {
            deviceSet.add(deviceService.getDevice(deviceId));
        }
        return deviceSet.iterator();
    } else {
        return null;
    }
}
#method_after
@Override
public Iterator<Device> getSFFOfTenant(TenantId tenantId) {
    checkNotNull(tenantId, TENANTID_NOT_NULL);
    Set<DeviceId> deviceIdSet = sffOvsMap.get(tenantId);
    Set<Device> deviceSet = new HashSet<>();
    if (deviceIdSet != null) {
        for (DeviceId deviceId : deviceIdSet) {
            deviceSet.add(deviceService.getDevice(deviceId));
        }
    }
    return deviceSet.iterator();
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    routerInterfaceStore.removeListener(routerInterfaceListener);
    routerInterfaceStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    routerInterfaceStore.removeListener(routerInterfaceListener);
    routerInterfaceStore.destroy();
    listeners.clear();
    log.info("Stopped");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    routerStore.removeListener(routerListener);
    routerStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    routerStore.removeListener(routerListener);
    routerStore.destroy();
    listeners.clear();
    log.info("Stopped");
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(FlowClassifier.class);
    flowClassifierStore = storageService.<FlowClassifierId, FlowClassifier>eventuallyConsistentMapBuilder().withName("flowclassifierstore").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.info("Flow Classifier service activated");
}
#method_after
@Activate
protected void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(FlowClassifier.class);
    flowClassifierStore = storageService.<FlowClassifierId, FlowClassifier>eventuallyConsistentMapBuilder().withName("flowclassifierstore").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.info("Flow Classifier service activated");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    flowClassifierStore.destroy();
    log.info("Flow Classifier service deactivated");
}
#method_after
@Deactivate
protected void deactivate() {
    flowClassifierStore.destroy();
    log.info("Flow Classifier service deactivated");
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getFlowClassifiers() {
    final Iterable<FlowClassifier> flowClassifiers = service.getFlowClassifiers();
    ObjectNode result = new ObjectMapper().createObjectNode();
    ArrayNode flowClassifierEntry = result.putArray("flow_classifiers");
    if (flowClassifiers != null) {
        for (final FlowClassifier flowClassifier : flowClassifiers) {
            flowClassifierEntry.add(new FlowClassifierCodec().encode(flowClassifier, this));
        }
    }
    return ok(result.toString()).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getFlowClassifiers() {
    Iterable<FlowClassifier> flowClassifiers = get(FlowClassifierService.class).getFlowClassifiers();
    ObjectNode result = new ObjectMapper().createObjectNode();
    ArrayNode flowClassifierEntry = result.putArray("flow_classifiers");
    if (flowClassifiers != null) {
        for (final FlowClassifier flowClassifier : flowClassifiers) {
            flowClassifierEntry.add(new FlowClassifierCodec().encode(flowClassifier, this));
        }
    }
    return ok(result.toString()).build();
}
#end_block

#method_before
@GET
@Path("{flow_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getFlowClassifier(@PathParam("flow_id") String id) {
    if (!service.exists(FlowClassifierId.of(id))) {
        return Response.status(NOT_FOUND).entity(FLOW_CLASSIFIER_NOT_FOUND).build();
    }
    FlowClassifier flowClassifier = nullIsNotFound(service.getFlowClassifier(FlowClassifierId.of(id)), FLOW_CLASSIFIER_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("flow_classifier", new FlowClassifierCodec().encode(flowClassifier, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Path("{flow_id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getFlowClassifier(@PathParam("flow_id") String id) {
    FlowClassifier flowClassifier = nullIsNotFound(get(FlowClassifierService.class).getFlowClassifier(FlowClassifierId.of(id)), FLOW_CLASSIFIER_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("flow_classifier", new FlowClassifierCodec().encode(flowClassifier, this));
    return ok(result.toString()).build();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFlowClassifier(InputStream stream) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode jsonTree = (ObjectNode) mapper.readTree(stream);
        JsonNode flow = jsonTree.get("flow_classifier");
        FlowClassifier flowClassifier = new FlowClassifierCodec().decode((ObjectNode) flow, this);
        Boolean issuccess = nullIsNotFound(service.createFlowClassifier(flowClassifier), FLOW_CLASSIFIER_NOT_FOUND);
        return Response.status(OK).entity(issuccess.toString()).build();
    } catch (IOException ex) {
        log.error("Exception while creating flow classifier {}.", ex.toString());
        throw new IllegalArgumentException(ex);
    }
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFlowClassifier(InputStream stream) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode jsonTree = (ObjectNode) mapper.readTree(stream);
        JsonNode flow = jsonTree.get("flow_classifier");
        FlowClassifier flowClassifier = new FlowClassifierCodec().decode((ObjectNode) flow, this);
        Boolean issuccess = nullIsNotFound(get(FlowClassifierService.class).createFlowClassifier(flowClassifier), FLOW_CLASSIFIER_NOT_FOUND);
        return Response.status(OK).entity(issuccess.toString()).build();
    } catch (IOException ex) {
        log.error("Exception while creating flow classifier {}.", ex.toString());
        throw new IllegalArgumentException(ex);
    }
}
#end_block

#method_before
@PUT
@Path("{flow_id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updateFlowClassifier(@PathParam("flow_id") String id, final InputStream stream) {
    try {
        JsonNode jsonTree = mapper().readTree(stream);
        JsonNode flow = jsonTree.get("flow_classifier");
        FlowClassifier flowClassifier = new FlowClassifierCodec().decode((ObjectNode) flow, this);
        Boolean result = nullIsNotFound(service.updateFlowClassifier(flowClassifier), FLOW_CLASSIFIER_NOT_FOUND);
        return Response.status(OK).entity(result.toString()).build();
    } catch (IOException e) {
        log.error("Update flow classifier failed because of exception {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#method_after
@PUT
@Path("{flow_id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updateFlowClassifier(@PathParam("flow_id") String id, final InputStream stream) {
    try {
        JsonNode jsonTree = mapper().readTree(stream);
        JsonNode flow = jsonTree.get("flow_classifier");
        FlowClassifier flowClassifier = new FlowClassifierCodec().decode((ObjectNode) flow, this);
        Boolean result = nullIsNotFound(get(FlowClassifierService.class).updateFlowClassifier(flowClassifier), FLOW_CLASSIFIER_NOT_FOUND);
        return Response.status(OK).entity(result.toString()).build();
    } catch (IOException e) {
        log.error("Update flow classifier failed because of exception {}.", e.toString());
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@Path("{flow_id}")
@DELETE
public void deleteFlowClassifier(@PathParam("flow_id") String id) {
    log.debug("Deletes flow classifier by identifier {}.", id);
    FlowClassifierId flowClassifierId = FlowClassifierId.of(id);
    Boolean issuccess = nullIsNotFound(service.removeFlowClassifier(flowClassifierId), FLOW_CLASSIFIER_NOT_FOUND);
}
#method_after
@Path("{flow_id}")
@DELETE
public void deleteFlowClassifier(@PathParam("flow_id") String id) {
    log.debug("Deletes flow classifier by identifier {}.", id);
    FlowClassifierId flowClassifierId = FlowClassifierId.of(id);
    Boolean issuccess = nullIsNotFound(get(FlowClassifierService.class).removeFlowClassifier(flowClassifierId), FLOW_CLASSIFIER_NOT_FOUND);
}
#end_block

#method_before
@Override
public void programRules(DeviceId deviceId, SegmentationId matchVni, IpAddress srcIP, MacAddress ethDst, MacAddress ethSrc, IpAddress ipSrc, SegmentationId actionVni, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(matchVni.segmentationId())).matchIPSrc(IpPrefix.valueOf(srcIP, 32)).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.setEthDst(ethDst).setEthSrc(ethSrc).setIpSrc(ipSrc).setTunnelId(Long.parseLong(actionVni.segmentationId()));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(SNAT_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("RouteRules-->ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("RouteRules-->REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#method_after
@Override
public void programRules(DeviceId deviceId, SegmentationId matchVni, IpAddress srcIP, MacAddress ethDst, MacAddress ethSrc, IpAddress ipSrc, SegmentationId actionVni, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(matchVni.segmentationId())).matchIPSrc(IpPrefix.valueOf(srcIP, PREFIC_LENGTH)).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.setEthDst(ethDst).setEthSrc(ethSrc).setIpSrc(ipSrc).setTunnelId(Long.parseLong(actionVni.segmentationId()));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(SNAT_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("RouteRules-->ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("RouteRules-->REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#end_block

#method_before
@Override
public void programRules(DeviceId deviceId, IpAddress dstIp, MacAddress ethSrc, IpAddress ipDst, SegmentationId actionVni, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(dstIp, 32)).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.setEthSrc(ethSrc).setIpDst(ipDst).setTunnelId(Long.parseLong(actionVni.segmentationId()));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(DNAT_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("RouteRules-->ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("RouteRules-->REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#method_after
@Override
public void programRules(DeviceId deviceId, IpAddress dstIp, MacAddress ethSrc, IpAddress ipDst, SegmentationId actionVni, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(dstIp, PREFIX_LENGTH)).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.setEthSrc(ethSrc).setIpDst(ipDst).setTunnelId(Long.parseLong(actionVni.segmentationId()));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(DNAT_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("RouteRules-->ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("RouteRules-->REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#end_block

#method_before
@Override
public void programRouteRules(DeviceId deviceId, SegmentationId l3Vni, IpAddress dstVmIP, SegmentationId dstVni, MacAddress dstVmGwMac, MacAddress dstVmMac, Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(IP_TYPE).matchTunnelId(Long.parseLong(l3Vni.segmentationId())).matchIPDst(IpPrefix.valueOf(dstVmIP, 32)).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.setEthSrc(dstVmGwMac).setEthDst(dstVmMac).add(Instructions.modTunnelId(Long.parseLong(dstVni.segmentationId())));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(L3FWD_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("RouteRules-->ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("RouteRules-->REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#method_after
@Override
public void programRouteRules(DeviceId deviceId, SegmentationId l3Vni, IpAddress dstVmIP, SegmentationId dstVni, MacAddress dstVmGwMac, MacAddress dstVmMac, Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(IP_TYPE).matchTunnelId(Long.parseLong(l3Vni.segmentationId())).matchIPDst(IpPrefix.valueOf(dstVmIP, PREFIX_LENGTH)).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.setEthSrc(dstVmGwMac).setEthDst(dstVmMac).add(Instructions.modTunnelId(Long.parseLong(dstVni.segmentationId())));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(L3FWD_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("RouteRules-->ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("RouteRules-->REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(FlowClassifier.class);
    flowClassifierStore = storageService.<FlowClassifierId, FlowClassifier>eventuallyConsistentMapBuilder().withName("flowclassifierstore").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.info("Flow Classifier service activated");
}
#method_after
@Activate
protected void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(FlowClassifier.class);
    flowClassifierStore = storageService.<FlowClassifierId, FlowClassifier>eventuallyConsistentMapBuilder().withName("flowclassifierstore").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.info("Flow Classifier service activated");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    flowClassifierStore.destroy();
    log.info("Flow Classifier service deactivated");
}
#method_after
@Deactivate
protected void deactivate() {
    flowClassifierStore.destroy();
    log.info("Flow Classifier service deactivated");
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    classifierService = new ClassifierServiceImpl(appId);
    l2ForwardService = new L2ForwardServiceImpl(appId);
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(NetworkOfLocalHostPorts.class).register(TenantNetworkId.class).register(Host.class).register(TenantNetwork.class).register(TenantId.class).register(SubnetId.class);
    switchesOfController = storageService.<IpAddress, Boolean>eventuallyConsistentMapBuilder().withName(SWITCHES_OF_CONTROLLER).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    switchOfLocalHostPorts = storageService.<DeviceId, NetworkOfLocalHostPorts>consistentMapBuilder().withName(SWITCH_OF_LOCAL_HOST_PORTS).withSerializer(Serializer.using(serializer.build())).build();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    classifierService = new ClassifierServiceImpl(appId);
    l2ForwardService = new L2ForwardServiceImpl(appId);
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(NetworkOfLocalHostPorts.class).register(TenantNetworkId.class).register(Host.class).register(TenantNetwork.class).register(TenantId.class).register(SubnetId.class);
    switchesOfController = storageService.<IpAddress, Boolean>eventuallyConsistentMapBuilder().withName(SWITCHES_OF_CONTROLLER).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    switchOfLocalHostPorts = storageService.<DeviceId, NetworkOfLocalHostPorts>eventuallyConsistentMapBuilder().withName(SWITCH_OF_LOCAL_HOST_PORTS).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    log.info("Started");
}
#end_block

#method_before
private void applyTunnelOut(Device device, Objective.Operation type) {
    if (device == null) {
        log.error("The device is null");
        return;
    }
    if (!mastershipService.isLocalMaster(device.id())) {
        return;
    }
    String controllerIp = VtnData.getControllerIpOfSwitch(device);
    if (controllerIp == null) {
        log.error("Can't find controller of device: {}", device.id().toString());
        return;
    }
    IpAddress ipAddress = IpAddress.valueOf(controllerIp);
    if (!switchesOfController.containsKey(ipAddress)) {
        log.error("Can't find controller of device: {}", device.id().toString());
        return;
    }
    if (type == Objective.Operation.ADD) {
        switchOfLocalHostPorts.put(device.id(), new NetworkOfLocalHostPorts());
    } else if (type == Objective.Operation.REMOVE) {
        switchOfLocalHostPorts.remove(device.id());
    }
    Iterable<Device> devices = deviceService.getAvailableDevices();
    DeviceId localControllerId = VtnData.getControllerId(device, devices);
    DriverHandler handler = driverService.createHandler(localControllerId);
    Set<PortNumber> ports = VtnConfig.getPortNumbers(handler);
    Iterable<Host> allHosts = hostService.getHosts();
    if (allHosts != null) {
        Sets.newHashSet(allHosts).stream().forEach(host -> {
            MacAddress hostMac = host.mac();
            String ifaceId = host.annotations().value(IFACEID);
            if (ifaceId == null) {
                log.error("The ifaceId of Host is null");
                return;
            }
            VirtualPortId virtualPortId = VirtualPortId.portId(ifaceId);
            VirtualPort virtualPort = virtualPortService.getPort(virtualPortId);
            TenantNetwork network = tenantNetworkService.getNetwork(virtualPort.networkId());
            SegmentationId segmentationId = network.segmentationId();
            DeviceId remoteDeviceId = host.location().deviceId();
            Device remoteDevice = deviceService.getDevice(remoteDeviceId);
            String remoteControllerIp = VtnData.getControllerIpOfSwitch(remoteDevice);
            if (remoteControllerIp == null) {
                log.error("Can't find remote controller of device: {}", remoteDeviceId.toString());
                return;
            }
            IpAddress remoteIpAddress = IpAddress.valueOf(remoteControllerIp);
            String tunnelName = "vxlan-" + remoteIpAddress.toString();
            ports.stream().filter(p -> p.name().equalsIgnoreCase(tunnelName)).forEach(p -> {
                l2ForwardService.programTunnelOut(device.id(), segmentationId, p, hostMac, type);
            });
        });
    }
}
#method_after
private void applyTunnelOut(Device device, Objective.Operation type) {
    if (device == null) {
        log.error("The device is null");
        return;
    }
    if (!mastershipService.isLocalMaster(device.id())) {
        return;
    }
    String controllerIp = VtnData.getControllerIpOfSwitch(device);
    if (controllerIp == null) {
        log.error("Can't find controller of device: {}", device.id().toString());
        return;
    }
    IpAddress ipAddress = IpAddress.valueOf(controllerIp);
    if (!switchesOfController.containsKey(ipAddress)) {
        log.error("Can't find controller of device: {}", device.id().toString());
        return;
    }
    if (type == Objective.Operation.ADD) {
        switchOfLocalHostPorts.put(device.id(), new NetworkOfLocalHostPorts());
    } else if (type == Objective.Operation.REMOVE) {
        switchOfLocalHostPorts.remove(device.id());
    }
    Iterable<Device> devices = deviceService.getAvailableDevices();
    DeviceId localControllerId = VtnData.getControllerId(device, devices);
    DriverHandler handler = driverService.createHandler(localControllerId);
    Set<PortNumber> ports = VtnConfig.getPortNumbers(handler);
    Iterable<Host> allHosts = hostService.getHosts();
    String tunnelName = "vxlan-" + DEFAULT_IP;
    if (allHosts != null) {
        Sets.newHashSet(allHosts).stream().forEach(host -> {
            MacAddress hostMac = host.mac();
            String ifaceId = host.annotations().value(IFACEID);
            if (ifaceId == null) {
                log.error("The ifaceId of Host is null");
                return;
            }
            VirtualPortId virtualPortId = VirtualPortId.portId(ifaceId);
            VirtualPort virtualPort = virtualPortService.getPort(virtualPortId);
            TenantNetwork network = tenantNetworkService.getNetwork(virtualPort.networkId());
            SegmentationId segmentationId = network.segmentationId();
            DeviceId remoteDeviceId = host.location().deviceId();
            Device remoteDevice = deviceService.getDevice(remoteDeviceId);
            String remoteControllerIp = VtnData.getControllerIpOfSwitch(remoteDevice);
            if (remoteControllerIp == null) {
                log.error("Can't find remote controller of device: {}", remoteDeviceId.toString());
                return;
            }
            IpAddress remoteIpAddress = IpAddress.valueOf(remoteControllerIp);
            ports.stream().filter(p -> p.name().equalsIgnoreCase(tunnelName)).forEach(p -> {
                l2ForwardService.programTunnelOut(device.id(), segmentationId, p, hostMac, type, remoteIpAddress);
            });
        });
    }
}
#end_block

#method_before
private void applyHostMonitoredL2Rules(Host host, Objective.Operation type) {
    DeviceId deviceId = host.location().deviceId();
    if (!mastershipService.isLocalMaster(deviceId)) {
        return;
    }
    String ifaceId = host.annotations().value(IFACEID);
    if (ifaceId == null) {
        log.error("The ifaceId of Host is null");
        return;
    }
    VirtualPortId virtualPortId = VirtualPortId.portId(ifaceId);
    VirtualPort virtualPort = virtualPortService.getPort(virtualPortId);
    if (virtualPort == null) {
        log.error("The virtualPort of host is null");
        return;
    }
    Iterable<Device> devices = deviceService.getAvailableDevices();
    PortNumber inPort = host.location().port();
    MacAddress mac = host.mac();
    Device device = deviceService.getDevice(deviceId);
    String controllerIp = VtnData.getControllerIpOfSwitch(device);
    IpAddress ipAddress = IpAddress.valueOf(controllerIp);
    TenantNetwork network = tenantNetworkService.getNetwork(virtualPort.networkId());
    if (network == null) {
        log.error("Can't find network of the host");
        return;
    }
    SegmentationId segmentationId = network.segmentationId();
    // Get all the tunnel PortNumber in the current node
    Iterable<Port> ports = deviceService.getPorts(deviceId);
    Collection<PortNumber> localTunnelPorts = VtnData.getLocalTunnelPorts(ports);
    // Get all the local vm's PortNumber in the current node
    Map<TenantNetworkId, Set<PortNumber>> localHostPorts = switchOfLocalHostPorts.get(deviceId).value().getNetworkOfLocalHostPorts();
    Set<PortNumber> networkOflocalHostPorts = localHostPorts.get(network.id());
    for (PortNumber p : localTunnelPorts) {
        programGroupTable(deviceId, appId, p, devices, type);
    }
    if (type == Objective.Operation.ADD) {
        if (networkOflocalHostPorts == null) {
            networkOflocalHostPorts = new HashSet<PortNumber>();
            localHostPorts.putIfAbsent(network.id(), networkOflocalHostPorts);
        }
        networkOflocalHostPorts.add(inPort);
        l2ForwardService.programLocalBcastRules(deviceId, segmentationId, inPort, networkOflocalHostPorts, localTunnelPorts, type);
        classifierService.programTunnelIn(deviceId, segmentationId, localTunnelPorts, type);
    } else if (type == Objective.Operation.REMOVE) {
        if (networkOflocalHostPorts != null) {
            l2ForwardService.programLocalBcastRules(deviceId, segmentationId, inPort, networkOflocalHostPorts, localTunnelPorts, type);
            networkOflocalHostPorts.remove(inPort);
            if (networkOflocalHostPorts.isEmpty()) {
                classifierService.programTunnelIn(deviceId, segmentationId, localTunnelPorts, type);
                switchOfLocalHostPorts.get(deviceId).value().getNetworkOfLocalHostPorts().remove(virtualPort.networkId());
            }
        }
    }
    l2ForwardService.programLocalOut(deviceId, segmentationId, inPort, mac, type);
    l2ForwardService.programTunnelBcastRules(deviceId, segmentationId, networkOflocalHostPorts, localTunnelPorts, type);
    programTunnelOuts(devices, ipAddress, segmentationId, mac, type);
    classifierService.programLocalIn(deviceId, segmentationId, inPort, mac, appId, type);
}
#method_after
private void applyHostMonitoredL2Rules(Host host, Objective.Operation type) {
    DeviceId deviceId = host.location().deviceId();
    if (!mastershipService.isLocalMaster(deviceId)) {
        return;
    }
    String ifaceId = host.annotations().value(IFACEID);
    if (ifaceId == null) {
        log.error("The ifaceId of Host is null");
        return;
    }
    VirtualPortId virtualPortId = VirtualPortId.portId(ifaceId);
    VirtualPort virtualPort = virtualPortService.getPort(virtualPortId);
    if (virtualPort == null) {
        log.error("The virtualPort of host is null");
        return;
    }
    Iterable<Device> devices = deviceService.getAvailableDevices();
    PortNumber inPort = host.location().port();
    MacAddress mac = host.mac();
    Device device = deviceService.getDevice(deviceId);
    String controllerIp = VtnData.getControllerIpOfSwitch(device);
    IpAddress ipAddress = IpAddress.valueOf(controllerIp);
    TenantNetwork network = tenantNetworkService.getNetwork(virtualPort.networkId());
    if (network == null) {
        log.error("Can't find network of the host");
        return;
    }
    SegmentationId segmentationId = network.segmentationId();
    // Get all the tunnel PortNumber in the current node
    Iterable<Port> ports = deviceService.getPorts(deviceId);
    Collection<PortNumber> localTunnelPorts = VtnData.getLocalTunnelPorts(ports);
    // Get all the local vm's PortNumber in the current node
    Map<TenantNetworkId, Set<PortNumber>> localHostPorts = switchOfLocalHostPorts.get(deviceId).getNetworkOfLocalHostPorts();
    Set<PortNumber> networkOflocalHostPorts = localHostPorts.get(network.id());
    for (PortNumber p : localTunnelPorts) {
        programGroupTable(deviceId, appId, p, devices, type);
    }
    if (type == Objective.Operation.ADD) {
        if (networkOflocalHostPorts == null) {
            networkOflocalHostPorts = new HashSet<PortNumber>();
            localHostPorts.putIfAbsent(network.id(), networkOflocalHostPorts);
        }
        networkOflocalHostPorts.add(inPort);
        l2ForwardService.programLocalBcastRules(deviceId, segmentationId, inPort, networkOflocalHostPorts, localTunnelPorts, type);
        classifierService.programTunnelIn(deviceId, segmentationId, localTunnelPorts, type);
    } else if (type == Objective.Operation.REMOVE) {
        if (networkOflocalHostPorts != null) {
            l2ForwardService.programLocalBcastRules(deviceId, segmentationId, inPort, networkOflocalHostPorts, localTunnelPorts, type);
            networkOflocalHostPorts.remove(inPort);
            if (networkOflocalHostPorts.isEmpty()) {
                classifierService.programTunnelIn(deviceId, segmentationId, localTunnelPorts, type);
                switchOfLocalHostPorts.get(deviceId).getNetworkOfLocalHostPorts().remove(virtualPort.networkId());
            }
        }
    }
    l2ForwardService.programLocalOut(deviceId, segmentationId, inPort, mac, type);
    l2ForwardService.programTunnelBcastRules(deviceId, segmentationId, networkOflocalHostPorts, localTunnelPorts, type);
    programTunnelOuts(devices, ipAddress, segmentationId, mac, type);
    classifierService.programLocalIn(deviceId, segmentationId, inPort, mac, appId, type);
}
#end_block

#method_before
private void programTunnelOuts(Iterable<Device> devices, IpAddress ipAddress, SegmentationId segmentationId, MacAddress dstMac, Objective.Operation type) {
    String tunnelName = "vxlan-" + DEFAULT_IP;
    Sets.newHashSet(devices).stream().filter(d -> d.type() == Device.Type.CONTROLLER).filter(d -> !("ovsdb:" + ipAddress).equals(d.id().toString())).forEach(d -> {
        DriverHandler handler = driverService.createHandler(d.id());
        BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
        Collection<BridgeDescription> bridgeDescriptions = bridgeConfig.getBridges();
        Set<PortNumber> ports = bridgeConfig.getPortNumbers();
        Iterator<BridgeDescription> it = bridgeDescriptions.iterator();
        if (it.hasNext()) {
            BridgeDescription sw = it.next();
            ports.stream().filter(p -> p.name().equalsIgnoreCase(tunnelName)).forEach(p -> {
                l2ForwardService.programTunnelOut(sw.deviceId(), segmentationId, p, dstMac, type);
            });
        }
    });
}
#method_after
private void programTunnelOuts(Iterable<Device> devices, IpAddress ipAddress, SegmentationId segmentationId, MacAddress dstMac, Objective.Operation type) {
    String tunnelName = "vxlan-" + DEFAULT_IP;
    Sets.newHashSet(devices).stream().filter(d -> d.type() == Device.Type.CONTROLLER).filter(d -> !("ovsdb:" + ipAddress).equals(d.id().toString())).forEach(d -> {
        DriverHandler handler = driverService.createHandler(d.id());
        BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
        Collection<BridgeDescription> bridgeDescriptions = bridgeConfig.getBridges();
        Set<PortNumber> ports = bridgeConfig.getPortNumbers();
        Iterator<BridgeDescription> it = bridgeDescriptions.iterator();
        if (it.hasNext()) {
            BridgeDescription sw = it.next();
            ports.stream().filter(p -> p.name().equalsIgnoreCase(tunnelName)).forEach(p -> {
                l2ForwardService.programTunnelOut(sw.deviceId(), segmentationId, p, dstMac, type, ipAddress);
            });
        }
    });
}
#end_block

#method_before
private void programGroupTable(DeviceId deviceId, ApplicationId appid, PortNumber portNumber, Iterable<Device> devices, Objective.Operation type) {
    if (type.equals(Objective.Operation.REMOVE)) {
        return;
    }
    List<GroupBucket> buckets = Lists.newArrayList();
    Sets.newHashSet(devices).stream().filter(d -> d.type() == Device.Type.CONTROLLER).filter(d -> !deviceId.equals(d.id())).forEach(d -> {
        String ipAddress = d.annotations().value(CONTROLLER_IP_KEY);
        Ip4Address dst = Ip4Address.valueOf(ipAddress);
        Builder builder = DefaultTrafficTreatment.builder();
        DriverHandler handler = driverService.createHandler(deviceId);
        ExtensionResolver resolver = handler.behaviour(ExtensionResolver.class);
        ExtensionInstruction instruction = resolver.getExtensionInstruction(ExtensionType.ExtensionTypes.NICIRA_SET_TUNNEL_DST.type());
        try {
            instruction.setPropertyValue("tunnelDst", dst);
        } catch (Exception e) {
            log.error(e.getMessage());
        }
        builder.extension(instruction, deviceId);
        builder.setOutput(portNumber);
        GroupBucket bucket = DefaultGroupBucket.createAllGroupBucket(builder.build());
        buckets.add(bucket);
    });
    final GroupKey key = new DefaultGroupKey(APP_ID.getBytes());
    GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(buckets), key, L2ForwardServiceImpl.GROUP_ID, appid);
    groupService.addGroup(groupDescription);
}
#method_after
private void programGroupTable(DeviceId deviceId, ApplicationId appid, PortNumber portNumber, Iterable<Device> devices, Objective.Operation type) {
    if (type.equals(Objective.Operation.REMOVE)) {
        return;
    }
    List<GroupBucket> buckets = Lists.newArrayList();
    Sets.newHashSet(devices).stream().filter(d -> d.type() == Device.Type.CONTROLLER).filter(d -> !deviceId.equals(d.id())).forEach(d -> {
        String ipAddress = d.annotations().value(CONTROLLER_IP_KEY);
        Ip4Address dst = Ip4Address.valueOf(ipAddress);
        Builder builder = DefaultTrafficTreatment.builder();
        DriverHandler handler = driverService.createHandler(deviceId);
        ExtensionTreatmentResolver resolver = handler.behaviour(ExtensionTreatmentResolver.class);
        ExtensionTreatment treatment = resolver.getExtensionInstruction(NICIRA_SET_TUNNEL_DST.type());
        try {
            treatment.setPropertyValue("tunnelDst", dst);
        } catch (Exception e) {
            log.error("Failed to get extension instruction to set tunnel dst {}", deviceId);
        }
        builder.extension(treatment, deviceId);
        builder.setOutput(portNumber);
        GroupBucket bucket = DefaultGroupBucket.createAllGroupBucket(builder.build());
        buckets.add(bucket);
    });
    final GroupKey key = new DefaultGroupKey(APP_ID.getBytes());
    GroupDescription groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(buckets), key, L2ForwardServiceImpl.GROUP_ID, appid);
    groupService.addGroup(groupDescription);
}
#end_block

#method_before
@Override
public void programTunnelOut(DeviceId deviceId, SegmentationId segmentationId, PortNumber tunnelOutPort, MacAddress dstMac, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(dstMac).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(new DefaultGroupId(GROUP_ID)).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#method_after
@Override
public void programTunnelOut(DeviceId deviceId, SegmentationId segmentationId, PortNumber tunnelOutPort, MacAddress dstMac, Objective.Operation type, IpAddress ipAddress) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(dstMac).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    DriverHandler handler = driverService.createHandler(deviceId);
    ExtensionTreatmentResolver resolver = handler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment treatment = resolver.getExtensionInstruction(NICIRA_SET_TUNNEL_DST.type());
    try {
        treatment.setPropertyValue("tunnelDst", Ip4Address.valueOf(ipAddress.toString()));
    } catch (Exception e) {
        log.error("Failed to get extension instruction to set tunnel dst {}", deviceId);
    }
    Builder builder = DefaultTrafficTreatment.builder();
    builder.extension(treatment, deviceId).setOutput(tunnelOutPort).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(builder.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#end_block

#method_before
public boolean enabled() {
    return get(ENABLED, true);
}
#method_after
public boolean enabled() {
    return get(ENABLED, defaultValue);
}
#end_block

#method_before
private MultiPointToSinglePointIntent generateRouteIntent(IpPrefix prefix, IpAddress nextHopIpAddress, MacAddress nextHopMacAddress) {
    // Find the attachment point (egress interface) of the next hop
    Interface egressInterface = interfaceService.getMatchingInterface(nextHopIpAddress);
    if (egressInterface == null) {
        log.warn("No outgoing interface found for {}", nextHopIpAddress);
        return null;
    }
    // Generate the intent itself
    Set<ConnectPoint> ingressPorts = new HashSet<>();
    ConnectPoint egressPort = egressInterface.connectPoint();
    log.debug("Generating intent for prefix {}, next hop mac {}", prefix, nextHopMacAddress);
    for (Interface intf : interfaceService.getInterfaces()) {
        // TODO this should be only peering interfaces
        if (!intf.connectPoint().equals(egressInterface.connectPoint())) {
            ConnectPoint srcPort = intf.connectPoint();
            ingressPorts.add(srcPort);
        }
    }
    // Match the destination IP prefix at the first hop
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    if (prefix.isIp4()) {
        selector.matchEthType(Ethernet.TYPE_IPV4);
        // IP address
        if (prefix.prefixLength() != 0) {
            selector.matchIPDst(prefix);
        }
    } else {
        selector.matchEthType(Ethernet.TYPE_IPV6);
        selector.matchIPv6Dst(prefix);
    }
    // Rewrite the destination MAC address
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(nextHopMacAddress);
    if (!egressInterface.vlan().equals(VlanId.NONE)) {
        treatment.setVlanId(egressInterface.vlan());
        // If we set VLAN ID, we have to make sure a VLAN tag exists.
        // TODO support no VLAN -> VLAN routing
        selector.matchVlanId(VlanId.ANY);
    }
    int priority = prefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    Key key = Key.of(prefix.toString(), appId);
    return MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector.build()).treatment(treatment.build()).ingressPoints(ingressPorts).egressPoint(egressPort).priority(priority).constraints(CONSTRAINTS).build();
}
#method_after
private MultiPointToSinglePointIntent generateRouteIntent(IpPrefix prefix, IpAddress nextHopIpAddress, MacAddress nextHopMacAddress) {
    // Find the attachment point (egress interface) of the next hop
    Interface egressInterface = interfaceService.getMatchingInterface(nextHopIpAddress);
    if (egressInterface == null) {
        log.warn("No outgoing interface found for {}", nextHopIpAddress);
        return null;
    }
    // Generate the intent itself
    Set<ConnectPoint> ingressPorts = new HashSet<>();
    ConnectPoint egressPort = egressInterface.connectPoint();
    log.debug("Generating intent for prefix {}, next hop mac {}", prefix, nextHopMacAddress);
    for (Interface intf : interfaceService.getInterfaces()) {
        // TODO this should be only peering interfaces
        if (!intf.connectPoint().equals(egressInterface.connectPoint())) {
            ConnectPoint srcPort = intf.connectPoint();
            ingressPorts.add(srcPort);
        }
    }
    // Match the destination IP prefix at the first hop
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    if (prefix.isIp4()) {
        selector.matchEthType(Ethernet.TYPE_IPV4);
        // IP address
        if (prefix.prefixLength() != 0) {
            selector.matchIPDst(prefix);
        }
    } else {
        selector.matchEthType(Ethernet.TYPE_IPV6);
        // IP address
        if (prefix.prefixLength() != 0) {
            selector.matchIPv6Dst(prefix);
        }
    }
    // Rewrite the destination MAC address
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(nextHopMacAddress);
    if (!egressInterface.vlan().equals(VlanId.NONE)) {
        treatment.setVlanId(egressInterface.vlan());
        // If we set VLAN ID, we have to make sure a VLAN tag exists.
        // TODO support no VLAN -> VLAN routing
        selector.matchVlanId(VlanId.ANY);
    }
    int priority = prefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    Key key = Key.of(prefix.toString(), appId);
    return MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector.build()).treatment(treatment.build()).ingressPoints(ingressPorts).egressPoint(egressPort).priority(priority).constraints(CONSTRAINTS).build();
}
#end_block

#method_before
@Activate
protected void activate() {
    ApplicationId appId = coreService.registerApplication("org.onosproject.cordvtn");
    nodeStore = storageService.<CordVtnNode, NodeState>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName("cordvtn-nodestore").withApplicationId(appId).build();
    ruleInstaller = new CordVtnRuleInstaller(appId, flowObjectiveService, flowRuleService, deviceService, driverService, DEFAULT_TUNNEL);
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    ApplicationId appId = coreService.registerApplication("org.onosproject.cordvtn");
    nodeStore = storageService.<CordVtnNode, NodeState>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName("cordvtn-nodestore").withApplicationId(appId).build();
    ruleInstaller = new CordVtnRuleInstaller(appId, flowObjectiveService, driverService, DEFAULT_TUNNEL);
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    log.info("Started");
}
#end_block

#method_before
private void setNodeState(CordVtnNode node, NodeState newState) {
    checkNotNull(node);
    nodeStore.put(node, newState);
    newState.process(this, node);
}
#method_after
private void setNodeState(CordVtnNode node, NodeState newState) {
    checkNotNull(node);
    log.info("Changed {} state: {}", node.hostname(), newState.toString());
    nodeStore.put(node, newState);
    newState.process(this, node);
}
#end_block

#method_before
private void postInit(CordVtnNode node) {
    disconnect(node);
}
#method_after
private void postInit(CordVtnNode node) {
    disconnect(node);
    Set<OpenstackNetwork> vNets = Sets.newHashSet();
    hostService.getConnectedHosts(node.intBrId()).stream().forEach(host -> {
        OpenstackNetwork vNet = getOpenstackNetworkByHost(host);
        if (vNet != null) {
            log.info("VM {} is detected", host.id());
            hostNetworkMap.put(host.id(), vNet.id());
            vNets.add(vNet);
        }
    });
    vNets.stream().forEach(this::installFlowRules);
}
#end_block

#method_before
private ConnectPoint getConnectPoint(OpenstackPort vPort) {
    Set<Host> hosts = hostService.getHostsByMac(vPort.macAddress());
    if (hosts.isEmpty()) {
        log.debug("Not a valid host with {}", vPort.macAddress());
        return null;
    }
    Host host = (Host) hosts.toArray()[0];
    return new ConnectPoint(host.location().deviceId(), host.location().port());
}
#method_after
private ConnectPoint getConnectPoint(OpenstackPort vPort) {
    try {
        Host host = hostService.getHostsByMac(vPort.macAddress()).stream().findFirst().get();
        return new ConnectPoint(host.location().deviceId(), host.location().port());
    } catch (NoSuchElementException e) {
        log.debug("Not a valid host with {}", vPort.macAddress());
        return null;
    }
}
#end_block

#method_before
@Override
public void connected(Host host) {
    OpenstackPort vPort = getOpenstackPortByHost(host);
    if (vPort == null) {
        log.warn("Couldn't find OpenStack port for host {}", host.id());
        return;
    }
    log.info("VM {} is detected", vPort.deviceId());
    OpenstackNetwork vNet = openstackService.network(vPort.networkId());
    installFlowRules(vNet);
}
#method_after
@Override
public void connected(Host host) {
    CordVtnNode node = getNodeByBridgeId(host.location().deviceId());
    if (node == null || !getNodeState(node).equals(NodeState.COMPLETE)) {
        // do nothing for the host on unregistered or unprepared device
        return;
    }
    OpenstackNetwork vNet = getOpenstackNetworkByHost(host);
    if (vNet == null) {
        return;
    }
    log.info("VM {} is detected", host.id());
    hostNetworkMap.put(host.id(), vNet.id());
    installFlowRules(vNet);
}
#end_block

#method_before
@Override
public void disconnected(Host host) {
    log.info("VM {} is vanished", host.id());
    Port port = deviceService.getPort(host.location().deviceId(), host.location().port());
    ruleInstaller.uninstallFlowRules(port, host.mac());
}
#method_after
@Override
public void disconnected(Host host) {
    CordVtnNode node = getNodeByBridgeId(host.location().deviceId());
    if (node == null || !getNodeState(node).equals(NodeState.COMPLETE)) {
        // do nothing for the host on unregistered or unprepared device
        return;
    }
    OpenstackNetwork vNet = openstackService.network(hostNetworkMap.get(host.id()));
    if (vNet == null) {
        return;
    }
    log.info("VM {} is vanished", host.id());
    uninstallFlowRules(vNet, host);
    hostNetworkMap.remove(host.id());
}
#end_block

#method_before
public Builder setIp(List<IpAddress> ip) {
    this.ip = ip;
    return this;
}
#method_after
public Builder setIp(List<IpAddress> ip) {
    this.ip = checkNotNull(ip, "IP cannot be null");
    return this;
}
#end_block

#method_before
public Builder setMac(MacAddress mac) {
    this.mac = mac;
    return this;
}
#method_after
public Builder setMac(MacAddress mac) {
    this.mac = checkNotNull(mac, "MAC address cannot be null");
    return this;
}
#end_block

#method_before
public Builder setRemoteIp(IpAddress remoteIp) {
    this.remoteIp = remoteIp;
    return this;
}
#method_after
public Builder setRemoteIp(IpAddress remoteIp) {
    this.remoteIp = checkNotNull(remoteIp, "Remote IP address cannot be null");
    return this;
}
#end_block

#method_before
public Builder setTunnelId(long tunnelId) {
    this.tunnelId = tunnelId;
    return this;
}
#method_after
public Builder setTunnelId(long tunnelId) {
    this.tunnelId = checkNotNull(tunnelId, "Tunnel ID cannot be null");
    return this;
}
#end_block

#method_before
public void installFlowRulesTunnelIn(DeviceId deviceId, Port inPort, List<DestinationInfo> dstInfos) {
    dstInfos.stream().forEach(dstInfo -> vtnRulesSameNode(deviceId, inPort, dstInfo));
}
#method_after
public void installFlowRulesTunnelIn(DeviceId deviceId, Port inPort, List<DestinationInfo> dstInfos) {
    dstInfos.stream().forEach(dstInfo -> {
        ForwardingObjective.Builder fBuilder = vtnRulesSameNode(inPort, dstInfo);
        if (fBuilder != null) {
            flowObjectiveService.forward(deviceId, fBuilder.add());
        }
    });
}
#end_block

#method_before
public void installFlowRulesLocalIn(DeviceId deviceId, Port inPort, List<DestinationInfo> dstInfos) {
    dstInfos.stream().forEach(dstInfo -> {
        if (isTunnelPort(dstInfo.output())) {
            vtnRulesRemoteNode(deviceId, inPort, dstInfo);
        } else {
            vtnRulesSameNode(deviceId, inPort, dstInfo);
        }
    });
}
#method_after
public void installFlowRulesLocalIn(DeviceId deviceId, Port inPort, List<DestinationInfo> dstInfos) {
    dstInfos.stream().forEach(dstInfo -> {
        ForwardingObjective.Builder fBuilder = isTunnelPort(dstInfo.output()) ? vtnRulesRemoteNode(deviceId, inPort, dstInfo) : vtnRulesSameNode(inPort, dstInfo);
        if (fBuilder != null) {
            flowObjectiveService.forward(deviceId, fBuilder.add());
        }
    });
}
#end_block

#method_before
public void uninstallFlowRules(Port port, MacAddress macAddress) {
    for (FlowRule flowRule : flowRuleService.getFlowRulesById(appId)) {
        DeviceId deviceId = flowRule.deviceId();
        if (deviceId.equals(port.element().id())) {
            Port inPort = getInPort(flowRule, deviceId);
            if (inPort != null && inPort.equals(port)) {
                ForwardingObjective fwdObjective = DefaultForwardingObjective.builder().withSelector(flowRule.selector()).withTreatment(flowRule.treatment()).withPriority(DEFAULT_PRIORITY).withFlag(ForwardingObjective.Flag.VERSATILE).fromApp(appId).makePermanent().remove();
                flowObjectiveService.forward(deviceId, fwdObjective);
                continue;
            }
        }
        MacAddress dstMac = getDstMacAddress(flowRule);
        if (dstMac != null && dstMac.equals(macAddress)) {
            ForwardingObjective fwdObjective = DefaultForwardingObjective.builder().withSelector(flowRule.selector()).withTreatment(flowRule.treatment()).withPriority(DEFAULT_PRIORITY).withFlag(ForwardingObjective.Flag.VERSATILE).fromApp(appId).makePermanent().remove();
            flowObjectiveService.forward(deviceId, fwdObjective);
        }
    }
}
#method_after
public void uninstallFlowRules(DeviceId deviceId, Port inPort, List<DestinationInfo> dstInfos) {
    dstInfos.stream().forEach(dstInfo -> {
        ForwardingObjective.Builder fBuilder = isTunnelPort(dstInfo.output()) ? vtnRulesRemoteNode(deviceId, inPort, dstInfo) : vtnRulesSameNode(inPort, dstInfo);
        if (fBuilder != null) {
            flowObjectiveService.forward(deviceId, fBuilder.remove());
        }
    });
}
#end_block

#method_before
private void vtnRulesSameNode(DeviceId deviceId, Port inPort, DestinationInfo dstInfo) {
    checkArgument(inPort.element().id().equals(dstInfo.output().element().id()));
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchInPort(inPort.number()).matchEthDst(dstInfo.mac());
    if (isTunnelPort(inPort)) {
        sBuilder.matchTunnelId(dstInfo.tunnelId());
    }
    tBuilder.setOutput(dstInfo.output().number());
    ForwardingObjective fwdObjective = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(DEFAULT_PRIORITY).withFlag(ForwardingObjective.Flag.VERSATILE).fromApp(appId).makePermanent().add();
    flowObjectiveService.forward(deviceId, fwdObjective);
}
#method_after
private ForwardingObjective.Builder vtnRulesSameNode(Port inPort, DestinationInfo dstInfo) {
    checkArgument(inPort.element().id().equals(dstInfo.output().element().id()));
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchInPort(inPort.number()).matchEthDst(dstInfo.mac());
    if (isTunnelPort(inPort)) {
        sBuilder.matchTunnelId(dstInfo.tunnelId());
    }
    tBuilder.setOutput(dstInfo.output().number());
    return DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(DEFAULT_PRIORITY).withFlag(ForwardingObjective.Flag.VERSATILE).fromApp(appId).makePermanent();
}
#end_block

#method_before
private void vtnRulesRemoteNode(DeviceId deviceId, Port inPort, DestinationInfo dstInfo) {
    checkArgument(isTunnelPort(dstInfo.output()));
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    ExtensionInstruction extension = getTunnelDstInstruction(deviceId, dstInfo.remoteIp().getIp4Address());
    if (extension == null) {
        return;
    }
    sBuilder.matchInPort(inPort.number()).matchEthDst(dstInfo.mac());
    tBuilder.extension(extension, deviceId).setTunnelId(dstInfo.tunnelId()).setOutput(dstInfo.output().number());
    ForwardingObjective fwdObjective = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(DEFAULT_PRIORITY).withFlag(ForwardingObjective.Flag.VERSATILE).fromApp(appId).makePermanent().add();
    flowObjectiveService.forward(deviceId, fwdObjective);
}
#method_after
private ForwardingObjective.Builder vtnRulesRemoteNode(DeviceId deviceId, Port inPort, DestinationInfo dstInfo) {
    checkArgument(isTunnelPort(dstInfo.output()));
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    ExtensionTreatment extTreatment = getTunnelDstInstruction(deviceId, dstInfo.remoteIp().getIp4Address());
    if (extTreatment == null) {
        return null;
    }
    sBuilder.matchInPort(inPort.number()).matchEthDst(dstInfo.mac());
    tBuilder.extension(extTreatment, deviceId).setTunnelId(dstInfo.tunnelId()).setOutput(dstInfo.output().number());
    return DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withPriority(DEFAULT_PRIORITY).withFlag(ForwardingObjective.Flag.VERSATILE).fromApp(appId).makePermanent();
}
#end_block

#method_before
private ExtensionInstruction getTunnelDstInstruction(DeviceId deviceId, Ip4Address remoteIp) {
    try {
        Driver driver = driverService.getDriver(deviceId);
        DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
        ExtensionResolver resolver = handler.behaviour(ExtensionResolver.class);
        ExtensionInstruction extension = resolver.getExtensionInstruction(NICIRA_SET_TUNNEL_DST.type());
        extension.setPropertyValue("tunnelDst", remoteIp);
        return extension;
    } catch (ItemNotFoundException | UnsupportedOperationException | ExtensionPropertyException e) {
        log.error("Failed to get extension instruction to set tunnel dst {}", deviceId);
        return null;
    }
}
#method_after
private ExtensionTreatment getTunnelDstInstruction(DeviceId deviceId, Ip4Address remoteIp) {
    try {
        Driver driver = driverService.getDriver(deviceId);
        DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
        ExtensionTreatmentResolver resolver = handler.behaviour(ExtensionTreatmentResolver.class);
        ExtensionTreatment treatment = resolver.getExtensionInstruction(NICIRA_SET_TUNNEL_DST.type());
        treatment.setPropertyValue("tunnelDst", remoteIp);
        return treatment;
    } catch (ItemNotFoundException | UnsupportedOperationException | ExtensionPropertyException e) {
        log.error("Failed to get extension instruction to set tunnel dst {}", deviceId);
        return null;
    }
}
#end_block

#method_before
public Collection<OpenstackNetwork> getNetworks() {
    String neutronUrl = "http://" + neutronIp + ":" + NEUTRON_PORT + "/v2.0/";
    WebResource.Builder builder = getClientBuilder(neutronUrl + "networks");
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header("X-Auth-Token", getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackNetwork> openstackNetworks = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode networkList = (ArrayNode) node.path("networks");
        OpenstackNetworkCodec networkCodec = new OpenstackNetworkCodec();
        networkList.forEach(n -> openstackNetworks.add(networkCodec.decode((ObjectNode) n, null)));
    } catch (IOException e) {
        e.printStackTrace();
    }
    log.debug("networks response:" + response);
    openstackNetworks.forEach(n -> log.debug("network ID: {}", n.id()));
    return openstackNetworks;
}
#method_after
public Collection<OpenstackNetwork> getNetworks() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + "networks");
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header("X-Auth-Token", getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackNetwork> openstackNetworks = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode networkList = (ArrayNode) node.path("networks");
        OpenstackNetworkCodec networkCodec = new OpenstackNetworkCodec();
        networkList.forEach(n -> openstackNetworks.add(networkCodec.decode((ObjectNode) n, null)));
    } catch (IOException e) {
        e.printStackTrace();
    }
    log.debug("networks response:" + response);
    openstackNetworks.forEach(n -> log.debug("network ID: {}", n.id()));
    return openstackNetworks;
}
#end_block

#method_before
public Collection<OpenstackPort> getPorts() {
    String neutronUrl = "http://" + neutronIp + ":" + NEUTRON_PORT + "/v2.0/";
    WebResource.Builder builder = getClientBuilder(neutronUrl + "ports");
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header("X-Auth-Token", getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackPort> openstackPorts = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode portList = (ArrayNode) node.path("ports");
        OpenstackPortCodec portCodec = new OpenstackPortCodec();
        portList.forEach(p -> openstackPorts.add(portCodec.decode((ObjectNode) p, null)));
    } catch (IOException e) {
        e.printStackTrace();
    }
    log.debug("port response:" + response);
    openstackPorts.forEach(n -> log.debug("port ID: {}", n.id()));
    return openstackPorts;
}
#method_after
public Collection<OpenstackPort> getPorts() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + "ports");
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header("X-Auth-Token", getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackPort> openstackPorts = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode portList = (ArrayNode) node.path("ports");
        OpenstackPortCodec portCodec = new OpenstackPortCodec();
        portList.forEach(p -> openstackPorts.add(portCodec.decode((ObjectNode) p, null)));
    } catch (IOException e) {
        e.printStackTrace();
    }
    log.debug("port response:" + response);
    openstackPorts.forEach(n -> log.debug("port ID: {}", n.id()));
    return openstackPorts;
}
#end_block

#method_before
public Collection<OpenstackSubnet> getSubnets() {
    String neutronUrl = "http://" + neutronIp + ":" + NEUTRON_PORT + "/v2.0/";
    WebResource.Builder builder = getClientBuilder(neutronUrl + "subnets");
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header("X-Auth-Token", getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackSubnet> subnets = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode subnetList = (ArrayNode) node.path("subnets");
        OpenstackSubnetCodec subnetCodec = new OpenstackSubnetCodec();
        subnetList.forEach(s -> subnets.add(subnetCodec.decode((ObjectNode) s, null)));
    } catch (IOException e) {
        e.printStackTrace();
    }
    log.debug("subnets response:" + response);
    subnets.forEach(s -> log.debug("subnet ID: {}", s.id()));
    return subnets;
}
#method_after
public Collection<OpenstackSubnet> getSubnets() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + "subnets");
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header("X-Auth-Token", getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackSubnet> subnets = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode subnetList = (ArrayNode) node.path("subnets");
        OpenstackSubnetCodec subnetCodec = new OpenstackSubnetCodec();
        subnetList.forEach(s -> subnets.add(subnetCodec.decode((ObjectNode) s, null)));
    } catch (IOException e) {
        e.printStackTrace();
    }
    log.debug("subnets response:" + response);
    subnets.forEach(s -> log.debug("subnet ID: {}", s.id()));
    return subnets;
}
#end_block

#method_before
private String getToken() {
    if (isTokenInvalid()) {
        String request = "{\"auth\": {\"tenantName\": \"admin\", " + "\"passwordCredentials\":  {\"username\": \"" + userName + "\",\"password\": \"" + pass + "\"}}}";
        String keystoneUrl = "http://" + keystoneIp + ":" + KEYSTONE_PORT + "/v2.0/";
        WebResource.Builder builder = getClientBuilder(keystoneUrl + "tokens");
        String response = builder.accept(MediaType.APPLICATION_JSON).post(String.class, request);
        ObjectMapper mapper = new ObjectMapper();
        try {
            ObjectNode node = (ObjectNode) mapper.readTree(response);
            tokenId = node.path("access").path("token").path("id").asText();
        } catch (IOException e) {
            e.printStackTrace();
        }
        log.debug("token response:" + response);
    }
    return tokenId;
}
#method_after
private String getToken() {
    if (isTokenInvalid()) {
        String request = "{\"auth\": {\"tenantName\": \"admin\", " + "\"passwordCredentials\":  {\"username\": \"" + userName + "\",\"password\": \"" + pass + "\"}}}";
        WebResource.Builder builder = getClientBuilder(keystoneUrl + "tokens");
        String response = builder.accept(MediaType.APPLICATION_JSON).post(String.class, request);
        ObjectMapper mapper = new ObjectMapper();
        try {
            ObjectNode node = (ObjectNode) mapper.readTree(response);
            tokenId = node.path("access").path("token").path("id").asText();
        } catch (IOException e) {
            e.printStackTrace();
        }
        log.debug("token response:" + response);
    }
    return tokenId;
}
#end_block

#method_before
private boolean isTokenInvalid() {
    // TODO: validation check for the existing token
    return (tokenId == null);
}
#method_after
private boolean isTokenInvalid() {
    // TODO: validation check for the existing token
    return true;
}
#end_block

#method_before
private ExtensionInstruction buildNiciraExtenstion(DeviceId id, Ip4Address hostIp) {
    Driver driver = driverService.getDriver(id);
    DriverHandler driverHandler = new DefaultDriverHandler(new DefaultDriverData(driver, id));
    ExtensionResolver resolver = driverHandler.behaviour(ExtensionResolver.class);
    ExtensionInstruction extensionInstruction = resolver.getExtensionInstruction(ExtensionType.ExtensionTypes.NICIRA_SET_TUNNEL_DST.type());
    try {
        extensionInstruction.setPropertyValue("tunnelDst", hostIp);
    } catch (ExtensionPropertyException e) {
        log.error("Error setting Nicira extension setting {}", e);
    }
    return extensionInstruction;
}
#method_after
private ExtensionTreatment buildNiciraExtenstion(DeviceId id, Ip4Address hostIp) {
    Driver driver = driverService.getDriver(id);
    DriverHandler driverHandler = new DefaultDriverHandler(new DefaultDriverData(driver, id));
    ExtensionTreatmentResolver resolver = driverHandler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment extensionInstruction = resolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type());
    try {
        extensionInstruction.setPropertyValue("tunnelDst", hostIp);
    } catch (ExtensionPropertyException e) {
        log.error("Error setting Nicira extension setting {}", e);
    }
    return extensionInstruction;
}
#end_block

#method_before
public Ip4Address neutronServer() {
    return Ip4Address.valueOf(get(NEUTRON_SERVER, ""));
}
#method_after
public String neutronServer() {
    return get(NEUTRON_SERVER, "");
}
#end_block

#method_before
public Ip4Address keystoneServer() {
    return Ip4Address.valueOf(get(KEYSTONE_SERVER, ""));
}
#method_after
public String keystoneServer() {
    return get(KEYSTONE_SERVER, "");
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.openstackswitching");
    packetService.addProcessor(internalPacketProcessor, PacketProcessor.director(1));
    deviceService.addListener(internalDeviceListener);
    cfgService.addListener(internalConfigListener);
    factories.forEach(cfgService::registerConfigFactory);
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg != null) {
        doNotPushFlows = cfg.doNotPushFlows();
        neutronServer = cfg.neutronServer();
        keystoneServer = cfg.keystoneServer();
        userName = cfg.userName();
        password = cfg.password();
    }
    restHandler = new OpenstackRestHandler(neutronServer, keystoneServer, userName, password);
    arpHandler = new OpenstackArpHandler(restHandler, packetService);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.openstackswitching");
    factories.forEach(cfgService::registerConfigFactory);
    packetService.addProcessor(internalPacketProcessor, PacketProcessor.director(1));
    deviceService.addListener(internalDeviceListener);
    cfgService.addListener(internalConfigListener);
    internalConfigListener.configureNetwork();
    log.info("Started");
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    if (((event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED)) && event.configClass().equals(OpenstackSwitchingConfig.class)) {
        OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
        if (cfg != null) {
            doNotPushFlows = cfg.doNotPushFlows();
            restHandler.setConfig(cfg.neutronServer(), cfg.keystoneServer(), cfg.userName(), cfg.password());
            log.info("Switching mode reconfigured");
        }
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (((event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED)) && event.configClass().equals(OpenstackSwitchingConfig.class)) {
        configureNetwork();
    }
}
#end_block

#method_before
private void registerPortResource(Device device, Port port) {
    ResourcePath resource = ResourcePath.discrete(device.id(), port.number());
    executor.submit(() -> adminService.registerResources(resource));
}
#method_after
private void registerPortResource(Device device, Port port) {
    ResourcePath portPath = ResourcePath.discrete(device.id(), port.number());
    executor.submit(() -> {
        adminService.registerResources(portPath);
        switch(port.type()) {
            case OCH:
                // register ODU TributarySlots against the OCH port
                registerTributarySlotsResources(((OchPort) port).signalType(), portPath);
                break;
            default:
                break;
        }
    });
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.openstackswitching");
    packetService.addProcessor(internalPacketProcessor, PacketProcessor.director(1));
    deviceService.addListener(internalDeviceListener);
    cfgService.addListener(internalConfigListener);
    factories.forEach(cfgService::registerConfigFactory);
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    doNotPushFlows = cfg.doNotPushFlows();
    openstackPortMap = Maps.newHashMap();
    openstackNetworkMap = Maps.newHashMap();
    vniPortMap = Maps.newHashMap();
    tunnelPortMap = Maps.newHashMap();
    arpHandler = new OpenstackArpHandler(openstackPortMap);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.openstackswitching");
    packetService.addProcessor(internalPacketProcessor, PacketProcessor.director(1));
    deviceService.addListener(internalDeviceListener);
    cfgService.addListener(internalConfigListener);
    factories.forEach(cfgService::registerConfigFactory);
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg != null) {
        doNotPushFlows = cfg.doNotPushFlows();
    }
    openstackPortMap = Maps.newHashMap();
    openstackNetworkMap = Maps.newHashMap();
    openstackSubnetMap = Maps.newHashMap();
    vniPortMap = Maps.newHashMap();
    tunnelPortMap = Maps.newHashMap();
    arpHandler = new OpenstackArpHandler(openstackPortMap, packetService);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    packetService.removeProcessor(internalPacketProcessor);
    deviceService.removeListener(internalDeviceListener);
    deviceEventExcutorService.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    packetService.removeProcessor(internalPacketProcessor);
    deviceService.removeListener(internalDeviceListener);
    cfgService.removeListener(internalConfigListener);
    deviceEventExcutorService.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void createPorts(OpenstackPort openstackPort) {
    openstackPortMap.put(openstackPort.id(), openstackPort);
}
#method_after
@Override
public void createPorts(OpenstackPort openstackPort) {
    registerDhcpInfo(openstackPort);
    openstackPortMap.put(openstackPort.id(), openstackPort);
}
#end_block

#method_before
private void processDeviceAdded(Device device) {
    log.warn("device {} is added", device.id());
    rulePopulator.populateDefaultRules(device.id());
}
#method_after
private void processDeviceAdded(Device device) {
    log.debug("device {} is added", device.id());
    rulePopulator.populateDefaultRules(device.id());
}
#end_block

#method_before
private void processPortAdded(Device device, Port port) {
    // TODO: All the logics need to be processed inside of the rulePopulator class
    synchronized (vniPortMap) {
        log.warn("port {} is updated", port.toString());
        updatePortMaps(device, port);
        if (!port.annotations().value("portName").equals("vxlan")) {
            populateFlowRulesForTrafficToSameCnode(device, port);
            populateFlowRulesForTrafficToDifferentCnode(device, port);
        }
    }
}
#method_after
private void processPortAdded(Device device, Port port) {
    // TODO: All the logics need to be processed inside of the rulePopulator class
    synchronized (vniPortMap) {
        log.debug("port {} is updated", port.toString());
        updatePortMaps(device, port);
        if (!port.annotations().value("portName").equals("vxlan")) {
            populateFlowRulesForTrafficToSameCnode(device, port);
            populateFlowRulesForTrafficToDifferentCnode(device, port);
        }
    }
}
#end_block

#method_before
private void processPortRemoved(Device device, Port port) {
    log.warn("port {} is removed", port.toString());
// TODO: need to update the vniPortMap
}
#method_after
private void processPortRemoved(Device device, Port port) {
    log.debug("port {} is removed", port.toString());
// TODO: need to update the vniPortMap
}
#end_block

#method_before
private void populateFlowRulesForTrafficToDifferentCnode(Device device, Port port) {
    String portName = port.annotations().value("portName");
    String channelId = device.annotations().value("channelId");
    Ip4Address hostIpAddress = Ip4Address.valueOf(channelId.split(":")[0]);
    Ip4Address fixedIp = getFixedIpAddressForPort(portName);
    // (possibly avoided by flowrule subsystem?)
    if (tunnelPortMap.get(hostIpAddress) == null) {
        log.warn("There is no tunnel port information");
        return;
    }
    String vni = getVniForPort(portName);
    MacAddress vmMac = getVmMacAddressForPort(portName);
    if (!vniPortMap.isEmpty() && vniPortMap.get(vni) != null) {
        for (PortInfo portInfo : vniPortMap.get(vni)) {
            if (!portInfo.portName.equals(portName) && !portInfo.hostIp.equals(hostIpAddress)) {
                MacAddress vmMacx = getVmMacAddressForPort(portInfo.portName);
                rulePopulator.populateForwardingRuleForOtherCnode(vni, device.id(), portInfo.hostIp, portInfo.fixedIp, vmMacx, tunnelPortMap.get(hostIpAddress).number(), portInfo.deviceId, hostIpAddress, fixedIp, vmMac, tunnelPortMap.get(portInfo.hostIp).number());
            }
        }
    }
}
#method_after
private void populateFlowRulesForTrafficToDifferentCnode(Device device, Port port) {
    String portName = port.annotations().value("portName");
    String channelId = device.annotations().value("channelId");
    Ip4Address hostIpAddress = Ip4Address.valueOf(channelId.split(":")[0]);
    Ip4Address fixedIp = getFixedIpAddressForPort(portName);
    // (possibly avoided by flowrule subsystem?)
    if (tunnelPortMap.get(hostIpAddress) == null) {
        log.debug("There is no tunnel port information");
        return;
    }
    String vni = getVniForPort(portName);
    MacAddress vmMac = getVmMacAddressForPort(portName);
    if (!vniPortMap.isEmpty() && vniPortMap.get(vni) != null) {
        for (PortInfo portInfo : vniPortMap.get(vni)) {
            if (!portInfo.portName.equals(portName) && !portInfo.hostIp.equals(hostIpAddress)) {
                MacAddress vmMacx = getVmMacAddressForPort(portInfo.portName);
                rulePopulator.populateForwardingRuleForOtherCnode(vni, device.id(), portInfo.hostIp, portInfo.fixedIp, vmMacx, tunnelPortMap.get(hostIpAddress).number(), portInfo.deviceId, hostIpAddress, fixedIp, vmMac, tunnelPortMap.get(portInfo.hostIp).number());
            }
        }
    }
}
#end_block

#method_before
private Ip4Prefix getCidrForPort(String portName) {
    String networkId = null;
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortMap.values().stream().filter(p -> p.id().startsWith(uuid)).findFirst().get();
    if (port == null) {
        log.warn("No port information for port {}", portName);
        return null;
    }
    // return Ip4Prefix.valueOf(subnet.cidr());
    return null;
}
#method_after
private Ip4Prefix getCidrForPort(String portName) {
    String networkId = null;
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortMap.values().stream().filter(p -> p.id().startsWith(uuid)).findFirst().get();
    if (port == null) {
        log.debug("No port information for port {}", portName);
        return null;
    }
    OpenstackSubnet subnet = openstackSubnetMap.values().stream().filter(s -> s.networkId().equals(port.networkId())).findFirst().get();
    if (subnet == null) {
        log.debug("No subnet information for network {}", port.networkId());
        return null;
    }
    return Ip4Prefix.valueOf(subnet.cidr());
}
#end_block

#method_before
private String getVniForPort(String portName) {
    String networkId = null;
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortMap.values().stream().filter(p -> p.id().startsWith(uuid)).findFirst().get();
    if (port == null) {
        log.warn("No port information for port {}", portName);
        return null;
    }
    OpenstackNetwork network = openstackNetworkMap.values().stream().filter(n -> n.id().equals(port.networkId())).findFirst().get();
    if (network == null) {
        log.warn("No VNI information for network {}", network.id());
        return null;
    }
    return network.segmentId();
}
#method_after
private String getVniForPort(String portName) {
    String networkId = null;
    String uuid = portName.substring(3);
    OpenstackPort port = openstackPortMap.values().stream().filter(p -> p.id().startsWith(uuid)).findFirst().get();
    if (port == null) {
        log.debug("No port information for port {}", portName);
        return null;
    }
    OpenstackNetwork network = openstackNetworkMap.values().stream().filter(n -> n.id().equals(port.networkId())).findFirst().get();
    if (network == null) {
        log.debug("No VNI information for network {}", network.id());
        return null;
    }
    return network.segmentId();
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt);
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipPacket = (IPv4) ethernet.getPayload();
        if (ipPacket.getProtocol() == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipPacket.getPayload();
            if (udpPacket.getDestinationPort() == DHCP_PORT) {
                dhcpHandler.processPacketIn(pkt);
            }
        }
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt);
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    if (((event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED)) && event.configClass().equals(OpenstackSwitchingConfig.class)) {
        OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
        doNotPushFlows = cfg.doNotPushFlows();
        log.info("Switching mode reconfigured");
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (((event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED)) && event.configClass().equals(OpenstackSwitchingConfig.class)) {
        OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
        if (cfg != null) {
            doNotPushFlows = cfg.doNotPushFlows();
            log.info("Switching mode reconfigured");
        }
    }
}
#end_block

#method_before
public void populateDefaultRules(DeviceId id) {
    // setFlowRuleForDHCP(id);
    setFlowRuleForArp(id);
    log.warn("Default rule has been set");
}
#method_after
public void populateDefaultRules(DeviceId id) {
    setFlowRuleForArp(id);
    log.warn("Default rule has been set");
}
#end_block

#method_before
public String networkType() {
    return this.networkType;
}
#method_after
public NetworkType networkType() {
    return this.networkType;
}
#end_block

#method_before
public Builder networkType(String type) {
    this.networkType = type;
    return this;
}
#method_after
public Builder networkType(NetworkType type) {
    this.networkType = type;
    return this;
}
#end_block

#method_before
@Override
public OpenstackNetwork decode(ObjectNode json, CodecContext context) {
    JsonNode networkInfo = json.get(NETWORK);
    String name = networkInfo.path(NAME).asText();
    String tenantId = networkInfo.path(TENANT_ID).asText();
    String id = networkInfo.path(ID).asText();
    OpenstackNetwork.Builder onb = OpenstackNetwork.builder();
    onb.name(name).tenantId(tenantId).id(id);
    if (!networkInfo.path(NETWORK_TYPE).isMissingNode()) {
        onb.name(networkInfo.path(NETWORK_TYPE).asText());
        onb.segmentId(networkInfo.path(SEGMENTATION_ID).asText());
    }
    return onb.build();
}
#method_after
@Override
public OpenstackNetwork decode(ObjectNode json, CodecContext context) {
    JsonNode networkInfo = json.get(NETWORK);
    String name = networkInfo.path(NAME).asText();
    String tenantId = networkInfo.path(TENANT_ID).asText();
    String id = networkInfo.path(ID).asText();
    OpenstackNetwork.Builder onb = OpenstackNetwork.builder();
    onb.name(name).tenantId(tenantId).id(id);
    if (!networkInfo.path(NETWORK_TYPE).isMissingNode()) {
        onb.networkType(OpenstackNetwork.NetworkType.valueOf(networkInfo.path(NETWORK_TYPE).asText().toUpperCase()));
        onb.name(networkInfo.path(NETWORK_TYPE).asText());
        onb.segmentId(networkInfo.path(SEGMENTATION_ID).asText());
    }
    return onb.build();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPorts(InputStream input) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode portNode = (ObjectNode) mapper.readTree(input);
        OpenstackPort openstackPort = PORT_CODEC.decode(portNode, this);
        OpenstackSwitchingService switchingService = get(OpenstackSwitchingService.class);
        switchingService.createPorts(openstackPort);
        log.info("REST API ports is called with {}", portNode.toString());
        return Response.status(Response.Status.OK).build();
    } catch (Exception e) {
        log.error("Creates VirtualPort failed because of exception {}", e.toString());
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createPorts(InputStream input) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode portNode = (ObjectNode) mapper.readTree(input);
        OpenstackPort openstackPort = PORT_CODEC.decode(portNode, this);
        OpenstackSwitchingService switchingService = get(OpenstackSwitchingService.class);
        switchingService.createPorts(openstackPort);
        log.debug("REST API ports is called with {}", portNode.toString());
        return Response.status(Response.Status.OK).build();
    } catch (Exception e) {
        log.error("Creates VirtualPort failed because of exception {}", e.toString());
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#end_block

#method_before
public void processPacketIn(InboundPacket pkt) {
    log.warn("Received an ARP packet");
}
#method_after
public void processPacketIn(InboundPacket pkt) {
    Ethernet ethernet = pkt.parsed();
    ARP arp = (ARP) ethernet.getPayload();
    if (arp.getOpCode() == ARP.OP_REQUEST) {
        byte[] srcMacAddress = arp.getSenderHardwareAddress();
        byte[] srcIPAddress = arp.getSenderProtocolAddress();
        byte[] dstIPAddress = arp.getTargetProtocolAddress();
        // Searches the Dst MAC Address based on openstackPortMap
        MacAddress macAddress = null;
        OpenstackPort openstackPort = openstackPortMap.values().stream().filter(e -> e.fixedIps().containsValue(Ip4Address.valueOf(dstIPAddress))).findAny().orElse(null);
        if (openstackPort != null) {
            macAddress = openstackPort.macAddress();
            log.debug("Found MACAddress: {}", macAddress.toString());
        } else {
            return;
        }
        // Creates a response packet
        ARP arpReply = new ARP();
        arpReply.setOpCode(ARP.OP_REPLY).setHardwareAddressLength(arp.getHardwareAddressLength()).setHardwareType(arp.getHardwareType()).setProtocolAddressLength(arp.getProtocolAddressLength()).setProtocolType(arp.getProtocolType()).setSenderHardwareAddress(macAddress.toBytes()).setSenderProtocolAddress(dstIPAddress).setTargetHardwareAddress(srcMacAddress).setTargetProtocolAddress(srcIPAddress);
        // Sends a response packet
        ethernet.setDestinationMACAddress(srcMacAddress).setSourceMACAddress(macAddress).setEtherType(Ethernet.TYPE_ARP).setPayload(arpReply);
        TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
        builder.setOutput(pkt.receivedFrom().port());
        OutboundPacket packet = new DefaultOutboundPacket(pkt.receivedFrom().deviceId(), builder.build(), ByteBuffer.wrap(ethernet.serialize()));
        packetService.emit(packet);
    }
}
#end_block

#method_before
public String floatingIpId() {
    return floatingIpId;
}
#method_after
public UUID floatingIpId() {
    return floatingIpId;
}
#end_block

#method_before
@Test
public void testEquals() {
    FloatingIpId id1 = FloatingIpId.valueOf(floatingIpIdStr1);
    FloatingIpId id2 = FloatingIpId.valueOf(floatingIpIdStr1);
    FloatingIpId id3 = FloatingIpId.valueOf(floatingIpIdStr2);
    new EqualsTester().addEqualityGroup(id1, id2).addEqualityGroup(id3).testEquals();
}
#method_after
@Test
public void testEquals() {
    FloatingIpId id1 = FloatingIpId.of(floatingIpIdStr1);
    FloatingIpId id2 = FloatingIpId.of(floatingIpIdStr1);
    FloatingIpId id3 = FloatingIpId.of(floatingIpIdStr2);
    new EqualsTester().addEqualityGroup(id1, id2).addEqualityGroup(id3).testEquals();
}
#end_block

#method_before
@Test
public void testConstruction() {
    final FloatingIpId id = FloatingIpId.valueOf(floatingIpIdStr1);
    assertThat(id, is(notNullValue()));
    assertThat(id.floatingIpId(), is(floatingIpIdStr1));
}
#method_after
@Test
public void testConstruction() {
    final FloatingIpId id = FloatingIpId.of(floatingIpIdStr1);
    assertThat(id, is(notNullValue()));
    assertThat(id.floatingIpId().toString(), is(floatingIpIdStr1));
}
#end_block

#method_before
@Override
public void setControllers(List<ControllerInfo> controllers) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    if (!Arrays.equals(clientService.getControllers(handler().data().deviceId()).toArray(), controllers.toArray())) {
        clientService.setControllersWithDeviceId(handler().data().deviceId(), controllers);
    }
}
#method_after
@Override
public void setControllers(List<ControllerInfo> controllers) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    if (!clientService.getControllers(handler().data().deviceId()).equals(ImmutableSet.copyOf(controllers))) {
        clientService.setControllersWithDeviceId(handler().data().deviceId(), controllers);
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(sender, subject, payload);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(sender, subject, payload, fingerprint);
}
#end_block

#method_before
@Override
public void accept(byte[] bytes) {
    M decoded = decoder.apply(ClusterMessage.fromBytes(bytes).payload());
    if (((ClusterMessage) decoded).getFingerPrint() == clusterFingerprint) {
        consumer.accept(decoded);
    }
}
#method_after
@Override
public void accept(byte[] bytes) {
    ClusterMessage clusterMessage = ClusterMessage.fromBytes(bytes);
    if (clusterMessage.getFingerPrint() == clusterFingerprint) {
        consumer.accept(decoder.apply(clusterMessage.payload()));
    } else if (BLACKLIST.add(clusterMessage.getFingerPrint())) {
        log.warn("Ignoring message with incorrect fingerprint expected {}, received {}", clusterFingerprint, clusterMessage.getFingerPrint());
    }
}
#end_block

#method_before
public static IsIsPseudonode read(ChannelBuffer cb) {
    byte[] isoNodeID = new byte[LENGTH - 1];
    cb.readBytes(isoNodeID, 0, LENGTH - 1);
    byte psnIdentifier = cb.readByte();
    return IsIsPseudonode.of(isoNodeID, psnIdentifier);
}
#method_after
public static IsIsPseudonode read(ChannelBuffer cb) {
    byte[] isoNodeID = new byte[LENGTH - 1];
    cb.readBytes(isoNodeID);
    byte psnIdentifier = cb.readByte();
    return IsIsPseudonode.of(isoNodeID, psnIdentifier);
}
#end_block

#method_before
public static IsIsNonPseudonode read(ChannelBuffer cb) {
    byte[] isoNodeID = new byte[LENGTH];
    cb.readBytes(isoNodeID, 0, LENGTH);
    return IsIsNonPseudonode.of(isoNodeID);
}
#method_after
public static IsIsNonPseudonode read(ChannelBuffer cb) {
    byte[] isoNodeID = new byte[LENGTH];
    cb.readBytes(isoNodeID);
    return IsIsNonPseudonode.of(isoNodeID);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("tributarySlot", index).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("index", index).toString();
}
#end_block

#method_before
private void registerPortResource(Device device, Port port) {
    ResourcePath parent = new ResourcePath(device.id());
    executor.submit(() -> {
        adminService.registerResources(parent, port.number());
        ResourcePath portPath = new ResourcePath(device.id(), port.number());
        switch(port.type()) {
            // register ODU TributarySlots against the OCH ports
            case OCH:
                OduSignalType signalType = ((OchPort) port).signalType();
                switch(signalType) {
                    case ODU2:
                        adminService.registerResources(portPath, ENTIRE_ODU2_TRIBUTARY_SLOTS);
                        break;
                    case ODU4:
                        adminService.registerResources(portPath, ENTIRE_ODU4_TRIBUTARY_SLOTS);
                        break;
                    default:
                        break;
                }
                break;
            default:
                break;
        }
    });
}
#method_after
private void registerPortResource(Device device, Port port) {
    ResourcePath parent = ResourcePath.discrete(device.id());
    executor.submit(() -> registerPortResource(device, port, parent));
}
#end_block

#method_before
private void registerPortResource(Device device, Port port) {
    ResourcePath parent = new ResourcePath(device.id());
    executor.submit(() -> {
        adminService.registerResources(parent, port.number());
        ResourcePath portPath = new ResourcePath(device.id(), port.number());
        switch(port.type()) {
            // register ODU TributarySlots against the OCH ports
            case OCH:
                OduSignalType signalType = ((OchPort) port).signalType();
                switch(signalType) {
                    case ODU2:
                        adminService.registerResources(portPath, ENTIRE_ODU2_TRIBUTARY_SLOTS);
                        break;
                    case ODU4:
                        adminService.registerResources(portPath, ENTIRE_ODU4_TRIBUTARY_SLOTS);
                        break;
                    default:
                        break;
                }
                break;
            default:
                break;
        }
    });
}
#method_after
private void registerPortResource(Device device, Port port, ResourcePath parent) {
    adminService.registerResources(parent, port.number());
    ResourcePath portPath = ResourcePath.discrete(device.id(), port.number());
    switch(port.type()) {
        case OCH:
            // register ODU TributarySlots against the OCH port
            registerTributarySlotsResources(((OchPort) port).signalType(), portPath);
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void unregisterPortResource(Device device, Port port) {
    ResourcePath parent = new ResourcePath(device.id());
    executor.submit(() -> adminService.unregisterResources(parent, port.number()));
}
#method_after
private void unregisterPortResource(Device device, Port port) {
    ResourcePath parent = ResourcePath.discrete(device.id());
    executor.submit(() -> adminService.unregisterResources(parent, port.number()));
}
#end_block

#method_before
private static List<TributarySlot> getEntireOdu2TributarySlots() {
    return IntStream.rangeClosed(1, TOTAL_ODU2_TRIBUTARY_SLOTS).mapToObj(x -> TributarySlot.tributarySlot(x)).collect(Collectors.toList());
}
#method_after
private static List<TributarySlot> getEntireOdu2TributarySlots() {
    return IntStream.rangeClosed(1, TOTAL_ODU2_TRIBUTARY_SLOTS).mapToObj(x -> TributarySlot.of(x)).collect(Collectors.toList());
}
#end_block

#method_before
private static List<TributarySlot> getEntireOdu4TributarySlots() {
    return IntStream.rangeClosed(1, TOTAL_ODU4_TRIBUTARY_SLOTS).mapToObj(x -> TributarySlot.tributarySlot(x)).collect(Collectors.toList());
}
#method_after
private static List<TributarySlot> getEntireOdu4TributarySlots() {
    return IntStream.rangeClosed(1, TOTAL_ODU4_TRIBUTARY_SLOTS).mapToObj(x -> TributarySlot.of(x)).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public PROTOCOLTYPE getProtocolId() throws BGPParseException {
    switch(protocolId) {
        case Constants.ISIS_LEVELONE:
            return PROTOCOLTYPE.ISIS_LevelOne;
        case Constants.ISIS_LEVELTWO:
            return PROTOCOLTYPE.ISIS_LevelTwo;
        case Constants.OSPFV2:
            return PROTOCOLTYPE.OSPFv2;
        case Constants.DIRECT:
            return PROTOCOLTYPE.Direct;
        case Constants.STATIC_CONFIGURATION:
            return PROTOCOLTYPE.Static_Configuration;
        case Constants.OSPFV3:
            return PROTOCOLTYPE.OSPFv3;
        default:
            throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, (byte) 0, null);
    }
}
#method_after
@Override
public ProtocolType getProtocolId() throws BGPParseException {
    switch(protocolId) {
        case Constants.ISIS_LEVELONE:
            return ProtocolType.ISIS_LEVEL_ONE;
        case Constants.ISIS_LEVELTWO:
            return ProtocolType.ISIS_LEVEL_TWO;
        case Constants.OSPFV2:
            return ProtocolType.OSPF_V2;
        case Constants.DIRECT:
            return ProtocolType.DIRECT;
        case Constants.STATIC_CONFIGURATION:
            return ProtocolType.STATIC_CONFIGURATION;
        case Constants.OSPFV3:
            return ProtocolType.OSPF_V3;
        default:
            throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, (byte) 0, null);
    }
}
#end_block

#method_before
@Override
public LinkProvider provider() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public DeviceProvider provider() {
    return null;
}
#end_block

#method_before
public TreeMap<BGPNodeLSIdentifier, PathAttrNlriDetails> nodeTree() {
    return nodeTree;
}
#method_after
public Map<BGPNodeLSIdentifier, PathAttrNlriDetails> nodeTree() {
    return nodeTree;
}
#end_block

#method_before
public TreeMap<BGPLinkLSIdentifier, PathAttrNlriDetails> linkTree() {
    return linkTree;
}
#method_after
public Map<BGPLinkLSIdentifier, PathAttrNlriDetails> linkTree() {
    return linkTree;
}
#end_block

#method_before
public TreeMap<BGPPrefixLSIdentifier, PathAttrNlriDetails> prefixTree() {
    return prefixTree;
}
#method_after
public Map<BGPPrefixLSIdentifier, PathAttrNlriDetails> prefixTree() {
    return prefixTree;
}
#end_block

#method_before
public TreeMap<BGPNodeLSIdentifier, PathAttrNlriDetails> nodeTree() {
    return nodeTree;
}
#method_after
public Map<BGPNodeLSIdentifier, PathAttrNlriDetails> nodeTree() {
    return nodeTree;
}
#end_block

#method_before
public TreeMap<BGPLinkLSIdentifier, PathAttrNlriDetails> linkTree() {
    return linkTree;
}
#method_after
public Map<BGPLinkLSIdentifier, PathAttrNlriDetails> linkTree() {
    return linkTree;
}
#end_block

#method_before
public TreeMap<BGPPrefixLSIdentifier, PathAttrNlriDetails> prefixTree() {
    return prefixTree;
}
#method_after
public Map<BGPPrefixLSIdentifier, PathAttrNlriDetails> prefixTree() {
    return prefixTree;
}
#end_block

#method_before
public TreeMap<RouteDistinguisher, TreeMap<BGPNodeLSIdentifier, PathAttrNlriDetails>> vpnNodeTree() {
    return vpnNodeTree;
}
#method_after
public Map<RouteDistinguisher, Map<BGPNodeLSIdentifier, PathAttrNlriDetails>> vpnNodeTree() {
    return vpnNodeTree;
}
#end_block

#method_before
public TreeMap<RouteDistinguisher, TreeMap<BGPLinkLSIdentifier, PathAttrNlriDetails>> vpnLinkTree() {
    return vpnLinkTree;
}
#method_after
public Map<RouteDistinguisher, Map<BGPLinkLSIdentifier, PathAttrNlriDetails>> vpnLinkTree() {
    return vpnLinkTree;
}
#end_block

#method_before
public TreeMap<RouteDistinguisher, TreeMap<BGPPrefixLSIdentifier, PathAttrNlriDetails>> vpnPrefixTree() {
    return vpnPrefixTree;
}
#method_after
public Map<RouteDistinguisher, Map<BGPPrefixLSIdentifier, PathAttrNlriDetails>> vpnPrefixTree() {
    return vpnPrefixTree;
}
#end_block

#method_before
/**
 * Builds the match for the flow mod.
 *
 * @return the match
 */
protected Match buildMatch() {
    Match.Builder mBuilder = factory.buildMatch();
    Ip6Address ip6Address;
    Ip4Prefix ip4Prefix;
    Ip6Prefix ip6Prefix;
    EthCriterion ethCriterion;
    IPCriterion ipCriterion;
    TcpPortCriterion tcpPortCriterion;
    UdpPortCriterion udpPortCriterion;
    SctpPortCriterion sctpPortCriterion;
    IPv6NDLinkLayerAddressCriterion llAddressCriterion;
    ArpHaCriterion arpHaCriterion;
    for (Criterion c : selector.criteria()) {
        switch(c.type()) {
            case IN_PORT:
                PortCriterion inPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPort.port().toLong()));
                break;
            case IN_PHY_PORT:
                PortCriterion inPhyPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPhyPort.port().toLong()));
                break;
            case METADATA:
                MetadataCriterion metadata = (MetadataCriterion) c;
                mBuilder.setExact(MatchField.METADATA, OFMetadata.ofRaw(metadata.metadata()));
                break;
            case ETH_DST:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_DST, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_SRC:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_SRC, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_TYPE:
                EthTypeCriterion ethType = (EthTypeCriterion) c;
                mBuilder.setExact(MatchField.ETH_TYPE, EthType.of(ethType.ethType().toShort()));
                break;
            case VLAN_VID:
                VlanIdCriterion vid = (VlanIdCriterion) c;
                if (vid.vlanId().equals(VlanId.ANY)) {
                    mBuilder.setMasked(MatchField.VLAN_VID, OFVlanVidMatch.PRESENT, OFVlanVidMatch.PRESENT);
                } else if (vid.vlanId().equals(VlanId.NONE)) {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.NONE);
                } else {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlanVid(VlanVid.ofVlan(vid.vlanId().toShort())));
                }
                break;
            case VLAN_PCP:
                VlanPcpCriterion vpcp = (VlanPcpCriterion) c;
                mBuilder.setExact(MatchField.VLAN_PCP, VlanPcp.of(vpcp.priority()));
                break;
            case IP_DSCP:
                IPDscpCriterion ipDscpCriterion = (IPDscpCriterion) c;
                mBuilder.setExact(MatchField.IP_DSCP, IpDscp.of(ipDscpCriterion.ipDscp()));
                break;
            case IP_ECN:
                IPEcnCriterion ipEcnCriterion = (IPEcnCriterion) c;
                mBuilder.setExact(MatchField.IP_ECN, IpEcn.of(ipEcnCriterion.ipEcn()));
                break;
            case IP_PROTO:
                IPProtocolCriterion p = (IPProtocolCriterion) c;
                mBuilder.setExact(MatchField.IP_PROTO, IpProtocol.of(p.protocol()));
                break;
            case IPV4_SRC:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_SRC, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IPV4_DST:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_DST, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case TCP_SRC:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_SRC, TransportPort.of(tcpPortCriterion.tcpPort().toInt()));
                break;
            case TCP_DST:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_DST, TransportPort.of(tcpPortCriterion.tcpPort().toInt()));
                break;
            case UDP_SRC:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_SRC, TransportPort.of(udpPortCriterion.udpPort().toInt()));
                break;
            case UDP_DST:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_DST, TransportPort.of(udpPortCriterion.udpPort().toInt()));
                break;
            case SCTP_SRC:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_SRC, TransportPort.of(sctpPortCriterion.sctpPort().toInt()));
                break;
            case SCTP_DST:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_DST, TransportPort.of(sctpPortCriterion.sctpPort().toInt()));
                break;
            case ICMPV4_TYPE:
                IcmpTypeCriterion icmpType = (IcmpTypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_TYPE, ICMPv4Type.of(icmpType.icmpType()));
                break;
            case ICMPV4_CODE:
                IcmpCodeCriterion icmpCode = (IcmpCodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_CODE, ICMPv4Code.of(icmpCode.icmpCode()));
                break;
            case IPV6_SRC:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_SRC, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_DST:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_DST, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_FLABEL:
                IPv6FlowLabelCriterion flowLabelCriterion = (IPv6FlowLabelCriterion) c;
                mBuilder.setExact(MatchField.IPV6_FLABEL, IPv6FlowLabel.of(flowLabelCriterion.flowLabel()));
                break;
            case ICMPV6_TYPE:
                Icmpv6TypeCriterion icmpv6Type = (Icmpv6TypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_TYPE, U8.of(icmpv6Type.icmpv6Type()));
                break;
            case ICMPV6_CODE:
                Icmpv6CodeCriterion icmpv6Code = (Icmpv6CodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_CODE, U8.of(icmpv6Code.icmpv6Code()));
                break;
            case IPV6_ND_TARGET:
                IPv6NDTargetAddressCriterion targetAddressCriterion = (IPv6NDTargetAddressCriterion) c;
                ip6Address = targetAddressCriterion.targetAddress();
                mBuilder.setExact(MatchField.IPV6_ND_TARGET, IPv6Address.of(ip6Address.toOctets()));
                break;
            case IPV6_ND_SLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_SLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case IPV6_ND_TLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_TLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case MPLS_LABEL:
                MplsCriterion mp = (MplsCriterion) c;
                mBuilder.setExact(MatchField.MPLS_LABEL, U32.of(mp.label().toInt()));
                break;
            case IPV6_EXTHDR:
                IPv6ExthdrFlagsCriterion exthdrFlagsCriterion = (IPv6ExthdrFlagsCriterion) c;
                mBuilder.setExact(MatchField.IPV6_EXTHDR, U16.of(exthdrFlagsCriterion.exthdrFlags()));
                break;
            case OCH_SIGID:
                try {
                    OchSignalCriterion ochSignalCriterion = (OchSignalCriterion) c;
                    OchSignal signal = ochSignalCriterion.lambda();
                    byte gridType = OpenFlowValueMapper.lookupGridType(signal.gridType());
                    byte channelSpacing = OpenFlowValueMapper.lookupChannelSpacing(signal.channelSpacing());
                    mBuilder.setExact(MatchField.OCH_SIGID, new CircuitSignalID(gridType, channelSpacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity()));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                }
                break;
            case OCH_SIGTYPE:
                OchSignalTypeCriterion sc = (OchSignalTypeCriterion) c;
                byte signalType = OpenFlowValueMapper.lookupOchSignalType(sc.signalType());
                mBuilder.setExact(MatchField.OCH_SIGTYPE, U8.of(signalType));
                break;
            case TUNNEL_ID:
                TunnelIdCriterion tunnelId = (TunnelIdCriterion) c;
                mBuilder.setExact(MatchField.TUNNEL_ID, U64.of(tunnelId.tunnelId()));
                break;
            case MPLS_BOS:
                MplsBosCriterion mplsBos = (MplsBosCriterion) c;
                mBuilder.setExact(MatchField.MPLS_BOS, mplsBos.mplsBos() ? OFBooleanValue.TRUE : OFBooleanValue.FALSE);
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
                arpHaCriterion = (ArpHaCriterion) c;
                mBuilder.setExact(MatchField.ARP_THA, MacAddress.of(arpHaCriterion.mac().toLong()));
                break;
            case ARP_TPA:
            case MPLS_TC:
            case PBB_ISID:
            default:
                log.warn("Match type {} not yet implemented.", c.type());
        }
    }
    return mBuilder.build();
}
#method_after
/**
 * Builds the match for the flow mod.
 *
 * @return the match
 */
protected Match buildMatch() {
    Match.Builder mBuilder = factory.buildMatch();
    Ip6Address ip6Address;
    Ip4Prefix ip4Prefix;
    Ip6Prefix ip6Prefix;
    EthCriterion ethCriterion;
    IPCriterion ipCriterion;
    TcpPortCriterion tcpPortCriterion;
    UdpPortCriterion udpPortCriterion;
    SctpPortCriterion sctpPortCriterion;
    IPv6NDLinkLayerAddressCriterion llAddressCriterion;
    ArpHaCriterion arpHaCriterion;
    for (Criterion c : selector.criteria()) {
        switch(c.type()) {
            case IN_PORT:
                PortCriterion inPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPort.port().toLong()));
                break;
            case IN_PHY_PORT:
                PortCriterion inPhyPort = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inPhyPort.port().toLong()));
                break;
            case METADATA:
                MetadataCriterion metadata = (MetadataCriterion) c;
                mBuilder.setExact(MatchField.METADATA, OFMetadata.ofRaw(metadata.metadata()));
                break;
            case ETH_DST:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_DST, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_SRC:
                ethCriterion = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_SRC, MacAddress.of(ethCriterion.mac().toLong()));
                break;
            case ETH_TYPE:
                EthTypeCriterion ethType = (EthTypeCriterion) c;
                mBuilder.setExact(MatchField.ETH_TYPE, EthType.of(ethType.ethType().toShort()));
                break;
            case VLAN_VID:
                VlanIdCriterion vid = (VlanIdCriterion) c;
                if (vid.vlanId().equals(VlanId.ANY)) {
                    mBuilder.setMasked(MatchField.VLAN_VID, OFVlanVidMatch.PRESENT, OFVlanVidMatch.PRESENT);
                } else if (vid.vlanId().equals(VlanId.NONE)) {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.NONE);
                } else {
                    mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlanVid(VlanVid.ofVlan(vid.vlanId().toShort())));
                }
                break;
            case VLAN_PCP:
                VlanPcpCriterion vpcp = (VlanPcpCriterion) c;
                mBuilder.setExact(MatchField.VLAN_PCP, VlanPcp.of(vpcp.priority()));
                break;
            case IP_DSCP:
                IPDscpCriterion ipDscpCriterion = (IPDscpCriterion) c;
                mBuilder.setExact(MatchField.IP_DSCP, IpDscp.of(ipDscpCriterion.ipDscp()));
                break;
            case IP_ECN:
                IPEcnCriterion ipEcnCriterion = (IPEcnCriterion) c;
                mBuilder.setExact(MatchField.IP_ECN, IpEcn.of(ipEcnCriterion.ipEcn()));
                break;
            case IP_PROTO:
                IPProtocolCriterion p = (IPProtocolCriterion) c;
                mBuilder.setExact(MatchField.IP_PROTO, IpProtocol.of(p.protocol()));
                break;
            case IPV4_SRC:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_SRC, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IPV4_DST:
                ipCriterion = (IPCriterion) c;
                ip4Prefix = ipCriterion.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_DST, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case TCP_SRC:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_SRC, TransportPort.of(tcpPortCriterion.tcpPort().toInt()));
                break;
            case TCP_DST:
                tcpPortCriterion = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_DST, TransportPort.of(tcpPortCriterion.tcpPort().toInt()));
                break;
            case UDP_SRC:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_SRC, TransportPort.of(udpPortCriterion.udpPort().toInt()));
                break;
            case UDP_DST:
                udpPortCriterion = (UdpPortCriterion) c;
                mBuilder.setExact(MatchField.UDP_DST, TransportPort.of(udpPortCriterion.udpPort().toInt()));
                break;
            case SCTP_SRC:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_SRC, TransportPort.of(sctpPortCriterion.sctpPort().toInt()));
                break;
            case SCTP_DST:
                sctpPortCriterion = (SctpPortCriterion) c;
                mBuilder.setExact(MatchField.SCTP_DST, TransportPort.of(sctpPortCriterion.sctpPort().toInt()));
                break;
            case ICMPV4_TYPE:
                IcmpTypeCriterion icmpType = (IcmpTypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_TYPE, ICMPv4Type.of(icmpType.icmpType()));
                break;
            case ICMPV4_CODE:
                IcmpCodeCriterion icmpCode = (IcmpCodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV4_CODE, ICMPv4Code.of(icmpCode.icmpCode()));
                break;
            case IPV6_SRC:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_SRC, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_DST:
                ipCriterion = (IPCriterion) c;
                ip6Prefix = ipCriterion.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_DST, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_FLABEL:
                IPv6FlowLabelCriterion flowLabelCriterion = (IPv6FlowLabelCriterion) c;
                mBuilder.setExact(MatchField.IPV6_FLABEL, IPv6FlowLabel.of(flowLabelCriterion.flowLabel()));
                break;
            case ICMPV6_TYPE:
                Icmpv6TypeCriterion icmpv6Type = (Icmpv6TypeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_TYPE, U8.of(icmpv6Type.icmpv6Type()));
                break;
            case ICMPV6_CODE:
                Icmpv6CodeCriterion icmpv6Code = (Icmpv6CodeCriterion) c;
                mBuilder.setExact(MatchField.ICMPV6_CODE, U8.of(icmpv6Code.icmpv6Code()));
                break;
            case IPV6_ND_TARGET:
                IPv6NDTargetAddressCriterion targetAddressCriterion = (IPv6NDTargetAddressCriterion) c;
                ip6Address = targetAddressCriterion.targetAddress();
                mBuilder.setExact(MatchField.IPV6_ND_TARGET, IPv6Address.of(ip6Address.toOctets()));
                break;
            case IPV6_ND_SLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_SLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case IPV6_ND_TLL:
                llAddressCriterion = (IPv6NDLinkLayerAddressCriterion) c;
                mBuilder.setExact(MatchField.IPV6_ND_TLL, MacAddress.of(llAddressCriterion.mac().toLong()));
                break;
            case MPLS_LABEL:
                MplsCriterion mp = (MplsCriterion) c;
                mBuilder.setExact(MatchField.MPLS_LABEL, U32.of(mp.label().toInt()));
                break;
            case IPV6_EXTHDR:
                IPv6ExthdrFlagsCriterion exthdrFlagsCriterion = (IPv6ExthdrFlagsCriterion) c;
                mBuilder.setExact(MatchField.IPV6_EXTHDR, U16.of(exthdrFlagsCriterion.exthdrFlags()));
                break;
            case OCH_SIGID:
                try {
                    OchSignalCriterion ochSignalCriterion = (OchSignalCriterion) c;
                    OchSignal signal = ochSignalCriterion.lambda();
                    byte gridType = OpenFlowValueMapper.lookupGridType(signal.gridType());
                    byte channelSpacing = OpenFlowValueMapper.lookupChannelSpacing(signal.channelSpacing());
                    mBuilder.setExact(MatchField.OCH_SIGID, new CircuitSignalID(gridType, channelSpacing, (short) signal.spacingMultiplier(), (short) signal.slotGranularity()));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                }
                break;
            case OCH_SIGTYPE:
                OchSignalTypeCriterion sc = (OchSignalTypeCriterion) c;
                byte signalType = OpenFlowValueMapper.lookupOchSignalType(sc.signalType());
                mBuilder.setExact(MatchField.OCH_SIGTYPE, U8.of(signalType));
                break;
            case TUNNEL_ID:
                TunnelIdCriterion tunnelId = (TunnelIdCriterion) c;
                mBuilder.setExact(MatchField.TUNNEL_ID, U64.of(tunnelId.tunnelId()));
                break;
            case MPLS_BOS:
                MplsBosCriterion mplsBos = (MplsBosCriterion) c;
                mBuilder.setExact(MatchField.MPLS_BOS, mplsBos.mplsBos() ? OFBooleanValue.TRUE : OFBooleanValue.FALSE);
                break;
            case ARP_THA:
                arpHaCriterion = (ArpHaCriterion) c;
                mBuilder.setExact(MatchField.ARP_THA, MacAddress.of(arpHaCriterion.mac().toLong()));
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_TPA:
            case MPLS_TC:
            case PBB_ISID:
            default:
                log.warn("Match type {} not yet implemented.", c.type());
        }
    }
    return mBuilder.build();
}
#end_block

#method_before
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                builder.matchEthDst(mac);
                break;
            case ETH_SRC:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                builder.matchEthSrc(mac);
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                builder.matchEthType((short) ethType);
                break;
            case VLAN_VID:
                VlanId vlanId = null;
                if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                    Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                    if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                        vlanId = VlanId.ANY;
                    }
                } else {
                    if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                        vlanId = VlanId.NONE;
                    } else {
                        vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                    }
                }
                if (vlanId != null) {
                    builder.matchVlanId(vlanId);
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc(TpPort.tpPort(match.get(MatchField.TCP_SRC).getPort()));
                break;
            case TCP_DST:
                builder.matchTcpDst(TpPort.tpPort(match.get(MatchField.TCP_DST).getPort()));
                break;
            case UDP_SRC:
                builder.matchUdpSrc(TpPort.tpPort(match.get(MatchField.UDP_SRC).getPort()));
                break;
            case UDP_DST:
                builder.matchUdpDst(TpPort.tpPort(match.get(MatchField.UDP_DST).getPort()));
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case MPLS_BOS:
                builder.matchMplsBos(match.get(MatchField.MPLS_BOS).getValue());
                break;
            case SCTP_SRC:
                builder.matchSctpSrc(TpPort.tpPort(match.get(MatchField.SCTP_SRC).getPort()));
                break;
            case SCTP_DST:
                builder.matchSctpDst(TpPort.tpPort(match.get(MatchField.SCTP_DST).getPort()));
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_THA).getLong());
                builder.matchArpTha(mac);
                break;
            case ARP_TPA:
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#method_after
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                builder.matchEthDst(mac);
                break;
            case ETH_SRC:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                builder.matchEthSrc(mac);
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                builder.matchEthType((short) ethType);
                break;
            case VLAN_VID:
                VlanId vlanId = null;
                if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                    Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                    if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                        vlanId = VlanId.ANY;
                    }
                } else {
                    if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                        vlanId = VlanId.NONE;
                    } else {
                        vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                    }
                }
                if (vlanId != null) {
                    builder.matchVlanId(vlanId);
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc(TpPort.tpPort(match.get(MatchField.TCP_SRC).getPort()));
                break;
            case TCP_DST:
                builder.matchTcpDst(TpPort.tpPort(match.get(MatchField.TCP_DST).getPort()));
                break;
            case UDP_SRC:
                builder.matchUdpSrc(TpPort.tpPort(match.get(MatchField.UDP_SRC).getPort()));
                break;
            case UDP_DST:
                builder.matchUdpDst(TpPort.tpPort(match.get(MatchField.UDP_DST).getPort()));
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case MPLS_BOS:
                builder.matchMplsBos(match.get(MatchField.MPLS_BOS).getValue());
                break;
            case SCTP_SRC:
                builder.matchSctpSrc(TpPort.tpPort(match.get(MatchField.SCTP_SRC).getPort()));
                break;
            case SCTP_DST:
                builder.matchSctpDst(TpPort.tpPort(match.get(MatchField.SCTP_DST).getPort()));
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_THA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_THA).getLong());
                builder.matchArpTha(mac);
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_TPA:
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#end_block

#method_before
@Activate
protected void activate() {
    ApplicationId appId = coreService.registerApplication("org.onosproject.cordvtn");
    nodeStore = storageService.<DeviceId, CordVtnNode>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName("cordvtn-nodestore").withApplicationId(appId).build();
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    ApplicationId appId = coreService.registerApplication("org.onosproject.cordvtn");
    nodeStore = storageService.<CordVtnNode, NodeState>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName("cordvtn-nodestore").withApplicationId(appId).build();
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    log.info("Started");
}
#end_block

#method_before
@Override
public void addNode(CordVtnNode node) {
    checkNotNull(node);
    nodeStore.putIfAbsent(node.ovsdbId(), node);
    initNode(node);
}
#method_after
@Override
public void addNode(CordVtnNode node) {
    checkNotNull(node);
    nodeStore.putIfAbsent(node, checkNodeState(node));
    initNode(node);
}
#end_block

#method_before
@Override
public void deleteNode(CordVtnNode node) {
    checkNotNull(node);
    if (getOvsdbConnectionState(node)) {
        disconnect(node);
    }
    nodeStore.remove(node.ovsdbId());
}
#method_after
@Override
public void deleteNode(CordVtnNode node) {
    checkNotNull(node);
    if (getOvsdbConnectionState(node)) {
        disconnect(node);
    }
    nodeStore.remove(node);
}
#end_block

#method_before
@Override
public List<CordVtnNode> getNodes() {
    List<CordVtnNode> nodes = new ArrayList<>();
    nodes.addAll(Collections2.transform(nodeStore.values(), Versioned::value));
    return nodes;
}
#method_after
@Override
public List<CordVtnNode> getNodes() {
    List<CordVtnNode> nodes = new ArrayList<>();
    nodes.addAll(nodeStore.keySet());
    return nodes;
}
#end_block

#method_before
@Override
public void initNode(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node.ovsdbId())) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (getNodeInitState(node)) {
        postInit(node);
    } else if (!getOvsdbConnectionState(node)) {
        connect(node);
    } else if (deviceService.getDevice(node.intBrId()) == null || !deviceService.isAvailable(node.intBrId())) {
        createIntegrationBridge(node);
    } else if (!checkVxlanInterface(node)) {
        createVxlanInterface(node);
    }
}
#method_after
@Override
public void initNode(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist, add node first", node.hostname());
        return;
    }
    NodeState state = getNodeState(node);
    if (state == null) {
        return;
    } else if (state.equals(NodeState.INCOMPLETE)) {
        state = checkNodeState(node);
    }
    state.process(this, node);
}
#end_block

#method_before
@Override
public boolean getNodeInitState(CordVtnNode node) {
    return deviceService.getDevice(node.intBrId()) != null && deviceService.isAvailable(node.intBrId()) && checkVxlanInterface(node);
}
#method_after
@Override
public boolean getNodeInitState(CordVtnNode node) {
    checkNotNull(node);
    NodeState state = getNodeState(node);
    return state != null && state.equals(NodeState.COMPLETE);
}
#end_block

#method_before
private void postInit(CordVtnNode node) {
    disconnect(node);
    adminService.removeDevice(node.ovsdbId());
}
#method_after
private void postInit(CordVtnNode node) {
    disconnect(node);
}
#end_block

#method_before
private boolean getOvsdbConnectionState(CordVtnNode node) {
    checkNotNull(node);
    OvsdbClientService ovsdbClient = getOvsdbClient(node);
    return ovsdbClient != null && ovsdbClient.isConnected();
}
#method_after
private boolean getOvsdbConnectionState(CordVtnNode node) {
    checkNotNull(node);
    OvsdbClientService ovsdbClient = getOvsdbClient(node);
    return deviceService.isAvailable(node.ovsdbId()) && ovsdbClient != null && ovsdbClient.isConnected();
}
#end_block

#method_before
private void connect(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node.ovsdbId())) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (!getOvsdbConnectionState(node)) {
        // FIXME remove existing OVSDB device to work around OVSDB device re-connect issue
        if (deviceService.getDevice(node.ovsdbId()) != null) {
            adminService.removeDevice(node.ovsdbId());
        }
        controller.connect(node.ovsdbIp(), node.ovsdbPort());
    }
}
#method_after
private void connect(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (!getOvsdbConnectionState(node)) {
        // FIXME remove existing OVSDB device to work around OVSDB device re-connect issue
        if (deviceService.getDevice(node.ovsdbId()) != null) {
            adminService.removeDevice(node.ovsdbId());
        }
        controller.connect(node.ovsdbIp(), node.ovsdbPort());
    }
}
#end_block

#method_before
private void disconnect(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node.ovsdbId())) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (getOvsdbConnectionState(node)) {
        OvsdbClientService ovsdbClient = getOvsdbClient(node);
        ovsdbClient.disconnect();
    }
}
#method_after
private void disconnect(CordVtnNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (getOvsdbConnectionState(node)) {
        OvsdbClientService ovsdbClient = getOvsdbClient(node);
        ovsdbClient.disconnect();
    }
    // FIXME remove existing OVSDB device to work around OVSDB device re-connect issue
    if (deviceService.getDevice(node.ovsdbId()) != null) {
        adminService.removeDevice(node.ovsdbId());
    }
}
#end_block

#method_before
private CordVtnNode getNodeByOvsdbId(DeviceId ovsdbId) {
    Versioned<CordVtnNode> node = nodeStore.get(ovsdbId);
    if (node != null) {
        return node.value();
    } else {
        return null;
    }
}
#method_after
private CordVtnNode getNodeByOvsdbId(DeviceId ovsdbId) {
    try {
        return getNodes().stream().filter(node -> node.ovsdbId().equals(ovsdbId)).findFirst().get();
    } catch (NoSuchElementException e) {
        log.debug("Couldn't find node information for {}", ovsdbId);
        return null;
    }
}
#end_block

#method_before
private CordVtnNode getNodeByBridgeId(DeviceId bridgeId) {
    try {
        return getNodes().stream().filter(node -> node.intBrId().equals(bridgeId)).findFirst().get();
    } catch (NoSuchElementException e) {
        log.warn("Couldn't find node information for {}", bridgeId);
        return null;
    }
}
#method_after
private CordVtnNode getNodeByBridgeId(DeviceId bridgeId) {
    try {
        return getNodes().stream().filter(node -> node.intBrId().equals(bridgeId)).findFirst().get();
    } catch (NoSuchElementException e) {
        log.debug("Couldn't find node information for {}", bridgeId);
        return null;
    }
}
#end_block

#method_before
private void createIntegrationBridge(CordVtnNode node) {
    List<ControllerInfo> controllers = new ArrayList<>();
    Sets.newHashSet(clusterService.getNodes()).forEach(controller -> {
        ControllerInfo ctrlInfo = new ControllerInfo(controller.ip(), OFPORT, "tcp");
        controllers.add(ctrlInfo);
    });
    String dpid = node.intBrId().toString().substring(DPID_BEGIN);
    try {
        DriverHandler handler = driverService.createHandler(node.ovsdbId());
        BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
        bridgeConfig.addBridge(BridgeName.bridgeName(DEFAULT_BRIDGE_NAME), dpid, controllers);
    } catch (ItemNotFoundException e) {
        log.warn("Failed to create integration bridge on {}", node.ovsdbId());
    }
}
#method_after
private void createIntegrationBridge(CordVtnNode node) {
    if (checkIntegrationBridge(node)) {
        return;
    }
    List<ControllerInfo> controllers = new ArrayList<>();
    Sets.newHashSet(clusterService.getNodes()).forEach(controller -> {
        ControllerInfo ctrlInfo = new ControllerInfo(controller.ip(), OFPORT, "tcp");
        controllers.add(ctrlInfo);
    });
    String dpid = node.intBrId().toString().substring(DPID_BEGIN);
    try {
        DriverHandler handler = driverService.createHandler(node.ovsdbId());
        BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
        bridgeConfig.addBridge(BridgeName.bridgeName(DEFAULT_BRIDGE_NAME), dpid, controllers);
    } catch (ItemNotFoundException e) {
        log.warn("Failed to create integration bridge on {}", node.ovsdbId());
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    ConnectionHandler<Device> handler = (device.type().equals(SWITCH) ? bridgeHandler : ovsdbHandler);
    switch(event.type()) {
        case PORT_ADDED:
            eventExecutor.submit(() -> bridgeHandler.portAdded(event.port()));
            break;
        case DEVICE_ADDED:
            eventExecutor.submit(() -> handler.connected(device));
            break;
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(device.id())) {
                eventExecutor.submit(() -> handler.connected(device));
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    ConnectionHandler<Device> handler = (device.type().equals(SWITCH) ? bridgeHandler : ovsdbHandler);
    switch(event.type()) {
        case PORT_ADDED:
            eventExecutor.submit(() -> bridgeHandler.portAdded(event.port()));
            break;
        case PORT_UPDATED:
            if (!event.port().isEnabled()) {
                eventExecutor.submit(() -> bridgeHandler.portRemoved(event.port()));
            }
            break;
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(device.id())) {
                eventExecutor.submit(() -> handler.connected(device));
            } else {
                eventExecutor.submit(() -> handler.disconnected(device));
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void connected(Device device) {
    log.info("OVSDB {} is connected", device.id());
    CordVtnNode node = getNodeByOvsdbId(device.id());
    if (node != null) {
        initNode(node);
    }
}
#method_after
@Override
public void connected(Device device) {
    CordVtnNode node = getNodeByOvsdbId(device.id());
    if (node != null) {
        setNodeState(node, checkNodeState(node));
    }
}
#end_block

#method_before
@Override
public void connected(Device device) {
    log.info("Integration Bridge {} is detected", device.id());
    CordVtnNode node = getNodeByBridgeId(device.id());
    if (node != null) {
        initNode(node);
    }
}
#method_after
@Override
public void connected(Device device) {
    CordVtnNode node = getNodeByBridgeId(device.id());
    if (node != null) {
        setNodeState(node, checkNodeState(node));
    }
}
#end_block

#method_before
@Override
public void disconnected(Device device) {
    log.info("Integration Bridge {} is vanished", device.id());
}
#method_after
@Override
public void disconnected(Device device) {
    CordVtnNode node = getNodeByBridgeId(device.id());
    if (node != null) {
        log.info("Integration Bridge is disconnected from {}", node.hostname());
        setNodeState(node, NodeState.INCOMPLETE);
    }
}
#end_block

#method_before
public void portAdded(Port port) {
    if (!port.annotations().value("portName").contains(DEFAULT_TUNNEL)) {
        return;
    }
    DeviceId deviceId = (DeviceId) port.element().id();
    log.info("VXLAN interface is created on {}", deviceId);
    CordVtnNode node = getNodeByBridgeId(deviceId);
    if (node != null) {
        initNode(node);
    }
}
#method_after
public void portAdded(Port port) {
    if (!port.annotations().value("portName").contains(DEFAULT_TUNNEL)) {
        return;
    }
    CordVtnNode node = getNodeByBridgeId((DeviceId) port.element().id());
    if (node != null) {
        setNodeState(node, checkNodeState(node));
    }
}
#end_block

#method_before
@Override
protected void execute() {
    CordVtnService service = AbstractShellCommand.get(CordVtnService.class);
    for (String host : hosts) {
        CordVtnNode node;
        try {
            node = service.getNodes().stream().filter(n -> n.hostname().equals(host)).findFirst().get();
        } catch (NoSuchElementException e) {
            print("Unable to find %s", host);
            continue;
        }
        service.deleteNode(node);
    }
}
#method_after
@Override
protected void execute() {
    CordVtnService service = AbstractShellCommand.get(CordVtnService.class);
    for (String hostname : hostnames) {
        CordVtnNode node;
        try {
            node = service.getNodes().stream().filter(n -> n.hostname().equals(hostname)).findFirst().get();
        } catch (NoSuchElementException e) {
            print("Unable to find %s", hostname);
            continue;
        }
        service.deleteNode(node);
    }
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o instanceof CordVtnNode) {
        CordVtnNode that = (CordVtnNode) o;
        if (this.hostname.equals(that.hostname) && this.ovsdbIp.equals(that.ovsdbIp) && this.ovsdbPort.equals(that.ovsdbPort) && this.bridgeId.equals(that.bridgeId)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof CordVtnNode) {
        CordVtnNode that = (CordVtnNode) obj;
        if (Objects.equals(hostname, that.hostname) && Objects.equals(ovsdbIp, that.ovsdbIp) && Objects.equals(ovsdbPort, that.ovsdbPort) && Objects.equals(bridgeId, that.bridgeId)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected void execute() {
    CordVtnService service = AbstractShellCommand.get(CordVtnService.class);
    for (String host : hosts) {
        CordVtnNode node;
        try {
            node = service.getNodes().stream().filter(n -> n.hostname().equals(host)).findFirst().get();
        } catch (NoSuchElementException e) {
            print("Unable to find %s", host);
            continue;
        }
        if (!service.getNodeInitState(node)) {
            service.initNode(node);
        }
    }
}
#method_after
@Override
protected void execute() {
    CordVtnService service = AbstractShellCommand.get(CordVtnService.class);
    for (String hostname : hostnames) {
        CordVtnNode node;
        try {
            node = service.getNodes().stream().filter(n -> n.hostname().equals(hostname)).findFirst().get();
        } catch (NoSuchElementException e) {
            print("Unable to find %s", hostname);
            continue;
        }
        service.initNode(node);
    }
}
#end_block

#method_before
public static BgpLinkAttrUnRsrvdLinkBandwidth of(ArrayList<Float> linkPfxMetric, short sType) {
    return new BgpLinkAttrUnRsrvdLinkBandwidth(linkPfxMetric, sType);
}
#method_after
public static BgpLinkAttrUnRsrvdLinkBandwidth of(List<Float> linkPfxMetric, short sType) {
    return new BgpLinkAttrUnRsrvdLinkBandwidth(linkPfxMetric, sType);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    clusterService = createMock(ClusterService.class);
    expect(clusterService.getLocalNode()).andReturn(self).anyTimes();
    expect(clusterService.getNodes()).andReturn(ImmutableSet.of(self)).anyTimes();
    replay(clusterService);
    clusterCommunicator = createMock(ClusterCommunicationService.class);
    persistenceService = new PersistenceManager();
    persistenceService.activate();
    // Add expectation for adding cluster message subscribers which
    // delegate to our ClusterCommunicationService implementation. This
    // allows us to get a reference to the map's internal cluster message
    // handlers so we can induce events coming in from a peer.
    clusterCommunicator.<String>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Consumer.class), anyObject(Executor.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(2);
    replay(clusterCommunicator);
    clockService = new SequentialClockService<>();
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(TestTimestamp.class);
    ecMap = new EventuallyConsistentMapBuilderImpl<String, String>(clusterService, clusterCommunicator, persistenceService).withName(MAP_NAME).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp(k, v)).withCommunicationExecutor(MoreExecutors.newDirectExecutorService()).withPersistentStorage().build();
    // Reset ready for tests to add their own expectations
    reset(clusterCommunicator);
}
#method_after
@Before
public void setUp() throws Exception {
    clusterService = createMock(ClusterService.class);
    expect(clusterService.getLocalNode()).andReturn(self).anyTimes();
    expect(clusterService.getNodes()).andReturn(ImmutableSet.of(self)).anyTimes();
    replay(clusterService);
    clusterCommunicator = createMock(ClusterCommunicationService.class);
    persistenceService = new PersistenceManager();
    persistenceService.activate();
    // Add expectation for adding cluster message subscribers which
    // delegate to our ClusterCommunicationService implementation. This
    // allows us to get a reference to the map's internal cluster message
    // handlers so we can induce events coming in from a peer.
    clusterCommunicator.<String>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Consumer.class), anyObject(Executor.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(2);
    replay(clusterCommunicator);
    clockService = new SequentialClockService<>();
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(TestTimestamp.class);
    ecMap = new EventuallyConsistentMapBuilderImpl<String, String>(clusterService, clusterCommunicator, persistenceService).withName(MAP_NAME).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp(k, v)).withCommunicationExecutor(MoreExecutors.newDirectExecutorService()).withPersistence().build();
    // Reset ready for tests to add their own expectations
    reset(clusterCommunicator);
}
#end_block

#method_before
private MapValue<V> removeInternal(K key, Optional<V> value, Optional<MapValue<V>> tombstone) {
    checkState(!destroyed, destroyedMessage);
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    tombstone.ifPresent(v -> checkState(v.isTombstone()));
    counter.incrementCount();
    AtomicBoolean updated = new AtomicBoolean(false);
    AtomicReference<MapValue<V>> previousValue = new AtomicReference<>();
    items.compute(key, (k, existing) -> {
        boolean valueMatches = true;
        if (value.isPresent() && existing != null && existing.isAlive()) {
            valueMatches = Objects.equals(value.get(), existing.get());
        }
        if (existing == null) {
            log.trace("ECMap Remove: Existing value for key {} is already null", k);
        }
        if (valueMatches) {
            if (existing == null) {
                updated.set(tombstone.isPresent());
            } else {
                updated.set(!tombstone.isPresent() || tombstone.get().isNewerThan(existing));
            }
        }
        if (updated.get()) {
            previousValue.set(existing);
            return tombstone.orElse(null);
        } else {
            return existing;
        }
    });
    if (updated.get()) {
        if (persistent) {
            if (tombstone.isPresent()) {
                persistentStore.update(key, tombstone.get());
            } else {
                persistentStore.remove(key);
            }
        }
    }
    return previousValue.get();
}
#method_after
private MapValue<V> removeInternal(K key, Optional<V> value, Optional<MapValue<V>> tombstone) {
    checkState(!destroyed, destroyedMessage);
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    tombstone.ifPresent(v -> checkState(v.isTombstone()));
    counter.incrementCount();
    AtomicBoolean updated = new AtomicBoolean(false);
    AtomicReference<MapValue<V>> previousValue = new AtomicReference<>();
    items.compute(key, (k, existing) -> {
        boolean valueMatches = true;
        if (value.isPresent() && existing != null && existing.isAlive()) {
            valueMatches = Objects.equals(value.get(), existing.get());
        }
        if (existing == null) {
            log.trace("ECMap Remove: Existing value for key {} is already null", k);
        }
        if (valueMatches) {
            if (existing == null) {
                updated.set(tombstone.isPresent());
            } else {
                updated.set(!tombstone.isPresent() || tombstone.get().isNewerThan(existing));
            }
        }
        if (updated.get()) {
            previousValue.set(existing);
            return tombstone.orElse(null);
        } else {
            return existing;
        }
    });
    return previousValue.get();
}
#end_block

#method_before
private boolean putInternal(K key, MapValue<V> newValue) {
    checkState(!destroyed, destroyedMessage);
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(newValue, ERROR_NULL_VALUE);
    checkState(newValue.isAlive());
    counter.incrementCount();
    AtomicBoolean updated = new AtomicBoolean(false);
    items.compute(key, (k, existing) -> {
        if (existing == null || newValue.isNewerThan(existing)) {
            updated.set(true);
            return newValue;
        }
        return existing;
    });
    if (updated.get() && persistent) {
        persistentStore.update(key, newValue);
    }
    return updated.get();
}
#method_after
private boolean putInternal(K key, MapValue<V> newValue) {
    checkState(!destroyed, destroyedMessage);
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(newValue, ERROR_NULL_VALUE);
    checkState(newValue.isAlive());
    counter.incrementCount();
    AtomicBoolean updated = new AtomicBoolean(false);
    items.compute(key, (k, existing) -> {
        if (existing == null || newValue.isNewerThan(existing)) {
            updated.set(true);
            return newValue;
        }
        return existing;
    });
    return updated.get();
}
#end_block

#method_before
@Override
public EventuallyConsistentMapBuilder<K, V> withPersistence() {
    persistent = true;
    return this;
}
#method_after
@Override
public EventuallyConsistentMapBuilder<K, V> withPersistence() {
    checkNotNull(this.persistenceService);
    persistent = true;
    return this;
}
#end_block

#method_before
@Override
public EventuallyConsistentMap<K, V> build() {
    checkNotNull(name, "name is a mandatory parameter");
    checkNotNull(serializerBuilder, "serializerBuilder is a mandatory parameter");
    checkNotNull(timestampProvider, "timestampProvider is a mandatory parameter");
    return new EventuallyConsistentMapImpl<>(name, clusterService, clusterCommunicator, serializerBuilder, timestampProvider, peerUpdateFunction, eventExecutor, communicationExecutor, backgroundExecutor, tombstonesDisabled, antiEntropyPeriod, antiEntropyTimeUnit, convergeFaster, persistent, persistentMap, persistenceService);
}
#method_after
@Override
public EventuallyConsistentMap<K, V> build() {
    checkNotNull(name, "name is a mandatory parameter");
    checkNotNull(serializerBuilder, "serializerBuilder is a mandatory parameter");
    checkNotNull(timestampProvider, "timestampProvider is a mandatory parameter");
    return new EventuallyConsistentMapImpl<>(name, clusterService, clusterCommunicator, serializerBuilder, timestampProvider, peerUpdateFunction, eventExecutor, communicationExecutor, backgroundExecutor, tombstonesDisabled, antiEntropyPeriod, antiEntropyTimeUnit, convergeFaster, persistent, persistenceService);
}
#end_block

#method_before
static Serializer using(List<KryoNamespace> namespaces, Class<?>... classes) {
    KryoNamespace.Builder builder = new KryoNamespace.Builder();
    namespaces.forEach(builder::register);
    Lists.newArrayList(classes).forEach(builder::register);
    builder.register(MapEvent.class, MapEvent.Type.class, Versioned.class);
    return using(builder);
}
#method_after
static Serializer using(List<KryoNamespace> namespaces, Class<?>... classes) {
    KryoNamespace.Builder builder = new KryoNamespace.Builder();
    namespaces.forEach(builder::register);
    Lists.newArrayList(classes).forEach(builder::register);
    builder.register(MapEvent.class, MapEvent.Type.class, Versioned.class);
    KryoNamespace namespace = builder.build();
    return new Serializer() {

        @Override
        public <T> byte[] encode(T object) {
            return namespace.serialize(object);
        }

        @Override
        public <T> T decode(byte[] bytes) {
            return namespace.deserialize(bytes);
        }
    };
}
#end_block

#method_before
@GET
@Path("{subjectClassKey}")
@Produces(MediaType.APPLICATION_JSON)
@SuppressWarnings("unchecked")
public Response download(@PathParam("subjectClassKey") String subjectClassKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    ObjectNode root = mapper().createObjectNode();
    SubjectFactory subjectFactory = nullIsNotFound(service.getSubjectFactory(subjectClassKey), "Subject '" + subjectClassKey + "' not found");
    produceJson(service, root, subjectFactory, subjectFactory.subjectClass());
    return ok(root).build();
}
#method_after
@GET
@Path("{subjectClassKey}")
@Produces(MediaType.APPLICATION_JSON)
@SuppressWarnings("unchecked")
public Response download(@PathParam("subjectClassKey") String subjectClassKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    ObjectNode root = mapper().createObjectNode();
    SubjectFactory subjectFactory = nullIsNotFound(service.getSubjectFactory(subjectClassKey), subjectClassNotFoundErrorString(subjectClassKey));
    produceJson(service, root, subjectFactory, subjectFactory.subjectClass());
    return ok(root).build();
}
#end_block

#method_before
@GET
@Path("{subjectClassKey}/{subjectKey}")
@Produces(MediaType.APPLICATION_JSON)
@SuppressWarnings("unchecked")
public Response download(@PathParam("subjectClassKey") String subjectClassKey, @PathParam("subjectKey") String subjectKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    ObjectNode root = mapper().createObjectNode();
    SubjectFactory subjectFactory = nullIsNotFound(service.getSubjectFactory(subjectClassKey), "Subject class not found '" + subjectClassKey + "' not found");
    produceSubjectJson(service, root, subjectFactory.createSubject(subjectKey), "Subject not found '" + subjectKey + "'");
    return ok(root).build();
}
#method_after
@GET
@Path("{subjectClassKey}/{subjectKey}")
@Produces(MediaType.APPLICATION_JSON)
@SuppressWarnings("unchecked")
public Response download(@PathParam("subjectClassKey") String subjectClassKey, @PathParam("subjectKey") String subjectKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    ObjectNode root = mapper().createObjectNode();
    SubjectFactory subjectFactory = nullIsNotFound(service.getSubjectFactory(subjectClassKey), subjectClassNotFoundErrorString(subjectClassKey));
    produceSubjectJson(service, root, subjectFactory.createSubject(subjectKey), true, subjectNotFoundErrorString(subjectClassKey, subjectKey));
    return ok(root).build();
}
#end_block

#method_before
@GET
@Path("{subjectClassKey}/{subjectKey}/{configKey}")
@Produces(MediaType.APPLICATION_JSON)
@SuppressWarnings("unchecked")
public Response download(@PathParam("subjectClassKey") String subjectClassKey, @PathParam("subjectKey") String subjectKey, @PathParam("configKey") String configKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    String keyError = "Key '" + subjectClassKey + "/" + subjectKey + "/" + configKey + "' not found";
    Class configClass = nullIsNotFound(service.getConfigClass(subjectClassKey, configKey), keyError);
    Object subject = nullIsNotFound(service.getSubjectFactory(subjectClassKey).createSubject(subjectKey), keyError);
    Config config = nullIsNotFound(service.getConfig(subject, configClass), keyError);
    return ok(config.node()).build();
}
#method_after
@GET
@Path("{subjectClassKey}/{subjectKey}/{configKey}")
@Produces(MediaType.APPLICATION_JSON)
@SuppressWarnings("unchecked")
public Response download(@PathParam("subjectClassKey") String subjectClassKey, @PathParam("subjectKey") String subjectKey, @PathParam("configKey") String configKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    Object subject = nullIsNotFound(service.getSubjectFactory(subjectClassKey).createSubject(subjectKey), subjectNotFoundErrorString(subjectClassKey, subjectKey));
    Class configClass = nullIsNotFound(service.getConfigClass(subjectClassKey, configKey), configKeyNotFoundErrorString(subjectClassKey, subjectKey, configKey));
    Config config = nullIsNotFound(service.getConfig(subject, configClass), configKeyNotFoundErrorString(subjectClassKey, subjectKey, configKey));
    return ok(config.node()).build();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void produceJson(NetworkConfigService service, ObjectNode node, SubjectFactory subjectFactory, Class subjectClass) {
    service.getSubjects(subjectClass).forEach(s -> produceSubjectJson(service, newObject(node, subjectFactory.subjectKey(s)), s, ""));
}
#method_after
@SuppressWarnings("unchecked")
private void produceJson(NetworkConfigService service, ObjectNode node, SubjectFactory subjectFactory, Class subjectClass) {
    service.getSubjects(subjectClass).forEach(s -> produceSubjectJson(service, newObject(node, subjectFactory.subjectKey(s)), s, false, ""));
}
#end_block

#method_before
private void produceSubjectJson(NetworkConfigService service, ObjectNode node, Object subject, String emptyMessage) {
    Set<? extends Config<Object>> configs = service.getConfigs(subject);
    if (!emptyMessage.equals("")) {
        // caller wants an empty set to be a 404
        // this is slightly ugly
        configs = emptyIsNotFound(configs, emptyMessage);
    }
    configs.forEach(c -> node.set(c.key(), c.node()));
}
#method_after
private void produceSubjectJson(NetworkConfigService service, ObjectNode node, Object subject, boolean emptyIsError, String emptyErrorMessage) {
    Set<? extends Config<Object>> configs = service.getConfigs(subject);
    if (emptyIsError) {
        // caller wants an empty set to be a 404
        configs = emptyIsNotFound(configs, emptyErrorMessage);
    }
    configs.forEach(c -> node.set(c.key(), c.node()));
}
#end_block

#method_before
@DELETE
@Path("{subjectClassKey}")
@SuppressWarnings("unchecked")
public Response delete(@PathParam("subjectClassKey") String subjectClassKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    service.getSubjects(service.getSubjectFactory(subjectClassKey).getClass()).forEach(subject -> service.getConfigs(subject).forEach(config -> service.removeConfig(subject, config.getClass())));
    return Response.ok().build();
}
#method_after
@DELETE
@Path("{subjectClassKey}")
@SuppressWarnings("unchecked")
public void delete(@PathParam("subjectClassKey") String subjectClassKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    service.getSubjects(service.getSubjectFactory(subjectClassKey).subjectClass()).forEach(subject -> service.getConfigs(subject).forEach(config -> service.removeConfig(subject, config.getClass())));
}
#end_block

#method_before
@DELETE
@Path("{subjectClassKey}/{subjectKey}")
@SuppressWarnings("unchecked")
public Response delete(@PathParam("subjectClassKey") String subjectClassKey, @PathParam("subjectKey") String subjectKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    Object s = service.getSubjectFactory(subjectClassKey).createSubject(subjectKey);
    service.getConfigs(s).forEach(c -> service.removeConfig(s, c.getClass()));
    return Response.ok().build();
}
#method_after
@DELETE
@Path("{subjectClassKey}/{subjectKey}")
@SuppressWarnings("unchecked")
public void delete(@PathParam("subjectClassKey") String subjectClassKey, @PathParam("subjectKey") String subjectKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    Object s = service.getSubjectFactory(subjectClassKey).createSubject(subjectKey);
    service.getConfigs(s).forEach(c -> service.removeConfig(s, c.getClass()));
}
#end_block

#method_before
@DELETE
@Path("{subjectClassKey}/{subjectKey}/{configKey}")
@SuppressWarnings("unchecked")
public Response delete(@PathParam("subjectClassKey") String subjectClassKey, @PathParam("subjectKey") String subjectKey, @PathParam("configKey") String configKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    service.removeConfig(service.getSubjectFactory(subjectClassKey).createSubject(subjectKey), service.getConfigClass(subjectClassKey, configKey));
    return Response.ok().build();
}
#method_after
@DELETE
@Path("{subjectClassKey}/{subjectKey}/{configKey}")
@SuppressWarnings("unchecked")
public void delete(@PathParam("subjectClassKey") String subjectClassKey, @PathParam("subjectKey") String subjectKey, @PathParam("configKey") String configKey) {
    NetworkConfigService service = get(NetworkConfigService.class);
    service.removeConfig(service.getSubjectFactory(subjectClassKey).createSubject(subjectKey), service.getConfigClass(subjectClassKey, configKey));
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.segmentrouting");
    kryoBuilder = new KryoNamespace.Builder().register(NeighborSetNextObjectiveStoreKey.class, SubnetNextObjectiveStoreKey.class, SubnetAssignedVidStoreKey.class, NeighborSet.class, DeviceId.class, URI.class, WallClockTimestamp.class, org.onosproject.cluster.NodeId.class, HashSet.class, Tunnel.class, DefaultTunnel.class, Policy.class, TunnelPolicy.class, Policy.Type.class, VlanId.class, Ip4Address.class, Ip4Prefix.class, IpAddress.Version.class, ConnectPoint.class);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(cfgFactory);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    cfgListener.configureNetwork();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.segmentrouting");
    kryoBuilder = new KryoNamespace.Builder().register(NeighborSetNextObjectiveStoreKey.class, SubnetNextObjectiveStoreKey.class, SubnetAssignedVidStoreKey.class, NeighborSet.class, DeviceId.class, URI.class, WallClockTimestamp.class, org.onosproject.cluster.NodeId.class, HashSet.class, Tunnel.class, DefaultTunnel.class, Policy.class, TunnelPolicy.class, Policy.Type.class, VlanId.class, Ip4Address.class, Ip4Prefix.class, IpAddress.Version.class, ConnectPoint.class);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(cfgFactory);
    hostService.addListener(hostListener);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    cfgListener.configureNetwork();
    log.info("Started");
}
#end_block

#method_before
private void processDeviceAdded(Device device) {
    log.debug("A new device with ID {} was added", device.id());
    if (deviceConfiguration == null || !deviceConfiguration.isConfigured(device.id())) {
        log.warn("Device configuration uploading. Device {} will be " + "processed after config completes.", device.id());
        return;
    }
    // per switch.
    if (groupHandlerMap.get(device.id()) == null) {
        DefaultGroupHandler groupHandler;
        try {
            groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore);
        } catch (DeviceConfigNotFoundException e) {
            log.warn(e.getMessage() + " Aborting processDeviceAdded.");
            return;
        }
        groupHandlerMap.put(device.id(), groupHandler);
        // Also, in some cases, drivers may need extra
        // information to process rules (eg. Router IP/MAC); and so, we send
        // port addressing rules to the driver as well irrespective of whether
        // this instance is the master or not.
        defaultRoutingHandler.populatePortAddressingRules(device.id());
    }
    if (mastershipService.isLocalMaster(device.id())) {
        DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
        groupHandler.createGroupsFromSubnetConfig();
        routingRulePopulator.populateDstMacMissBroadcast(device.id());
    }
}
#method_after
private void processDeviceAdded(Device device) {
    log.debug("A new device with ID {} was added", device.id());
    if (deviceConfiguration == null || !deviceConfiguration.isConfigured(device.id())) {
        log.warn("Device configuration uploading. Device {} will be " + "processed after config completes.", device.id());
        return;
    }
    // per switch.
    if (groupHandlerMap.get(device.id()) == null) {
        DefaultGroupHandler groupHandler;
        try {
            groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore);
        } catch (DeviceConfigNotFoundException e) {
            log.warn(e.getMessage() + " Aborting processDeviceAdded.");
            return;
        }
        groupHandlerMap.put(device.id(), groupHandler);
        // Also, in some cases, drivers may need extra
        // information to process rules (eg. Router IP/MAC); and so, we send
        // port addressing rules to the driver as well irrespective of whether
        // this instance is the master or not.
        defaultRoutingHandler.populatePortAddressingRules(device.id());
    }
    if (mastershipService.isLocalMaster(device.id())) {
        DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
        groupHandler.createGroupsFromSubnetConfig();
        routingRulePopulator.populateSubnetBroadcastRule(device.id());
    }
}
#end_block

#method_before
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    for (Device device : deviceService.getDevices()) {
        // per switch.
        if (groupHandlerMap.get(device.id()) == null) {
            DefaultGroupHandler groupHandler;
            try {
                groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting configureNetwork.");
                return;
            }
            groupHandlerMap.put(device.id(), groupHandler);
            // Also, in some cases, drivers may need extra
            // information to process rules (eg. Router IP/MAC); and so, we send
            // port addressing rules to the driver as well, irrespective of whether
            // this instance is the master or not.
            defaultRoutingHandler.populatePortAddressingRules(device.id());
        }
        if (mastershipService.isLocalMaster(device.id())) {
            DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
            groupHandler.createGroupsFromSubnetConfig();
            routingRulePopulator.populateDstMacMissBroadcast(device.id());
        }
    }
    defaultRoutingHandler.startPopulationProcess();
}
#method_after
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    for (Device device : deviceService.getDevices()) {
        // per switch.
        if (groupHandlerMap.get(device.id()) == null) {
            DefaultGroupHandler groupHandler;
            try {
                groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore, subnetNextObjStore);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting configureNetwork.");
                return;
            }
            groupHandlerMap.put(device.id(), groupHandler);
            // Also, in some cases, drivers may need extra
            // information to process rules (eg. Router IP/MAC); and so, we send
            // port addressing rules to the driver as well, irrespective of whether
            // this instance is the master or not.
            defaultRoutingHandler.populatePortAddressingRules(device.id());
        }
        if (mastershipService.isLocalMaster(device.id())) {
            DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
            groupHandler.createGroupsFromSubnetConfig();
            routingRulePopulator.populateSubnetBroadcastRule(device.id());
        }
    }
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
private void handleArpRequest(DeviceId deviceId, ConnectPoint inPort, Ethernet payload) {
    ARP arpRequest = (ARP) payload.getPayload();
    VlanId vlanId = VlanId.vlanId(payload.getVlanID());
    HostId targetHostId = HostId.hostId(MacAddress.valueOf(arpRequest.getTargetHardwareAddress()), vlanId);
    // ARP request for router. Send ARP reply.
    if (isArpReqForRouter(deviceId, arpRequest)) {
        Ip4Address targetAddress = Ip4Address.valueOf(arpRequest.getTargetProtocolAddress());
        sendArpResponse(arpRequest, config.getRouterMacForAGatewayIp(targetAddress), vlanId);
    } else {
        Host targetHost = srManager.hostService.getHost(targetHostId);
        // ARP request for known hosts. Send proxy ARP reply on behalf of the target.
        if (targetHost != null) {
            sendArpResponse(arpRequest, targetHost.mac(), vlanId);
        // ARP request for unknown host in the subnet. Flood in the subnet.
        } else {
            removeVlanAndFlood(payload, inPort);
        }
    }
}
#method_after
private void handleArpRequest(DeviceId deviceId, ConnectPoint inPort, Ethernet payload) {
    ARP arpRequest = (ARP) payload.getPayload();
    VlanId vlanId = VlanId.vlanId(payload.getVlanID());
    HostId targetHostId = HostId.hostId(MacAddress.valueOf(arpRequest.getTargetHardwareAddress()), vlanId);
    // ARP request for router. Send ARP reply.
    if (isArpReqForRouter(deviceId, arpRequest)) {
        Ip4Address targetAddress = Ip4Address.valueOf(arpRequest.getTargetProtocolAddress());
        sendArpResponse(arpRequest, config.getRouterMacForAGatewayIp(targetAddress), vlanId);
    } else {
        Host targetHost = srManager.hostService.getHost(targetHostId);
        // ARP request for known hosts. Send proxy ARP reply on behalf of the target.
        if (targetHost != null) {
            removeVlanAndForward(payload, targetHost.location());
        // ARP request for unknown host in the subnet. Flood in the subnet.
        } else {
            removeVlanAndFlood(payload, inPort);
        }
    }
}
#end_block

#method_before
private void sendICMPResponse(Ethernet icmpRequest, ConnectPoint outport) {
    Ethernet icmpReplyEth = new Ethernet();
    IPv4 icmpRequestIpv4 = (IPv4) icmpRequest.getPayload();
    IPv4 icmpReplyIpv4 = new IPv4();
    int destAddress = icmpRequestIpv4.getDestinationAddress();
    icmpReplyIpv4.setDestinationAddress(icmpRequestIpv4.getSourceAddress());
    icmpReplyIpv4.setSourceAddress(destAddress);
    icmpReplyIpv4.setTtl((byte) 64);
    icmpReplyIpv4.setChecksum((short) 0);
    ICMP icmpReply = new ICMP();
    icmpReply.setPayload(((ICMP) icmpRequestIpv4.getPayload()).getPayload());
    icmpReply.setIcmpType(ICMP.TYPE_ECHO_REPLY);
    icmpReply.setIcmpCode(ICMP.SUBTYPE_ECHO_REPLY);
    icmpReply.setChecksum((short) 0);
    icmpReplyIpv4.setPayload(icmpReply);
    icmpReplyEth.setPayload(icmpReplyIpv4);
    icmpReplyEth.setEtherType(Ethernet.TYPE_IPV4);
    icmpReplyEth.setDestinationMACAddress(icmpRequest.getSourceMACAddress());
    icmpReplyEth.setSourceMACAddress(icmpRequest.getDestinationMACAddress());
    Ip4Address destIpAddress = Ip4Address.valueOf(icmpReplyIpv4.getDestinationAddress());
    Ip4Address destRouterAddress = config.getRouterIpAddressForASubnetHost(destIpAddress);
    int sid = config.getSegmentId(destRouterAddress);
    if (sid < 0) {
        log.warn("Cannot find the Segment ID for {}", destAddress);
        return;
    }
    sendPacketOut(outport, icmpReplyEth, sid);
}
#method_after
private void sendICMPResponse(Ethernet icmpRequest, ConnectPoint outport) {
    // Note: We assume that packets arrive at the edge switches have
    // untagged VLAN.
    Ethernet icmpReplyEth = new Ethernet();
    IPv4 icmpRequestIpv4 = (IPv4) icmpRequest.getPayload();
    IPv4 icmpReplyIpv4 = new IPv4();
    int destAddress = icmpRequestIpv4.getDestinationAddress();
    icmpReplyIpv4.setDestinationAddress(icmpRequestIpv4.getSourceAddress());
    icmpReplyIpv4.setSourceAddress(destAddress);
    icmpReplyIpv4.setTtl((byte) 64);
    icmpReplyIpv4.setChecksum((short) 0);
    ICMP icmpReply = new ICMP();
    icmpReply.setPayload(((ICMP) icmpRequestIpv4.getPayload()).getPayload());
    icmpReply.setIcmpType(ICMP.TYPE_ECHO_REPLY);
    icmpReply.setIcmpCode(ICMP.SUBTYPE_ECHO_REPLY);
    icmpReply.setChecksum((short) 0);
    icmpReplyIpv4.setPayload(icmpReply);
    icmpReplyEth.setPayload(icmpReplyIpv4);
    icmpReplyEth.setEtherType(Ethernet.TYPE_IPV4);
    icmpReplyEth.setDestinationMACAddress(icmpRequest.getSourceMACAddress());
    icmpReplyEth.setSourceMACAddress(icmpRequest.getDestinationMACAddress());
    Ip4Address destIpAddress = Ip4Address.valueOf(icmpReplyIpv4.getDestinationAddress());
    Ip4Address destRouterAddress = config.getRouterIpAddressForASubnetHost(destIpAddress);
    int sid = config.getSegmentId(destRouterAddress);
    if (sid < 0) {
        log.warn("Cannot find the Segment ID for {}", destAddress);
        return;
    }
    sendPacketOut(outport, icmpReplyEth, sid);
}
#end_block

#method_before
public void populateIpRuleForHost(DeviceId deviceId, Ip4Address hostIp, MacAddress hostMac, PortNumber outPort) {
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateIpRuleForHost.");
        return;
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    sbuilder.matchIPDst(IpPrefix.valueOf(hostIp, IpPrefix.MAX_INET_MASK_LENGTH));
    sbuilder.matchEthType(Ethernet.TYPE_IPV4);
    tbuilder.deferred().setEthDst(hostMac).setEthSrc(deviceMac).setOutput(outPort);
    TrafficTreatment treatment = tbuilder.build();
    TrafficSelector selector = sbuilder.build();
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(srManager.appId).makePermanent().withSelector(selector).withTreatment(treatment).withPriority(100).withFlag(ForwardingObjective.Flag.SPECIFIC);
    log.debug("Installing IPv4 forwarding objective " + "for host {} in switch {}", hostIp, deviceId);
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    rulePopulationCounter.incrementAndGet();
}
#method_after
public void populateIpRuleForHost(DeviceId deviceId, Ip4Address hostIp, MacAddress hostMac, PortNumber outPort) {
    log.debug("Populate IP table entry for host {} at {}:{}", hostIp, deviceId, outPort);
    ForwardingObjective.Builder fwdBuilder;
    try {
        fwdBuilder = getForwardingObjectiveBuilder(deviceId, hostIp, hostMac, outPort);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateIpRuleForHost.");
        return;
    }
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    rulePopulationCounter.incrementAndGet();
}
#end_block

#method_before
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.debug("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    TrafficTreatment treatment = null;
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.UNKNOWN);
        return Collections.emptySet();
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.wipeDeferred();
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        if (next != null) {
            GroupKey key = appKryo.deserialize(next.data());
            Group group = groupService.getGroup(deviceId, key);
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            treatmentBuilder.deferred().group(group.id());
            treatment = treatmentBuilder.build();
            log.debug("Adding OUTGROUP action");
        }
    } else if (fwd.treatment() != null) {
        if (fwd.treatment().allInstructions().size() == 1 && fwd.treatment().allInstructions().get(0).type() == Instruction.Type.OUTPUT) {
            OutputInstruction o = (OutputInstruction) fwd.treatment().allInstructions().get(0);
            if (o.port() == PortNumber.CONTROLLER) {
                /* To emulate hardware behavior, we clear all deferred instr
                     * before sending PACKET_IN to controller.
                     */
                treatmentBuilder.wipeDeferred();
                treatmentBuilder.punt();
                treatment = treatmentBuilder.build();
            } else {
                treatment = fwd.treatment();
            }
        } else {
            treatment = fwd.treatment();
        }
    } else {
        log.warn("VERSATILE forwarding objective needs next objective ID " + "or treatment.");
        return Collections.emptySet();
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(fwd.selector()).withTreatment(treatment);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    ruleBuilder.forTable(aclTableId);
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
private Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.debug("Processing versatile forwarding objective");
    TrafficSelector selector = fwd.selector();
    TrafficTreatment treatment = null;
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.UNKNOWN);
        return Collections.emptySet();
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.wipeDeferred();
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        if (next != null) {
            GroupKey key = appKryo.deserialize(next.data());
            Group group = groupService.getGroup(deviceId, key);
            if (group == null) {
                log.warn("The group left!");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            treatmentBuilder.deferred().group(group.id());
            treatment = treatmentBuilder.build();
            log.debug("Adding OUTGROUP action");
        }
    } else if (fwd.treatment() != null) {
        if (fwd.treatment().allInstructions().size() == 1 && fwd.treatment().allInstructions().get(0).type() == Instruction.Type.OUTPUT) {
            OutputInstruction o = (OutputInstruction) fwd.treatment().allInstructions().get(0);
            if (o.port() == PortNumber.CONTROLLER) {
                treatmentBuilder.punt();
                treatment = treatmentBuilder.build();
            } else {
                treatment = fwd.treatment();
            }
        } else {
            treatment = fwd.treatment();
        }
    } else {
        log.warn("VERSATILE forwarding objective needs next objective ID " + "or treatment.");
        return Collections.emptySet();
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(fwd.selector()).withTreatment(treatment);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    ruleBuilder.forTable(aclTableId);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
protected Collection<FlowRule> processEthDstSpecificObjective(ForwardingObjective fwd) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector selector = fwd.selector();
    EthCriterion ethCriterion = (EthCriterion) selector.getCriterion(Criterion.Type.ETH_DST);
    VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) selector.getCriterion(Criterion.Type.VLAN_VID);
    // Table miss entry
    if (ethCriterion.mac().equals(MacAddress.NONE)) {
        TrafficSelector.Builder filteredSelectorBuilder = DefaultTrafficSelector.builder();
        filteredSelectorBuilder = filteredSelectorBuilder.matchVlanId(vlanIdCriterion.vlanId());
        TrafficSelector filteredSelector = filteredSelectorBuilder.build();
        TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
        if (fwd.nextId() != null) {
            NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
            if (next != null) {
                GroupKey key = appKryo.deserialize(next.data());
                Group group = groupService.getGroup(deviceId, key);
                if (group != null) {
                    treatmentBuilder.deferred().group(group.id());
                } else {
                    log.warn("Group Missing");
                    fail(fwd, ObjectiveError.GROUPMISSING);
                    return Collections.emptySet();
                }
            }
        }
        treatmentBuilder.immediate().transition(aclTableId);
        TrafficTreatment filteredTreatment = treatmentBuilder.build();
        FlowRule.Builder flowRuleBuilder = DefaultFlowRule.builder();
        flowRuleBuilder.fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector).withTreatment(filteredTreatment).forTable(dstMacTableId);
        if (fwd.permanent()) {
            flowRuleBuilder.makePermanent();
        } else {
            flowRuleBuilder.makeTemporary(fwd.timeout());
        }
        rules.add(flowRuleBuilder.build());
    // Normal ETH_DST specific objective
    } else {
        // TODO implement ETH_DST specific objective for MAC learning
        return rules;
    }
    return rules;
}
#method_after
protected Collection<FlowRule> processEthDstSpecificObjective(ForwardingObjective fwd) {
    List<FlowRule> rules = new ArrayList<>();
    // Build filtered selector
    TrafficSelector selector = fwd.selector();
    EthCriterion ethCriterion = (EthCriterion) selector.getCriterion(Criterion.Type.ETH_DST);
    VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) selector.getCriterion(Criterion.Type.VLAN_VID);
    TrafficSelector.Builder filteredSelectorBuilder = DefaultTrafficSelector.builder();
    // Do not match MacAddress for subnet broadcast entry
    if (!ethCriterion.mac().equals(MacAddress.NONE)) {
        filteredSelectorBuilder.matchEthDst(ethCriterion.mac());
    }
    filteredSelectorBuilder.matchVlanId(vlanIdCriterion.vlanId());
    TrafficSelector filteredSelector = filteredSelectorBuilder.build();
    // Build filtered treatment
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        treatmentBuilder.deferred();
        fwd.treatment().allInstructions().forEach(treatmentBuilder::add);
    }
    if (fwd.nextId() != null) {
        NextGroup next = flowObjectiveStore.getNextGroup(fwd.nextId());
        if (next != null) {
            GroupKey key = appKryo.deserialize(next.data());
            Group group = groupService.getGroup(deviceId, key);
            if (group != null) {
                treatmentBuilder.deferred().group(group.id());
            } else {
                log.warn("Group Missing");
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
        }
    }
    treatmentBuilder.immediate().transition(aclTableId);
    TrafficTreatment filteredTreatment = treatmentBuilder.build();
    // Build bridging table entries
    FlowRule.Builder flowRuleBuilder = DefaultFlowRule.builder();
    flowRuleBuilder.fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector).withTreatment(filteredTreatment).forTable(dstMacTableId);
    if (fwd.permanent()) {
        flowRuleBuilder.makePermanent();
    } else {
        flowRuleBuilder.makeTemporary(fwd.timeout());
    }
    rules.add(flowRuleBuilder.build());
    return rules;
}
#end_block

#method_before
protected void setTableMissEntries() {
    // set all table-miss-entries
    populateTableMissEntry(vlanTableId, true, false, false, -1);
    populateTableMissEntry(tmacTableId, false, false, true, dstMacTableId);
    populateTableMissEntry(ipv4UnicastTableId, false, true, true, aclTableId);
    populateTableMissEntry(mplsTableId, false, true, true, aclTableId);
    populateTableMissEntry(aclTableId, false, false, false, -1);
    populateTableMissEntry(dstMacTableId, false, false, true, aclTableId);
}
#method_after
protected void setTableMissEntries() {
    // set all table-miss-entries
    populateTableMissEntry(vlanTableId, true, false, false, -1);
    populateTableMissEntry(tmacTableId, false, false, true, dstMacTableId);
    populateTableMissEntry(ipv4UnicastTableId, false, true, true, aclTableId);
    populateTableMissEntry(mplsTableId, false, true, true, aclTableId);
    populateTableMissEntry(dstMacTableId, false, false, true, aclTableId);
    populateTableMissEntry(aclTableId, false, false, false, -1);
}
#end_block

#method_before
public static Criterion matchArpSpa(Ip4Address ip) {
    return new ArpPaCriterion(ip, Type.ARP_TPA);
}
#method_after
public static Criterion matchArpSpa(Ip4Address ip) {
    return new ArpPaCriterion(ip, Type.ARP_SPA);
}
#end_block

#method_before
private boolean capabilityValidation(BGPChannelHandler h, BGPOpenMsg openmsg) throws BGPParseException {
    log.debug("capabilityValidation");
    boolean isMultiProtocolcapabilityExists = false;
    boolean isFourOctetCapabilityExits = false;
    int capAsNum = 0;
    LinkedList<BGPValueType> capabilityTlv = openmsg.getCapabilityTlv();
    ListIterator<BGPValueType> listIterator = capabilityTlv.listIterator();
    LinkedList<BGPValueType> unSupportedCapabilityTlv = new LinkedList<>();
    ListIterator<BGPValueType> unSupportedCaplistIterator = unSupportedCapabilityTlv.listIterator();
    BGPValueType tempTlv;
    boolean isLargeAsCapabilityCfg = h.bgpconfig.getLargeASCapability();
    boolean isLsCapabilityCfg = h.bgpconfig.getLsCapability();
    while (listIterator.hasNext()) {
        BGPValueType tlv = listIterator.next();
        if (tlv.getType() == MULTI_PROTOCOL_EXTN_CAPA_TYPE) {
            isMultiProtocolcapabilityExists = true;
        }
        if (tlv.getType() == FOUR_OCTET_AS_NUM_CAPA_TYPE) {
            isFourOctetCapabilityExits = true;
            capAsNum = ((FourOctetAsNumCapabilityTlv) tlv).getInt();
        }
    }
    if (isFourOctetCapabilityExits) {
        if (capAsNum > 65535) {
            if (openmsg.getAsNumber() != AS_TRANS) {
                throw new BGPParseException(BGPErrorType.OPEN_MESSAGE_ERROR, BGPErrorType.BAD_PEER_AS, null);
            }
        } else {
            if (capAsNum != openmsg.getAsNumber()) {
                throw new BGPParseException(BGPErrorType.OPEN_MESSAGE_ERROR, BGPErrorType.BAD_PEER_AS, null);
            }
        }
    }
    if ((isLsCapabilityCfg)) {
        if (!isMultiProtocolcapabilityExists) {
            short afi = 16388;
            byte res = 0;
            byte safi = 71;
            tempTlv = new MultiProtocolExtnCapabilityTlv(afi, res, safi);
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if ((isLargeAsCapabilityCfg)) {
        if (!isFourOctetCapabilityExits) {
            tempTlv = new FourOctetAsNumCapabilityTlv(h.bgpconfig.getAsNumber());
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if (unSupportedCaplistIterator.hasNext()) {
        ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
        while (unSupportedCaplistIterator.hasNext()) {
            BGPValueType tlv = unSupportedCaplistIterator.next();
            tlv.write(buffer);
        }
        throw new BGPParseException(BGPErrorType.OPEN_MESSAGE_ERROR, BGPErrorType.UNSUPPORTED_CAPABILITY, buffer);
    } else {
        return true;
    }
}
#method_after
private boolean capabilityValidation(BGPChannelHandler h, BGPOpenMsg openmsg) throws BGPParseException {
    log.debug("capabilityValidation");
    boolean isMultiProtocolcapabilityExists = false;
    boolean isFourOctetCapabilityExits = false;
    int capAsNum = 0;
    List<BGPValueType> capabilityTlv = openmsg.getCapabilityTlv();
    ListIterator<BGPValueType> listIterator = capabilityTlv.listIterator();
    List<BGPValueType> unSupportedCapabilityTlv = new LinkedList<>();
    ListIterator<BGPValueType> unSupportedCaplistIterator = unSupportedCapabilityTlv.listIterator();
    BGPValueType tempTlv;
    boolean isLargeAsCapabilityCfg = h.bgpconfig.getLargeASCapability();
    boolean isLsCapabilityCfg = h.bgpconfig.getLsCapability();
    while (listIterator.hasNext()) {
        BGPValueType tlv = listIterator.next();
        if (tlv.getType() == MULTI_PROTOCOL_EXTN_CAPA_TYPE) {
            isMultiProtocolcapabilityExists = true;
        }
        if (tlv.getType() == FOUR_OCTET_AS_NUM_CAPA_TYPE) {
            isFourOctetCapabilityExits = true;
            capAsNum = ((FourOctetAsNumCapabilityTlv) tlv).getInt();
        }
    }
    if (isFourOctetCapabilityExits) {
        if (capAsNum > MAX_AS2_NUM) {
            if (openmsg.getAsNumber() != AS_TRANS) {
                throw new BGPParseException(BGPErrorType.OPEN_MESSAGE_ERROR, BGPErrorType.BAD_PEER_AS, null);
            }
        } else {
            if (capAsNum != openmsg.getAsNumber()) {
                throw new BGPParseException(BGPErrorType.OPEN_MESSAGE_ERROR, BGPErrorType.BAD_PEER_AS, null);
            }
        }
    }
    if ((isLsCapabilityCfg)) {
        if (!isMultiProtocolcapabilityExists) {
            tempTlv = new MultiProtocolExtnCapabilityTlv(AFI, RES, SAFI);
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if ((isLargeAsCapabilityCfg)) {
        if (!isFourOctetCapabilityExits) {
            tempTlv = new FourOctetAsNumCapabilityTlv(h.bgpconfig.getAsNumber());
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if (unSupportedCaplistIterator.hasNext()) {
        ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
        while (unSupportedCaplistIterator.hasNext()) {
            BGPValueType tlv = unSupportedCaplistIterator.next();
            tlv.write(buffer);
        }
        throw new BGPParseException(BGPErrorType.OPEN_MESSAGE_ERROR, BGPErrorType.UNSUPPORTED_CAPABILITY, buffer);
    } else {
        return true;
    }
}
#end_block

#method_before
private boolean asNumberValidation(BGPChannelHandler h, BGPOpenMsg openMsg) {
    log.debug("AS Num validation");
    int capAsNum = 0;
    boolean isFourOctetCapabilityExits = false;
    BGPPeerCfg peerCfg = h.bgpconfig.displayPeers(peerAddr);
    LinkedList<BGPValueType> capabilityTlv = openMsg.getCapabilityTlv();
    ListIterator<BGPValueType> listIterator = capabilityTlv.listIterator();
    while (listIterator.hasNext()) {
        BGPValueType tlv = listIterator.next();
        if (tlv.getType() == FOUR_OCTET_AS_NUM_CAPA_TYPE) {
            isFourOctetCapabilityExits = true;
            capAsNum = ((FourOctetAsNumCapabilityTlv) tlv).getInt();
        }
    }
    if (peerCfg.getAsNumber() > 65535) {
        if (openMsg.getAsNumber() != AS_TRANS) {
            return false;
        }
        if (!isFourOctetCapabilityExits) {
            return false;
        }
        if (peerCfg.getAsNumber() != capAsNum) {
            return false;
        }
        isIbgpSession = peerCfg.getIsIBgp();
        if (isIbgpSession) {
            // IBGP - AS number should be same for Peer and local if it is IBGP
            if (h.bgpconfig.getAsNumber() != capAsNum) {
                return false;
            }
        }
    } else {
        if (openMsg.getAsNumber() != peerCfg.getAsNumber()) {
            return false;
        }
        if (isFourOctetCapabilityExits) {
            if (capAsNum != peerCfg.getAsNumber()) {
                return false;
            }
        }
        isIbgpSession = peerCfg.getIsIBgp();
        if (isIbgpSession) {
            // IBGP - AS number should be same for Peer and local if it is IBGP
            if (openMsg.getAsNumber() != h.bgpconfig.getAsNumber()) {
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean asNumberValidation(BGPChannelHandler h, BGPOpenMsg openMsg) {
    log.debug("AS Num validation");
    int capAsNum = 0;
    boolean isFourOctetCapabilityExits = false;
    BGPPeerCfg peerCfg = h.bgpconfig.displayPeers(peerAddr);
    List<BGPValueType> capabilityTlv = openMsg.getCapabilityTlv();
    ListIterator<BGPValueType> listIterator = capabilityTlv.listIterator();
    while (listIterator.hasNext()) {
        BGPValueType tlv = listIterator.next();
        if (tlv.getType() == FOUR_OCTET_AS_NUM_CAPA_TYPE) {
            isFourOctetCapabilityExits = true;
            capAsNum = ((FourOctetAsNumCapabilityTlv) tlv).getInt();
        }
    }
    if (peerCfg.getAsNumber() > MAX_AS2_NUM) {
        if (openMsg.getAsNumber() != AS_TRANS) {
            return false;
        }
        if (!isFourOctetCapabilityExits) {
            return false;
        }
        if (peerCfg.getAsNumber() != capAsNum) {
            return false;
        }
        isIbgpSession = peerCfg.getIsIBgp();
        if (isIbgpSession) {
            // IBGP - AS number should be same for Peer and local if it is IBGP
            if (h.bgpconfig.getAsNumber() != capAsNum) {
                return false;
            }
        }
    } else {
        if (openMsg.getAsNumber() != peerCfg.getAsNumber()) {
            return false;
        }
        if (isFourOctetCapabilityExits) {
            if (capAsNum != peerCfg.getAsNumber()) {
                return false;
            }
        }
        isIbgpSession = peerCfg.getIsIBgp();
        if (isIbgpSession) {
            // IBGP - AS number should be same for Peer and local if it is IBGP
            if (openMsg.getAsNumber() != h.bgpconfig.getAsNumber()) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
public static BgpPrefixAttrExtRouteTag read(ChannelBuffer cb) throws BGPParseException {
    long[] pfxExtRouteTag;
    short lsAttrLength = cb.readShort();
    int len = lsAttrLength / ATTR_PREFIX_EXT_LEN;
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    pfxExtRouteTag = new long[lsAttrLength];
    for (int i = 0; i < len; i++) {
        pfxExtRouteTag[i] = cb.readLong();
    }
    return new BgpPrefixAttrExtRouteTag(pfxExtRouteTag);
}
#method_after
public static BgpPrefixAttrExtRouteTag read(ChannelBuffer cb) throws BGPParseException {
    ArrayList<Long> pfxExtRouteTag = new ArrayList<Long>();
    long temp;
    short lsAttrLength = cb.readShort();
    int len = lsAttrLength / ATTR_PREFIX_EXT_LEN;
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    for (int i = 0; i < len; i++) {
        temp = cb.readLong();
        pfxExtRouteTag.add(new Long(temp));
    }
    return new BgpPrefixAttrExtRouteTag(pfxExtRouteTag);
}
#end_block

#method_before
public ArrayList<Short> attrMultiTopologyId() {
    return multiTopologyId;
}
#method_after
public List<Short> attrMultiTopologyId() {
    return multiTopologyId;
}
#end_block

#method_before
private void loadFromDisk() {
    getApplicationNames().forEach(appName -> {
        loadFromDisk(appName);
    });
}
#method_after
private void loadFromDisk() {
    getApplicationNames().forEach(appName -> {
        Application app = loadFromDisk(appName);
        if (app != null && isActive(app.id().name())) {
            activate(app.id(), false);
        // TODO Load app permissions
        }
    });
}
#end_block

#method_before
private void loadFromDisk(String appName) {
    for (int i = 0; i < MAX_LOAD_RETRIES; i++) {
        try {
            ApplicationDescription appDesc = getApplicationDescription(appName);
            appDesc.requiredApps().forEach(requiredAppName -> {
                loadFromDisk(requiredAppName);
            });
            Application app = create(appDesc, false);
            if (app != null && isActive(app.id().name())) {
                requiredBy.put(app.id(), coreAppId);
                activate(app.id(), false);
            // load app permissions
            }
        } catch (Exception e) {
            log.warn("Unable to load application {} from disk; retrying", appName);
            // FIXME: This is a deliberate hack; fix in Falcon
            randomDelay(RETRY_DELAY_MS);
        }
    }
}
#method_after
private Application loadFromDisk(String appName) {
    for (int i = 0; i < MAX_LOAD_RETRIES; i++) {
        try {
            // Directly return if app already exists
            ApplicationId appId = getId(appName);
            if (appId != null) {
                return getApplication(appId);
            }
            ApplicationDescription appDesc = getApplicationDescription(appName);
            boolean success = appDesc.requiredApps().stream().noneMatch(requiredApp -> loadFromDisk(requiredApp) == null);
            return success ? create(appDesc, false) : null;
        } catch (Exception e) {
            log.warn("Unable to load application {} from disk; retrying", appName);
            // FIXME: This is a deliberate hack; fix in Falcon
            randomDelay(RETRY_DELAY_MS);
        }
    }
    return null;
}
#end_block

#method_before
private static void parseOptionalParameters(BgpSession bgpSession, ChannelHandlerContext ctx, ChannelBuffer message) throws BgpMessage.BgpParseException {
    // 
    // Get and verify the Optional Parameters Length
    // 
    int optParamLength = message.readUnsignedByte();
    if (optParamLength > message.readableBytes()) {
        // ERROR: Invalid Optional Parameter Length
        String errorMsg = "Invalid Optional Parameter Length field " + optParamLength + ". Remaining Optional Parameters " + message.readableBytes();
        throw new BgpMessage.BgpParseException(errorMsg);
    }
    if (optParamLength == 0) {
        // No Optional Parameters
        return;
    }
    // 
    // Parse the Optional Parameters
    // 
    int optParamEnd = message.readerIndex() + optParamLength;
    while (message.readerIndex() < optParamEnd) {
        int paramType = message.readUnsignedByte();
        if (message.readerIndex() >= optParamEnd) {
            // ERROR: Malformed Optional Parameters
            String errorMsg = "Malformed Optional Parameters";
            throw new BgpMessage.BgpParseException(errorMsg);
        }
        int paramLen = message.readUnsignedByte();
        if (message.readerIndex() + paramLen > optParamEnd) {
            // ERROR: Malformed Optional Parameters
            String errorMsg = "Malformed Optional Parameters";
            throw new BgpMessage.BgpParseException(errorMsg);
        }
        // 
        switch(paramType) {
            case BgpConstants.Open.Capabilities.TYPE:
                // Optional Parameter Type: Capabilities
                if (paramLen < BgpConstants.Open.Capabilities.MIN_LENGTH) {
                    // ERROR: Malformed Param Type
                    String errorMsg = "Malformed Param Type " + paramType;
                    throw new BgpMessage.BgpParseException(errorMsg);
                }
                int paramEnd = message.readerIndex() + paramLen;
                while (message.readerIndex() < paramEnd) {
                    int capabCode = message.readUnsignedByte();
                    int capabLen = message.readUnsignedByte();
                    if (message.readerIndex() + capabLen > paramEnd) {
                        // ERROR: Malformed Capability
                        String errorMsg = "Malformed Capability Type with code " + capabCode;
                        throw new BgpMessage.BgpParseException(errorMsg);
                    }
                    switch(capabCode) {
                        case BgpConstants.Open.Capabilities.MultiprotocolExtensions.CODE:
                            // Multiprotocol Extensions Capabilities (RFC 4760)
                            if (capabLen != BgpConstants.Open.Capabilities.MultiprotocolExtensions.LENGTH) {
                                // ERROR: Multiprotocol Extension Length Error
                                String errorMsg = "Multiprotocol Extension Length Error";
                                throw new BgpMessage.BgpParseException(errorMsg);
                            }
                            // Decode the AFI (2 octets) and SAFI (1 octet)
                            int afi = message.readUnsignedShort();
                            int reserved = message.readUnsignedByte();
                            int safi = message.readUnsignedByte();
                            log.debug("BGP RX OPEN Capability: AFI = {} SAFI = {}", afi, safi);
                            // 
                            if (afi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.AFI_IPV4 && safi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.SAFI_UNICAST) {
                                bgpSession.remoteInfo().setIpv4Unicast();
                                bgpSession.localInfo().setIpv4Unicast();
                            } else if (afi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.AFI_IPV4 && safi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.SAFI_MULTICAST) {
                                bgpSession.remoteInfo().setIpv4Multicast();
                                bgpSession.localInfo().setIpv4Multicast();
                            } else if (afi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.AFI_IPV6 && safi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.SAFI_UNICAST) {
                                bgpSession.remoteInfo().setIpv6Unicast();
                                bgpSession.localInfo().setIpv6Unicast();
                            } else if (afi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.AFI_IPV6 && safi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.SAFI_MULTICAST) {
                                bgpSession.remoteInfo().setIpv6Multicast();
                                bgpSession.localInfo().setIpv6Multicast();
                            } else {
                                log.debug("BGP RX OPEN Capability: Unknown AFI = {} SAFI = {}", afi, safi);
                            }
                            break;
                        case BgpConstants.Open.Capabilities.As4Octet.CODE:
                            // Support for 4-octet AS Number Capabilities (RFC 6793)
                            if (capabLen != BgpConstants.Open.Capabilities.As4Octet.LENGTH) {
                                // ERROR: 4-octet AS Number Capability Length Error
                                String errorMsg = "4-octet AS Number Capability Length Error";
                                throw new BgpMessage.BgpParseException(errorMsg);
                            }
                            long as4Number = message.readUnsignedInt();
                            bgpSession.remoteInfo().setAs4OctetCapability();
                            bgpSession.remoteInfo().setAs4Number(as4Number);
                            // 
                            // Copy remote 4-octet AS Number Capabilities and AS
                            // Number. This is a temporary setting until local AS
                            // number configuration is supported.
                            // 
                            bgpSession.localInfo().setAs4OctetCapability();
                            bgpSession.localInfo().setAs4Number(as4Number);
                            log.debug("BGP RX OPEN Capability: AS4 Number = {}", as4Number);
                            break;
                        default:
                            // Unknown Capability: ignore it
                            log.debug("BGP RX OPEN Capability Code = {} Length = {}", capabCode, capabLen);
                            message.readBytes(capabLen);
                            break;
                    }
                }
                break;
            default:
                // Unknown Parameter Type: ignore it
                log.debug("BGP RX OPEN Parameter Type = {} Length = {}", paramType, paramLen);
                message.readBytes(paramLen);
                break;
        }
    }
}
#method_after
private static void parseOptionalParameters(BgpSession bgpSession, ChannelHandlerContext ctx, ChannelBuffer message) throws BgpMessage.BgpParseException {
    // 
    // Get and verify the Optional Parameters Length
    // 
    int optParamLength = message.readUnsignedByte();
    if (optParamLength > message.readableBytes()) {
        // ERROR: Invalid Optional Parameter Length
        String errorMsg = "Invalid Optional Parameter Length field " + optParamLength + ". Remaining Optional Parameters " + message.readableBytes();
        throw new BgpMessage.BgpParseException(errorMsg);
    }
    if (optParamLength == 0) {
        // No Optional Parameters
        return;
    }
    // 
    // Parse the Optional Parameters
    // 
    int optParamEnd = message.readerIndex() + optParamLength;
    while (message.readerIndex() < optParamEnd) {
        int paramType = message.readUnsignedByte();
        if (message.readerIndex() >= optParamEnd) {
            // ERROR: Malformed Optional Parameters
            String errorMsg = "Malformed Optional Parameters";
            throw new BgpMessage.BgpParseException(errorMsg);
        }
        int paramLen = message.readUnsignedByte();
        if (message.readerIndex() + paramLen > optParamEnd) {
            // ERROR: Malformed Optional Parameters
            String errorMsg = "Malformed Optional Parameters";
            throw new BgpMessage.BgpParseException(errorMsg);
        }
        // 
        switch(paramType) {
            case BgpConstants.Open.Capabilities.TYPE:
                // Optional Parameter Type: Capabilities
                if (paramLen < BgpConstants.Open.Capabilities.MIN_LENGTH) {
                    // ERROR: Malformed Param Type
                    String errorMsg = "Malformed Capabilities Optional " + "Parameter Type " + paramType;
                    throw new BgpMessage.BgpParseException(errorMsg);
                }
                int paramEnd = message.readerIndex() + paramLen;
                // Parse Capabilities
                while (message.readerIndex() < paramEnd) {
                    if (paramEnd - message.readerIndex() < BgpConstants.Open.Capabilities.MIN_LENGTH) {
                        String errorMsg = "Malformed Capabilities";
                        throw new BgpMessage.BgpParseException(errorMsg);
                    }
                    int capabCode = message.readUnsignedByte();
                    int capabLen = message.readUnsignedByte();
                    if (message.readerIndex() + capabLen > paramEnd) {
                        // ERROR: Malformed Capability
                        String errorMsg = "Malformed Capability instance with " + "code " + capabCode;
                        throw new BgpMessage.BgpParseException(errorMsg);
                    }
                    switch(capabCode) {
                        case BgpConstants.Open.Capabilities.MultiprotocolExtensions.CODE:
                            // Multiprotocol Extensions Capabilities (RFC 4760)
                            if (capabLen != BgpConstants.Open.Capabilities.MultiprotocolExtensions.LENGTH) {
                                // ERROR: Multiprotocol Extension Length Error
                                String errorMsg = "Multiprotocol Extension Length Error";
                                throw new BgpMessage.BgpParseException(errorMsg);
                            }
                            // Decode the AFI (2 octets) and SAFI (1 octet)
                            int afi = message.readUnsignedShort();
                            int reserved = message.readUnsignedByte();
                            int safi = message.readUnsignedByte();
                            log.debug("BGP RX OPEN Capability: AFI = {} SAFI = {}", afi, safi);
                            // 
                            if (afi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.AFI_IPV4 && safi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.SAFI_UNICAST) {
                                bgpSession.remoteInfo().setIpv4Unicast();
                                bgpSession.localInfo().setIpv4Unicast();
                            } else if (afi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.AFI_IPV4 && safi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.SAFI_MULTICAST) {
                                bgpSession.remoteInfo().setIpv4Multicast();
                                bgpSession.localInfo().setIpv4Multicast();
                            } else if (afi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.AFI_IPV6 && safi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.SAFI_UNICAST) {
                                bgpSession.remoteInfo().setIpv6Unicast();
                                bgpSession.localInfo().setIpv6Unicast();
                            } else if (afi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.AFI_IPV6 && safi == BgpConstants.Open.Capabilities.MultiprotocolExtensions.SAFI_MULTICAST) {
                                bgpSession.remoteInfo().setIpv6Multicast();
                                bgpSession.localInfo().setIpv6Multicast();
                            } else {
                                log.debug("BGP RX OPEN Capability: Unknown AFI = {} SAFI = {}", afi, safi);
                            }
                            break;
                        case BgpConstants.Open.Capabilities.As4Octet.CODE:
                            // Support for 4-octet AS Number Capabilities (RFC 6793)
                            if (capabLen != BgpConstants.Open.Capabilities.As4Octet.LENGTH) {
                                // ERROR: 4-octet AS Number Capability Length Error
                                String errorMsg = "4-octet AS Number Capability Length Error";
                                throw new BgpMessage.BgpParseException(errorMsg);
                            }
                            long as4Number = message.readUnsignedInt();
                            bgpSession.remoteInfo().setAs4OctetCapability();
                            bgpSession.remoteInfo().setAs4Number(as4Number);
                            // 
                            // Copy remote 4-octet AS Number Capabilities and AS
                            // Number. This is a temporary setting until local AS
                            // number configuration is supported.
                            // 
                            bgpSession.localInfo().setAs4OctetCapability();
                            bgpSession.localInfo().setAs4Number(as4Number);
                            log.debug("BGP RX OPEN Capability: AS4 Number = {}", as4Number);
                            break;
                        default:
                            // Unknown Capability: ignore it
                            log.debug("BGP RX OPEN Capability Code = {} Length = {}", capabCode, capabLen);
                            message.readBytes(capabLen);
                            break;
                    }
                }
                break;
            default:
                // Unknown Parameter Type: ignore it
                log.debug("BGP RX OPEN Parameter Type = {} Length = {}", paramType, paramLen);
                message.readBytes(paramLen);
                break;
        }
    }
}
#end_block

#method_before
public static BgpAttrOpaqueNode read(ChannelBuffer cb) throws BGPParseException {
    byte[] opaqueNodeAttribute;
    short lsAttrLength = cb.readShort();
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    opaqueNodeAttribute = new byte[lsAttrLength];
    cb.readBytes(opaqueNodeAttribute);
    return new BgpAttrOpaqueNode(opaqueNodeAttribute);
}
#method_after
public static BgpAttrOpaqueNode read(ChannelBuffer cb) throws BGPParseException {
    byte[] opaqueNodeAttribute;
    short lsAttrLength = cb.readShort();
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    opaqueNodeAttribute = new byte[lsAttrLength];
    cb.readBytes(opaqueNodeAttribute);
    return BgpAttrOpaqueNode.of(opaqueNodeAttribute);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(opaqueNodeAttribute);
}
#method_after
@Override
public int hashCode() {
    return Arrays.hashCode(opaqueNodeAttribute);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof BgpAttrOpaqueNode) {
        BgpAttrOpaqueNode other = (BgpAttrOpaqueNode) obj;
        return Objects.equals(opaqueNodeAttribute, other.opaqueNodeAttribute);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof BgpAttrOpaqueNode) {
        BgpAttrOpaqueNode other = (BgpAttrOpaqueNode) obj;
        return Arrays.equals(opaqueNodeAttribute, other.opaqueNodeAttribute);
    }
    return false;
}
#end_block

#method_before
@Override
public int write(ChannelBuffer cb) {
    // TODO will be implementing it later
    return 0;
}
#method_after
@Override
public int write(ChannelBuffer cb) {
    // TODO This will be implemented in the next version
    return 0;
}
#end_block

#method_before
public static BgpAttrNodeName read(ChannelBuffer cb) throws BGPParseException {
    byte[] nodeName;
    short lsAttrLength = cb.readShort();
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    nodeName = new byte[lsAttrLength];
    cb.readBytes(nodeName);
    return new BgpAttrNodeName(nodeName);
}
#method_after
public static BgpAttrNodeName read(ChannelBuffer cb) throws BGPParseException {
    byte[] nodeName;
    short lsAttrLength = cb.readShort();
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    nodeName = new byte[lsAttrLength];
    cb.readBytes(nodeName);
    return BgpAttrNodeName.of(nodeName);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(nodeName);
}
#method_after
@Override
public int hashCode() {
    return Arrays.hashCode(nodeName);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof BgpAttrNodeName) {
        BgpAttrNodeName other = (BgpAttrNodeName) obj;
        return Objects.equals(nodeName, other.nodeName);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof BgpAttrNodeName) {
        BgpAttrNodeName other = (BgpAttrNodeName) obj;
        return Arrays.equals(nodeName, other.nodeName);
    }
    return false;
}
#end_block

#method_before
@Override
public int write(ChannelBuffer cb) {
    // TODO will be implementing it later
    return 0;
}
#method_after
@Override
public int write(ChannelBuffer cb) {
    // TODO This will be implemented in the next version
    return 0;
}
#end_block

#method_before
public static BgpAttrNodeIsIsAreaId read(ChannelBuffer cb) throws BGPParseException {
    byte[] isisAreaId;
    short lsAttrLength = cb.readShort();
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    isisAreaId = new byte[lsAttrLength];
    cb.readBytes(isisAreaId);
    return new BgpAttrNodeIsIsAreaId(isisAreaId);
}
#method_after
public static BgpAttrNodeIsIsAreaId read(ChannelBuffer cb) throws BGPParseException {
    byte[] isisAreaId;
    short lsAttrLength = cb.readShort();
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    isisAreaId = new byte[lsAttrLength];
    cb.readBytes(isisAreaId);
    return BgpAttrNodeIsIsAreaId.of(isisAreaId);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(isisAreaId);
}
#method_after
@Override
public int hashCode() {
    return Arrays.hashCode(isisAreaId);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof BgpAttrNodeIsIsAreaId) {
        BgpAttrNodeIsIsAreaId other = (BgpAttrNodeIsIsAreaId) obj;
        return Objects.equals(isisAreaId, other.isisAreaId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof BgpAttrNodeIsIsAreaId) {
        BgpAttrNodeIsIsAreaId other = (BgpAttrNodeIsIsAreaId) obj;
        return Arrays.equals(isisAreaId, other.isisAreaId);
    }
    return false;
}
#end_block

#method_before
@Override
public int write(ChannelBuffer cb) {
    // TODO will be implementing it later
    return 0;
}
#method_after
@Override
public int write(ChannelBuffer cb) {
    // TODO This will be implemented in the next version
    return 0;
}
#end_block

#method_before
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeInt(bgpLSIdentifier);
    return c.writerIndex() - iLenStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeInt(bgpLSIdentifier);
    return c.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeInt(asNum);
    return c.writerIndex() - iLenStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeInt(asNum);
    return c.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
public static NodeDescriptors parseLocalNodeDescriptors(ChannelBuffer cb, byte protocolId) throws BGPParseException {
    ChannelBuffer tempBuf = cb;
    short type = cb.readShort();
    short length = cb.readShort();
    if (cb.readableBytes() < length) {
        // length + 4 implies data contains type, length and value
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(length + 4));
    }
    NodeDescriptors localNodeDescriptors = new NodeDescriptors();
    ChannelBuffer tempCb = cb.readBytes(length);
    if (type == NodeDescriptors.LOCAL_NODE_DES_TYPE) {
        localNodeDescriptors = NodeDescriptors.read(tempCb, length, type, protocolId);
    } else {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.MALFORMED_ATTRIBUTE_LIST, null);
    }
    return localNodeDescriptors;
}
#method_after
public static NodeDescriptors parseLocalNodeDescriptors(ChannelBuffer cb, byte protocolId) throws BGPParseException {
    ChannelBuffer tempBuf = cb;
    short type = cb.readShort();
    short length = cb.readShort();
    if (cb.readableBytes() < length) {
        // length + 4 implies data contains type, length and value
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(cb.readableBytes() + TYPE_AND_LEN));
    }
    NodeDescriptors localNodeDescriptors = new NodeDescriptors();
    ChannelBuffer tempCb = cb.readBytes(length);
    if (type == NodeDescriptors.LOCAL_NODE_DES_TYPE) {
        localNodeDescriptors = NodeDescriptors.read(tempCb, length, type, protocolId);
    } else {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.MALFORMED_ATTRIBUTE_LIST, null);
    }
    return localNodeDescriptors;
}
#end_block

#method_before
public static LinkedList<BGPValueType> parsePrefixDescriptors(ChannelBuffer cb) throws BGPParseException {
    LinkedList<BGPValueType> prefixDescriptor = new LinkedList<>();
    BGPValueType tlv = null;
    boolean isIpReachInfo = false;
    ChannelBuffer tempCb;
    int count = 0;
    while (cb.readableBytes() > 0) {
        ChannelBuffer tempBuf = cb;
        short type = cb.readShort();
        short length = cb.readShort();
        if (cb.readableBytes() < length) {
            // length + 4 implies data contains type, length and value
            throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(length + 4));
        }
        tempCb = cb.readBytes(length);
        switch(type) {
            case OSPFRouteTypeTlv.TYPE:
                tlv = OSPFRouteTypeTlv.read(tempCb);
                break;
            case IPReachabilityInformationTlv.TYPE:
                tlv = IPReachabilityInformationTlv.read(tempCb, length);
                isIpReachInfo = true;
                break;
            case BgpAttrNodeMultiTopologyId.ATTRNODE_MULTITOPOLOGY:
                tlv = BgpAttrNodeMultiTopologyId.read(tempCb);
                count = count + 1;
                if (count > 1) {
                    // length + 4 implies data contains type, length and value
                    throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(length + 4));
                }
                break;
            default:
                UnSupportedAttribute.skipBytes(tempCb, length);
        }
        prefixDescriptor.add(tlv);
    }
    if (!isIpReachInfo) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.OPTIONAL_ATTRIBUTE_ERROR, null);
    }
    return prefixDescriptor;
}
#method_after
public static LinkedList<BGPValueType> parsePrefixDescriptors(ChannelBuffer cb) throws BGPParseException {
    LinkedList<BGPValueType> prefixDescriptor = new LinkedList<>();
    BGPValueType tlv = null;
    boolean isIpReachInfo = false;
    ChannelBuffer tempCb;
    int count = 0;
    while (cb.readableBytes() > 0) {
        ChannelBuffer tempBuf = cb;
        short type = cb.readShort();
        short length = cb.readShort();
        if (cb.readableBytes() < length) {
            // length + 4 implies data contains type, length and value
            throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(cb.readableBytes() + TYPE_AND_LEN));
        }
        tempCb = cb.readBytes(length);
        switch(type) {
            case OSPFRouteTypeTlv.TYPE:
                tlv = OSPFRouteTypeTlv.read(tempCb);
                break;
            case IPReachabilityInformationTlv.TYPE:
                tlv = IPReachabilityInformationTlv.read(tempCb, length);
                isIpReachInfo = true;
                break;
            case BgpAttrNodeMultiTopologyId.ATTRNODE_MULTITOPOLOGY:
                tlv = BgpAttrNodeMultiTopologyId.read(tempCb);
                count = count + 1;
                if (count > 1) {
                    // length + 4 implies data contains type, length and value
                    throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(length + TYPE_AND_LEN));
                }
                break;
            default:
                UnSupportedAttribute.skipBytes(tempCb, length);
        }
        prefixDescriptor.add(tlv);
    }
    if (!isIpReachInfo) {
        throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.OPTIONAL_ATTRIBUTE_ERROR, null);
    }
    return prefixDescriptor;
}
#end_block

#method_before
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeInt(areaID);
    return c.writerIndex() - iLenStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeInt(areaID);
    return c.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
public static NodeDescriptors read(ChannelBuffer cb, short desLength, short desType, byte protocolId) throws BGPParseException {
    LinkedList<BGPValueType> subTlvs;
    subTlvs = new LinkedList<>();
    BGPValueType tlv = null;
    while (cb.readableBytes() > 0) {
        ChannelBuffer tempBuf = cb;
        short type = cb.readShort();
        short length = cb.readShort();
        if (cb.readableBytes() < length) {
            throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(length + 4));
        }
        ChannelBuffer tempCb = cb.readBytes(length);
        switch(type) {
            case AutonomousSystemTlv.TYPE:
                tlv = AutonomousSystemTlv.read(tempCb);
                break;
            case BGPLSIdentifierTlv.TYPE:
                tlv = BGPLSIdentifierTlv.read(tempCb);
                break;
            case AreaIDTlv.TYPE:
                tlv = AreaIDTlv.read(tempCb);
                break;
            case IGP_ROUTERID_TYPE:
                if (protocolId == IS_IS_LEVEL_1_PROTOCOL_ID || protocolId == IS_IS_LEVEL_2_PROTOCOL_ID) {
                    if (length == 6) {
                        tlv = IsIsNonPseudonode.read(tempCb);
                    } else if (length == 7) {
                        tlv = IsIsPseudonode.read(tempCb);
                    }
                } else if (protocolId == OSPF_V2_PROTOCOL_ID || protocolId == OSPF_V3_PROTOCOL_ID) {
                    if (length == 4) {
                        tlv = OSPFNonPseudonode.read(tempCb);
                    } else if (length == 8) {
                        tlv = OSPFPseudonode.read(tempCb);
                    }
                }
                break;
            default:
                UnSupportedAttribute.skipBytes(tempCb, length);
        }
        subTlvs.add(tlv);
    }
    return new NodeDescriptors(subTlvs, desLength, desType);
}
#method_after
public static NodeDescriptors read(ChannelBuffer cb, short desLength, short desType, byte protocolId) throws BGPParseException {
    LinkedList<BGPValueType> subTlvs;
    subTlvs = new LinkedList<>();
    BGPValueType tlv = null;
    while (cb.readableBytes() > 0) {
        ChannelBuffer tempBuf = cb;
        short type = cb.readShort();
        short length = cb.readShort();
        if (cb.readableBytes() < length) {
            throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, BGPErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(cb.readableBytes() + TYPE_AND_LEN));
        }
        ChannelBuffer tempCb = cb.readBytes(length);
        switch(type) {
            case AutonomousSystemTlv.TYPE:
                tlv = AutonomousSystemTlv.read(tempCb);
                break;
            case BGPLSIdentifierTlv.TYPE:
                tlv = BGPLSIdentifierTlv.read(tempCb);
                break;
            case AreaIDTlv.TYPE:
                tlv = AreaIDTlv.read(tempCb);
                break;
            case IGP_ROUTERID_TYPE:
                if (protocolId == IS_IS_LEVEL_1_PROTOCOL_ID || protocolId == IS_IS_LEVEL_2_PROTOCOL_ID) {
                    if (length == ISISNONPSEUDONODE_LEN) {
                        tlv = IsIsNonPseudonode.read(tempCb);
                    } else if (length == ISISPSEUDONODE_LEN) {
                        tlv = IsIsPseudonode.read(tempCb);
                    }
                } else if (protocolId == OSPF_V2_PROTOCOL_ID || protocolId == OSPF_V3_PROTOCOL_ID) {
                    if (length == OSPFNONPSEUDONODE_LEN) {
                        tlv = OSPFNonPseudonode.read(tempCb);
                    } else if (length == OSPFPSEUDONODE_LEN) {
                        tlv = OSPFPseudonode.read(tempCb);
                    }
                }
                break;
            default:
                UnSupportedAttribute.skipBytes(tempCb, length);
        }
        subTlvs.add(tlv);
    }
    return new NodeDescriptors(subTlvs, desLength, desType);
}
#end_block

#method_before
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeBytes(isoNodeID);
    return c.writerIndex() - iLenStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeBytes(isoNodeID);
    return c.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeInt(routerID);
    return c.writerIndex() - iLenStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeInt(routerID);
    return c.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeInt(routerID);
    c.writeInt(drInterface.toInt());
    return c.writerIndex() - iLenStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeInt(routerID);
    c.writeInt(drInterface.toInt());
    return c.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
public IpPrefix getPrefixValue() {
    IpPrefix prefix = IpPrefix.valueOf(IpAddress.Version.INET, ipPrefix, length);
    return prefix;
}
#method_after
public IpPrefix getPrefixValue() {
    IpPrefix prefix = Validation.bytesToPrefix(ipPrefix, prefixLen);
    return prefix;
}
#end_block

#method_before
public int write(ChannelBuffer cb) {
    int iLenStartIndex = cb.writerIndex();
    cb.writeShort(TYPE);
    cb.writeShort(length);
    cb.writeByte(prefixLen);
    cb.writeBytes(ipPrefix);
    return cb.writerIndex() - iLenStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer cb) {
    int iLenStartIndex = cb.writerIndex();
    cb.writeShort(TYPE);
    cb.writeShort(length);
    cb.writeByte(prefixLen);
    cb.writeBytes(ipPrefix);
    return cb.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
public static IPReachabilityInformationTlv read(ChannelBuffer cb, short length) {
    byte preficLen = cb.readByte();
    byte[] prefix;
    if (preficLen == 0) {
        prefix = new byte[] { 0 };
    } else {
        int len = preficLen / 8;
        int reminder = preficLen % 8;
        if (reminder > 0) {
            len = len + 1;
        }
        prefix = new byte[len];
        cb.readBytes(prefix, 0, len);
    }
    return new IPReachabilityInformationTlv(preficLen, prefix, length);
}
#method_after
public static IPReachabilityInformationTlv read(ChannelBuffer cb, short length) {
    byte preficLen = cb.readByte();
    byte[] prefix;
    if (preficLen == 0) {
        prefix = new byte[] { 0 };
    } else {
        int len = preficLen / ONE_BYTE_LEN;
        int reminder = preficLen % ONE_BYTE_LEN;
        if (reminder > 0) {
            len = len + 1;
        }
        prefix = new byte[len];
        cb.readBytes(prefix, 0, len);
    }
    return IPReachabilityInformationTlv.of(preficLen, prefix, length);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Type", TYPE).add("Length", length).add("Prefix length", getPrefixLen()).add("Prefix value", getPrefixValue()).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Type", TYPE).add("Length", length).add("Prefixlength", getPrefixLen()).add("Prefixvalue", getPrefixValue()).toString();
}
#end_block

#method_before
public ROUTETYPE getValue() throws BGPParseException {
    switch(routeType) {
        case 1:
            return ROUTETYPE.Intra_Area;
        case 2:
            return ROUTETYPE.Inter_Area;
        case 3:
            return ROUTETYPE.External_1;
        case 4:
            return ROUTETYPE.External_2;
        case 5:
            return ROUTETYPE.NSSA_1;
        case 6:
            return ROUTETYPE.NSSA_2;
        default:
            throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, (byte) 0, null);
    }
}
#method_after
public ROUTETYPE getValue() throws BGPParseException {
    switch(routeType) {
        case INTRA_AREA_TYPE:
            return ROUTETYPE.Intra_Area;
        case INTER_AREA_TYPE:
            return ROUTETYPE.Inter_Area;
        case EXTERNAL_TYPE_1:
            return ROUTETYPE.External_1;
        case EXTERNAL_TYPE_2:
            return ROUTETYPE.External_2;
        case NSSA_TYPE_1:
            return ROUTETYPE.NSSA_1;
        case NSSA_TYPE_2:
            return ROUTETYPE.NSSA_2;
        default:
            throw new BGPParseException(BGPErrorType.UPDATE_MESSAGE_ERROR, (byte) 0, null);
    }
}
#end_block

#method_before
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeByte(routeType);
    return c.writerIndex() - iLenStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeByte(routeType);
    return c.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeBytes(isoNodeID);
    c.writeByte(psnIdentifier);
    return c.writerIndex() - iLenStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int iLenStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    c.writeShort(LENGTH);
    c.writeBytes(isoNodeID);
    c.writeByte(psnIdentifier);
    return c.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
private void processParameters(JavaMethod javaMethod, ObjectNode methodNode, String method, DocletTag tag) {
    ArrayNode parameters = mapper.createArrayNode();
    methodNode.set("parameters", parameters);
    boolean required = true;
    for (JavaParameter javaParameter : javaMethod.getParameters()) {
        ObjectNode individualParameterNode = mapper.createObjectNode();
        Optional<JavaAnnotation> optional = javaParameter.getAnnotations().stream().filter(annotation -> annotation.getType().getName().equals(PATH_PARAM) || annotation.getType().getName().equals(QUERY_PARAM)).findAny();
        JavaAnnotation pathType = optional.isPresent() ? optional.get() : null;
        String annotationName = javaParameter.getName();
        if (pathType != null) {
            // the parameter is a path or query parameter
            individualParameterNode.put("name", pathType.getNamedParameter("value").toString().replace("\"", ""));
            if (pathType.getType().getName().equals(PATH_PARAM)) {
                individualParameterNode.put("in", "path");
            } else if (pathType.getType().getName().equals(QUERY_PARAM)) {
                individualParameterNode.put("in", "query");
            }
            individualParameterNode.put("type", getType(javaParameter.getType()));
        } else {
            // the parameter is a body parameter
            individualParameterNode.put("name", annotationName);
            individualParameterNode.put("in", "body");
            // individualParameterNode.set("schema", schema);
            if (tag != null && (method.toLowerCase().equals("post") || method.toLowerCase().equals("put"))) {
                ObjectNode schema = mapper.createObjectNode();
                tag.getParameters().stream().forEach(param -> {
                    schema.put("$ref", "#/definitions/" + param);
                });
                individualParameterNode.set("schema", schema);
            }
        }
        for (DocletTag p : javaMethod.getTagsByName("param")) {
            if (p.getValue().contains(annotationName)) {
                try {
                    String description = p.getValue().split(" ", 2)[1].trim();
                    if (description.contains("optional")) {
                        required = false;
                    }
                    individualParameterNode.put("description", description);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        individualParameterNode.put("required", required);
        parameters.add(individualParameterNode);
    }
}
#method_after
private void processParameters(JavaMethod javaMethod, ObjectNode methodNode, String method, DocletTag tag) {
    ArrayNode parameters = mapper.createArrayNode();
    methodNode.set("parameters", parameters);
    boolean required = true;
    for (JavaParameter javaParameter : javaMethod.getParameters()) {
        ObjectNode individualParameterNode = mapper.createObjectNode();
        Optional<JavaAnnotation> optional = javaParameter.getAnnotations().stream().filter(annotation -> annotation.getType().getName().equals(PATH_PARAM) || annotation.getType().getName().equals(QUERY_PARAM)).findAny();
        JavaAnnotation pathType = optional.isPresent() ? optional.get() : null;
        String annotationName = javaParameter.getName();
        if (pathType != null) {
            // the parameter is a path or query parameter
            individualParameterNode.put("name", pathType.getNamedParameter("value").toString().replace("\"", ""));
            if (pathType.getType().getName().equals(PATH_PARAM)) {
                individualParameterNode.put("in", "path");
            } else if (pathType.getType().getName().equals(QUERY_PARAM)) {
                individualParameterNode.put("in", "query");
            }
            individualParameterNode.put("type", getType(javaParameter.getType()));
        } else {
            // the parameter is a body parameter
            individualParameterNode.put("name", annotationName);
            individualParameterNode.put("in", "body");
            // that goes in the post or put operation
            if (tag != null && (method.toLowerCase().equals("post") || method.toLowerCase().equals("put"))) {
                ObjectNode schema = mapper.createObjectNode();
                tag.getParameters().stream().forEach(param -> {
                    schema.put("$ref", "#/definitions/" + param);
                });
                individualParameterNode.set("schema", schema);
            }
        }
        for (DocletTag p : javaMethod.getTagsByName("param")) {
            if (p.getValue().contains(annotationName)) {
                try {
                    String description = p.getValue().split(" ", 2)[1].trim();
                    if (description.contains("optional")) {
                        required = false;
                    }
                    individualParameterNode.put("description", description);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        individualParameterNode.put("required", required);
        parameters.add(individualParameterNode);
    }
}
#end_block

#method_before
@Override
public void performGroupOperation(DeviceId deviceId, GroupOperations groupOps) {
    Map<OFGroupMod, OpenFlowSwitch> mods = Maps.newIdentityHashMap();
    final Dpid dpid = Dpid.dpid(deviceId.uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    for (GroupOperation groupOperation : groupOps.operations()) {
        if (sw == null) {
            log.error("SW {} is not found", dpid);
            return;
        }
        final Long groupModXid = XID_COUNTER.getAndIncrement();
        GroupModBuilder builder = GroupModBuilder.builder(groupOperation.buckets(), groupOperation.groupId(), groupOperation.groupType(), sw.factory(), Optional.of(groupModXid), driverService);
        OFGroupMod groupMod = null;
        switch(groupOperation.opType()) {
            case ADD:
                groupMod = builder.buildGroupAdd();
                break;
            case MODIFY:
                groupMod = builder.buildGroupMod();
                break;
            case DELETE:
                groupMod = builder.buildGroupDel();
                break;
            default:
                log.error("Unsupported Group operation");
        }
        sw.sendMsg(groupMod);
        GroupId groudId = new DefaultGroupId(groupMod.getGroup().getGroupNumber());
        pendingGroupOperations.put(groudId, groupOperation);
        pendingXidMaps.put(groudId, groupModXid);
    }
}
#method_after
@Override
public void performGroupOperation(DeviceId deviceId, GroupOperations groupOps) {
    Map<OFGroupMod, OpenFlowSwitch> mods = Maps.newIdentityHashMap();
    final Dpid dpid = Dpid.dpid(deviceId.uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    for (GroupOperation groupOperation : groupOps.operations()) {
        if (sw == null) {
            log.error("SW {} is not found", dpid);
            return;
        }
        final Long groupModXid = XID_COUNTER.getAndIncrement();
        GroupModBuilder builder = null;
        if (driverService == null) {
            builder = GroupModBuilder.builder(groupOperation.buckets(), groupOperation.groupId(), groupOperation.groupType(), sw.factory(), Optional.of(groupModXid));
        } else {
            builder = GroupModBuilder.builder(groupOperation.buckets(), groupOperation.groupId(), groupOperation.groupType(), sw.factory(), Optional.of(groupModXid), Optional.of(driverService));
        }
        OFGroupMod groupMod = null;
        switch(groupOperation.opType()) {
            case ADD:
                groupMod = builder.buildGroupAdd();
                break;
            case MODIFY:
                groupMod = builder.buildGroupMod();
                break;
            case DELETE:
                groupMod = builder.buildGroupDel();
                break;
            default:
                log.error("Unsupported Group operation");
        }
        sw.sendMsg(groupMod);
        GroupId groudId = new DefaultGroupId(groupMod.getGroup().getGroupNumber());
        pendingGroupOperations.put(groudId, groupOperation);
        pendingXidMaps.put(groudId, groupModXid);
    }
}
#end_block

#method_before
public static GroupModBuilder builder(GroupBuckets buckets, GroupId groupId, GroupDescription.Type type, OFFactory factory, Optional<Long> xid, DriverService driverService) {
    return new GroupModBuilder(buckets, groupId, type, factory, xid, driverService);
}
#method_after
public static GroupModBuilder builder(GroupBuckets buckets, GroupId groupId, GroupDescription.Type type, OFFactory factory, Optional<Long> xid, Optional<DriverService> driverService) {
    return new GroupModBuilder(buckets, groupId, type, factory, xid, driverService);
}
#end_block

#method_before
private OFAction buildExtensionAction(ExtensionInstruction i, DeviceId deviceId) {
    if (driverService == null) {
        log.error("No driver service present");
        return null;
    }
    Driver driver = driverService.getDriver(deviceId);
    if (driver.hasBehaviour(ExtensionInterpreter.class)) {
        DefaultDriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
        ExtensionInterpreter interpreter = handler.behaviour(ExtensionInterpreter.class);
        return interpreter.mapInstruction(factory, i);
    }
    return null;
}
#method_after
private OFAction buildExtensionAction(ExtensionInstruction i, DeviceId deviceId) {
    if (!driverService.isPresent()) {
        log.error("No driver service present");
        return null;
    }
    Driver driver = driverService.get().getDriver(deviceId);
    if (driver.hasBehaviour(ExtensionInterpreter.class)) {
        DefaultDriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
        ExtensionInterpreter interpreter = handler.behaviour(ExtensionInterpreter.class);
        return interpreter.mapInstruction(factory, i);
    }
    return null;
}
#end_block

