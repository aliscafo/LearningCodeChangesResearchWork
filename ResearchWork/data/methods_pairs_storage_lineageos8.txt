38
#method_before
protected void addCommonClientTlvs(ByteBuffer buf) {
    addTlv(buf, DHCP_MAX_MESSAGE_SIZE, (short) MAX_LENGTH);
    addTlv(buf, DHCP_VENDOR_CLASS_ID, "android-dhcp-" + Build.VERSION.RELEASE);
    String hostname = SystemProperties.get("net.hostname");
    if (hostname.length() == 0) {
        /* make sure the hostname is never empty, because the DHCP
                 * standard forbids it (RFC2132, section 3.14) and certain DHCP
                 * forwarders and servers ignore such malformed requests */
        hostname = "android-dhcp";
    }
    addTlv(buf, DHCP_HOST_NAME, hostname);
}
#method_after
protected void addCommonClientTlvs(ByteBuffer buf) {
    addTlv(buf, DHCP_MAX_MESSAGE_SIZE, (short) MAX_LENGTH);
    addTlv(buf, DHCP_VENDOR_CLASS_ID, "android-dhcp-" + Build.VERSION.RELEASE);
    /* the default 'android-dhcp' is there to make sure the hostname is
         * never empty, because the DHCP standard forbids it (RFC2132, section
         * 3.14) and certain DHCP forwarders and servers ignore such malformed
         * requests */
    addTlv(buf, DHCP_HOST_NAME, SystemProperties.get("net.hostname", "android-dhcp"));
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final int scanCode = event.getScanCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive, unless the user has explicitly disabled this wake key.
        result = ACTION_PASS_TO_USER;
        isWakeKey = isWakeKey && isWakeKeyEnabled(keyCode);
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only should consume known keys.
            if (mDeviceKeyHandler.handleKeyEvent(event)) {
                return 0;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    mBackKeyHandled = false;
                    if (hasLongPressOnBackBehavior()) {
                        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    }
                } else {
                    boolean handled = mBackKeyHandled;
                    // Reset back key state
                    cancelPendingBackKeyAction();
                    // Don't pass back press to app if we've already handled it
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                // This disables volume control, music control, and "beep" on key up.
                if (isWakeKey && mVolumeWakeScreen) {
                    setVolumeWakeTriggered(keyCode, true);
                    break;
                } else if (getVolumeWakeTriggered(keyCode) && !down) {
                    result &= ~ACTION_PASS_TO_USER;
                    setVolumeWakeTriggered(keyCode, false);
                    break;
                }
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeUpKeyTriggered = true;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                        }
                    } else {
                        mScreenshotChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                            // If we are in call but we decided not to pass the key to
                            // the application, just pass it to the session service.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                            break;
                        }
                    }
                }
                if (mUseTvRouting) {
                    // On TVs, defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, true);
                }
                // Disable music and volume control when used as wake key
                if ((result & ACTION_PASS_TO_USER) == 0 && !mVolumeWakeScreen) {
                    boolean mayChangeVolume = false;
                    if (isMusicActive()) {
                        if (mVolBtnMusicControls && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                            // Detect long key presses.
                            if (down) {
                                mIsLongPress = false;
                                // TODO: Long press of MUTE could be mapped to KEYCODE_MEDIA_PLAY_PAUSE
                                int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                                scheduleLongPressKeyEvent(event, newKeyCode);
                                // Consume key down events of all presses.
                                break;
                            } else {
                                mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                                // Consume key up events of long presses only.
                                if (mIsLongPress) {
                                    break;
                                }
                                // Change volume only on key up events of short presses.
                                mayChangeVolume = true;
                            }
                        } else {
                            // Long key press detection not applicable, change volume only
                            // on key down events
                            mayChangeVolume = down;
                        }
                    }
                    if (mayChangeVolume) {
                        if (mUseTvRouting) {
                            dispatchDirectAudioEvent(event);
                        } else {
                            // If we aren't passing to the user and no one else
                            // handled it send it to the session manager to figure
                            // out.
                            // Rewrite the event to use key-down as sendVolumeKeyEvent will
                            // only change the volume on key down.
                            KeyEvent newEvent = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(newEvent, true);
                        }
                    }
                    break;
                }
                break;
            }
        case KeyEvent.KEYCODE_HOME:
            if (down && !interactive && mHomeWakeScreen) {
                isWakeKey = true;
            }
            break;
        case KeyEvent.KEYCODE_FOCUS:
            if (down && !interactive && mCameraSleepOnRelease) {
                mIsFocusPressed = true;
            } else if ((event.getAction() == KeyEvent.ACTION_UP) && mScreenOnFully && mIsFocusPressed) {
                // Check if screen is fully on before letting the device go to sleep
                mPowerManager.goToSleep(SystemClock.uptimeMillis());
                mIsFocusPressed = false;
            }
            break;
        case KeyEvent.KEYCODE_CAMERA:
            if (down && mIsFocusPressed) {
                mIsFocusPressed = false;
            }
            if (down) {
                mIsLongPress = false;
                scheduleLongPressKeyEvent(event, KeyEvent.KEYCODE_CAMERA);
                // Consume key down events of all presses.
                break;
            } else {
                mHandler.removeMessages(MSG_CAMERA_LONG_PRESS);
                // Consume key up events of long presses only.
                if (mIsLongPress && mCameraLaunch) {
                    Intent intent;
                    if (keyguardActive) {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE);
                    } else {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA);
                    }
                    isWakeKey = true;
                    startActivityAsUser(intent, UserHandle.CURRENT_OR_SELF);
                }
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                if ((mTopFullscreenOpaqueWindowState.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_POWER_KEY) != 0 && mScreenOnFully) {
                    return result;
                }
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final int scanCode = event.getScanCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive, unless the user has explicitly disabled this wake key.
        result = ACTION_PASS_TO_USER;
        isWakeKey = isWakeKey && isWakeKeyEnabled(keyCode);
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only should consume known keys.
            if (mDeviceKeyHandler.handleKeyEvent(event)) {
                return 0;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    mBackKeyHandled = false;
                    if (hasLongPressOnBackBehavior()) {
                        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    }
                } else {
                    boolean handled = mBackKeyHandled;
                    // Reset back key state
                    cancelPendingBackKeyAction();
                    // Don't pass back press to app if we've already handled it
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                // This disables volume control, music control, and "beep" on key up.
                if (isWakeKey && mVolumeWakeScreen) {
                    setVolumeWakeTriggered(keyCode, true);
                    break;
                } else if (getVolumeWakeTriggered(keyCode) && !down) {
                    result &= ~ACTION_PASS_TO_USER;
                    setVolumeWakeTriggered(keyCode, false);
                    break;
                }
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeUpKeyTriggered = true;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                        }
                    } else {
                        mScreenshotChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                            // If we are in call but we decided not to pass the key to
                            // the application, just pass it to the session service.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                            break;
                        }
                    }
                }
                // Disable music and volume control when used as wake key
                if ((result & ACTION_PASS_TO_USER) == 0 && !mVolumeWakeScreen) {
                    boolean mayChangeVolume = false;
                    if (isMusicActive()) {
                        if (mVolBtnMusicControls && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                            // Detect long key presses.
                            if (down) {
                                mIsLongPress = false;
                                // TODO: Long press of MUTE could be mapped to KEYCODE_MEDIA_PLAY_PAUSE
                                int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                                scheduleLongPressKeyEvent(event, newKeyCode);
                                // Consume key down events of all presses.
                                break;
                            } else {
                                mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                                // Consume key up events of long presses only.
                                if (mIsLongPress) {
                                    break;
                                }
                                // Change volume only on key up events of short presses.
                                mayChangeVolume = true;
                            }
                        } else {
                            // Long key press detection not applicable, change volume only
                            // on key down events
                            mayChangeVolume = down;
                        }
                    }
                    if (mayChangeVolume) {
                        if (mUseTvRouting) {
                            dispatchDirectAudioEvent(event);
                        } else {
                            // If we aren't passing to the user and no one else
                            // handled it send it to the session manager to figure
                            // out.
                            // Rewrite the event to use key-down as sendVolumeKeyEvent will
                            // only change the volume on key down.
                            KeyEvent newEvent = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(newEvent, true);
                        }
                    }
                    break;
                }
                break;
            }
        case KeyEvent.KEYCODE_HOME:
            if (down && !interactive && mHomeWakeScreen) {
                isWakeKey = true;
            }
            break;
        case KeyEvent.KEYCODE_FOCUS:
            if (down && !interactive && mCameraSleepOnRelease) {
                mIsFocusPressed = true;
            } else if ((event.getAction() == KeyEvent.ACTION_UP) && mScreenOnFully && mIsFocusPressed) {
                // Check if screen is fully on before letting the device go to sleep
                mPowerManager.goToSleep(SystemClock.uptimeMillis());
                mIsFocusPressed = false;
            }
            break;
        case KeyEvent.KEYCODE_CAMERA:
            if (down && mIsFocusPressed) {
                mIsFocusPressed = false;
            }
            if (down) {
                mIsLongPress = false;
                scheduleLongPressKeyEvent(event, KeyEvent.KEYCODE_CAMERA);
                // Consume key down events of all presses.
                break;
            } else {
                mHandler.removeMessages(MSG_CAMERA_LONG_PRESS);
                // Consume key up events of long presses only.
                if (mIsLongPress && mCameraLaunch) {
                    Intent intent;
                    if (keyguardActive) {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE);
                    } else {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA);
                    }
                    isWakeKey = true;
                    startActivityAsUser(intent, UserHandle.CURRENT_OR_SELF);
                }
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                if ((mTopFullscreenOpaqueWindowState.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_POWER_KEY) != 0 && mScreenOnFully) {
                    return result;
                }
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#end_block

#method_before
public void systemReady() {
    prepareNativeDaemon();
    // Registering the receiver for Zerobalance blocking/unblocking
    if (mContext.getResources().getBoolean(R.bool.config_zero_balance_operator)) {
        final IntentFilter restrictFilter = new IntentFilter();
        restrictFilter.addAction("org.codeaurora.restrictData");
        mContext.registerReceiver(mZeroBalanceReceiver, restrictFilter);
    }
    if (DBG)
        Slog.d(TAG, "Prepared");
}
#method_after
public void systemReady() {
    prepareNativeDaemon();
    // Register the receiver for Zerobalance blocking/unblocking
    if (mContext.getResources().getBoolean(R.bool.config_zero_balance_operator)) {
        final IntentFilter restrictFilter = new IntentFilter();
        restrictFilter.addAction("org.codeaurora.restrictData");
        mContext.registerReceiver(mZeroBalanceReceiver, restrictFilter);
    }
    if (DBG)
        Slog.d(TAG, "Prepared");
}
#end_block

#method_before
public String getBgDataProperty() {
    String isBgDataPropertySet = SystemProperties.get(BACKGROUND_DATA_PROPERTY, "false");
    if (Boolean.valueOf(isBgDataPropertySet)) {
        sRedirectCount = 0;
    }
    return isBgDataPropertySet;
}
#method_after
public String getBgDataProperty() {
    String isBgDataPropertySet = SystemProperties.get(BACKGROUND_DATA_PROPERTY, "false");
    if (Boolean.parseBoolean(isBgDataPropertySet)) {
        sRedirectCount = 0;
    }
    return isBgDataPropertySet;
}
#end_block

#method_before
public synchronized void setHttpRedirectCount(String url) {
    String redirectUrl = getConfiguredRedirectURL();
    if (redirectUrl != null && url.contains(redirectUrl)) {
        sRedirectCount++;
        Log.d(TAG, "http:sRedirectCount=" + sRedirectCount);
        if (sRedirectCount >= 3) {
            Log.d(TAG, "http:Background Data will be disabled");
            setBgDataProperty("true");
            sRedirectCount = 0;
        }
    } else {
        Log.d(TAG, "http: resetting the counter ");
        sRedirectCount = 0;
    }
}
#method_after
public synchronized void setHttpRedirectCount(String url) {
    String redirectUrl = getConfiguredRedirectURL();
    if (redirectUrl != null && url.contains(redirectUrl)) {
        sRedirectCount++;
        Log.d(TAG, "http:sRedirectCount=" + sRedirectCount);
        if (sRedirectCount >= sRedirectMaxCount) {
            Log.d(TAG, "http:Background Data will be disabled");
            setBgDataProperty("true");
            sRedirectCount = 0;
        }
    } else {
        Log.d(TAG, "http: resetting the counter ");
        sRedirectCount = 0;
    }
}
#end_block

#method_before
// Some apps like to compare the build type embedded in fingerprint
// to the actual build type. As the fingerprint in our case is almost
// always hardcoded to the stock ROM fingerprint, provide that instead
private static String parseBuildTypeFromFingerprint() {
    final String fingerprint = SystemProperties.get("ro.build.fingerprint");
    if (TextUtils.isEmpty(fingerprint)) {
        return null;
    }
    Pattern fingerprintPattern = Pattern.compile("(.*)\\/(.*)\\/(.*):(.*)\\/(.*)\\/(.*):(.*)\\/(.*)");
    Matcher matcher = fingerprintPattern.matcher(fingerprint);
    return matcher.matches() ? matcher.group(7) : null;
}
#method_after
private static String parseBuildTypeFromFingerprint() {
    final String fingerprint = SystemProperties.get("ro.build.fingerprint");
    if (TextUtils.isEmpty(fingerprint)) {
        return null;
    }
    Pattern fingerprintPattern = Pattern.compile("(.*)\\/(.*)\\/(.*):(.*)\\/(.*)\\/(.*):(.*)\\/(.*)");
    Matcher matcher = fingerprintPattern.matcher(fingerprint);
    return matcher.matches() ? matcher.group(7) : null;
}
#end_block

#method_before
@Override
public void interfaceStatusChanged(String iface, boolean up) {
    // See NetlinkHandler.cpp:71.
    if (VDBG)
        Log.d(TAG, "interfaceStatusChanged " + iface + ", " + up);
    WifiManager mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
    WifiDevice device = new WifiDevice(iface);
    synchronized (mPublicSync) {
        int interfaceType = ifaceNameToType(iface);
        if (interfaceType == ConnectivityManager.TETHERING_INVALID) {
            return;
        }
        TetherState tetherState = mTetherStates.get(iface);
        if (up) {
            if (tetherState == null) {
                trackNewTetherableInterface(iface, interfaceType);
                mConnectedDeviceMap.put(device.deviceAddress, device);
            }
        } else {
            if (interfaceType == ConnectivityManager.TETHERING_BLUETOOTH) {
                tetherState.mStateMachine.sendMessage(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
                mTetherStates.remove(iface);
                mConnectedDeviceMap.remove(iface);
            } else {
                if (isUsb(iface) || isBluetooth(iface) || isWifi(iface)) {
                    // through the WifiManager.WIFI_AP_STATE_CHANGED_ACTION intent.
                    if (VDBG)
                        Log.d(TAG, "ignore interface down for " + iface);
                }
            }
        }
    }
}
#method_after
@Override
public void interfaceStatusChanged(String iface, boolean up) {
    // See NetlinkHandler.cpp:71.
    if (VDBG)
        Log.d(TAG, "interfaceStatusChanged " + iface + ", " + up);
    WifiManager mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
    WifiDevice device = new WifiDevice(iface);
    synchronized (mPublicSync) {
        int interfaceType = ifaceNameToType(iface);
        if (interfaceType == ConnectivityManager.TETHERING_INVALID) {
            return;
        }
        TetherState tetherState = mTetherStates.get(iface);
        if (up) {
            if (tetherState == null) {
                trackNewTetherableInterface(iface, interfaceType);
                mConnectedDeviceMap.put(device.deviceAddress, device);
            }
        } else {
            if (interfaceType == ConnectivityManager.TETHERING_BLUETOOTH) {
                tetherState.mStateMachine.sendMessage(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
                mTetherStates.remove(iface);
                mConnectedDeviceMap.remove(iface);
            }
        }
    }
}
#end_block

#method_before
public void interfaceMessageRecevied(String message) {
    // if softap extension feature not enabled, do nothing
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_softap_extention)) {
        return;
    }
    if (DBG)
        Log.d(TAG, "interfaceMessageRecevied: message=" + message);
    try {
        WifiDevice device = new WifiDevice(message);
        if (device.deviceState == WifiDevice.CONNECTED) {
            mL2ConnectedDeviceMap.put(device.deviceAddress, device);
            // will exit after a timeout.
            if (readDeviceInfoFromDnsmasq(device)) {
                mConnectedDeviceMap.put(device.deviceAddress, device);
                sendTetherConnectStateChangedBroadcast();
            } else {
                if (DBG)
                    Log.d(TAG, "Starting poll device info for " + device.deviceAddress);
                new DnsmasqThread(this, device, DNSMASQ_POLLING_INTERVAL, DNSMASQ_POLLING_MAX_TIMES).start();
            }
        // cancelInactivityTimeout();
        } else if (device.deviceState == WifiDevice.DISCONNECTED) {
            mL2ConnectedDeviceMap.remove(device.deviceAddress);
            mConnectedDeviceMap.remove(device.deviceAddress);
            sendTetherConnectStateChangedBroadcast();
        // schedule inactivity timeout if non-zero and no more devices are connected
        // if (mWiFiApInactivityTimeout > 0 && mL2ConnectedDeviceMap.size() == 0) {
        // scheduleInactivityTimeout();
        // }
        }
    } catch (IllegalArgumentException ex) {
        Log.e(TAG, "WifiDevice IllegalArgument: " + ex);
    }
}
#method_after
public void interfaceMessageRecevied(String message) {
    // if softap extension feature not enabled, do nothing
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_softap_extention)) {
        return;
    }
    if (DBG)
        Log.d(TAG, "interfaceMessageRecevied: message=" + message);
    try {
        WifiDevice device = new WifiDevice(message);
        if (device.deviceState == WifiDevice.CONNECTED) {
            mL2ConnectedDeviceMap.put(device.deviceAddress, device);
            // will exit after a timeout.
            if (readDeviceInfoFromDnsmasq(device)) {
                mConnectedDeviceMap.put(device.deviceAddress, device);
                sendTetherConnectStateChangedBroadcast();
            } else {
                if (DBG)
                    Log.d(TAG, "Starting poll device info for " + device.deviceAddress);
                new DnsmasqThread(this, device, DNSMASQ_POLLING_INTERVAL, DNSMASQ_POLLING_MAX_TIMES).start();
            }
        // cancelInactivityTimeout();
        } else if (device.deviceState == WifiDevice.DISCONNECTED) {
            mL2ConnectedDeviceMap.remove(device.deviceAddress);
            mConnectedDeviceMap.remove(device.deviceAddress);
            sendTetherConnectStateChangedBroadcast();
        }
    } catch (IllegalArgumentException ex) {
        Log.e(TAG, "WifiDevice IllegalArgument: " + ex);
    }
}
#end_block

#method_before
@Override
public void setListening(boolean listening) {
    if (mListening == listening)
        return;
    if (listening) {
        mController.addCallback(mCallback);
        mContext.registerReceiver(mTetherConnectStateChangedReceiver, new IntentFilter(ConnectivityManager.TETHER_CONNECT_STATE_CHANGED));
        final IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
        refreshState();
    } else {
        mController.removeCallback(mCallback);
        mContext.unregisterReceiver(mTetherConnectStateChangedReceiver);
    }
    mListening = listening;
// mAirplaneMode.setListening(listening);
}
#method_after
@Override
public void setListening(boolean listening) {
    if (mListening == listening)
        return;
    if (listening) {
        mController.addCallback(mCallback);
        mContext.registerReceiver(mTetherConnectStateChangedReceiver, new IntentFilter(ConnectivityManager.TETHER_CONNECT_STATE_CHANGED));
        final IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
        refreshState();
    } else {
        mController.removeCallback(mCallback);
        mContext.unregisterReceiver(mTetherConnectStateChangedReceiver);
    }
    mListening = listening;
    mAirplaneMode.setListening(listening);
}
#end_block

#method_before
@Override
protected void handleUpdateState(AirplaneBooleanState state, Object arg) {
    state.visible = mController.isHotspotEnabled();
    state.label = mContext.getString(R.string.quick_settings_hotspot_label);
    checkIfRestrictionEnforcedByAdminOnly(state, UserManager.DISALLOW_CONFIG_TETHERING);
    if (arg instanceof Boolean) {
        state.value = (boolean) arg;
    } else {
        state.value = mController.isHotspotEnabled();
    }
    state.icon = state.value ? mEnable : mDisable;
    boolean wasAirplane = state.isAirplaneMode;
    state.isAirplaneMode = mAirplaneMode.getValue() != 0;
    if (state.isAirplaneMode) {
        final int disabledColor = mHost.getContext().getColor(R.color.qs_tile_tint_unavailable);
        state.label = new SpannableStringBuilder().append(state.label, new ForegroundColorSpan(disabledColor), SpannableStringBuilder.SPAN_INCLUSIVE_INCLUSIVE);
        state.icon = mUnavailable;
    } else if (wasAirplane) {
        state.icon = mDisableNoAnimation;
    }
    state.minimalAccessibilityClassName = state.expandedAccessibilityClassName = Switch.class.getName();
    state.contentDescription = state.label;
    if (state.visible && state.value) {
        state.label = mContext.getResources().getQuantityString(R.plurals.wifi_hotspot_connected_clients_label, mNumConnectedClients, mNumConnectedClients);
        mNumConnectedClients = 0;
    } else {
        state.label = mContext.getString(R.string.quick_settings_hotspot_label);
    }
    state.icon = state.visible && state.value ? mEnable : mDisable;
}
#method_after
@Override
protected void handleUpdateState(AirplaneBooleanState state, Object arg) {
    boolean visible = mController.isHotspotEnabled();
    state.label = mContext.getString(R.string.quick_settings_hotspot_label);
    checkIfRestrictionEnforcedByAdminOnly(state, UserManager.DISALLOW_CONFIG_TETHERING);
    if (arg instanceof Boolean) {
        state.value = (boolean) arg;
    } else {
        state.value = mController.isHotspotEnabled();
    }
    state.icon = state.value ? mEnable : mDisable;
    boolean wasAirplane = state.isAirplaneMode;
    state.isAirplaneMode = mAirplaneMode.getValue() != 0;
    if (state.isAirplaneMode) {
        final int disabledColor = mHost.getContext().getColor(R.color.qs_tile_tint_unavailable);
        state.label = new SpannableStringBuilder().append(state.label, new ForegroundColorSpan(disabledColor), SpannableStringBuilder.SPAN_INCLUSIVE_INCLUSIVE);
        state.icon = mUnavailable;
    } else if (wasAirplane) {
        state.icon = mDisableNoAnimation;
    }
    state.minimalAccessibilityClassName = state.expandedAccessibilityClassName = Switch.class.getName();
    state.contentDescription = state.label;
    if (visible && state.value) {
        state.label = mContext.getResources().getQuantityString(R.plurals.wifi_hotspot_connected_clients_label, mNumConnectedClients, mNumConnectedClients);
        mNumConnectedClients = 0;
    } else {
        state.label = mContext.getString(R.string.quick_settings_hotspot_label);
    }
    state.icon = visible && state.value ? mEnable : mDisable;
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.Global.getUriFor(CMSettings.Global.DEV_FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.VOLBTN_MUSIC_CONTROLS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.BACK_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.MENU_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.ASSIST_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.APP_SWITCH_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.CAMERA_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.CAMERA_SLEEP_ON_RELEASE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.CAMERA_LAUNCH), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.VOLUME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.HOME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.VOLUME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NAVBAR_LEFT_IN_LANDSCAPE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.TORCH_LONG_PRESS_POWER_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.VOLUME_ANSWER_CALL), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.Global.getUriFor(CMSettings.Global.DEV_FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.VOLBTN_MUSIC_CONTROLS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.BACK_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.MENU_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.ASSIST_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.APP_SWITCH_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.CAMERA_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.CAMERA_SLEEP_ON_RELEASE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.CAMERA_LAUNCH), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.VOLUME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.HOME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.VOLUME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.VOLUME_ANSWER_CALL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NAVBAR_LEFT_IN_LANDSCAPE), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
private void interceptPowerKeyDown(KeyEvent event, boolean interactive) {
    // Hold a wake lock until the power key is released.
    if (!mPowerKeyWakeLock.isHeld()) {
        mPowerKeyWakeLock.acquire();
    }
    // Cancel multi-press detection timeout.
    if (mPowerKeyPressCounter != 0) {
        mHandler.removeMessages(MSG_POWER_DELAYED_PRESS);
    }
    // Detect user pressing the power button in panic when an application has
    // taken over the whole screen.
    boolean panic = mImmersiveModeConfirmation.onPowerKeyDown(interactive, SystemClock.elapsedRealtime(), isImmersiveMode(mLastSystemUiFlags), isNavBarEmpty(mLastSystemUiFlags));
    if (panic) {
        mHandler.post(mHiddenNavPanic);
    }
    // Latch power key state to detect screenshot chord.
    if (interactive && !mScreenshotChordPowerKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
        mScreenshotChordPowerKeyTriggered = true;
        mScreenshotChordPowerKeyTime = event.getDownTime();
        interceptScreenshotChord();
    }
    // Stop ringing or end call if configured to do so when power is pressed.
    TelecomManager telecomManager = getTelecommService();
    boolean hungUp = false;
    if (telecomManager != null) {
        if (telecomManager.isRinging()) {
            // Pressing Power while there's a ringing incoming
            // call should silence the ringer.
            telecomManager.silenceRinger();
        } else if ((mIncallPowerBehavior & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 && telecomManager.isInCall() && interactive) {
            // Otherwise, if "Power button ends call" is enabled,
            // the Power button will hang up any current active call.
            hungUp = telecomManager.endCall();
        }
    }
    GestureLauncherService gestureService = LocalServices.getService(GestureLauncherService.class);
    boolean gesturedServiceIntercepted = false;
    if (gestureService != null) {
        gesturedServiceIntercepted = gestureService.interceptPowerKeyDown(event, interactive, mTmpBoolean);
        if (mTmpBoolean.value && mGoingToSleep) {
            mCameraGestureTriggeredDuringGoingToSleep = true;
        }
    }
    // If the power key has still not yet been handled, then detect short
    // press, long press, or multi press and decide what to do.
    mPowerKeyHandled = hungUp || mScreenshotChordVolumeDownKeyTriggered || mScreenshotChordVolumeUpKeyTriggered || gesturedServiceIntercepted;
    if (!mPowerKeyHandled) {
        if (interactive) {
            // Wait for a long press or for the button to be released to decide what to do.
            if (hasLongPressOnPowerBehavior()) {
                Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS);
                msg.setAsynchronous(true);
                mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
            }
        } else {
            if (!mTorchLongPressPowerEnabled) {
                wakeUpFromPowerKey(event.getDownTime());
            }
            if (mTorchLongPressPowerEnabled && mIsTorchActive) {
                try {
                    mCameraManager.setTorchMode(getCameraId(), false);
                } catch (Exception e) {
                    mWasTorchActive = false;
                }
                mIsTorchActive = false;
                mWasTorchActive = true;
            } else if ((mSupportLongPressPowerWhenNonInteractive && hasLongPressOnPowerBehavior()) || mTorchLongPressPowerEnabled) {
                Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS);
                msg.setAsynchronous(true);
                mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                mBeganFromNonInteractive = true;
            } else {
                final int maxCount = getMaxMultiPressPowerCount();
                if (maxCount <= 1) {
                    mPowerKeyHandled = true;
                } else {
                    mBeganFromNonInteractive = true;
                }
            }
        }
    }
}
#method_after
private void interceptPowerKeyDown(KeyEvent event, boolean interactive) {
    // Hold a wake lock until the power key is released.
    if (!mPowerKeyWakeLock.isHeld()) {
        mPowerKeyWakeLock.acquire();
    }
    // Cancel multi-press detection timeout.
    if (mPowerKeyPressCounter != 0) {
        mHandler.removeMessages(MSG_POWER_DELAYED_PRESS);
    }
    // Detect user pressing the power button in panic when an application has
    // taken over the whole screen.
    boolean panic = mImmersiveModeConfirmation.onPowerKeyDown(interactive, SystemClock.elapsedRealtime(), isImmersiveMode(mLastSystemUiFlags), isNavBarEmpty(mLastSystemUiFlags));
    if (panic) {
        mHandler.post(mHiddenNavPanic);
    }
    // Latch power key state to detect screenshot chord.
    if (interactive && !mScreenshotChordPowerKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
        mScreenshotChordPowerKeyTriggered = true;
        mScreenshotChordPowerKeyTime = event.getDownTime();
        interceptScreenshotChord();
    }
    // Stop ringing or end call if configured to do so when power is pressed.
    TelecomManager telecomManager = getTelecommService();
    boolean hungUp = false;
    if (telecomManager != null) {
        if (telecomManager.isRinging()) {
            // Pressing Power while there's a ringing incoming
            // call should silence the ringer.
            telecomManager.silenceRinger();
        } else if ((mIncallPowerBehavior & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 && telecomManager.isInCall() && interactive) {
            // Otherwise, if "Power button ends call" is enabled,
            // the Power button will hang up any current active call.
            hungUp = telecomManager.endCall();
        }
    }
    GestureLauncherService gestureService = LocalServices.getService(GestureLauncherService.class);
    boolean gesturedServiceIntercepted = false;
    if (gestureService != null) {
        gesturedServiceIntercepted = gestureService.interceptPowerKeyDown(event, interactive, mTmpBoolean);
        if (mTmpBoolean.value && mGoingToSleep) {
            mCameraGestureTriggeredDuringGoingToSleep = true;
        }
    }
    // If the power key has still not yet been handled, then detect short
    // press, long press, or multi press and decide what to do.
    mPowerKeyHandled = hungUp || mScreenshotChordVolumeDownKeyTriggered || mScreenshotChordVolumeUpKeyTriggered || gesturedServiceIntercepted;
    if (!mPowerKeyHandled) {
        if (interactive) {
            // Wait for a long press or for the button to be released to decide what to do.
            if (hasLongPressOnPowerBehavior()) {
                Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS);
                msg.setAsynchronous(true);
                mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
            }
        } else {
            wakeUpFromPowerKey(event.getDownTime());
            if (mSupportLongPressPowerWhenNonInteractive && hasLongPressOnPowerBehavior()) {
                Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS);
                msg.setAsynchronous(true);
                mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                mBeganFromNonInteractive = true;
            } else {
                final int maxCount = getMaxMultiPressPowerCount();
                if (maxCount <= 1) {
                    mPowerKeyHandled = true;
                } else {
                    mBeganFromNonInteractive = true;
                }
            }
        }
    }
}
#end_block

#method_before
private void cancelPendingPowerKeyAction() {
    if (!mPowerKeyHandled) {
        mPowerKeyHandled = true;
        mHandler.removeMessages(MSG_POWER_LONG_PRESS);
        if (mTorchLongPressPowerEnabled && !isScreenOn()) {
            if (mWasTorchActive) {
                mWasTorchActive = false;
            } else {
                wakeUpFromPowerKey(SystemClock.uptimeMillis());
            }
        }
    }
}
#method_after
private void cancelPendingPowerKeyAction() {
    if (!mPowerKeyHandled) {
        mPowerKeyHandled = true;
        mHandler.removeMessages(MSG_POWER_LONG_PRESS);
    }
}
#end_block

#method_before
private void powerLongPress() {
    if (!mTorchLongPressPowerEnabled || isScreenOn()) {
        final int behavior = getResolvedLongPressOnPowerBehavior();
        switch(behavior) {
            case LONG_PRESS_POWER_NOTHING:
                break;
            case LONG_PRESS_POWER_GLOBAL_ACTIONS:
                mPowerKeyHandled = true;
                if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) {
                    performAuditoryFeedbackForAccessibilityIfNeed();
                }
                showGlobalActionsInternal();
                break;
            case LONG_PRESS_POWER_SHUT_OFF:
            case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM:
                mPowerKeyHandled = true;
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);
                mWindowManagerFuncs.shutdown(behavior == LONG_PRESS_POWER_SHUT_OFF);
                break;
        }
    } else if (mTorchLongPressPowerEnabled && !isScreenOn()) {
        try {
            mCameraManager.setTorchMode(getCameraId(), true);
        } catch (Exception e) {
        }
        mWasTorchActive = false;
        mIsTorchActive = true;
        mPowerKeyHandled = true;
    }
}
#method_after
private void powerLongPress() {
    final int behavior = getResolvedLongPressOnPowerBehavior();
    switch(behavior) {
        case LONG_PRESS_POWER_NOTHING:
            break;
        case LONG_PRESS_POWER_GLOBAL_ACTIONS:
            mPowerKeyHandled = true;
            if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) {
                performAuditoryFeedbackForAccessibilityIfNeed();
            }
            showGlobalActionsInternal();
            break;
        case LONG_PRESS_POWER_SHUT_OFF:
        case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM:
            mPowerKeyHandled = true;
            performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);
            mWindowManagerFuncs.shutdown(behavior == LONG_PRESS_POWER_SHUT_OFF);
            break;
    }
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mCameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    mBackKillTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_backKillTimeout);
    updateKeyAssignments();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    String deviceKeyHandlerLib = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerLib);
    String deviceKeyHandlerClass = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerClass);
    if (!deviceKeyHandlerLib.isEmpty() && !deviceKeyHandlerClass.isEmpty()) {
        PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLib, getClass().getClassLoader());
        try {
            Class<?> klass = loader.loadClass(deviceKeyHandlerClass);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandler = (DeviceKeyHandler) constructor.newInstance(mContext);
            if (DEBUG)
                Slog.d(TAG, "Device key handler loaded");
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerClass + " from class " + deviceKeyHandlerLib, e);
        }
    }
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    mBackKillTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_backKillTimeout);
    updateKeyAssignments();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    String deviceKeyHandlerLib = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerLib);
    String deviceKeyHandlerClass = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerClass);
    if (!deviceKeyHandlerLib.isEmpty() && !deviceKeyHandlerClass.isEmpty()) {
        PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLib, getClass().getClassLoader());
        try {
            Class<?> klass = loader.loadClass(deviceKeyHandlerClass);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandler = (DeviceKeyHandler) constructor.newInstance(mContext);
            if (DEBUG)
                Slog.d(TAG, "Device key handler loaded");
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerClass + " from class " + deviceKeyHandlerLib, e);
        }
    }
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    int mDeviceHardwareWakeKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareWakeKeys);
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mHomeWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.HOME_WAKE_SCREEN, 1, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_HOME) != 0);
        mBackWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.BACK_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_BACK) != 0);
        mMenuWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.MENU_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_MENU) != 0);
        mAssistWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.ASSIST_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_ASSIST) != 0);
        mAppSwitchWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.APP_SWITCH_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_APP_SWITCH) != 0);
        mCameraWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_CAMERA) != 0);
        mCameraSleepOnRelease = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_SLEEP_ON_RELEASE, 0, UserHandle.USER_CURRENT) == 1);
        mCameraLaunch = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_LAUNCH, 0, UserHandle.USER_CURRENT) == 1);
        mVolumeWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.VOLUME_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_VOLUME) != 0);
        mVolBtnMusicControls = (CMSettings.System.getIntForUser(resolver, CMSettings.System.VOLBTN_MUSIC_CONTROLS, 1, UserHandle.USER_CURRENT) == 1);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        boolean devForceNavbar = CMSettings.Global.getIntForUser(resolver, CMSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT) == 1;
        if (devForceNavbar != mDevForceNavbar) {
            mDevForceNavbar = devForceNavbar;
            if (mCMHardware.isSupported(CMHardwareManager.FEATURE_KEY_DISABLE)) {
                mCMHardware.set(CMHardwareManager.FEATURE_KEY_DISABLE, mDevForceNavbar);
            }
        }
        mNavigationBarLeftInLandscape = CMSettings.System.getIntForUser(resolver, CMSettings.System.NAVBAR_LEFT_IN_LANDSCAPE, 0, UserHandle.USER_CURRENT) == 1;
        updateKeyAssignments();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = Settings.System.getInt(resolver, Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
        mTorchLongPressPowerEnabled = (CMSettings.System.getIntForUser(resolver, CMSettings.System.TORCH_LONG_PRESS_POWER_GESTURE, 0, UserHandle.USER_CURRENT) == 1);
        mVolumeAnswerCall = CMSettings.System.getIntForUser(resolver, CMSettings.Secure.VOLUME_ANSWER_CALL, 0, UserHandle.USER_CURRENT) == 1;
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        WindowManagerPolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    int mDeviceHardwareWakeKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareWakeKeys);
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mHomeWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.HOME_WAKE_SCREEN, 1, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_HOME) != 0);
        mBackWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.BACK_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_BACK) != 0);
        mMenuWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.MENU_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_MENU) != 0);
        mAssistWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.ASSIST_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_ASSIST) != 0);
        mAppSwitchWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.APP_SWITCH_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_APP_SWITCH) != 0);
        mCameraWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_CAMERA) != 0);
        mCameraSleepOnRelease = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_SLEEP_ON_RELEASE, 0, UserHandle.USER_CURRENT) == 1);
        mCameraLaunch = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_LAUNCH, 0, UserHandle.USER_CURRENT) == 1);
        mVolumeWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.VOLUME_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_VOLUME) != 0);
        mVolBtnMusicControls = (CMSettings.System.getIntForUser(resolver, CMSettings.System.VOLBTN_MUSIC_CONTROLS, 1, UserHandle.USER_CURRENT) == 1);
        mVolumeAnswerCall = CMSettings.System.getIntForUser(resolver, CMSettings.System.VOLUME_ANSWER_CALL, 0, UserHandle.USER_CURRENT) == 1;
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        boolean devForceNavbar = CMSettings.Global.getIntForUser(resolver, CMSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT) == 1;
        if (devForceNavbar != mDevForceNavbar) {
            mDevForceNavbar = devForceNavbar;
            if (mCMHardware.isSupported(CMHardwareManager.FEATURE_KEY_DISABLE)) {
                mCMHardware.set(CMHardwareManager.FEATURE_KEY_DISABLE, mDevForceNavbar);
            }
        }
        mNavigationBarLeftInLandscape = CMSettings.System.getIntForUser(resolver, CMSettings.System.NAVBAR_LEFT_IN_LANDSCAPE, 0, UserHandle.USER_CURRENT) == 1;
        updateKeyAssignments();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = Settings.System.getInt(resolver, Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        WindowManagerPolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final int scanCode = event.getScanCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive, unless the user has explicitly disabled this wake key.
        result = ACTION_PASS_TO_USER;
        isWakeKey = isWakeKey && isWakeKeyEnabled(keyCode);
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only should consume known keys.
            if (mDeviceKeyHandler.handleKeyEvent(event)) {
                return 0;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    mBackKeyHandled = false;
                    if (hasLongPressOnBackBehavior()) {
                        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    }
                } else {
                    boolean handled = mBackKeyHandled;
                    // Reset back key state
                    cancelPendingBackKeyAction();
                    // Don't pass back press to app if we've already handled it
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                // This disables volume control, music control, and "beep" on key up.
                if (isWakeKey && mVolumeWakeScreen) {
                    setVolumeWakeTriggered(keyCode, true);
                    break;
                } else if (getVolumeWakeTriggered(keyCode) && !down) {
                    result &= ~ACTION_PASS_TO_USER;
                    setVolumeWakeTriggered(keyCode, false);
                    break;
                }
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeUpKeyTriggered = true;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                        }
                    } else {
                        mScreenshotChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // The volume key answer
                            if (mVolumeAnswerCall) {
                                telecomManager.acceptRingingCall();
                            }
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                            // If we are in call but we decided not to pass the key to
                            // the application, just pass it to the session service.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                            break;
                        }
                    }
                }
                // Disable music and volume control when used as wake key
                if ((result & ACTION_PASS_TO_USER) == 0 && !mVolumeWakeScreen) {
                    boolean mayChangeVolume = false;
                    if (isMusicActive()) {
                        if (mVolBtnMusicControls && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                            // Detect long key presses.
                            if (down) {
                                mIsLongPress = false;
                                // TODO: Long press of MUTE could be mapped to KEYCODE_MEDIA_PLAY_PAUSE
                                int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                                scheduleLongPressKeyEvent(event, newKeyCode);
                                // Consume key down events of all presses.
                                break;
                            } else {
                                mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                                // Consume key up events of long presses only.
                                if (mIsLongPress) {
                                    break;
                                }
                                // Change volume only on key up events of short presses.
                                mayChangeVolume = true;
                            }
                        } else {
                            // Long key press detection not applicable, change volume only
                            // on key down events
                            mayChangeVolume = down;
                        }
                    }
                    if (mayChangeVolume) {
                        if (mUseTvRouting) {
                            dispatchDirectAudioEvent(event);
                        } else {
                            // If we aren't passing to the user and no one else
                            // handled it send it to the session manager to figure
                            // out.
                            // Rewrite the event to use key-down as sendVolumeKeyEvent will
                            // only change the volume on key down.
                            KeyEvent newEvent = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(newEvent, true);
                        }
                    }
                    break;
                }
                break;
            }
        case KeyEvent.KEYCODE_HOME:
            if (down && !interactive && mHomeWakeScreen) {
                isWakeKey = true;
            }
            break;
        case KeyEvent.KEYCODE_FOCUS:
            if (down && !interactive && mCameraSleepOnRelease) {
                mIsFocusPressed = true;
            } else if ((event.getAction() == KeyEvent.ACTION_UP) && mScreenOnFully && mIsFocusPressed) {
                // Check if screen is fully on before letting the device go to sleep
                mPowerManager.goToSleep(SystemClock.uptimeMillis());
                mIsFocusPressed = false;
            }
            break;
        case KeyEvent.KEYCODE_CAMERA:
            if (down && mIsFocusPressed) {
                mIsFocusPressed = false;
            }
            if (down) {
                mIsLongPress = false;
                scheduleLongPressKeyEvent(event, KeyEvent.KEYCODE_CAMERA);
                // Consume key down events of all presses.
                break;
            } else {
                mHandler.removeMessages(MSG_CAMERA_LONG_PRESS);
                // Consume key up events of long presses only.
                if (mIsLongPress && mCameraLaunch) {
                    Intent intent;
                    if (keyguardActive) {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE);
                    } else {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA);
                    }
                    isWakeKey = true;
                    startActivityAsUser(intent, UserHandle.CURRENT_OR_SELF);
                }
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                if ((mTopFullscreenOpaqueWindowState.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_POWER_KEY) != 0 && mScreenOnFully) {
                    return result;
                }
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final int scanCode = event.getScanCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive, unless the user has explicitly disabled this wake key.
        result = ACTION_PASS_TO_USER;
        isWakeKey = isWakeKey && isWakeKeyEnabled(keyCode);
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only should consume known keys.
            if (mDeviceKeyHandler.handleKeyEvent(event)) {
                return 0;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    mBackKeyHandled = false;
                    if (hasLongPressOnBackBehavior()) {
                        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    }
                } else {
                    boolean handled = mBackKeyHandled;
                    // Reset back key state
                    cancelPendingBackKeyAction();
                    // Don't pass back press to app if we've already handled it
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                // This disables volume control, music control, and "beep" on key up.
                if (isWakeKey && mVolumeWakeScreen) {
                    setVolumeWakeTriggered(keyCode, true);
                    break;
                } else if (getVolumeWakeTriggered(keyCode) && !down) {
                    result &= ~ACTION_PASS_TO_USER;
                    setVolumeWakeTriggered(keyCode, false);
                    break;
                }
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeUpKeyTriggered = true;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                        }
                    } else {
                        mScreenshotChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            if (mVolumeAnswerCall) {
                                telecomManager.acceptRingingCall();
                            }
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                            // If we are in call but we decided not to pass the key to
                            // the application, just pass it to the session service.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                            break;
                        }
                    }
                }
                // Disable music and volume control when used as wake key
                if ((result & ACTION_PASS_TO_USER) == 0 && !mVolumeWakeScreen) {
                    boolean mayChangeVolume = false;
                    if (isMusicActive()) {
                        if (mVolBtnMusicControls && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                            // Detect long key presses.
                            if (down) {
                                mIsLongPress = false;
                                // TODO: Long press of MUTE could be mapped to KEYCODE_MEDIA_PLAY_PAUSE
                                int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                                scheduleLongPressKeyEvent(event, newKeyCode);
                                // Consume key down events of all presses.
                                break;
                            } else {
                                mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                                // Consume key up events of long presses only.
                                if (mIsLongPress) {
                                    break;
                                }
                                // Change volume only on key up events of short presses.
                                mayChangeVolume = true;
                            }
                        } else {
                            // Long key press detection not applicable, change volume only
                            // on key down events
                            mayChangeVolume = down;
                        }
                    }
                    if (mayChangeVolume) {
                        if (mUseTvRouting) {
                            dispatchDirectAudioEvent(event);
                        } else {
                            // If we aren't passing to the user and no one else
                            // handled it send it to the session manager to figure
                            // out.
                            // Rewrite the event to use key-down as sendVolumeKeyEvent will
                            // only change the volume on key down.
                            KeyEvent newEvent = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(newEvent, true);
                        }
                    }
                    break;
                }
                break;
            }
        case KeyEvent.KEYCODE_HOME:
            if (down && !interactive && mHomeWakeScreen) {
                isWakeKey = true;
            }
            break;
        case KeyEvent.KEYCODE_FOCUS:
            if (down && !interactive && mCameraSleepOnRelease) {
                mIsFocusPressed = true;
            } else if ((event.getAction() == KeyEvent.ACTION_UP) && mScreenOnFully && mIsFocusPressed) {
                // Check if screen is fully on before letting the device go to sleep
                mPowerManager.goToSleep(SystemClock.uptimeMillis());
                mIsFocusPressed = false;
            }
            break;
        case KeyEvent.KEYCODE_CAMERA:
            if (down && mIsFocusPressed) {
                mIsFocusPressed = false;
            }
            if (down) {
                mIsLongPress = false;
                scheduleLongPressKeyEvent(event, KeyEvent.KEYCODE_CAMERA);
                // Consume key down events of all presses.
                break;
            } else {
                mHandler.removeMessages(MSG_CAMERA_LONG_PRESS);
                // Consume key up events of long presses only.
                if (mIsLongPress && mCameraLaunch) {
                    Intent intent;
                    if (keyguardActive) {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE);
                    } else {
                        intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA);
                    }
                    isWakeKey = true;
                    startActivityAsUser(intent, UserHandle.CURRENT_OR_SELF);
                }
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                if ((mTopFullscreenOpaqueWindowState.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_POWER_KEY) != 0 && mScreenOnFully) {
                    return result;
                }
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", // Check prox only on wake key
        event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#end_block

#method_before
public void dismissResources() {
    if (DEBUG) {
        Slog.d(TAG, "dismissResources");
    }
    if (mCreatedResources) {
        attachEglContext();
        try {
            destroyScreenshotTexture();
            destroyGLShaders();
            destroyGLBuffers();
            if (!sDestroySurfaceAfterDetach) {
                destroyEglSurface();
            }
        } finally {
            detachEglContext();
        }
        if (sDestroySurfaceAfterDetach) {
            destroyEglSurface();
        }
        // This is being called with no active context so shouldn't be
        // needed but is safer to not change for now.
        GLES20.glFlush();
        mCreatedResources = false;
    }
}
#method_after
public void dismissResources() {
    if (DEBUG) {
        Slog.d(TAG, "dismissResources");
    }
    if (mCreatedResources) {
        attachEglContext();
        try {
            destroyScreenshotTexture();
            destroyGLShaders();
            destroyGLBuffers();
            if (!DESTROY_SURFACE_AFTER_DETACH) {
                destroyEglSurface();
            }
        } finally {
            detachEglContext();
        }
        if (DESTROY_SURFACE_AFTER_DETACH) {
            destroyEglSurface();
        }
        // This is being called with no active context so shouldn't be
        // needed but is safer to not change for now.
        GLES20.glFlush();
        mCreatedResources = false;
    }
}
#end_block

#method_before
@Override
public void onStart() {
    Resources resources = getContext().getResources();
    mMaxPackageEnqueueRate = Settings.Global.getFloat(getContext().getContentResolver(), Settings.Global.MAX_NOTIFICATION_ENQUEUE_RATE, DEFAULT_MAX_NOTIFICATION_ENQUEUE_RATE);
    mAm = ActivityManagerNative.getDefault();
    mAppOps = (AppOpsManager) getContext().getSystemService(Context.APP_OPS_SERVICE);
    mVibrator = (Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
    mAppUsageStats = LocalServices.getService(UsageStatsManagerInternal.class);
    mKeyguardManager = (KeyguardManager) getContext().getSystemService(Context.KEYGUARD_SERVICE);
    // This is the package that contains the AOSP framework update.
    mRankerServicePackageName = getContext().getPackageManager().getServicesSystemSharedLibraryPackageName();
    mHandler = new WorkerHandler();
    mRankingThread.start();
    String[] extractorNames;
    try {
        extractorNames = resources.getStringArray(R.array.config_notificationSignalExtractors);
    } catch (Resources.NotFoundException e) {
        extractorNames = new String[0];
    }
    mUsageStats = new NotificationUsageStats(getContext());
    mRankingHandler = new RankingHandlerWorker(mRankingThread.getLooper());
    mRankingHelper = new RankingHelper(getContext(), mRankingHandler, mUsageStats, extractorNames);
    mConditionProviders = new ConditionProviders(getContext(), mHandler, mUserProfiles);
    mZenModeHelper = new ZenModeHelper(getContext(), mHandler.getLooper(), mConditionProviders);
    mZenModeHelper.addCallback(new ZenModeHelper.Callback() {

        @Override
        public void onConfigChanged() {
            savePolicyFile();
        }

        @Override
        void onZenModeChanged() {
            sendRegisteredOnlyBroadcast(NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED);
            getContext().sendBroadcastAsUser(new Intent(NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED_INTERNAL).addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT), UserHandle.ALL, android.Manifest.permission.MANAGE_NOTIFICATIONS);
            synchronized (mNotificationList) {
                updateInterruptionFilterLocked();
            }
        }

        @Override
        void onPolicyChanged() {
            sendRegisteredOnlyBroadcast(NotificationManager.ACTION_NOTIFICATION_POLICY_CHANGED);
        }
    });
    final File systemDir = new File(Environment.getDataDirectory(), "system");
    mPolicyFile = new AtomicFile(new File(systemDir, "notification_policy.xml"));
    syncBlockDb();
    // This is a MangedServices object that keeps track of the listeners.
    mListeners = new NotificationListeners();
    // This is a MangedServices object that keeps track of the ranker.
    mRankerServices = new NotificationRankers();
    // Find the updatable ranker and register it.
    mRankerServices.registerRanker();
    mStatusBar = getLocalService(StatusBarManagerInternal.class);
    if (mStatusBar != null) {
        mStatusBar.setNotificationDelegate(mNotificationDelegate);
    }
    final LightsManager lights = getLocalService(LightsManager.class);
    mNotificationLight = lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
    mAttentionLight = lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
    mDefaultNotificationColor = resources.getColor(R.color.config_defaultNotificationColor);
    mDefaultNotificationLedOn = resources.getInteger(R.integer.config_defaultNotificationLedOn);
    mDefaultNotificationLedOff = resources.getInteger(R.integer.config_defaultNotificationLedOff);
    mMultiColorNotificationLed = deviceLightsCan(NotificationManager.LIGHTS_RGB_NOTIFICATION);
    mNotificationPulseCustomLedValues = new ArrayMap<String, NotificationLedValues>();
    mPackageNameMappings = new ArrayMap<String, String>();
    final String[] defaultMapping = resources.getStringArray(com.android.internal.R.array.notification_light_package_mapping);
    for (String mapping : defaultMapping) {
        String[] map = mapping.split("\\|");
        mPackageNameMappings.put(map[0], map[1]);
    }
    mDefaultVibrationPattern = getLongArray(resources, R.array.config_defaultNotificationVibePattern, VIBRATE_PATTERN_MAXLEN, DEFAULT_VIBRATE_PATTERN);
    mFallbackVibrationPattern = getLongArray(resources, R.array.config_notificationFallbackVibePattern, VIBRATE_PATTERN_MAXLEN, DEFAULT_VIBRATE_PATTERN);
    mAdjustableNotificationLedBrightness = deviceLightsCan(NotificationManager.LIGHTS_ADJUSTABLE_NOTIFICATION_BRIGHTNESS);
    mMultipleNotificationLeds = deviceLightsCan(NotificationManager.LIGHTS_MULTIPLE_LED);
    mUseAttentionLight = resources.getBoolean(R.bool.config_useAttentionLight);
    // flag at least once and we'll go back to 0 after that.
    if (0 == Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0)) {
        mDisableNotificationEffects = true;
    }
    mZenModeHelper.initZenMode();
    mZenModeHelper.readAllowLightsFromSettings();
    mZenModeHelper.readVibrationModeFromSettings();
    mInterruptionFilter = mZenModeHelper.getZenModeListenerInterruptionFilter();
    mUserProfiles.updateCache(getContext());
    listenForCallState();
    // register for various Intents
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    filter.addAction(Intent.ACTION_USER_STOPPED);
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    filter.addAction(Intent.ACTION_USER_ADDED);
    filter.addAction(Intent.ACTION_USER_REMOVED);
    filter.addAction(Intent.ACTION_USER_UNLOCKED);
    filter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);
    getContext().registerReceiver(mIntentReceiver, filter);
    IntentFilter pkgFilter = new IntentFilter();
    pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
    pkgFilter.addDataScheme("package");
    getContext().registerReceiverAsUser(mPackageIntentReceiver, UserHandle.ALL, pkgFilter, null, null);
    IntentFilter suspendedPkgFilter = new IntentFilter();
    suspendedPkgFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);
    getContext().registerReceiverAsUser(mPackageIntentReceiver, UserHandle.ALL, suspendedPkgFilter, null, null);
    IntentFilter sdFilter = new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
    getContext().registerReceiverAsUser(mPackageIntentReceiver, UserHandle.ALL, sdFilter, null, null);
    mSettingsObserver = new LEDSettingsObserver(mHandler);
    mSettingsObserver.observe();
    mArchive = new Archive(resources.getInteger(R.integer.config_notificationServiceArchiveSize));
    publishBinderService(Context.NOTIFICATION_SERVICE, mService);
    publishLocalService(NotificationManagerInternal.class, mInternalService);
}
#method_after
@Override
public void onStart() {
    Resources resources = getContext().getResources();
    mMaxPackageEnqueueRate = Settings.Global.getFloat(getContext().getContentResolver(), Settings.Global.MAX_NOTIFICATION_ENQUEUE_RATE, DEFAULT_MAX_NOTIFICATION_ENQUEUE_RATE);
    mAm = ActivityManagerNative.getDefault();
    mAppOps = (AppOpsManager) getContext().getSystemService(Context.APP_OPS_SERVICE);
    mVibrator = (Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
    mAppUsageStats = LocalServices.getService(UsageStatsManagerInternal.class);
    mKeyguardManager = (KeyguardManager) getContext().getSystemService(Context.KEYGUARD_SERVICE);
    // This is the package that contains the AOSP framework update.
    mRankerServicePackageName = getContext().getPackageManager().getServicesSystemSharedLibraryPackageName();
    mHandler = new WorkerHandler();
    mRankingThread.start();
    String[] extractorNames;
    try {
        extractorNames = resources.getStringArray(R.array.config_notificationSignalExtractors);
    } catch (Resources.NotFoundException e) {
        extractorNames = new String[0];
    }
    mUsageStats = new NotificationUsageStats(getContext());
    mRankingHandler = new RankingHandlerWorker(mRankingThread.getLooper());
    mRankingHelper = new RankingHelper(getContext(), mRankingHandler, mUsageStats, extractorNames);
    mConditionProviders = new ConditionProviders(getContext(), mHandler, mUserProfiles);
    mZenModeHelper = new ZenModeHelper(getContext(), mHandler.getLooper(), mConditionProviders);
    mZenModeHelper.addCallback(new ZenModeHelper.Callback() {

        @Override
        public void onConfigChanged() {
            savePolicyFile();
        }

        @Override
        void onZenModeChanged() {
            sendRegisteredOnlyBroadcast(NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED);
            getContext().sendBroadcastAsUser(new Intent(NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED_INTERNAL).addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT), UserHandle.ALL, android.Manifest.permission.MANAGE_NOTIFICATIONS);
            synchronized (mNotificationList) {
                updateInterruptionFilterLocked();
            }
        }

        @Override
        void onPolicyChanged() {
            sendRegisteredOnlyBroadcast(NotificationManager.ACTION_NOTIFICATION_POLICY_CHANGED);
        }
    });
    final File systemDir = new File(Environment.getDataDirectory(), "system");
    mPolicyFile = new AtomicFile(new File(systemDir, "notification_policy.xml"));
    syncBlockDb();
    // This is a MangedServices object that keeps track of the listeners.
    mListeners = new NotificationListeners();
    // This is a MangedServices object that keeps track of the ranker.
    mRankerServices = new NotificationRankers();
    // Find the updatable ranker and register it.
    mRankerServices.registerRanker();
    mStatusBar = getLocalService(StatusBarManagerInternal.class);
    if (mStatusBar != null) {
        mStatusBar.setNotificationDelegate(mNotificationDelegate);
    }
    final LightsManager lights = getLocalService(LightsManager.class);
    mNotificationLight = lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
    mAttentionLight = lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
    mDefaultNotificationColor = resources.getColor(R.color.config_defaultNotificationColor);
    mDefaultNotificationLedOn = resources.getInteger(R.integer.config_defaultNotificationLedOn);
    mDefaultNotificationLedOff = resources.getInteger(R.integer.config_defaultNotificationLedOff);
    mMultiColorNotificationLed = doLightsSupport(NotificationManager.LIGHTS_RGB_NOTIFICATION_LED);
    mNotificationPulseCustomLedValues = new ArrayMap<String, NotificationLedValues>();
    mPackageNameMappings = new ArrayMap<String, String>();
    final String[] defaultMapping = resources.getStringArray(com.android.internal.R.array.notification_light_package_mapping);
    for (String mapping : defaultMapping) {
        String[] map = mapping.split("\\|");
        mPackageNameMappings.put(map[0], map[1]);
    }
    mDefaultVibrationPattern = getLongArray(resources, R.array.config_defaultNotificationVibePattern, VIBRATE_PATTERN_MAXLEN, DEFAULT_VIBRATE_PATTERN);
    mFallbackVibrationPattern = getLongArray(resources, R.array.config_notificationFallbackVibePattern, VIBRATE_PATTERN_MAXLEN, DEFAULT_VIBRATE_PATTERN);
    mAdjustableNotificationLedBrightness = doLightsSupport(NotificationManager.LIGHTS_ADJUSTABLE_NOTIFICATION_LED_BRIGHTNESS);
    mMultipleNotificationLeds = doLightsSupport(NotificationManager.LIGHTS_MULTIPLE_NOTIFICATION_LED);
    mUseAttentionLight = resources.getBoolean(R.bool.config_useAttentionLight);
    // flag at least once and we'll go back to 0 after that.
    if (0 == Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0)) {
        mDisableNotificationEffects = true;
    }
    mZenModeHelper.initZenMode();
    mZenModeHelper.readAllowLightsFromSettings();
    mZenModeHelper.readVibrationModeFromSettings();
    mInterruptionFilter = mZenModeHelper.getZenModeListenerInterruptionFilter();
    mUserProfiles.updateCache(getContext());
    listenForCallState();
    // register for various Intents
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    filter.addAction(Intent.ACTION_USER_STOPPED);
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    filter.addAction(Intent.ACTION_USER_ADDED);
    filter.addAction(Intent.ACTION_USER_REMOVED);
    filter.addAction(Intent.ACTION_USER_UNLOCKED);
    filter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);
    getContext().registerReceiver(mIntentReceiver, filter);
    IntentFilter pkgFilter = new IntentFilter();
    pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
    pkgFilter.addDataScheme("package");
    getContext().registerReceiverAsUser(mPackageIntentReceiver, UserHandle.ALL, pkgFilter, null, null);
    IntentFilter suspendedPkgFilter = new IntentFilter();
    suspendedPkgFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);
    getContext().registerReceiverAsUser(mPackageIntentReceiver, UserHandle.ALL, suspendedPkgFilter, null, null);
    IntentFilter sdFilter = new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
    getContext().registerReceiverAsUser(mPackageIntentReceiver, UserHandle.ALL, sdFilter, null, null);
    mSettingsObserver = new LEDSettingsObserver(mHandler);
    mSettingsObserver.observe();
    mArchive = new Archive(resources.getInteger(R.integer.config_notificationServiceArchiveSize));
    publishBinderService(Context.NOTIFICATION_SERVICE, mService);
    publishLocalService(NotificationManagerInternal.class, mInternalService);
}
#end_block

#method_before
public static boolean isEnabled() {
    return (Long.decode(FileUtils.readOneLine(CONTROL_PATH)) & 0x200) == 0x200;
}
#method_after
public static boolean isEnabled() {
    boolean enabled = false;
    String state = FileUtils.readOneLine(CONTROL_PATH);
    if (state != null)
        enabled = (Long.decode(state) & 0x200) == 0x200;
    return enabled;
}
#end_block

#method_before
@Override
protected Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt() & 0xff;
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        voiceSettings = p.readInt();
        dc.isVoice = (0 == voiceSettings) ? false : true;
        // boolean isVideo = (0 != p.readInt());   // Samsung CallDetails
        // Samsung CallDetails
        int call_type = p.readInt();
        // Samsung CallDetails
        int call_domain = p.readInt();
        // Samsung CallDetails
        String csv = p.readString();
        dc.isVoicePrivacy = (0 != p.readInt());
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        dc.namePresentation = p.readInt();
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#method_after
@Override
protected Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt() & 0xff;
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        voiceSettings = p.readInt();
        dc.isVoice = (0 != voiceSettings);
        // boolean isVideo = (0 != p.readInt());   // Samsung CallDetails
        // Samsung CallDetails
        int call_type = p.readInt();
        // Samsung CallDetails
        int call_domain = p.readInt();
        // Samsung CallDetails
        String csv = p.readString();
        dc.isVoicePrivacy = (0 != p.readInt());
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        dc.namePresentation = p.readInt();
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#end_block

#method_before
private boolean shouldPulse(long timestamp) {
    long delta = timestamp - mInPocketTime;
    if (mHandwaveGestureEnabled && mPocketGestureEnabled) {
        return true;
    } else if (mProximityWakeEnabled && (delta < POCKET_DELTA_NS) && timestamp < System.nanoTime()) {
        mPowerManager.wakeUp(TimeUnit.NANOSECONDS.toMillis(timestamp));
        return false;
    } else if (mHandwaveGestureEnabled && !mPocketGestureEnabled) {
        return delta < POCKET_DELTA_NS;
    } else if (!mHandwaveGestureEnabled && mPocketGestureEnabled) {
        return delta >= POCKET_DELTA_NS;
    }
    return false;
}
#method_after
private boolean shouldPulse(long timestamp) {
    // Never pulse if the timestamp is from the future
    if (timestamp > System.nanoTime()) {
        return false;
    }
    long delta = timestamp - mInPocketTime;
    if (mHandwaveGestureEnabled && mPocketGestureEnabled) {
        return true;
    } else if (mProximityWakeEnabled && (delta < POCKET_DELTA_NS)) {
        mPowerManager.wakeUp(TimeUnit.NANOSECONDS.toMillis(timestamp));
        return false;
    } else if (mHandwaveGestureEnabled && !mPocketGestureEnabled) {
        return delta < POCKET_DELTA_NS;
    } else if (!mHandwaveGestureEnabled && mPocketGestureEnabled) {
        return delta >= POCKET_DELTA_NS;
    }
    return false;
}
#end_block

#method_before
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    if (samsungEmergency && PhoneNumberUtils.isEmergencyNumber(address)) {
        dialEmergencyCall(address, clirMode, result);
        return;
    }
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    // CallDetails.call_type
    rr.mParcel.writeInt(0);
    // CallDetails.call_domain
    rr.mParcel.writeInt(1);
    // CallDetails.getCsvFromExtras
    rr.mParcel.writeString("");
    if (uusInfo == null) {
        // UUS information is absent
        rr.mParcel.writeInt(0);
    } else {
        // UUS information is present
        rr.mParcel.writeInt(1);
        rr.mParcel.writeInt(uusInfo.getType());
        rr.mParcel.writeInt(uusInfo.getDcs());
        rr.mParcel.writeByteArray(uusInfo.getUserData());
    }
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    if (PhoneNumberUtils.isEmergencyNumber(address)) {
        dialEmergencyCall(address, clirMode, result);
        return;
    }
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    // CallDetails.call_type
    rr.mParcel.writeInt(0);
    // CallDetails.call_domain
    rr.mParcel.writeInt(1);
    // CallDetails.getCsvFromExtras
    rr.mParcel.writeString("");
    if (uusInfo == null) {
        // UUS information is absent
        rr.mParcel.writeInt(0);
    } else {
        // UUS information is present
        rr.mParcel.writeInt(1);
        rr.mParcel.writeInt(uusInfo.getType());
        rr.mParcel.writeInt(uusInfo.getDcs());
        rr.mParcel.writeByteArray(uusInfo.getUserData());
    }
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#end_block

#method_before
@Override
protected Object responseIccCardStatus(Parcel p) {
    IccCardApplicationStatus appStatus;
    IccCardStatus cardStatus = new IccCardStatus();
    cardStatus.setCardState(p.readInt());
    cardStatus.setUniversalPinState(p.readInt());
    cardStatus.mGsmUmtsSubscriptionAppIndex = p.readInt();
    cardStatus.mCdmaSubscriptionAppIndex = p.readInt();
    cardStatus.mImsSubscriptionAppIndex = p.readInt();
    int numApplications = p.readInt();
    // limit to maximum allowed applications
    if (numApplications > IccCardStatus.CARD_MAX_APPS) {
        numApplications = IccCardStatus.CARD_MAX_APPS;
    }
    cardStatus.mApplications = new IccCardApplicationStatus[numApplications];
    appStatus = new IccCardApplicationStatus();
    for (int i = 0; i < numApplications; i++) {
        if (i != 0) {
            appStatus = new IccCardApplicationStatus();
        }
        appStatus.app_type = appStatus.AppTypeFromRILInt(p.readInt());
        appStatus.app_state = appStatus.AppStateFromRILInt(p.readInt());
        appStatus.perso_substate = appStatus.PersoSubstateFromRILInt(p.readInt());
        appStatus.aid = p.readString();
        appStatus.app_label = p.readString();
        appStatus.pin1_replaced = p.readInt();
        appStatus.pin1 = appStatus.PinStateFromRILInt(p.readInt());
        appStatus.pin2 = appStatus.PinStateFromRILInt(p.readInt());
        // pin1_num_retries
        p.readInt();
        // puk1_num_retries
        p.readInt();
        // pin2_num_retries
        p.readInt();
        // puk2_num_retries
        p.readInt();
        // perso_unblock_retries
        p.readInt();
        cardStatus.mApplications[i] = appStatus;
    }
    if (numApplications == 1 && !isGSM && appStatus.app_type == appStatus.AppTypeFromRILInt(2)) {
        cardStatus.mApplications = new IccCardApplicationStatus[numApplications + 2];
        cardStatus.mGsmUmtsSubscriptionAppIndex = 0;
        cardStatus.mApplications[cardStatus.mGsmUmtsSubscriptionAppIndex] = appStatus;
        cardStatus.mCdmaSubscriptionAppIndex = 1;
        cardStatus.mImsSubscriptionAppIndex = 2;
        IccCardApplicationStatus appStatus2 = new IccCardApplicationStatus();
        // csim state
        appStatus2.app_type = appStatus2.AppTypeFromRILInt(4);
        appStatus2.app_state = appStatus.app_state;
        appStatus2.perso_substate = appStatus.perso_substate;
        appStatus2.aid = appStatus.aid;
        appStatus2.app_label = appStatus.app_label;
        appStatus2.pin1_replaced = appStatus.pin1_replaced;
        appStatus2.pin1 = appStatus.pin1;
        appStatus2.pin2 = appStatus.pin2;
        cardStatus.mApplications[cardStatus.mCdmaSubscriptionAppIndex] = appStatus2;
        IccCardApplicationStatus appStatus3 = new IccCardApplicationStatus();
        // ims state
        appStatus3.app_type = appStatus3.AppTypeFromRILInt(5);
        appStatus3.app_state = appStatus.app_state;
        appStatus3.perso_substate = appStatus.perso_substate;
        appStatus3.aid = appStatus.aid;
        appStatus3.app_label = appStatus.app_label;
        appStatus3.pin1_replaced = appStatus.pin1_replaced;
        appStatus3.pin1 = appStatus.pin1;
        appStatus3.pin2 = appStatus.pin2;
        cardStatus.mApplications[cardStatus.mImsSubscriptionAppIndex] = appStatus3;
    }
    return cardStatus;
}
#method_after
@Override
protected Object responseIccCardStatus(Parcel p) {
    IccCardApplicationStatus appStatus;
    IccCardStatus cardStatus = new IccCardStatus();
    cardStatus.setCardState(p.readInt());
    cardStatus.setUniversalPinState(p.readInt());
    cardStatus.mGsmUmtsSubscriptionAppIndex = p.readInt();
    cardStatus.mCdmaSubscriptionAppIndex = p.readInt();
    cardStatus.mImsSubscriptionAppIndex = p.readInt();
    int numApplications = p.readInt();
    // limit to maximum allowed applications
    if (numApplications > IccCardStatus.CARD_MAX_APPS) {
        numApplications = IccCardStatus.CARD_MAX_APPS;
    }
    cardStatus.mApplications = new IccCardApplicationStatus[numApplications];
    for (int i = 0; i < numApplications; i++) {
        appStatus = new IccCardApplicationStatus();
        appStatus.app_type = appStatus.AppTypeFromRILInt(p.readInt());
        appStatus.app_state = appStatus.AppStateFromRILInt(p.readInt());
        appStatus.perso_substate = appStatus.PersoSubstateFromRILInt(p.readInt());
        appStatus.aid = p.readString();
        appStatus.app_label = p.readString();
        appStatus.pin1_replaced = p.readInt();
        appStatus.pin1 = appStatus.PinStateFromRILInt(p.readInt());
        appStatus.pin2 = appStatus.PinStateFromRILInt(p.readInt());
        // pin1_num_retries
        p.readInt();
        // puk1_num_retries
        p.readInt();
        // pin2_num_retries
        p.readInt();
        // puk2_num_retries
        p.readInt();
        // perso_unblock_retries
        p.readInt();
        cardStatus.mApplications[i] = appStatus;
    }
    return cardStatus;
}
#end_block

#method_before
protected Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt() & 0xff;
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        voiceSettings = p.readInt();
        if (isGSM) {
            p.readInt();
        }
        dc.isVoice = (0 == voiceSettings) ? false : true;
        dc.isVoicePrivacy = (0 != p.readInt());
        if (isGSM) {
            p.readInt();
            p.readInt();
            p.readString();
        }
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        dc.namePresentation = p.readInt();
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#method_after
@Override
protected Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt() & 0xff;
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        voiceSettings = p.readInt();
        dc.isVoice = (0 != voiceSettings);
        // Samsung CallDetails
        boolean isVideo = (0 != p.readInt());
        // Samsung CallDetails
        int call_type = p.readInt();
        // Samsung CallDetails
        int call_domain = p.readInt();
        // Samsung CallDetails
        String csv = p.readString();
        dc.isVoicePrivacy = (0 != p.readInt());
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        dc.namePresentation = p.readInt();
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#end_block

#method_before
@Override
protected Object responseSignalStrength(Parcel p) {
    int numInts = 13;
    int[] response;
    // Get raw data
    response = new int[numInts];
    for (int i = 0; i < numInts; i++) {
        response[i] = p.readInt();
    }
    // gsm
    response[0] &= 0xff;
    // cdma
    response[2] %= 256;
    response[4] %= 256;
    response[7] &= 0xff;
    return new SignalStrength(response[0], response[1], response[2], response[3], response[4], response[5], response[6], response[7], response[8], response[9], response[10], response[11], (response[12] != 0));
}
#method_after
@Override
protected Object responseSignalStrength(Parcel p) {
    int gsmSignalStrength = p.readInt() & 0xff;
    int gsmBitErrorRate = p.readInt();
    int cdmaDbm = p.readInt();
    int cdmaEcio = p.readInt();
    int evdoDbm = p.readInt();
    int evdoEcio = p.readInt();
    int evdoSnr = p.readInt();
    int lteSignalStrength = p.readInt();
    int lteRsrp = p.readInt();
    int lteRsrq = p.readInt();
    int lteRssnr = p.readInt();
    int lteCqi = p.readInt();
    int tdScdmaRscp = p.readInt();
    // constructor sets default true, makeSignalStrengthFromRilParcel does not set it
    boolean isGsm = true;
    if ((lteSignalStrength & 0xff) == 255 || lteSignalStrength == 99) {
        lteSignalStrength = 99;
        lteRsrp = SignalStrength.INVALID;
        lteRsrq = SignalStrength.INVALID;
        lteRssnr = SignalStrength.INVALID;
        lteCqi = SignalStrength.INVALID;
    } else {
        lteSignalStrength &= 0xff;
    }
    if (RILJ_LOGD)
        riljLog("gsmSignalStrength:" + gsmSignalStrength + " gsmBitErrorRate:" + gsmBitErrorRate + " cdmaDbm:" + cdmaDbm + " cdmaEcio:" + cdmaEcio + " evdoDbm:" + evdoDbm + " evdoEcio: " + evdoEcio + " evdoSnr:" + evdoSnr + " lteSignalStrength:" + lteSignalStrength + " lteRsrp:" + lteRsrp + " lteRsrq:" + lteRsrq + " lteRssnr:" + lteRssnr + " lteCqi:" + lteCqi + " tdScdmaRscp:" + tdScdmaRscp + " isGsm:" + (isGsm ? "true" : "false"));
    return new SignalStrength(gsmSignalStrength, gsmBitErrorRate, cdmaDbm, cdmaEcio, evdoDbm, evdoEcio, evdoSnr, lteSignalStrength, lteRsrp, lteRsrq, lteRssnr, lteCqi, tdScdmaRscp, isGsm);
}
#end_block

#method_before
public void dialEmergencyCall(String address, int clirMode, Message result) {
    RILRequest rr;
    rr = RILRequest.obtain(RIL_REQUEST_DIAL_EMERGENCY, result);
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    // CallDetails.call_type
    rr.mParcel.writeInt(0);
    // CallDetails.call_domain
    rr.mParcel.writeInt(3);
    // CallDetails.getCsvFromExtra
    rr.mParcel.writeString("");
    // Unknown
    rr.mParcel.writeInt(0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
private void dialEmergencyCall(String address, int clirMode, Message result) {
    RILRequest rr;
    rr = RILRequest.obtain(RIL_REQUEST_DIAL_EMERGENCY, result);
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    // CallDetails.call_type
    rr.mParcel.writeInt(0);
    // CallDetails.call_domain
    rr.mParcel.writeInt(3);
    // CallDetails.getCsvFromExtra
    rr.mParcel.writeString("");
    // Unknown
    rr.mParcel.writeInt(0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#end_block

#method_before
@Override
protected Object responseIccCardStatus(Parcel p) {
    IccCardApplicationStatus appStatus;
    IccCardStatus cardStatus = new IccCardStatus();
    cardStatus.setCardState(p.readInt());
    cardStatus.setUniversalPinState(p.readInt());
    cardStatus.mGsmUmtsSubscriptionAppIndex = p.readInt();
    cardStatus.mCdmaSubscriptionAppIndex = p.readInt();
    cardStatus.mImsSubscriptionAppIndex = p.readInt();
    int numApplications = p.readInt();
    // limit to maximum allowed applications
    if (numApplications > IccCardStatus.CARD_MAX_APPS) {
        numApplications = IccCardStatus.CARD_MAX_APPS;
    }
    cardStatus.mApplications = new IccCardApplicationStatus[numApplications];
    appStatus = new IccCardApplicationStatus();
    for (int i = 0; i < numApplications; i++) {
        if (i != 0) {
            appStatus = new IccCardApplicationStatus();
        }
        appStatus.app_type = appStatus.AppTypeFromRILInt(p.readInt());
        appStatus.app_state = appStatus.AppStateFromRILInt(p.readInt());
        appStatus.perso_substate = appStatus.PersoSubstateFromRILInt(p.readInt());
        appStatus.aid = p.readString();
        appStatus.app_label = p.readString();
        appStatus.pin1_replaced = p.readInt();
        appStatus.pin1 = appStatus.PinStateFromRILInt(p.readInt());
        appStatus.pin2 = appStatus.PinStateFromRILInt(p.readInt());
        // pin1_num_retries
        p.readInt();
        // puk1_num_retries
        p.readInt();
        // pin2_num_retries
        p.readInt();
        // puk2_num_retries
        p.readInt();
        // perso_unblock_retries
        p.readInt();
        cardStatus.mApplications[i] = appStatus;
    }
    // for sprint gsm(lte) only sim
    if (numApplications == 1 && !mIsGsm && appStatus.app_type == appStatus.AppTypeFromRILInt(2)) {
        cardStatus.mApplications = new IccCardApplicationStatus[numApplications + 2];
        cardStatus.mGsmUmtsSubscriptionAppIndex = 0;
        cardStatus.mApplications[cardStatus.mGsmUmtsSubscriptionAppIndex] = appStatus;
        cardStatus.mCdmaSubscriptionAppIndex = 1;
        cardStatus.mImsSubscriptionAppIndex = 2;
        IccCardApplicationStatus appStatus2 = new IccCardApplicationStatus();
        // csim state
        appStatus2.app_type = appStatus2.AppTypeFromRILInt(4);
        appStatus2.app_state = appStatus.app_state;
        appStatus2.perso_substate = appStatus.perso_substate;
        appStatus2.aid = appStatus.aid;
        appStatus2.app_label = appStatus.app_label;
        appStatus2.pin1_replaced = appStatus.pin1_replaced;
        appStatus2.pin1 = appStatus.pin1;
        appStatus2.pin2 = appStatus.pin2;
        cardStatus.mApplications[cardStatus.mCdmaSubscriptionAppIndex] = appStatus2;
        IccCardApplicationStatus appStatus3 = new IccCardApplicationStatus();
        // ims state
        appStatus3.app_type = appStatus3.AppTypeFromRILInt(5);
        appStatus3.app_state = appStatus.app_state;
        appStatus3.perso_substate = appStatus.perso_substate;
        appStatus3.aid = appStatus.aid;
        appStatus3.app_label = appStatus.app_label;
        appStatus3.pin1_replaced = appStatus.pin1_replaced;
        appStatus3.pin1 = appStatus.pin1;
        appStatus3.pin2 = appStatus.pin2;
        cardStatus.mApplications[cardStatus.mImsSubscriptionAppIndex] = appStatus3;
    }
    return cardStatus;
}
#method_after
@Override
protected Object responseIccCardStatus(Parcel p) {
    IccCardApplicationStatus appStatus = null;
    IccCardStatus cardStatus = new IccCardStatus();
    cardStatus.setCardState(p.readInt());
    cardStatus.setUniversalPinState(p.readInt());
    cardStatus.mGsmUmtsSubscriptionAppIndex = p.readInt();
    cardStatus.mCdmaSubscriptionAppIndex = p.readInt();
    cardStatus.mImsSubscriptionAppIndex = p.readInt();
    int numApplications = p.readInt();
    // limit to maximum allowed applications
    if (numApplications > IccCardStatus.CARD_MAX_APPS) {
        numApplications = IccCardStatus.CARD_MAX_APPS;
    }
    cardStatus.mApplications = new IccCardApplicationStatus[numApplications];
    for (int i = 0; i < numApplications; i++) {
        appStatus = new IccCardApplicationStatus();
        appStatus.app_type = appStatus.AppTypeFromRILInt(p.readInt());
        appStatus.app_state = appStatus.AppStateFromRILInt(p.readInt());
        appStatus.perso_substate = appStatus.PersoSubstateFromRILInt(p.readInt());
        appStatus.aid = p.readString();
        appStatus.app_label = p.readString();
        appStatus.pin1_replaced = p.readInt();
        appStatus.pin1 = appStatus.PinStateFromRILInt(p.readInt());
        appStatus.pin2 = appStatus.PinStateFromRILInt(p.readInt());
        // pin1_num_retries
        p.readInt();
        // puk1_num_retries
        p.readInt();
        // pin2_num_retries
        p.readInt();
        // puk2_num_retries
        p.readInt();
        // perso_unblock_retries
        p.readInt();
        cardStatus.mApplications[i] = appStatus;
    }
    // For Sprint LTE only SIM
    if (appStatus != null && numApplications == 1 && !mIsGsm && appStatus.app_type == appStatus.AppTypeFromRILInt(2)) {
        cardStatus.mApplications = new IccCardApplicationStatus[3];
        cardStatus.mApplications[0] = appStatus;
        cardStatus.mGsmUmtsSubscriptionAppIndex = 0;
        cardStatus.mCdmaSubscriptionAppIndex = 1;
        cardStatus.mImsSubscriptionAppIndex = 2;
        IccCardApplicationStatus appStatus2 = new IccCardApplicationStatus();
        // csim state
        appStatus2.app_type = appStatus2.AppTypeFromRILInt(4);
        appStatus2.app_state = appStatus.app_state;
        appStatus2.perso_substate = appStatus.perso_substate;
        appStatus2.aid = appStatus.aid;
        appStatus2.app_label = appStatus.app_label;
        appStatus2.pin1_replaced = appStatus.pin1_replaced;
        appStatus2.pin1 = appStatus.pin1;
        appStatus2.pin2 = appStatus.pin2;
        cardStatus.mApplications[cardStatus.mCdmaSubscriptionAppIndex] = appStatus2;
        IccCardApplicationStatus appStatus3 = new IccCardApplicationStatus();
        // ims state
        appStatus3.app_type = appStatus3.AppTypeFromRILInt(5);
        appStatus3.app_state = appStatus.app_state;
        appStatus3.perso_substate = appStatus.perso_substate;
        appStatus3.aid = appStatus.aid;
        appStatus3.app_label = appStatus.app_label;
        appStatus3.pin1_replaced = appStatus.pin1_replaced;
        appStatus3.pin1 = appStatus.pin1;
        appStatus3.pin2 = appStatus.pin2;
        cardStatus.mApplications[cardStatus.mImsSubscriptionAppIndex] = appStatus3;
    }
    return cardStatus;
}
#end_block

#method_before
@Override
protected Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    boolean isLLril = false;
    isLLril = Integer.valueOf(SystemProperties.get(SIM_NUMBER_PROP, "1")).intValue() == 2;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt() & 0xff;
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        voiceSettings = p.readInt();
        dc.isVoice = (0 != voiceSettings);
        if (mIsGsm) {
            boolean isVideo;
            if (!isLLril)
                // Samsung CallDetails
                isVideo = (0 != p.readInt());
            // Samsung CallDetails
            int call_type = p.readInt();
            // Samsung CallDetails
            int call_domain = p.readInt();
            // Samsung CallDetails
            String csv = p.readString();
        }
        dc.isVoicePrivacy = (0 != p.readInt());
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        if (!isLLril)
            dc.namePresentation = p.readInt();
        else
            dc.namePresentation = DriverCall.presentationFromCLIP(p.readInt());
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#method_after
@Override
protected Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt() & 0xff;
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        voiceSettings = p.readInt();
        dc.isVoice = (0 != voiceSettings);
        if (mIsGsm) {
            boolean isVideo;
            if (!isLollipopRadio)
                // Samsung CallDetails
                isVideo = (0 != p.readInt());
            // Samsung CallDetails
            int call_type = p.readInt();
            // Samsung CallDetails
            int call_domain = p.readInt();
            // Samsung CallDetails
            String csv = p.readString();
        }
        dc.isVoicePrivacy = (0 != p.readInt());
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        if (!isLollipopRadio) {
            dc.namePresentation = p.readInt();
        } else {
            dc.namePresentation = DriverCall.presentationFromCLIP(p.readInt());
        }
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#end_block

#method_before
@Override
protected void processUnsolicited(Parcel p) {
    Object ret;
    int dataPosition = p.dataPosition();
    int response = p.readInt();
    int newResponse = response;
    boolean isLLril = false;
    isLLril = Integer.valueOf(SystemProperties.get(SIM_NUMBER_PROP, "1")).intValue() == 2;
    if (isLLril) {
        switch(response) {
            case RIL_UNSOL_ON_SS_LL:
                newResponse = RIL_UNSOL_ON_SS;
                break;
        }
        if (newResponse != response) {
            p.setDataPosition(dataPosition);
            p.writeInt(newResponse);
        }
    }
    p.setDataPosition(dataPosition);
    super.processUnsolicited(p);
}
#method_after
@Override
protected void processUnsolicited(Parcel p) {
    Object ret;
    int dataPosition = p.dataPosition();
    int response = p.readInt();
    int newResponse = response;
    if (isLollipopRadio) {
        switch(response) {
            case RIL_UNSOL_ON_SS_LL:
                newResponse = RIL_UNSOL_ON_SS;
                break;
        }
        if (newResponse != response) {
            p.setDataPosition(dataPosition);
            p.writeInt(newResponse);
        }
    }
    p.setDataPosition(dataPosition);
    super.processUnsolicited(p);
}
#end_block

#method_before
private void dialEmergencyCall(String address, int clirMode, Message result) {
    RILRequest rr;
    boolean isLLril = false;
    isLLril = Integer.valueOf(SystemProperties.get(SIM_NUMBER_PROP, "1")).intValue() == 2;
    if (isLLril)
        rr = RILRequest.obtain(RIL_REQUEST_DIAL_EMERGENCY_LL, result);
    else
        rr = RILRequest.obtain(RIL_REQUEST_DIAL_EMERGENCY, result);
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    // CallDetails.call_type
    rr.mParcel.writeInt(0);
    // CallDetails.call_domain
    rr.mParcel.writeInt(3);
    // CallDetails.getCsvFromExtra
    rr.mParcel.writeString("");
    // Unknown
    rr.mParcel.writeInt(0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
private void dialEmergencyCall(String address, int clirMode, Message result) {
    RILRequest rr;
    if (isLollipopRadio) {
        rr = RILRequest.obtain(RIL_REQUEST_DIAL_EMERGENCY_LL, result);
    } else {
        rr = RILRequest.obtain(RIL_REQUEST_DIAL_EMERGENCY, result);
    }
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    // CallDetails.call_type
    rr.mParcel.writeInt(0);
    // CallDetails.call_domain
    rr.mParcel.writeInt(3);
    // CallDetails.getCsvFromExtra
    rr.mParcel.writeString("");
    // Unknown
    rr.mParcel.writeInt(0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#end_block

#method_before
@Override
public void onCreate() {
    super.onCreate();
    VLog.v("onCreate");
    try {
        mServerSocket = new LocalServerSocket(SOCKET_NAME);
        mServerSocket_cb = new LocalServerSocket(SOCKET_NAME_CB);
    } catch (IOException e) {
        VLog.v("in onCreate, making server socket: " + e);
        return;
    }
    Thread t_server = new Thread() {

        @Override
        public void run() {
            LocalSocket socket = null;
            while (true) {
                try {
                    VLog.v("Waiting for connection...");
                    socket = mServerSocket.accept();
                    VLog.v(".....Got socket: " + socket);
                    if (socket != null) {
                        startService(socket);
                    } else {
                        return;
                    }
                } catch (IOException e) {
                    VLog.v("in accept: " + e);
                }
            }
        }
    };
    Thread t_server_cb = new Thread() {

        @Override
        public void run() {
            while (true) {
                try {
                    VLog.v("Waiting for connection...");
                    socket_cb = mServerSocket_cb.accept();
                    VLog.v(".....Got socket: " + socket_cb);
                    if (socket_cb == null) {
                        return;
                    }
                } catch (IOException e) {
                    VLog.v("in accept: " + e);
                }
            }
        }
    };
    t_server.start();
    t_server_cb.start();
    ScreenReceiver receiver = new ScreenReceiver();
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(receiver, filter);
}
#method_after
@Override
public void onCreate() {
    super.onCreate();
    VLog.v("onCreate");
    try {
        mServerSocket = new LocalServerSocket(SOCKET_NAME);
        mServerSocketCB = new LocalServerSocket(SOCKET_NAME_CB);
    } catch (IOException e) {
        VLog.v("in onCreate, making server socket: " + e);
        return;
    }
    Thread t_server = new Thread() {

        @Override
        public void run() {
            LocalSocket socket = null;
            while (true) {
                try {
                    VLog.v("Waiting for connection...");
                    socket = mServerSocket.accept();
                    VLog.v(".....Got socket: " + socket);
                    if (socket != null) {
                        startService(socket);
                    } else {
                        return;
                    }
                } catch (IOException e) {
                    VLog.v("in accept: " + e);
                }
            }
        }
    };
    Thread t_server_cb = new Thread() {

        @Override
        public void run() {
            while (true) {
                try {
                    VLog.v("Waiting for connection...");
                    mSocketCB = mServerSocketCB.accept();
                    VLog.v(".....Got socket: " + mSocketCB);
                    if (mSocketCB == null) {
                        return;
                    }
                } catch (IOException e) {
                    VLog.v("in accept: " + e);
                }
            }
        }
    };
    t_server.start();
    t_server_cb.start();
    ScreenReceiver receiver = new ScreenReceiver();
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(receiver, filter);
}
#end_block

#method_before
private void startService(final LocalSocket socket) {
    Thread t = new Thread() {

        @Override
        public void run() {
            try {
                InputStream is = socket.getInputStream();
                OutputStream os = socket.getOutputStream();
                InputStreamReader isr = new InputStreamReader(is);
                OutputStreamWriter osr = new OutputStreamWriter(os);
                while (true) {
                    byte[] data = new byte[128];
                    int count = is.read(data);
                    int ret = -1;
                    String userId;
                    int fingerIndex;
                    for (int i = 0; i < count; i++) {
                        VLog.d("data[" + i + "]=" + data[i]);
                    }
                    switch(data[0]) {
                        case CALL_initService:
                            ret = initService();
                            break;
                        case CALL_enroll:
                            userId = "User_" + data[1];
                            fingerIndex = data[2];
                            last_enroll_fingerindex = fingerIndex;
                            enroll_bad = false;
                            enroll_repeat_count = 8;
                            fp.verifyPassword(userId, pwdhash);
                            ret = fp.enroll(userId, "", fingerIndex, Fingerprint.VCS_ENROLL_MODE_DEFAULT);
                            break;
                        case CALL_cancel:
                            ret = fp.cancel();
                            break;
                        case CALL_remove:
                            userId = "User_" + data[1];
                            fingerIndex = data[2];
                            ret = fp.removeEnrolledFinger(userId, fingerIndex);
                            if (fingerIndex == VcsEvents.FINGER_INDEX_ALL) {
                                notify_end();
                                notify_start();
                            }
                            break;
                        case CALL_identify:
                            userId = "User_" + data[1];
                            status = "identify";
                            fp.setSecurityLevel(VcsEvents.VCS_SECURITY_LEVEL_HIGH);
                            idresult = null;
                            active_gid = data[1];
                            ret = fp.identify(userId);
                            break;
                        case CALL_getEnrolledFingerList:
                            userId = "User_" + data[1];
                            VcsInt fingermask = new VcsInt();
                            fp.getEnrolledFingerList(userId, fingermask);
                            ret = fingermask.num;
                            break;
                        case CALL_cleanup:
                            notify_end();
                            ret = fp.cleanUp();
                            break;
                        default:
                            VLog.e("unknown function:" + data[0]);
                    }
                    String str = ret + "";
                    osr.write(str);
                    osr.flush();
                }
            } catch (IOException e) {
                VLog.v("in startService loop: " + e.getMessage());
            }
        }
    };
    t.start();
}
#method_after
private void startService(final LocalSocket socket) {
    Thread t = new Thread() {

        @Override
        public void run() {
            try {
                InputStream is = socket.getInputStream();
                OutputStream os = socket.getOutputStream();
                InputStreamReader isr = new InputStreamReader(is);
                OutputStreamWriter osr = new OutputStreamWriter(os);
                while (true) {
                    byte[] data = new byte[128];
                    int count = is.read(data);
                    int ret = -1;
                    String userId;
                    int fingerIndex;
                    for (int i = 0; i < count; i++) {
                        VLog.d("data[" + i + "]=" + data[i]);
                    }
                    switch(data[0]) {
                        case CALL_INITSERVICE:
                            ret = initService();
                            break;
                        case CALL_ENROLL:
                            userId = "User_" + data[1];
                            fingerIndex = data[2];
                            mLastEnrollFingerindex = fingerIndex;
                            mEnrollBad = false;
                            mEnrollRepeatCount = 8;
                            fp.verifyPassword(userId, pwdhash);
                            ret = fp.enroll(userId, "", fingerIndex, Fingerprint.VCS_ENROLL_MODE_DEFAULT);
                            break;
                        case CALL_CANCEL:
                            ret = fp.cancel();
                            break;
                        case CALL_REMOVE:
                            userId = "User_" + data[1];
                            fingerIndex = data[2];
                            ret = fp.removeEnrolledFinger(userId, fingerIndex);
                            if (fingerIndex == VcsEvents.FINGER_INDEX_ALL) {
                                notify_end();
                                notify_start();
                            }
                            break;
                        case CALL_IDENTIFY:
                            userId = "User_" + data[1];
                            mIsIdentify = true;
                            fp.setSecurityLevel(VcsEvents.VCS_SECURITY_LEVEL_HIGH);
                            mIdresult = null;
                            mActiveGid = data[1];
                            ret = fp.identify(userId);
                            break;
                        case CALL_GET_ENROLLED_FINGER_LIST:
                            userId = "User_" + data[1];
                            VcsInt fingermask = new VcsInt();
                            fp.getEnrolledFingerList(userId, fingermask);
                            ret = fingermask.num;
                            break;
                        case CALL_CLEANUP:
                            notify_end();
                            ret = fp.cleanUp();
                            break;
                        default:
                            VLog.e("unknown function:" + data[0]);
                    }
                    String str = ret + "";
                    osr.write(str);
                    osr.flush();
                }
            } catch (IOException e) {
                VLog.e("in startService loop: " + e.getMessage());
                try {
                    socket.close();
                } catch (IOException es) {
                    VLog.e("Cannot close socket: " + es.getMessage());
                }
                return;
            }
        }
    };
    t.start();
}
#end_block

#method_before
public int getIdentifyFid() {
    if (idresult == null)
        return 1;
    return idresult.fingerIndex;
}
#method_after
public int getIdentifyFid() {
    if (mIdresult == null)
        return 1;
    return mIdresult.fingerIndex;
}
#end_block

#method_before
public void onEvent(final FingerprintEvent event) {
    VLog.v("identify onEvent: receive event :" + event.eventId);
    try {
        OutputStream os = socket_cb.getOutputStream();
        OutputStreamWriter osr = new OutputStreamWriter(os);
        String str = "";
        switch(event.eventId) {
            case VcsEvents.VCS_EVT_EIV_FINGERPRINT_CAPTURE_REDUNDANT:
                str = CB_acquired + ":" + 1;
                enroll_bad = true;
                break;
            case VcsEvents.VCS_EVT_ENROLL_CAPTURE_STATUS:
                EnrollCaptureStatus data_status = (EnrollCaptureStatus) event.eventData;
                if (enroll_bad)
                    enroll_bad = false;
                else
                    enroll_repeat_count = enroll_repeat_count - 1;
                if (enroll_repeat_count != 0) {
                    str = CB_enroll + ":" + last_enroll_fingerindex + ":" + enroll_repeat_count;
                }
                break;
            case VcsEvents.VCS_EVT_EIV_FINGERPRINT_CAPTURED_BAD:
                str = CB_acquired + ":" + convertImageQuality((int) event.eventData);
                enroll_bad = true;
                break;
            case VcsEvents.VCS_EVT_ENROLL_SUCCESS:
                str = CB_enroll + ":" + last_enroll_fingerindex + ":" + 0;
                fp.setPassword("User_0", pwdhash);
                break;
            case VcsEvents.VCS_EVT_ENROLL_FAILED:
                // FINGERPRINT_ERROR_UNABLE_TO_PROCESS
                str = CB_error + ":" + 2;
                VLog.e("enroll onEvent: enroll error, result=" + (int) event.eventData);
                break;
            case VcsEvents.VCS_EVT_VERIFY_COMPLETED:
            case VcsEvents.VCS_EVT_IDENTIFY_COMPLETED:
                idresult = (IdentifyResult) event.eventData;
                break;
            case VcsEvents.VCS_EVT_EIV_FINGERPRINT_CAPTURED:
                FingerprintBitmap data_map = (FingerprintBitmap) event.eventData;
                str = CB_acquired + ":" + convertImageQuality(data_map.quality);
                break;
            case VcsEvents.VCS_EVT_VERIFY_SUCCESS:
            case VcsEvents.VCS_EVT_IDENTIFY_SUCCESS:
                status = "";
                str = CB_authenticated + ":" + getIdentifyFid();
                break;
            case VcsEvents.VCS_EVT_SENSOR_REMOVED:
                status = "";
                // FINGERPRINT_ERROR_HW_UNAVAILABLE
                str = CB_error + ":" + 1;
                VLog.e("identify onEvent: identify error, result=" + (int) event.eventData);
                break;
            case VcsEvents.VCS_EVT_VERIFY_FAILED:
            case VcsEvents.VCS_EVT_IDENTIFY_FAILED:
                status = "";
                VLog.e("identify onEvent: identify error, result=" + (int) event.eventData);
                switch((int) event.eventData) {
                    case VcsEvents.VCS_RESULT_BAD_QUALITY_IMAGE:
                    case VcsEvents.VCS_RESULT_USER_DOESNT_EXIST:
                        fp.setSecurityLevel(VcsEvents.VCS_SECURITY_LEVEL_HIGH);
                        idresult = null;
                        status = "identify";
                        fp.identify("User_" + active_gid);
                        break;
                    case VcsEvents.VCS_RESULT_OPERATION_CANCELED:
                        break;
                    default:
                        // FINGERPRINT_ERROR_UNABLE_TO_PROCESS
                        str = CB_error + ":" + 2;
                }
                break;
            default:
                VLog.v("identify onEvent: No need to process event :" + event.eventId);
        }
        if (str.equals("") == false) {
            osr.write(str);
            osr.flush();
        }
    } catch (IOException e) {
        VLog.d("in onEvent: " + e.getMessage());
    }
}
#method_after
public void onEvent(final FingerprintEvent event) {
    VLog.v("identify onEvent: receive event :" + event.eventId);
    OutputStreamWriter osr = null;
    try {
        OutputStream os = mSocketCB.getOutputStream();
        osr = new OutputStreamWriter(os);
        String str = null;
        switch(event.eventId) {
            case VcsEvents.VCS_EVT_EIV_FINGERPRINT_CAPTURE_REDUNDANT:
                str = CB_ACQUIRED + ":" + 1;
                mEnrollBad = true;
                break;
            case VcsEvents.VCS_EVT_ENROLL_CAPTURE_STATUS:
                EnrollCaptureStatus data_status = (EnrollCaptureStatus) event.eventData;
                if (mEnrollBad)
                    mEnrollBad = false;
                else
                    mEnrollRepeatCount = mEnrollRepeatCount - 1;
                if (mEnrollRepeatCount != 0) {
                    str = CB_ENROLL + ":" + mLastEnrollFingerindex + ":" + mEnrollRepeatCount;
                }
                break;
            case VcsEvents.VCS_EVT_EIV_FINGERPRINT_CAPTURED_BAD:
                str = CB_ACQUIRED + ":" + convertImageQuality((int) event.eventData);
                mEnrollBad = true;
                break;
            case VcsEvents.VCS_EVT_ENROLL_SUCCESS:
                str = CB_ENROLL + ":" + mLastEnrollFingerindex + ":" + 0;
                fp.setPassword("User_0", pwdhash);
                break;
            case VcsEvents.VCS_EVT_ENROLL_FAILED:
                // FINGERPRINT_ERROR_UNABLE_TO_PROCESS
                str = CB_ERROR + ":" + 2;
                VLog.e("enroll onEvent: enroll error, result=" + (int) event.eventData);
                break;
            case VcsEvents.VCS_EVT_VERIFY_COMPLETED:
            case VcsEvents.VCS_EVT_IDENTIFY_COMPLETED:
                mIdresult = (IdentifyResult) event.eventData;
                break;
            case VcsEvents.VCS_EVT_EIV_FINGERPRINT_CAPTURED:
                FingerprintBitmap data_map = (FingerprintBitmap) event.eventData;
                mIdentifyImage = convertImageQuality(data_map.quality);
                break;
            case VcsEvents.VCS_EVT_VERIFY_SUCCESS:
            case VcsEvents.VCS_EVT_IDENTIFY_SUCCESS:
                mIsIdentify = false;
                str = CB_AUTHENTICATED + ":" + getIdentifyFid();
                break;
            case VcsEvents.VCS_EVT_SENSOR_REMOVED:
                mIsIdentify = false;
                // FINGERPRINT_ERROR_HW_UNAVAILABLE
                str = CB_ERROR + ":" + 1;
                VLog.e("identify onEvent: identify error, result=" + (int) event.eventData);
                break;
            case VcsEvents.VCS_EVT_VERIFY_FAILED:
            case VcsEvents.VCS_EVT_IDENTIFY_FAILED:
                mIsIdentify = false;
                VLog.e("identify onEvent: identify error, result=" + (int) event.eventData);
                switch((int) event.eventData) {
                    case VcsEvents.VCS_RESULT_BAD_QUALITY_IMAGE:
                        str = CB_ACQUIRED + ":" + mIdentifyImage;
                    case VcsEvents.VCS_RESULT_USER_DOESNT_EXIST:
                        fp.setSecurityLevel(VcsEvents.VCS_SECURITY_LEVEL_HIGH);
                        mIdresult = null;
                        mIsIdentify = true;
                        fp.identify("User_" + mActiveGid);
                        if (str == null) {
                            // FINGERPRINT_ACQUIRED_PARTIAL
                            str = CB_ACQUIRED + ":" + 1;
                        }
                        break;
                    case VcsEvents.VCS_RESULT_OPERATION_CANCELED:
                        break;
                    default:
                        // FINGERPRINT_ERROR_UNABLE_TO_PROCESS
                        str = CB_ERROR + ":" + 2;
                }
                break;
            default:
                VLog.v("identify onEvent: No need to process event :" + event.eventId);
        }
        if (str != null) {
            osr.write(str);
            osr.flush();
        }
    } catch (IOException e) {
        VLog.e("in onEvent: " + e.getMessage());
        try {
            osr.close();
            mSocketCB.close();
        } catch (IOException es) {
            VLog.e("Cannot close socket: " + es.getMessage());
        }
        return;
    }
}
#end_block

#method_before
public void onScreenOn() {
    if (isneedIdentify) {
        isneedIdentify = false;
        fp.setSecurityLevel(VcsEvents.VCS_SECURITY_LEVEL_HIGH);
        idresult = null;
        status = "identify";
        fp.identify("User_" + active_gid);
    }
}
#method_after
public void onScreenOn() {
    if (mIsNeedIdentify) {
        mIsNeedIdentify = false;
        fp.setSecurityLevel(VcsEvents.VCS_SECURITY_LEVEL_HIGH);
        mIdresult = null;
        mIsIdentify = true;
        fp.identify("User_" + mActiveGid);
    }
}
#end_block

#method_before
public void onScreenOff() {
    if (status.equals("identify"))
        isneedIdentify = true;
}
#method_after
public void onScreenOff() {
    if (mIsIdentify) {
        mIsNeedIdentify = true;
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    if (intent.getAction().equals(Intent.ACTION_SCREEN_ON))
        onScreenOn();
    else if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF))
        onScreenOff();
    else
        VLog.e("Unknown intent:" + intent.getAction());
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
        onScreenOn();
    } else if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
        onScreenOff();
    } else
        VLog.e("Unknown intent:" + intent.getAction());
}
#end_block

