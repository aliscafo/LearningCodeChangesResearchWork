160
#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ApproveCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(CreateProject.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "submit").to(SubmitCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ReviewCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(CreateProject.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "review").to(ReviewCommand.class);
}
#end_block

#method_before
private void applyRightFloor(final PatchSetApproval a) {
    final IdentifiedUser user = userFactory.create(a.getAccountId());
    RefControl rc = controlFor(user);
    // Find the maximal range actually granted to the user.
    // 
    short minAllowed = 0, maxAllowed = 0;
    for (final RefRight r : rc.getAllRights(a.getCategoryId())) {
        final AccountGroup.Id grp = r.getAccountGroupId();
        if (user.getEffectiveGroups().contains(grp)) {
            minAllowed = (short) Math.min(minAllowed, r.getMinValue());
            maxAllowed = (short) Math.max(maxAllowed, r.getMaxValue());
        }
    }
    // 
    if (a.getValue() < minAllowed) {
        a.setValue(minAllowed);
    } else if (a.getValue() > maxAllowed) {
        a.setValue(maxAllowed);
    }
}
#method_after
private void applyRightFloor(final PatchSetApproval a) {
    final IdentifiedUser user = userFactory.create(a.getAccountId());
    RefControl rc = controlFor(user);
    // Find the maximal range actually granted to the user.
    // 
    short minAllowed = 0, maxAllowed = 0;
    for (final RefRight r : rc.getApplicableRights(a.getCategoryId())) {
        final AccountGroup.Id grp = r.getAccountGroupId();
        if (user.getEffectiveGroups().contains(grp)) {
            minAllowed = (short) Math.min(minAllowed, r.getMinValue());
            maxAllowed = (short) Math.max(maxAllowed, r.getMaxValue());
        }
    }
    // 
    if (a.getValue() < minAllowed) {
        a.setValue(minAllowed);
    } else if (a.getValue() > maxAllowed) {
        a.setValue(maxAllowed);
    }
}
#end_block

#method_before
private void initRights(final Panel body) {
    final FlowPanel addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            rights.deleteChecked();
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#method_after
private void initRights(final Panel body) {
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            final HashSet<RefRight.Key> refRightIds = rights.getRefRightIdsChecked();
            doDeleteRefRights(refRightIds);
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#end_block

#method_before
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
}
#method_after
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
    addPanel.setVisible(result.canModifyAccess);
    delRight.setVisible(rights.getCanDelete());
}
#end_block

#method_before
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    idx = rangeMaxBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
    if (max == null) {
        return;
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    if (at.getCategory().isRange()) {
        idx = rangeMaxBox.getSelectedIndex();
        if (idx < 0) {
            return;
        }
        max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
        if (max == null) {
            return;
        }
    } else {
        // If its not a range, the maximum box was disabled.  Use the min
        // value as the max, and select the min from the category values.
        // 
        max = min;
        min = at.getMin();
        for (ApprovalCategoryValue v : at.getValues()) {
            if (0 <= v.getValue() && v.getValue() <= max.getValue()) {
                min = v;
                break;
            }
        }
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#method_after
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    rangeMaxBox.setVisible(at.getCategory().isRange());
    addRight.setEnabled(true);
}
#end_block

#method_before
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<InheritedRefRight> refRights) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final InheritedRefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r);
    }
}
#method_after
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<InheritedRefRight> refRights) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final InheritedRefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r);
    }
}
#end_block

#method_before
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, right.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 4, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        formatValue(m, right.getMinValue(), min);
        if (right.getMinValue() != right.getMaxValue()) {
            m.br();
            formatValue(m, right.getMaxValue(), max);
        }
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#method_after
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited() || !r.isOwner()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, right.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 4, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        if (ar != null && ar.getCategory().isRange()) {
            formatValue(m, right.getMinValue(), min);
            m.br();
        }
        formatValue(m, right.getMaxValue(), max);
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (refPattern.startsWith("-")) {
        if (!refPattern.startsWith("-" + Constants.R_REFS)) {
            refPattern = "-" + Constants.R_HEADS + refPattern;
        }
    } else if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    checkPatternFormat(refPattern);
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    boolean exclusive = refPattern.startsWith("-");
    if (exclusive) {
        refPattern = refPattern.substring(1);
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (exclusive) {
        refPattern = "-" + refPattern;
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public boolean isVisible() {
    return canPerform(READ, (short) 1);
}
#method_after
public boolean isVisible() {
    return getProjectControl().visibleForReplication() || canPerform(READ, (short) 1);
}
#end_block

#method_before
public int allowedValueForRef(Set<AccountGroup.Id> groups) {
    int val = Integer.MIN_VALUE;
    for (RefRight right : rights) {
        if (groups.contains(right.getAccountGroupId())) {
            if ((val < 0 && right.getMaxValue() > 0)) {
                // If one of the user's groups had denied them access, but
                // this group grants them access, prefer the grant over
                // the denial. We have to break the tie somehow and we
                // prefer being "more open" to being "more closed".
                // 
                val = right.getMaxValue();
            } else {
                // Otherwise we use the largest value we can get.
                // 
                val = Math.max(right.getMaxValue(), val);
            }
        }
    }
    return val;
}
#method_after
public int allowedValueForRef(Set<AccountGroup.Id> groups) {
    int val = Integer.MIN_VALUE;
    for (RefRight right : rights) {
        if (groups.contains(right.getAccountGroupId())) {
            val = Math.max(right.getMaxValue(), val);
        }
    }
    return val;
}
#end_block

#method_before
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (String pattern : perPatternRights.keySet()) {
        val = Math.max(val, perPatternRights.get(pattern).allowedValueForRef(groups));
        if (val >= level || perPatternRights.get(pattern).containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#method_after
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (RefRightsForPattern right : perPatternRights.values()) {
        val = Math.max(val, right.allowedValueForRef(groups));
        if (val >= level || right.containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#end_block

#method_before
public static SortedMap<String, RefRightsForPattern> sortedRightsByPattern(List<RefRight> actionRights) {
    SortedMap<String, RefRightsForPattern> rights = new TreeMap<String, RefRightsForPattern>(DESCENDING_SORT);
    for (RefRight right : actionRights) {
        if (rights.containsKey(right.getRefPattern())) {
            rights.get(right.getRefPattern()).addRight(right);
        } else {
            RefRightsForPattern patternRights = new RefRightsForPattern();
            patternRights.addRight(right);
            rights.put(right.getRefPattern(), patternRights);
        }
    }
    return rights;
}
#method_after
private static SortedMap<String, RefRightsForPattern> sortedRightsByPattern(List<RefRight> actionRights) {
    SortedMap<String, RefRightsForPattern> rights = new TreeMap<String, RefRightsForPattern>(DESCENDING_SORT);
    for (RefRight actionRight : actionRights) {
        RefRightsForPattern patternRights = rights.get(actionRight.getRefPattern());
        if (patternRights == null) {
            patternRights = new RefRightsForPattern();
            rights.put(actionRight.getRefPattern(), patternRights);
        }
        patternRights.addRight(actionRight);
    }
    return rights;
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    event.change = getChangeAttribute(change);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--patchset");
    args.add(event.patchSet.number);
    runHook(getRepo(change), args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    event.change = getChangeAttribute(change);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--patchset");
    args.add(event.patchSet.number);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = getChangeAttribute(change);
    event.author = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = getChangeAttribute(change);
    event.author = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = getChangeAttribute(change);
    event.submitter = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    runHook(getRepo(change), args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = getChangeAttribute(change);
    event.submitter = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = getChangeAttribute(change);
    event.abandoner = getAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = getChangeAttribute(change);
    event.abandoner = getAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#end_block

#method_before
private void display() throws Failure {
    final PrintWriter stdout = toPrintWriter(out);
    TreeMap<String, TreeNode> treeMap = null;
    if (showTree) {
        treeMap = new TreeMap<String, TreeNode>();
    }
    try {
        for (final Project p : db.projects().all()) {
            if (p.getNameKey().equals(wildProject)) {
                // 
                continue;
            }
            final ProjectState e = projectCache.get(p.getNameKey());
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (!showTree) {
                if (!pctl.isVisible()) {
                    // 
                    continue;
                }
                if (showBranch != null) {
                    final Ref ref = getBranchRef(p.getNameKey());
                    if (ref == null || ref.getObjectId() == null || !pctl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                        // 
                        continue;
                    }
                    stdout.print(ref.getObjectId().name());
                    stdout.print(' ');
                }
                stdout.print(p.getName());
                stdout.println();
            } else {
                TreeNode node = new TreeNode(p, pctl.isVisible());
                treeMap.put(p.getName(), node);
            }
        }
        if (showTree && treeMap.size() > 0) {
            final List<TreeNode> sortedNodes = new ArrayList<TreeNode>();
            // 
            for (final TreeNode key : treeMap.values()) {
                final String parentName = key.getParentName();
                if (parentName != null) {
                    final TreeNode node = (TreeNode) treeMap.get((String) parentName);
                    node.addChild(key);
                } else {
                    sortedNodes.add(key);
                }
            }
            // Builds a fake root node, which contains the sorted projects.
            // 
            final TreeNode fakeRoot = new TreeNode(null, sortedNodes, false);
            printElement(stdout, fakeRoot, -1, false, sortedNodes.get(sortedNodes.size() - 1));
        }
    } catch (OrmException e) {
        throw new Failure(1, "fatal: database error", e);
    } finally {
        stdout.flush();
    }
}
#method_after
private void display() throws Failure {
    if (showTree && (showBranch != null)) {
        throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
    }
    final PrintWriter stdout = toPrintWriter(out);
    TreeMap<String, TreeNode> treeMap = null;
    if (showTree) {
        treeMap = new TreeMap<String, TreeNode>();
    }
    try {
        for (final Project p : db.projects().all()) {
            if (p.getNameKey().equals(wildProject)) {
                // 
                continue;
            }
            final ProjectState e = projectCache.get(p.getNameKey());
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (!showTree) {
                if (!pctl.isVisible()) {
                    // 
                    continue;
                }
                if (showBranch != null) {
                    final Ref ref = getBranchRef(p.getNameKey());
                    if (ref == null || ref.getObjectId() == null || !pctl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                        // 
                        continue;
                    }
                    stdout.print(ref.getObjectId().name());
                    stdout.print(' ');
                }
                stdout.print(p.getName() + "\n");
            } else {
                treeMap.put(p.getName(), new TreeNode(p, pctl.isVisible()));
            }
        }
        if (showTree && treeMap.size() > 0) {
            final List<TreeNode> sortedNodes = new ArrayList<TreeNode>();
            // 
            for (final TreeNode key : treeMap.values()) {
                final String parentName = key.getParentName();
                if (parentName != null) {
                    final TreeNode node = treeMap.get((String) parentName);
                    if (node != null) {
                        node.addChild(key);
                    } else {
                        sortedNodes.add(key);
                    }
                } else {
                    sortedNodes.add(key);
                }
            }
            // Builds a fake root node, which contains the sorted projects.
            // 
            final TreeNode fakeRoot = new TreeNode(null, sortedNodes, false);
            printElement(stdout, fakeRoot, -1, false, sortedNodes.get(sortedNodes.size() - 1));
            stdout.flush();
        }
    } catch (OrmException e) {
        throw new Failure(1, "fatal: database error", e);
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private void printElement(final PrintWriter stdout, TreeNode node, int level, boolean isLast, final TreeNode lastParentNode) {
    // 
    if (node.getProject() != null) {
        // 
        if (!currentTabSeparator.equals(" ")) {
            final String nodeProject = node.getProject().getName();
            final String lastParentProject = lastParentNode.getProject().getName();
            if (nodeProject.equals(lastParentProject)) {
                currentTabSeparator = " ";
            }
        }
        if (level > 0) {
            stdout.print(String.format("%-" + 4 * level + "s", currentTabSeparator));
        }
        final String prefix = isLast ? LAST_NODE_PREFIX : NODE_PREFIX;
        String printout;
        if (node.isVisible()) {
            printout = prefix + node.getProject().getName();
        } else {
            printout = prefix + NOT_VISIBLE_PROJECT;
        }
        stdout.println(printout);
        stdout.flush();
    }
    if (node.isLeaf()) {
        return;
    } else {
        final List<TreeNode> children = node.getChildren();
        ++level;
        for (TreeNode treeNode : children) {
            final boolean isLastIndex = children.indexOf(treeNode) == children.size() - 1;
            printElement(stdout, treeNode, level, isLastIndex, lastParentNode);
        }
    }
}
#method_after
private void printElement(final PrintWriter stdout, TreeNode node, int level, boolean isLast, final TreeNode lastParentNode) {
    // 
    if (node.getProject() != null) {
        // 
        if (!currentTabSeparator.equals(" ")) {
            final String nodeProject = node.getProject().getName();
            final String lastParentProject = lastParentNode.getProject().getName();
            if (nodeProject.equals(lastParentProject)) {
                currentTabSeparator = " ";
            }
        }
        if (level > 0) {
            stdout.print(String.format("%-" + 4 * level + "s", currentTabSeparator));
        }
        final String prefix = isLast ? LAST_NODE_PREFIX : NODE_PREFIX;
        String printout;
        if (node.isVisible()) {
            printout = prefix + node.getProject().getName();
        } else {
            printout = prefix + NOT_VISIBLE_PROJECT;
        }
        stdout.print(printout + "\n");
    }
    if (node.isLeaf()) {
        return;
    } else {
        final List<TreeNode> children = node.getChildren();
        ++level;
        for (TreeNode treeNode : children) {
            final boolean isLastIndex = children.indexOf(treeNode) == children.size() - 1;
            printElement(stdout, treeNode, level, isLastIndex, lastParentNode);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.listBranches(projectName, new GerritCallback<List<Branch>>() {

        public void onSuccess(final List<Branch> result) {
            Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

                public void onSuccess(final ProjectDetail projectDetail) {
                    com.google.gerrit.client.account.Util.ACCOUNT_SEC.myGroups(new GerritCallback<List<AccountGroup>>() {

                        public void onSuccess(List<AccountGroup> myGroups) {
                            boolean userHasOwnRight = Util.hasOwnRight(projectDetail, myGroups);
                            enableForm(true);
                            branches.display(result, userHasOwnRight);
                            addPanel.setVisible(userHasOwnRight);
                            delBranch.setVisible(userHasOwnRight);
                        }
                    });
                }
            });
        }
    });
}
#method_after
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.listBranches(projectName, new GerritCallback<ListBranchesResult>() {

        public void onSuccess(final ListBranchesResult result) {
            enableForm(true);
            display(result.getBranches());
            addPanel.setVisible(result.getCanAdd());
        }
    });
}
#end_block

#method_before
private void doAddNewBranch() {
    String branchName = nameTxtBox.getText();
    if ("".equals(branchName) || Util.C.defaultBranchName().equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    String rev = irevTxtBox.getText();
    if ("".equals(rev) || Util.C.defaultRevisionSpec().equals(rev)) {
        irevTxtBox.setText("HEAD");
        DeferredCommand.addCommand(new Command() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    if (!branchName.startsWith(Branch.R_REFS)) {
        branchName = Branch.R_HEADS + branchName;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(projectName, branchName, rev, new GerritCallback<List<Branch>>() {

        public void onSuccess(final List<Branch> result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            branches.display(result, true);
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (caught instanceof InvalidNameException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidNameException.MESSAGE)) {
                nameTxtBox.selectAll();
                nameTxtBox.setFocus(true);
            } else if (caught instanceof InvalidRevisionException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidRevisionException.MESSAGE)) {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
            addBranch.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewBranch() {
    String branchName = nameTxtBox.getText();
    if ("".equals(branchName) || Util.C.defaultBranchName().equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    String rev = irevTxtBox.getText();
    if ("".equals(rev) || Util.C.defaultRevisionSpec().equals(rev)) {
        irevTxtBox.setText("HEAD");
        DeferredCommand.addCommand(new Command() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    if (!branchName.startsWith(Branch.R_REFS)) {
        branchName = Branch.R_HEADS + branchName;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(projectName, branchName, rev, new GerritCallback<ListBranchesResult>() {

        public void onSuccess(final ListBranchesResult result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            display(result.getBranches());
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (caught instanceof InvalidNameException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidNameException.MESSAGE)) {
                nameTxtBox.selectAll();
                nameTxtBox.setFocus(true);
            } else if (caught instanceof InvalidRevisionException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidRevisionException.MESSAGE)) {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
            addBranch.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
void display(final List<Branch> result, final boolean canEdit) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final Branch k : result) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, k, canEdit);
    }
}
#method_after
void display(final List<Branch> result) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final Branch k : result) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, k);
    }
}
#end_block

#method_before
void populate(final int row, final Branch k, final boolean canEdit) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (canEdit) {
        table.setWidget(row, 1, new CheckBox());
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    if (c != null) {
        fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    }
    setRowItem(row, k);
}
#method_after
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    if (c != null) {
        fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    }
    setRowItem(row, k);
}
#end_block

#method_before
@Override
public void deleteRight(final Project.NameKey projectName, final Set<RefRight.Key> toRemove, final AsyncCallback<VoidResult> callback) {
    deleteRefRightsFactory.create(projectName, toRemove).to(callback);
}
#method_after
@Override
public void deleteRight(final Project.NameKey projectName, final Set<RefRight.Key> toRemove, final AsyncCallback<ProjectDetail> callback) {
    deleteRefRightsFactory.create(projectName, toRemove).to(callback);
}
#end_block

#method_before
@Override
public void listBranches(final Project.NameKey projectName, final AsyncCallback<List<Branch>> callback) {
    listBranchesFactory.create(projectName).to(callback);
}
#method_after
@Override
public void listBranches(final Project.NameKey projectName, final AsyncCallback<ListBranchesResult> callback) {
    listBranchesFactory.create(projectName).to(callback);
}
#end_block

#method_before
@Override
public void addBranch(final Project.NameKey projectName, final String branchName, final String startingRevision, final AsyncCallback<List<Branch>> callback) {
    addBranchFactory.create(projectName, branchName, startingRevision).to(callback);
}
#method_after
@Override
public void addBranch(final Project.NameKey projectName, final String branchName, final String startingRevision, final AsyncCallback<ListBranchesResult> callback) {
    addBranchFactory.create(projectName, branchName, startingRevision).to(callback);
}
#end_block

#method_before
@Override
protected void onLoad() {
    enableForm(false);
    saveProject.setEnabled(false);
    super.onLoad();
    refresh();
}
#method_after
@Override
protected void onLoad() {
    enableForm(false, false, false);
    saveProject.setEnabled(false);
    super.onLoad();
    refresh();
}
#end_block

#method_before
private void refresh() {
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            com.google.gerrit.client.account.Util.ACCOUNT_SEC.myGroups(new GerritCallback<List<AccountGroup>>() {

                public void onSuccess(List<AccountGroup> myGroups) {
                    boolean userHasOwnRight = Util.hasOwnRight(result, myGroups);
                    enableForm(userHasOwnRight);
                    saveProject.setVisible(userHasOwnRight);
                    saveProject.setEnabled(false);
                    display(result);
                }
            });
        }
    });
}
#method_after
private void refresh() {
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType);
            saveProject.setVisible(result.canModifyAgreements || result.canModifyDescription || result.canModifyMergeType);
            saveProject.setEnabled(false);
            display(result);
        }
    });
}
#end_block

#method_before
private void enableForm(final boolean on) {
    submitType.setEnabled(on);
    descTxt.setEnabled(on);
    useContributorAgreements.setEnabled(on);
    useSignedOffBy.setEnabled(on);
    saveProject.setEnabled(on);
}
#method_after
private void enableForm(final boolean canModifyAgreements, final boolean canModifyDescription, final boolean canModifyMergeType) {
    submitType.setEnabled(canModifyMergeType);
    descTxt.setEnabled(canModifyDescription);
    useContributorAgreements.setEnabled(canModifyAgreements);
    useSignedOffBy.setEnabled(canModifyAgreements);
    saveProject.setEnabled(canModifyAgreements || canModifyDescription || canModifyMergeType);
}
#end_block

#method_before
private void doSave() {
    project.setDescription(descTxt.getText().trim());
    project.setUseContributorAgreements(useContributorAgreements.getValue());
    project.setUseSignedOffBy(useSignedOffBy.getValue());
    if (submitType.getSelectedIndex() >= 0) {
        project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())));
    }
    enableForm(false);
    saveProject.setEnabled(false);
    Util.PROJECT_SVC.changeProjectSettings(project, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(true);
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            refresh();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    project.setDescription(descTxt.getText().trim());
    project.setUseContributorAgreements(useContributorAgreements.getValue());
    project.setUseSignedOffBy(useSignedOffBy.getValue());
    if (submitType.getSelectedIndex() >= 0) {
        project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())));
    }
    enableForm(false, false, false);
    saveProject.setEnabled(false);
    Util.PROJECT_SVC.changeProjectSettings(project, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType);
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            refresh();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            com.google.gerrit.client.account.Util.ACCOUNT_SEC.myGroups(new GerritCallback<List<AccountGroup>>() {

                public void onSuccess(List<AccountGroup> myGroups) {
                    boolean hasOwnRights = Util.hasOwnRight(result, myGroups);
                    enableForm(true);
                    display(result, !hasOwnRights);
                    addPanel.setVisible(hasOwnRights);
                    delRight.setVisible(hasOwnRights);
                }
            });
        }
    });
}
#method_after
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(true);
            display(result);
        }
    });
}
#end_block

#method_before
private void initRights(final Panel body) {
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            rights.deleteChecked();
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#method_after
private void initRights(final Panel body) {
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            final HashSet<RefRight.Key> refRightIds = rights.getRefRightIdsChecked();
            doDeleteRefRights(refRightIds);
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#end_block

#method_before
void display(final ProjectDetail result, final boolean readOnly) {
    rights.display(result.groups, result.rights, readOnly);
}
#method_after
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
    addPanel.setVisible(result.canModifyAccess);
    delRight.setVisible(rights.getCanDelete());
}
#end_block

#method_before
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    idx = rangeMaxBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
    if (max == null) {
        return;
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result, false);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    if (at.getCategory().isRange()) {
        idx = rangeMaxBox.getSelectedIndex();
        if (idx < 0) {
            return;
        }
        max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
        if (max == null) {
            return;
        }
    } else {
        // If its not a range, the maximum box was disabled.  Use the min
        // value as the max, and select the min from the category values.
        // 
        max = min;
        min = at.getMin();
        for (ApprovalCategoryValue v : at.getValues()) {
            if (0 <= v.getValue() && v.getValue() <= max.getValue()) {
                min = v;
                break;
            }
        }
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    // TODO Support per-branch READ access.
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        referenceTxt.setText("");
        referenceTxt.setEnabled(false);
    } else {
        referenceTxt.setEnabled(true);
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#method_after
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    rangeMaxBox.setVisible(at.getCategory().isRange());
    addRight.setEnabled(true);
}
#end_block

#method_before
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<RefRight> refRights, final boolean readOnly) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final RefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r, readOnly);
    }
}
#method_after
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<InheritedRefRight> refRights) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final InheritedRefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r);
    }
}
#end_block

#method_before
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final RefRight r, final boolean readOnly) {
    final GerritConfig config = Gerrit.getConfig();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(r.getApprovalCategoryId());
    final AccountGroup group = groups.get(r.getAccountGroupId());
    if (readOnly || (!projectName.equals(Gerrit.getConfig().getWildProject()) && Gerrit.getConfig().getWildProject().equals(r.getProjectNameKey()))) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, r.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(r.getAccountGroupId().get()));
    }
    table.setText(row, 4, r.getRefPattern());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(r.getMinValue()) : null;
        max = ar != null ? ar.getValue(r.getMaxValue()) : null;
        formatValue(m, r.getMinValue(), min);
        if (r.getMinValue() != r.getMaxValue()) {
            m.br();
            formatValue(m, r.getMaxValue(), max);
        }
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, r);
}
#method_after
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited() || !r.isOwner()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, right.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 4, right.getRefPattern());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        if (ar != null && ar.getCategory().isRange()) {
            formatValue(m, right.getMinValue(), min);
            m.br();
        }
        formatValue(m, right.getMaxValue(), max);
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#end_block

#method_before
@Override
public T atomicUpdate(final K key, final AtomicUpdate<T> update) throws OrmException {
    return schema.run(new OrmRunnable<T, JdbcSchema>() {

        @Override
        public T run(JdbcSchema db, boolean retry) throws OrmException {
            final T obj = get(key);
            if (obj == null) {
                return null;
            }
            final T res = update.update(obj);
            update(Collections.singleton(obj));
            return res;
        }
    });
}
#method_after
@Override
public T atomicUpdate(final K key, final AtomicUpdate<T> update) throws OrmException {
    for (int attempts = 1; ; attempts++) {
        try {
            final T obj = get(key);
            if (obj == null) {
                return null;
            }
            final T res = update.update(obj);
            update(Collections.singleton(obj));
            return res;
        } catch (OrmConcurrencyException err) {
            if (attempts < MAX_TRIES) {
                continue;
            }
            throw err;
        }
    }
}
#end_block

#method_before
public boolean isBatchUser() {
    return false;
}
#method_after
public boolean isBatchUser() {
    return getEffectiveGroups().contains(authConfig.getBatchUsersGroup());
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.addContinuationListener(task);
        cont.setAttribute(TASK, task);
        executor.submit(task);
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    WorkQueue.Executor executor = getExecutor();
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.addContinuationListener(task);
        cont.setAttribute(TASK, task);
        executor.submit(task);
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#end_block

#method_before
@Override
public void onTimeout(Continuation self) {
    executor.remove(this);
}
#method_after
@Override
public void onTimeout(Continuation self) {
    WorkQueue.Executor executor = getExecutor();
    executor.remove(this);
}
#end_block

#method_before
@Override
public WorkQueue.Executor get() {
    CurrentUser user = userProvider.get();
    WorkQueue.Executor executor = queues.getInteractiveQueue();
    if (user.isBatchUser()) {
        executor = queues.getBatchQueue();
    }
    return executor;
}
#method_after
@Override
public WorkQueue.Executor get() {
    WorkQueue.Executor executor;
    if (user.isBatchUser()) {
        executor = queues.getBatchQueue();
    } else {
        executor = queues.getInteractiveQueue();
    }
    return executor;
}
#end_block

#method_before
@Override
public WorkQueue.Executor getBatchQueue() {
    System.out.println("Job scheduled in batch Queue");
    return batchExecutor;
}
#method_after
@Override
public WorkQueue.Executor getBatchQueue() {
    return batchExecutor;
}
#end_block

#method_before
protected synchronized void startThread(final CommandRunnable thunk) {
    final TaskThunk tt = new TaskThunk(thunk);
    if (isAdminCommand() || userProvider.get().isAdministrator()) {
        // Admin commands should not block the main work threads (there
        // might be an interactive shell there), nor should they wait
        // for the main work threads.
        // 
        new Thread(tt, tt.toString()).start();
    } else {
        task = executor.submit(tt);
    }
}
#method_after
protected synchronized void startThread(final CommandRunnable thunk) {
    final TaskThunk tt = new TaskThunk(thunk);
    if (isAdminCommand() || (isAdminHighPriorityCommand() && userProvider.get().isAdministrator())) {
        // Admin commands should not block the main work threads (there
        // might be an interactive shell there), nor should they wait
        // for the main work threads.
        // 
        new Thread(tt, tt.toString()).start();
    } else {
        task = executor.submit(tt);
    }
}
#end_block

#method_before
private void display() {
    p = toPrintWriter(out);
    final List<Task<?>> pending = workQueue.getTasks();
    Collections.sort(pending, new Comparator<Task<?>>() {

        public int compare(Task<?> a, Task<?> b) {
            final Task.State aState = a.getState();
            final Task.State bState = b.getState();
            if (aState != bState) {
                return aState.ordinal() - bState.ordinal();
            }
            final long aDelay = a.getDelay(TimeUnit.MILLISECONDS);
            final long bDelay = b.getDelay(TimeUnit.MILLISECONDS);
            if (aDelay < bDelay) {
                return -1;
            } else if (aDelay > bDelay) {
                return 1;
            }
            return format(a).compareTo(format(b));
        }
    });
    taskNameWidth = wide ? Integer.MAX_VALUE : columns - 8 - 12 - 8 - 4;
    p.print(// 
    String.format(// 
    "%-8s %-12s %-8s %s\n", "Task", "State", "", "Command"));
    p.print("----------------------------------------------" + "--------------------------------\n");
    int numberOfPendingTasks = 0;
    final long now = System.currentTimeMillis();
    boolean isAdministrator = userProvider.get().isAdministrator();
    for (final Task<?> task : pending) {
        final long delay = task.getDelay(TimeUnit.MILLISECONDS);
        final Task.State state = task.getState();
        final String start;
        switch(state) {
            case DONE:
            case CANCELLED:
            case RUNNING:
            case READY:
                start = format(state);
                break;
            default:
                start = time(now, delay);
                break;
        }
        boolean regularUserCanSee = false;
        // If the user is not administrator, check if has rights to see
        // the Task
        Project.NameKey projectName = null;
        String remoteName = null;
        if (!isAdministrator) {
            if (task instanceof ProjectTask<?>) {
                projectName = ((ProjectTask<?>) task).getProjectNameKey();
                remoteName = ((ProjectTask<?>) task).getRemoteName();
            }
            ProjectState e = null;
            if (projectName != null) {
                e = projectCache.get(projectName);
            }
            regularUserCanSee = (e != null && e.controlFor(userProvider.get()).isVisible());
            if (regularUserCanSee) {
                numberOfPendingTasks++;
            }
        }
        // Shows information about tasks depending on the user rights
        if (isAdministrator) {
            p.print(// 
            String.format(// 
            "%8s %-12s %-8s %s\n", id(task.getTaskId()), start, "", format(task)));
        } else {
            if (regularUserCanSee) {
                p.print(// 
                String.format(// 
                "%8s %-12s %-8s %s\n", id(task.getTaskId()), start, "", remoteName + "/" + projectName));
            }
        }
    }
    p.print("----------------------------------------------" + "--------------------------------\n");
    if (isAdministrator) {
        numberOfPendingTasks = pending.size();
    }
    p.print("  " + numberOfPendingTasks + " tasks\n");
    p.flush();
}
#method_after
private void display() {
    p = toPrintWriter(out);
    final List<Task<?>> pending = workQueue.getTasks();
    Collections.sort(pending, new Comparator<Task<?>>() {

        public int compare(Task<?> a, Task<?> b) {
            final Task.State aState = a.getState();
            final Task.State bState = b.getState();
            if (aState != bState) {
                return aState.ordinal() - bState.ordinal();
            }
            final long aDelay = a.getDelay(TimeUnit.MILLISECONDS);
            final long bDelay = b.getDelay(TimeUnit.MILLISECONDS);
            if (aDelay < bDelay) {
                return -1;
            } else if (aDelay > bDelay) {
                return 1;
            }
            return format(a).compareTo(format(b));
        }
    });
    taskNameWidth = wide ? Integer.MAX_VALUE : columns - 8 - 12 - 8 - 4;
    p.print(// 
    String.format(// 
    "%-8s %-12s %-8s %s\n", "Task", "State", "", "Command"));
    p.print("----------------------------------------------" + "--------------------------------\n");
    int numberOfPendingTasks = 0;
    final long now = System.currentTimeMillis();
    final boolean isAdministrator = userProvider.isAdministrator();
    for (final Task<?> task : pending) {
        final long delay = task.getDelay(TimeUnit.MILLISECONDS);
        final Task.State state = task.getState();
        final String start;
        switch(state) {
            case DONE:
            case CANCELLED:
            case RUNNING:
            case READY:
                start = format(state);
                break;
            default:
                start = time(now, delay);
                break;
        }
        boolean regularUserCanSee = false;
        boolean hasCustomizedPrint = true;
        // If the user is not administrator, check if has rights to see
        // the Task
        Project.NameKey projectName = null;
        String remoteName = null;
        if (!isAdministrator) {
            if (task instanceof ProjectTask<?>) {
                projectName = ((ProjectTask<?>) task).getProjectNameKey();
                remoteName = ((ProjectTask<?>) task).getRemoteName();
                hasCustomizedPrint = ((ProjectTask<?>) task).hasCustomizedPrint();
            }
            ProjectState e = null;
            if (projectName != null) {
                e = projectCache.get(projectName);
            }
            regularUserCanSee = e != null && e.controlFor(userProvider).isVisible();
            if (regularUserCanSee) {
                numberOfPendingTasks++;
            }
        }
        // Shows information about tasks depending on the user rights
        if (isAdministrator || (!hasCustomizedPrint && regularUserCanSee)) {
            p.print(// 
            String.format(// 
            "%8s %-12s %-8s %s\n", id(task.getTaskId()), start, "", format(task)));
        } else if (regularUserCanSee) {
            if (remoteName == null) {
                remoteName = projectName.get();
            } else {
                remoteName = remoteName + "/" + projectName;
            }
            p.print(// 
            String.format(// 
            "%8s %-12s %-8s %s\n", id(task.getTaskId()), start, "", remoteName));
        }
    }
    p.print("----------------------------------------------" + "--------------------------------\n");
    if (isAdministrator) {
        numberOfPendingTasks = pending.size();
    }
    p.print("  " + numberOfPendingTasks + " tasks\n");
    p.flush();
}
#end_block

#method_before
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task = null;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<V>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<V>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#method_after
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<V>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<V>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            PrintWriter p = toPrintWriter(out);
            try {
                parseCommandLine();
                final ProjectAccess projectAccess = db.projects();
                Project.NameKey parentNameKey = new Project.NameKey(parentName);
                final List<Project.NameKey> grandParents = new ArrayList<Project.NameKey>();
                if (parentName != null) {
                    final ProjectState projectState = projectCache.get(parentNameKey);
                    if (projectState == null) {
                        throw new Failure(1, "parent project " + parentName + " does not exist \n");
                    } else {
                        Project.NameKey grandParent = projectState.getProject().getParent();
                        // avoid deadlocks on retrieving the project rights
                        while (grandParent != null && !grandParent.equals(wildProject)) {
                            grandParents.add(grandParent);
                            grandParent = projectCache.get(grandParent).getProject().getParent();
                        }
                    }
                } else {
                    // if there is no parent, "All projects" is the default
                    parentName = wildProject.get();
                    parentNameKey = new Project.NameKey(parentName);
                }
                for (String child : children) {
                    final Project.NameKey childNameKey = new Project.NameKey(child);
                    Project projectChild = projectAccess.get(childNameKey);
                    // If the child project doesn't exist, just skip it
                    if (projectChild != null && !child.equals(wildProject.get()) && !child.equals(parentName) && (!grandParents.contains(childNameKey))) {
                        projectChild.setParent(parentNameKey);
                        projectAccess.update(Collections.singleton(projectChild));
                    } else {
                        p.print("It was not possible to set the parent project " + parentName + " to the following project : " + child + "\n");
                        p.flush();
                    }
                }
                // invalidates all projects on cache
                projectCache.evict();
            } catch (Throwable e) {
                p.print("Error when trying to set a parent to a project: " + e.getMessage() + "\n");
                p.flush();
            }
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            parseCommandLine();
            updateParents();
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ApproveCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(AdminCreateProject.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ApproveCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(CreateProject.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchProjectException, OrmException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    for (final RefRight.Key k : toRemove) {
        if (!projectName.equals(k.getProjectNameKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!controlForRef(projectControl, k.getRefPattern()).isOwner()) {
            throw new NoSuchRefException(k.getRefPattern());
        }
    }
    for (final RefRight.Key k : toRemove) {
        final RefRight m = db.refRights().get(k);
        if (m != null) {
            db.refRights().delete(Collections.singleton(m));
        }
    }
    projectCache.evict();
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws NoSuchProjectException, OrmException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    for (final RefRight.Key k : toRemove) {
        if (!projectName.equals(k.getProjectNameKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!controlForRef(projectControl, k.getRefPattern()).isOwner()) {
            throw new NoSuchRefException(k.getRefPattern());
        }
    }
    for (final RefRight.Key k : toRemove) {
        final RefRight m = db.refRights().get(k);
        if (m != null) {
            db.refRights().delete(Collections.singleton(m));
        }
    }
    projectCache.evictAll();
    return VoidResult.INSTANCE;
}
#end_block

#method_before
private ProjectState lookup(final Project.NameKey key) throws OrmException {
    if (key == null) {
        return null;
    }
    // handles the "wildcard" project state (recursion break)
    if (key.equals(wildProject) || key.get() == null || key.get().isEmpty()) {
        return getWildProjectState();
    }
    final ReviewDb db = schema.open();
    try {
        final Project project = db.projects().get(key);
        if (project == null) {
            return null;
        }
        // retrieves the parent project state (recursively)
        ProjectState parentProjectState = null;
        Project.NameKey parentNameKey = project.getParent();
        if (parentNameKey == null || parentNameKey.get() == null || parentNameKey.get().isEmpty()) {
            // if the parent project name is not defined, uses the wildcard project
            parentProjectState = getWildProjectState();
        } else {
            // gets parent project state recursively (unless its available on cache)
            parentProjectState = ProjectCacheImpl.this.get(parentNameKey);
            if (parentProjectState == null) {
                parentProjectState = lookup(parentNameKey);
            }
        }
        // retrieves the project rights
        final Collection<RefRight> projectRights = Collections.unmodifiableCollection(db.refRights().byProject(project.getNameKey()).toList());
        // evaluates the project inherited rights from parent project state
        final ProjectState.InheritedRights inheritedRights = new InheritedRightsComposer(parentProjectState);
        return projectStateFactory.create(project, projectRights, inheritedRights);
    } finally {
        db.close();
    }
}
#method_after
private ProjectState lookup(final Project.NameKey key) throws OrmException {
    final ReviewDb db = schema.open();
    try {
        final Project p = db.projects().get(key);
        if (p == null) {
            return null;
        }
        final Collection<RefRight> rights = Collections.unmodifiableCollection(db.refRights().byProject(p.getNameKey()).toList());
        return projectStateFactory.create(p, rights);
    } finally {
        db.close();
    }
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = "refs/heads/*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = "refs/heads/*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = "refs/tags/*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = "refs/*";
        } else {
            // Assume project wide for the default.
            refPattern = "refs/*";
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    // TODO Support per-branch READ access.
    if (ApprovalCategory.READ.equals(categoryId) && !refPattern.equals("refs/*")) {
        throw new UnsupportedOperationException("READ on " + refPattern + " not yet supported.");
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evict();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    InheritedRefRight inheritedRefRight = (InheritedRefRight) o;
    RefRight refRight = inheritedRefRight.getRight();
    if (refRight.getAccountGroupId().equals(this.getRight().getAccountGroupId()) && refRight.getApprovalCategoryId().equals(this.getRight().getApprovalCategoryId()) && refRight.getMinValue() == this.getRight().getMinValue() && refRight.getMaxValue() == this.getRight().getMaxValue() && refRight.getRefPattern().equals(this.getRight().getRefPattern())) {
        return true;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o instanceof InheritedRefRight) {
        InheritedRefRight a = this;
        InheritedRefRight b = (InheritedRefRight) o;
        return a.getRight().equals(b.getRight()) && a.isInherited() == b.isInherited();
    }
    return false;
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ErrorSlaveMode.class);
    command(gerrit, "create-account").to(ErrorSlaveMode.class);
    command(gerrit, "create-project").to(ErrorSlaveMode.class);
    command(gerrit, "set-project-parent").to(ErrorSlaveMode.class);
    command(gerrit, "gsql").to(ErrorSlaveMode.class);
    command(gerrit, "receive-pack").to(ErrorSlaveMode.class);
    command(gerrit, "replicate").to(ErrorSlaveMode.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ErrorSlaveMode.class);
    command(gerrit, "create-account").to(ErrorSlaveMode.class);
    command(gerrit, "create-project").to(ErrorSlaveMode.class);
    command(gerrit, "gsql").to(ErrorSlaveMode.class);
    command(gerrit, "receive-pack").to(ErrorSlaveMode.class);
    command(gerrit, "replicate").to(ErrorSlaveMode.class);
    command(gerrit, "set-project-parent").to(ErrorSlaveMode.class);
}
#end_block

#method_before
void display(final ProjectDetail result) {
    rights.display(result.groups, result.rights);
}
#method_after
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
}
#end_block

#method_before
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    // TODO Support per-branch READ access.
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        referenceTxt.setText("");
        referenceTxt.setEnabled(false);
    } else {
        referenceTxt.setEnabled(true);
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#method_after
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> am = ad.getApprovalMap();
    final StringBuilder hint = new StringBuilder();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    // TODO populate the account role
    table.clearCell(row, col++);
    for (final ApprovalType type : types) {
        final PatchSetApproval ca = am.get(type.getCategory().getId());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
            col++;
            continue;
        }
        final ApprovalCategoryValue acv = type.getValue(ca);
        if (acv != null) {
            if (hint.length() > 0) {
                hint.append("; ");
            }
            hint.append(acv.getName());
        }
        if (type.isMaxNegative(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (type.isMaxPositive(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    // 
    // Remove button
    // 
    Button removeButton = new Button("X");
    removeButton.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
    removeButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

                @Override
                public void onSuccess(ReviewerResult result) {
                    final ChangeDetail r = result.getChange();
                    display(r.getChange(), r.getMissingApprovals(), r.getApprovals());
                }
            });
        }
    });
    table.setWidget(row, col++, removeButton);
    table.setText(row, col++, hint.toString());
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> am = ad.getApprovalMap();
    final StringBuilder hint = new StringBuilder();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    // TODO populate the account role
    table.clearCell(row, col++);
    for (final ApprovalType type : types) {
        final PatchSetApproval ca = am.get(type.getCategory().getId());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
            col++;
            continue;
        }
        final ApprovalCategoryValue acv = type.getValue(ca);
        if (acv != null) {
            if (hint.length() > 0) {
                hint.append("; ");
            }
            hint.append(acv.getName());
        }
        if (type.isMaxNegative(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (type.isMaxPositive(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    // 
    if (Gerrit.isSignedIn()) {
        Button removeButton = new Button("X");
        removeButton.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        removeButton.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

                    @Override
                    public void onSuccess(ReviewerResult result) {
                        if (result.getErrors().isEmpty()) {
                            final ChangeDetail r = result.getChange();
                            display(r.getChange(), r.getMissingApprovals(), r.getApprovals());
                        } else {
                            new ErrorDialog(result.getErrors().get(0).toString()).center();
                        }
                    }
                });
            }
        });
        table.setWidget(row, col++, removeButton);
    }
    table.setText(row, col++, hint.toString());
}
#end_block

#method_before
@Override
public ReviewerResult call() throws Exception {
    ReviewerResult result = new ReviewerResult();
    List<Account.Id> accounts = Lists.newArrayList();
    Iterable<PatchSetApproval> patchSets = db.patchSetApprovals().byChange(changeId);
    List<PatchSetApproval> toDelete = Lists.newArrayList();
    for (PatchSetApproval psa : patchSets) {
        if (psa.getAccountId().equals(reviewerId)) {
            toDelete.add(psa);
        }
    }
    try {
        db.patchSetApprovals().delete(toDelete);
    } catch (OrmException ex) {
        result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.COULD_NOT_REMOVE, "Could not remove reviewer " + reviewerId));
    }
    // Note: call setChange() after the deletion has been made or it will still
    // contain the reviewer we want to delete.
    result.setChange(changeDetailFactory.create(changeId).call());
    return result;
}
#method_after
@Override
public ReviewerResult call() throws Exception {
    ReviewerResult result = new ReviewerResult();
    List<Account.Id> accounts = new ArrayList<Account.Id>();
    ChangeControl ctl = changeControlFactory.validateFor(changeId);
    boolean permitted = true;
    List<PatchSetApproval> toDelete = new ArrayList<PatchSetApproval>();
    for (PatchSetApproval psa : db.patchSetApprovals().byChange(changeId)) {
        if (psa.getAccountId().equals(reviewerId)) {
            if (ctl.canRemoveReviewer(psa)) {
                toDelete.add(psa);
            } else {
                permitted = false;
                break;
            }
        }
    }
    if (permitted) {
        try {
            db.patchSetApprovals().delete(toDelete);
        } catch (OrmException ex) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.COULD_NOT_REMOVE, "Could not remove reviewer " + reviewerId));
        }
    } else {
        result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.COULD_NOT_REMOVE, "Not allowed to remove reviewer " + reviewerId));
    }
    // Note: call setChange() after the deletion has been made or it will still
    // contain the reviewer we want to delete.
    result.setChange(changeDetailFactory.create(changeId).call());
    return result;
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = "refs/heads/*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = "refs/heads/*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = "refs/tags/*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = "refs/*";
        } else {
            // Assume project wide for the default.
            refPattern = "refs/*";
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evict(projectControl.getProject());
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evict(projectControl.getProject());
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException {
    final UploadPack up = new UploadPack(repo);
    up.setRefFilter(this);
    up.upload(in, out, err);
}
#method_after
@Override
protected void runImpl() throws IOException {
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db));
    }
    up.upload(in, out, err);
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        checkVisibility(cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#end_block

#method_before
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    final LdapSchema schema = getSchema(ctx);
    final Set<String> groupDNs = new HashSet<String>();
    if (!schema.groupMemberQueryList.isEmpty()) {
        final HashMap<String, String> params = new HashMap<String, String>();
        if (schema.groupNeedsAccount) {
            if (account == null) {
                account = findAccount(schema, ctx, username);
            }
            for (String name : schema.groupMemberQueryList.get(0).getParameters()) {
                params.put(name, account.get(name));
            }
        }
        params.put(USERNAME, username);
    }
    if (schema.accountMemberField != null) {
        if (account == null) {
            account = findAccount(schema, ctx, username);
        }
        final Attribute groupAtt = account.getAll(schema.accountMemberField);
        if (groupAtt != null) {
            final NamingEnumeration<?> groups = groupAtt.getAll();
            while (groups.hasMore()) {
                final String nextDN = (String) groups.next();
                recursivelyExpandGroups(groupDNs, schema, ctx, nextDN);
            }
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (String dn : groupDNs) {
        for (AccountGroup group : groupCache.get(new AccountGroup.ExternalNameKey(dn))) {
            if (group.getType() == AccountGroup.Type.LDAP) {
                actual.add(group.getId());
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#method_after
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    final LdapSchema schema = getSchema(ctx);
    final Set<String> groupDNs = new HashSet<String>();
    if (!schema.groupMemberQueryList.isEmpty()) {
        final HashMap<String, String> params = new HashMap<String, String>();
        if (schema.groupNeedsAccount) {
            if (account == null) {
                account = findAccount(schema, ctx, username);
            }
            for (String name : schema.groupMemberQueryList.get(0).getParameters()) {
                params.put(name, account.get(name));
            }
        }
        params.put(USERNAME, username);
        for (LdapQuery groupMemberQuery : schema.groupMemberQueryList) {
            for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
                recursivelyExpandGroups(groupDNs, schema, ctx, r.getDN());
            }
        }
    }
    if (schema.accountMemberField != null) {
        if (account == null) {
            account = findAccount(schema, ctx, username);
        }
        final Attribute groupAtt = account.getAll(schema.accountMemberField);
        if (groupAtt != null) {
            final NamingEnumeration<?> groups = groupAtt.getAll();
            while (groups.hasMore()) {
                final String nextDN = (String) groups.next();
                recursivelyExpandGroups(groupDNs, schema, ctx, nextDN);
            }
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (String dn : groupDNs) {
        for (AccountGroup group : groupCache.get(new AccountGroup.ExternalNameKey(dn))) {
            if (group.getType() == AccountGroup.Type.LDAP) {
                actual.add(group.getId());
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(AdminFlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "show-caches").to(AdminShowCaches.class);
    command(gerrit, "show-connections").to(AdminShowConnections.class);
    command(gerrit, "show-queue").to(AdminShowQueue.class);
    command(gerrit, "stream-changes").to(StreamChangeEvents.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(AdminShowCaches.class);
    command("kill").to(AdminKill.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(AdminFlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "show-caches").to(AdminShowCaches.class);
    command(gerrit, "show-connections").to(AdminShowConnections.class);
    command(gerrit, "show-queue").to(AdminShowQueue.class);
    command(gerrit, "stream-events").to(StreamEvents.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(AdminShowCaches.class);
    command("kill").to(AdminKill.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
}
#end_block

#method_before
public void addChangeListener(ChangeListener listener) {
    listeners.add(listener);
}
#method_after
public void addChangeListener(ChangeListener listener, IdentifiedUser user) {
    listeners.put(listener, new ChangeListenerHolder(listener, user));
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    for (ChangeListener listener : listeners) {
        listener.onPatchsetCreated(change, patchSet);
    }
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    args.add("--patchset");
    args.add(Integer.toString(patchSet.getPatchSetId()));
    runHook(getRepo(change), args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.commit = patchSet.getRevision().get();
    event.patchSet = Integer.toString(patchSet.getPatchSetId());
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--commit");
    args.add(event.commit);
    args.add("--patchset");
    args.add(event.patchSet);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    for (ChangeListener listener : listeners) {
        listener.onCommentAdded(change, patchSet, account, approvals, comment);
    }
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.author = getAuthorAttribute(account);
    event.revision = patchSet.getRevision().get();
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            ApprovalAttribute a = new ApprovalAttribute();
            a.type = approval.getKey().get();
            a.value = Short.toString(approval.getValue().get());
            event.approvals[i++] = a;
        }
    }
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.revision);
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    for (ChangeListener listener : listeners) {
        listener.onChangeMerged(change, account, patchSet);
    }
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    runHook(getRepo(change), args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.submitter = getAuthorAttribute(account);
    event.patchSet = patchSet.getRevision().get();
    event.description = change.getSubject();
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    for (ChangeListener listener : listeners) {
        listener.onChangeAbandoned(change, account, reason);
    }
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.author = getAuthorAttribute(account);
    event.reason = reason;
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    // Get the LDAP authentication username and password
    // from the user's input.
    // 
    final String authUsername = who.getLocalUser();
    final String authPassword = who.getPassword();
    // 
    if (this.username == null) {
        this.username = authUsername;
        this.password = authPassword;
    }
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, authUsername);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), authPassword);
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(authUsername)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(authUsername));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(authUsername, queryForGroups(ctx, authUsername, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = authenticate(username, who.getPassword());
        } else {
            ctx = open();
        }
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private void authenticate(String dn, String password) throws AccountException {
    final Properties env = createContextProperties();
    env.put(Context.SECURITY_AUTHENTICATION, "simple");
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        new InitialDirContext(env).close();
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#method_after
private DirContext authenticate(String dn, String password) throws AccountException {
    final Properties env = createContextProperties();
    env.put(Context.SECURITY_AUTHENTICATION, "simple");
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        return new InitialDirContext(env);
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#end_block

#method_before
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#method_after
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false, false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final PatchSet.Id merged = c.currentPatchSetId();
    PatchSetApproval submitter = null;
    for (int attempts = 0; attempts < 10; attempts++) {
        c.setStatus(Change.Status.MERGED);
        ChangeUtil.updated(c);
        try {
            final Transaction txn = schema.beginTransaction();
            // Flatten out all existing approvals based upon the current
            // permissions. Once the change is closed the approvals are
            // not updated at presentation view time, so we need to make.
            // sure they are accurate now. This way if permissions get
            // modified in the future, historical records stay accurate.
            // 
            final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(c.getId()).toList();
            final FunctionState fs = functionState.create(c, merged, approvals);
            for (ApprovalType at : approvalTypes.getApprovalTypes()) {
                CategoryFunction.forCategory(at.getCategory()).run(at, fs);
            }
            for (PatchSetApproval a : approvals) {
                if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                    if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                        submitter = a;
                    }
                }
                a.cache(c);
            }
            schema.patchSetApprovals().update(approvals, txn);
            if (msg != null) {
                if (submitter != null && msg.getAuthor() == null) {
                    msg.setAuthor(submitter.getAccountId());
                }
                schema.changeMessages().insert(Collections.singleton(msg), txn);
            }
            schema.changes().update(Collections.singleton(c), txn);
            txn.commit();
            break;
        } catch (OrmException e) {
            final Change.Id id = c.getId();
            try {
                c = schema.changes().get(id);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
            } catch (OrmException e2) {
                log.error("Cannot set change " + id + " to merged " + merged, e2);
            }
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        ChangeHookRunner.get().doChangeMergedHook(c, schema.accounts().get(submitter.getAccountId()), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, boolean makeNew) {
    for (int attempts = 0; attempts < 10; attempts++) {
        if (makeNew) {
            c.setStatus(Change.Status.NEW);
        }
        ChangeUtil.updated(c);
        try {
            final Transaction txn = schema.beginTransaction();
            schema.changes().update(Collections.singleton(c), txn);
            if (msg != null) {
                schema.changeMessages().insert(Collections.singleton(msg), txn);
            }
            txn.commit();
            break;
        } catch (OrmException e) {
            try {
                c = schema.changes().get(c.getId());
                if (c.getStatus().isClosed()) {
                    // 
                    break;
                }
            } catch (OrmException e2) {
            }
        }
    }
    try {
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Transaction txn = db.beginTransaction();
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    final PatchSet ps = new PatchSet(change.newPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    final PatchSetImporter imp = importFactory.create(db, c, ps, true);
    imp.setTransaction(txn);
    imp.run();
    change.setCurrentPatchSet(imp.getPatchSetInfo());
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change), txn);
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = imp.getPatchSetInfo().getAuthor() != null ? imp.getPatchSetInfo().getAuthor().getAccount() : null;
        final Account.Id committerId = imp.getPatchSetInfo().getCommitter() != null ? imp.getPatchSetInfo().getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db, txn);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db, txn);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db, txn);
            }
        }
    }
    txn.commit();
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, imp.getPatchSetInfo());
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeHookRunner.get().doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    if (!validCommitter(request.cmd, c)) {
        return null;
    }
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result;
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    result = db.run(new OrmRunnable<ReplaceResult, ReviewDb>() {

        public ReplaceResult run(final ReviewDb db, final Transaction txn, final boolean isRetry) throws OrmException {
            final Change change = db.changes().get(request.ontoChange);
            if (change == null) {
                reject(request.cmd, "change " + request.ontoChange + " not found");
                return null;
            }
            if (change.getStatus().isClosed()) {
                reject(request.cmd, "change " + request.ontoChange + " closed");
                return null;
            }
            final PatchSet.Id priorPatchSet = change.currentPatchSetId();
            for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
                if (ps.getRevision() == null) {
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
                final String revIdStr = ps.getRevision().get();
                final ObjectId commitId;
                try {
                    commitId = ObjectId.fromString(revIdStr);
                } catch (IllegalArgumentException e) {
                    log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
                try {
                    final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
                    // 
                    if (rp.getRevWalk().isMergedInto(prior, c)) {
                        reject(request.cmd, "squash commits first");
                        return null;
                    }
                    // 
                    if (c == prior) {
                        reject(request.cmd, "commit already exists");
                        return null;
                    }
                    // 
                    if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                        rp.getRevWalk().parseBody(prior);
                        final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                        final boolean parentsEq = parentsEqual(c, prior);
                        if (messageEq && parentsEq) {
                            reject(request.cmd, "no changes made");
                            return null;
                        } else {
                            err.write(Constants.encode(// 
                            "warning: " + change.getKey().abbreviate() + // 
                            ": " + // 
                            " no files changed, but" + // 
                            (!messageEq ? " message updated" : "") + // 
                            (!messageEq && !parentsEq ? " and" : "") + // 
                            (!parentsEq ? " was rebased" : "") + // 
                            "\n"));
                        }
                    }
                } catch (IOException e) {
                    log.error("Change " + change.getId() + " missing " + revIdStr, e);
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
            }
            final PatchSet ps = new PatchSet(change.newPatchSetId());
            ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
            ps.setUploader(currentUser.getAccountId());
            final PatchSetImporter imp = importFactory.create(db, c, ps, true);
            imp.setTransaction(txn);
            imp.run();
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            final ReplaceResult result = new ReplaceResult();
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
            result.change = change;
            result.patchSet = ps;
            result.info = imp.getPatchSetInfo();
            final Account.Id authorId = imp.getPatchSetInfo().getAuthor() != null ? imp.getPatchSetInfo().getAuthor().getAccount() : null;
            final Account.Id committerId = imp.getPatchSetInfo().getCommitter() != null ? imp.getPatchSetInfo().getCommitter().getAccount() : null;
            boolean haveAuthor = false;
            boolean haveCommitter = false;
            final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
            oldReviewers.clear();
            oldCC.clear();
            for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
                haveApprovals.add(a.getAccountId());
                if (a.getValue() != 0) {
                    oldReviewers.add(a.getAccountId());
                } else {
                    oldCC.add(a.getAccountId());
                }
                final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)), txn);
                }
                if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                    haveAuthor = true;
                }
                if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                    haveCommitter = true;
                }
            }
            final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
            msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
            db.changeMessages().insert(Collections.singleton(msg), txn);
            result.msg = msg;
            if (result.mergedIntoRef != null) {
                // Change was already submitted to a branch, close it.
                // 
                markChangeMergedByPush(db, txn, result);
            } else {
                // Change should be new, so it can go through review again.
                // 
                change.setStatus(Change.Status.NEW);
                change.setCurrentPatchSet(imp.getPatchSetInfo());
                ChangeUtil.updated(change);
                db.changes().update(Collections.singleton(change), txn);
            }
            final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
            if (allTypes.size() > 0) {
                final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
                if (authorId != null && haveApprovals.add(authorId)) {
                    insertDummyApproval(result, authorId, catId, db, txn);
                }
                if (committerId != null && haveApprovals.add(committerId)) {
                    insertDummyApproval(result, committerId, catId, db, txn);
                }
                for (final Account.Id reviewer : reviewers) {
                    if (haveApprovals.add(reviewer)) {
                        insertDummyApproval(result, reviewer, catId, db, txn);
                    }
                }
            }
            return result;
        }
    });
    if (result != null) {
        final PatchSet ps = result.patchSet;
        final RefUpdate ru = repo.updateRef(ps.getRefName());
        ru.setNewObjectId(c);
        ru.disableRefLog();
        if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(project.getNameKey(), ru.getName());
        request.cmd.setResult(ReceiveCommand.Result.OK);
        try {
            final ReplacePatchSetSender cm;
            cm = replacePatchSetFactory.create(result.change);
            cm.setFrom(me);
            cm.setPatchSet(ps, result.info);
            cm.setChangeMessage(result.msg);
            cm.setReviewDb(db);
            cm.addReviewers(reviewers);
            cm.addExtraCC(cc);
            cm.addReviewers(oldReviewers);
            cm.addExtraCC(oldCC);
            cm.send();
        } catch (EmailException e) {
            log.error("Cannot send email for new patch set " + ps.getId(), e);
        }
        ChangeHookRunner.get().doPatchsetCreatedHook(result.change, ps);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    if (!validCommitter(request.cmd, c)) {
        return null;
    }
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                if (messageEq && parentsEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    err.write(Constants.encode(// 
                    "warning: " + change.getKey().abbreviate() + // 
                    ": " + // 
                    " no files changed, but" + // 
                    (!messageEq ? " message updated" : "") + // 
                    (!messageEq && !parentsEq ? " and" : "") + // 
                    (!parentsEq ? " was rebased" : "") + // 
                    "\n"));
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void insertDummyApproval(final Change change, final PatchSet.Id psId, final Account.Id forAccount, final ApprovalCategory.Id catId, final ReviewDb db, final Transaction txn) throws OrmException {
    final PatchSetApproval ca = new PatchSetApproval(new PatchSetApproval.Key(psId, forAccount, catId), (short) 0);
    ca.cache(change);
    db.patchSetApprovals().insert(Collections.singleton(ca), txn);
}
#method_after
private void insertDummyApproval(final ReplaceResult result, final Account.Id forAccount, final ApprovalCategory.Id catId, final ReviewDb db) throws OrmException {
    insertDummyApproval(result.change, result.patchSet.getId(), forAccount, catId, db);
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final ReplaceResult result = db.run(new OrmRunnable<ReplaceResult, ReviewDb>() {

        @Override
        public ReplaceResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
            final Change change = db.changes().get(cid);
            final PatchSet ps = db.patchSets().get(psi);
            if (change == null || ps == null) {
                log.warn(project.getName() + " " + psi + " is missing");
                return null;
            }
            if (change.getStatus() == Change.Status.MERGED) {
                // 
                return null;
            }
            final ReplaceResult result = new ReplaceResult();
            result.change = change;
            result.patchSet = ps;
            result.info = patchSetInfoFactory.get(commit, psi);
            result.mergedIntoRef = refName;
            markChangeMergedByPush(db, txn, result);
            return result;
        }
    });
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final Transaction txn, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.patchSetApprovals().update(approvals, txn);
    db.changeMessages().insert(Collections.singleton(msg), txn);
    db.changes().update(Collections.singleton(change), txn);
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        ChangeHookRunner.get().doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, PatchSetInfoNotAvailableException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    final Change change = changeControl.getChange();
    if (change.getStatus().isClosed()) {
        throw error("change " + changeId + " is closed");
    }
    final Transaction txn = db.beginTransaction();
    final StringBuffer msgBuf = new StringBuffer();
    msgBuf.append("Patch Set ");
    msgBuf.append(patchSetId.get());
    msgBuf.append(": ");
    String verified = "";
    String approved = "";
    for (ApproveOption co : optionList) {
        final ApprovalCategory.Id category = co.getCategoryId();
        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
        Short score = co.value();
        if (score != null) {
            addApproval(psaKey, score, change, co, txn);
        } else {
            if (psa == null) {
                score = 0;
                addApproval(psaKey, score, change, co, txn);
            } else {
                score = psa.getValue();
            }
        }
        String message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
        msgBuf.append(" " + message + ";");
        if (category.get().equalsIgnoreCase("VRIF")) {
            verified = Short.toString(score);
        } else if (category.get().equalsIgnoreCase("CVRW")) {
            approved = Short.toString(score);
        }
    }
    msgBuf.deleteCharAt(msgBuf.length() - 1);
    msgBuf.append("\n\n");
    if (changeComment != null) {
        msgBuf.append(changeComment);
    }
    String uuid = ChangeUtil.messageUUID(db);
    ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(changeId, uuid), currentUser.getAccountId());
    cm.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(cm), txn);
    ChangeUtil.updated(change);
    db.changes().update(Collections.singleton(change), txn);
    txn.commit();
    ChangeHookRunner.get().doCommentAddedHook(change, currentUser.getAccount(), verified, approved, changeComment);
    sendMail(change, change.currentPatchSetId(), cm);
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, PatchSetInfoNotAvailableException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    final Change change = changeControl.getChange();
    if (change.getStatus().isClosed()) {
        throw error("change " + changeId + " is closed");
    }
    final StringBuffer msgBuf = new StringBuffer();
    msgBuf.append("Patch Set ");
    msgBuf.append(patchSetId.get());
    msgBuf.append(": ");
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvalsMap = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (ApproveOption co : optionList) {
        final ApprovalCategory.Id category = co.getCategoryId();
        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
        Short score = co.value();
        if (score != null) {
            addApproval(psaKey, score, change, co);
        } else {
            if (psa == null) {
                score = 0;
                addApproval(psaKey, score, change, co);
            } else {
                score = psa.getValue();
            }
        }
        final ApprovalCategoryValue.Id val = new ApprovalCategoryValue.Id(category, score);
        String message = db.approvalCategoryValues().get(val).getName();
        msgBuf.append(" " + message + ";");
        approvalsMap.put(category, val);
    }
    msgBuf.deleteCharAt(msgBuf.length() - 1);
    msgBuf.append("\n\n");
    if (changeComment != null) {
        msgBuf.append(changeComment);
    }
    String uuid = ChangeUtil.messageUUID(db);
    ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(changeId, uuid), currentUser.getAccountId());
    cm.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(cm));
    ChangeUtil.touch(change, db);
    sendMail(change, change.currentPatchSetId(), cm);
    hooks.doCommentAddedHook(change, currentUser.getAccount(), changeComment, approvalsMap);
}
#end_block

#method_before
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final ApproveOption co, final Transaction txn) throws OrmException, UnloggedFailure {
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    boolean insert = false;
    if (psa == null) {
        insert = true;
        psa = new PatchSetApproval(psaKey, score);
    }
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, psaKey.getParentKey(), approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw error(co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    if (insert) {
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#method_after
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final ApproveOption co) throws OrmException, UnloggedFailure {
    final PatchSetApproval psa = new PatchSetApproval(psaKey, score);
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, psaKey.getParentKey(), approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw error(co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    db.patchSetApprovals().upsert(Collections.singleton(psa));
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    Boolean dbSuccess = db.run(new OrmRunnable<Boolean, ReviewDb>() {

        public Boolean run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
            return doAbandonChange(message, change, patchSetId, cmsg, db, txn);
        }
    });
    if (dbSuccess) {
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(currentUser.getAccountId());
        cm.setReviewDb(db);
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    ChangeHookRunner.get().doChangeAbandonedHook(change, currentUser.getAccount(), message);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(currentUser.getAccountId());
        cm.setReviewDb(db);
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, currentUser.getAccount(), message);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
private void generateProxyCallCreator(final TreeLogger logger, final SourceWriter w) throws UnableToCompleteException {
    // TODO: implement annotation for json-rpc versions selection
    String callName = getJsonCallClassName(logger);
    w.println();
    w.println("@Override");
    w.print("protected <T> ");
    w.print(callName);
    w.print("<T> newJsonCall(final AbstractJsonProxy proxy, ");
    w.print("final String methodName, final String reqData, ");
    w.println("final ResultDeserializer<T> ser, final AsyncCallback<T> cb) {");
    w.indent();
    w.print("return new ");
    w.print(callName);
    w.println("<T>(proxy, methodName, reqData, ser, cb);");
    w.outdent();
    w.println("}");
}
#method_after
private void generateProxyCallCreator(final TreeLogger logger, final SourceWriter w) throws UnableToCompleteException {
    String callName = getJsonCallClassName(logger);
    w.println();
    w.println("@Override");
    w.print("protected <T> ");
    w.print(callName);
    w.print("<T> newJsonCall(final AbstractJsonProxy proxy, ");
    w.print("final String methodName, final String reqData, ");
    w.println("final ResultDeserializer<T> ser, final AsyncCallback<T> cb) {");
    w.indent();
    w.print("return new ");
    w.print(callName);
    w.println("<T>(proxy, methodName, reqData, ser, cb);");
    w.outdent();
    w.println("}");
}
#end_block

#method_before
private void generateProxyMethod(final TreeLogger logger, final JMethod method, final SourceWriter w) {
    final JParameter[] params = method.getParameters();
    final JParameter callback = params[params.length - 1];
    final JClassType resultType = callback.getType().isParameterized().getTypeArgs()[0];
    final String[] serializerFields = new String[params.length];
    final HostPageCache hpc = method.getAnnotation(HostPageCache.class);
    w.println();
    for (int i = 0; i < params.length - 1; i++) {
        final JType pType = params[i].getType();
        if (SerializerCreator.needsTypeParameter(pType)) {
            serializerFields[i] = "serializer_" + instanceField++;
            w.print("private static final ");
            if (pType.isArray() != null)
                w.print(serializerCreator.serializerFor(pType));
            else
                w.print(JsonSerializer.class.getName());
            w.print(" ");
            w.print(serializerFields[i]);
            w.print(" = ");
            serializerCreator.generateSerializerReference(pType, w);
            w.println(";");
        }
    }
    if (resultType.isParameterized() != null) {
        serializerFields[params.length - 1] = "serializer_" + instanceField++;
        w.print("private static final ");
        w.print(ResultDeserializer.class.getName());
        w.print(" ");
        w.print(serializerFields[params.length - 1]);
        w.print(" = ");
        serializerCreator.generateSerializerReference(resultType, w);
        w.println(";");
    }
    w.print("public ");
    w.print(method.getReturnType().getQualifiedSourceName());
    w.print(" ");
    w.print(method.getName());
    w.print("(");
    boolean needsComma = false;
    final NameFactory nameFactory = new NameFactory();
    for (int i = 0; i < params.length; i++) {
        final JParameter param = params[i];
        if (needsComma) {
            w.print(", ");
        } else {
            needsComma = true;
        }
        final JType paramType = param.getType().getErasedType();
        w.print(paramType.getQualifiedSourceName());
        w.print(" ");
        nameFactory.addName(param.getName());
        w.print(param.getName());
    }
    w.println(") {");
    w.indent();
    if (returnsCallbackHandle(method)) {
        w.print("return new ");
        w.print(CallbackHandle.class.getName());
        w.print("(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.println(");");
        w.outdent();
        w.println("}");
        return;
    }
    if (hpc != null) {
        final String objName = nameFactory.createName("cached");
        w.print("final JavaScriptObject " + objName + " = ");
        w.print(AbstractJsonProxy.class.getName());
        w.print(".");
        w.print(hpc.once() ? "hostPageCacheGetOnce" : "hostPageCacheGetMany");
        w.println("(\"" + hpc.name() + "\");");
        w.println("if (" + objName + " != null) {");
        w.indent();
        w.print(JsonUtil.class.getName());
        w.print(".invoke(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.print(", " + objName);
        w.println(");");
        w.println("return;");
        w.outdent();
        w.println("}");
    }
    final String reqDataStr;
    if (params.length == 1) {
        reqDataStr = "\"\"";
    } else {
        final String reqData = nameFactory.createName("reqData");
        w.println("final StringBuilder " + reqData + " = new StringBuilder();");
        needsComma = false;
        for (int i = 0; i < params.length - 1; i++) {
            if (needsComma) {
                w.println(reqData + ".append(\",\");");
            } else {
                needsComma = true;
            }
            final JType pType = params[i].getType();
            final String pName = params[i].getName();
            if (pType == JPrimitiveType.CHAR || SerializerCreator.isBoxedCharacter(pType)) {
                w.println(reqData + ".append(\"\\\"\");");
                w.println(reqData + ".append(" + JsonSerializer.class.getSimpleName() + ".escapeChar(" + pName + "));");
                w.println(reqData + ".append(\"\\\"\");");
            } else if ((SerializerCreator.isJsonPrimitive(pType) || SerializerCreator.isBoxedPrimitive(pType)) && !SerializerCreator.isJsonString(pType)) {
                w.println(reqData + ".append(" + pName + ");");
            } else {
                w.println("if (" + pName + " != null) {");
                w.indent();
                if (SerializerCreator.needsTypeParameter(pType)) {
                    w.print(serializerFields[i]);
                } else {
                    serializerCreator.generateSerializerReference(pType, w);
                }
                w.println(".printJson(" + reqData + ", " + pName + ");");
                w.outdent();
                w.println("} else {");
                w.indent();
                w.println(reqData + ".append(" + JsonSerializer.class.getName() + ".JS_NULL);");
                w.outdent();
                w.println("}");
            }
        }
        reqDataStr = reqData + ".toString()";
    }
    w.print("doInvoke(");
    w.print("\"" + method.getName() + "\"");
    w.print(", " + reqDataStr);
    w.print(", ");
    if (resultType.isParameterized() != null) {
        w.print(serializerFields[params.length - 1]);
    } else {
        deserializerCreator.generateDeserializerReference(resultType, w);
    }
    w.print(", " + callback.getName());
    w.println(");");
    w.outdent();
    w.println("}");
}
#method_after
private void generateProxyMethod(final TreeLogger logger, final JMethod method, final SourceWriter w) {
    final JParameter[] params = method.getParameters();
    final JParameter callback = params[params.length - 1];
    final JClassType resultType = callback.getType().isParameterized().getTypeArgs()[0];
    final String[] serializerFields = new String[params.length];
    final HostPageCache hpc = method.getAnnotation(HostPageCache.class);
    w.println();
    for (int i = 0; i < params.length - 1; i++) {
        final JType pType = params[i].getType();
        if (SerializerCreator.needsTypeParameter(pType)) {
            serializerFields[i] = "serializer_" + instanceField++;
            w.print("private static final ");
            if (pType.isArray() != null)
                w.print(serializerCreator.serializerFor(pType));
            else
                w.print(JsonSerializer.class.getName());
            w.print(" ");
            w.print(serializerFields[i]);
            w.print(" = ");
            serializerCreator.generateSerializerReference(pType, w);
            w.println(";");
        }
    }
    if (resultType.isParameterized() != null) {
        serializerFields[params.length - 1] = "serializer_" + instanceField++;
        w.print("private static final ");
        w.print(ResultDeserializer.class.getName());
        w.print(" ");
        w.print(serializerFields[params.length - 1]);
        w.print(" = ");
        serializerCreator.generateSerializerReference(resultType, w);
        w.println(";");
    }
    w.print("public ");
    w.print(method.getReturnType().getQualifiedSourceName());
    w.print(" ");
    w.print(method.getName());
    w.print("(");
    boolean needsComma = false;
    final NameFactory nameFactory = new NameFactory();
    for (int i = 0; i < params.length; i++) {
        final JParameter param = params[i];
        if (needsComma) {
            w.print(", ");
        } else {
            needsComma = true;
        }
        final JType paramType = param.getType().getErasedType();
        w.print(paramType.getQualifiedSourceName());
        w.print(" ");
        nameFactory.addName(param.getName());
        w.print(param.getName());
    }
    w.println(") {");
    w.indent();
    if (returnsCallbackHandle(method)) {
        w.print("return new ");
        w.print(CallbackHandle.class.getName());
        w.print("(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.println(");");
        w.outdent();
        w.println("}");
        return;
    }
    if (hpc != null) {
        final String objName = nameFactory.createName("cached");
        w.print("final JavaScriptObject " + objName + " = ");
        w.print(AbstractJsonProxy.class.getName());
        w.print(".");
        w.print(hpc.once() ? "hostPageCacheGetOnce" : "hostPageCacheGetMany");
        w.println("(\"" + hpc.name() + "\");");
        w.println("if (" + objName + " != null) {");
        w.indent();
        w.print(JsonUtil.class.getName());
        w.print(".invoke(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.print(", " + objName);
        w.println(");");
        w.println("return;");
        w.outdent();
        w.println("}");
    }
    final String reqDataStr;
    if (params.length == 1) {
        reqDataStr = "\"[]\"";
    } else {
        final String reqData = nameFactory.createName("reqData");
        w.println("final StringBuilder " + reqData + " = new StringBuilder();");
        needsComma = false;
        w.println(reqData + ".append('[');");
        for (int i = 0; i < params.length - 1; i++) {
            if (needsComma) {
                w.println(reqData + ".append(\",\");");
            } else {
                needsComma = true;
            }
            final JType pType = params[i].getType();
            final String pName = params[i].getName();
            if (pType == JPrimitiveType.CHAR || SerializerCreator.isBoxedCharacter(pType)) {
                w.println(reqData + ".append(\"\\\"\");");
                w.println(reqData + ".append(" + JsonSerializer.class.getSimpleName() + ".escapeChar(" + pName + "));");
                w.println(reqData + ".append(\"\\\"\");");
            } else if ((SerializerCreator.isJsonPrimitive(pType) || SerializerCreator.isBoxedPrimitive(pType)) && !SerializerCreator.isJsonString(pType)) {
                w.println(reqData + ".append(" + pName + ");");
            } else {
                w.println("if (" + pName + " != null) {");
                w.indent();
                if (SerializerCreator.needsTypeParameter(pType)) {
                    w.print(serializerFields[i]);
                } else {
                    serializerCreator.generateSerializerReference(pType, w);
                }
                w.println(".printJson(" + reqData + ", " + pName + ");");
                w.outdent();
                w.println("} else {");
                w.indent();
                w.println(reqData + ".append(" + JsonSerializer.class.getName() + ".JS_NULL);");
                w.outdent();
                w.println("}");
            }
        }
        w.println(reqData + ".append(']');");
        reqDataStr = reqData + ".toString()";
    }
    w.print("doInvoke(");
    w.print("\"" + method.getName() + "\"");
    w.print(", " + reqDataStr);
    w.print(", ");
    if (resultType.isParameterized() != null) {
        w.print(serializerFields[params.length - 1]);
    } else {
        deserializerCreator.generateDeserializerReference(resultType, w);
    }
    w.print(", " + callback.getName());
    w.println(");");
    w.outdent();
    w.println("}");
}
#end_block

#method_before
@Override
void send() {
    final StringBuilder body = new StringBuilder();
    body.append("{\"version\":\"1.1\",\"method\":\"");
    body.append(methodName);
    body.append("\",\"params\":[");
    body.append(requestParams);
    body.append("]");
    final String xsrfKey = proxy.getXsrfManager().getToken(proxy);
    if (xsrfKey != null) {
        body.append(",\"xsrfKey\":");
        body.append(JsonSerializer.escapeString(xsrfKey));
    }
    body.append("}");
    final RequestBuilder rb;
    rb = new RequestBuilder(RequestBuilder.POST, proxy.url);
    rb.setHeader("Content-Type", JsonUtil.JSON_REQ_CT);
    rb.setHeader("Accept", JsonUtil.JSON_TYPE);
    rb.setCallback(this);
    rb.setRequestData(body.toString());
    send(rb);
}
#method_after
@Override
void send() {
    final StringBuilder body = new StringBuilder();
    body.append("{\"version\":\"1.1\",\"method\":\"");
    body.append(methodName);
    body.append("\",\"params\":");
    body.append(requestParams);
    final String xsrfKey = proxy.getXsrfManager().getToken(proxy);
    if (xsrfKey != null) {
        body.append(",\"xsrfKey\":");
        body.append(JsonSerializer.escapeString(xsrfKey));
    }
    body.append("}");
    final RequestBuilder rb;
    rb = new RequestBuilder(RequestBuilder.POST, proxy.url);
    rb.setHeader("Content-Type", JsonUtil.JSON_REQ_CT);
    rb.setHeader("Accept", JsonUtil.JSON_TYPE);
    rb.setCallback(this);
    rb.setRequestData(body.toString());
    send(rb);
}
#end_block

#method_before
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (rsp.getStatusCode() == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(rsp.getStatusCode(), rsp.getStatusText()));
    }
}
#method_after
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    // FIXME: implement version 2.0
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (rsp.getStatusCode() == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(rsp.getStatusCode(), rsp.getStatusText()));
    }
}
#method_after
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            // TODO: define status code for the invalid XSRF msg for 2.0 (-32099 ?)
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("data")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
private List<ReplicationConfig> allConfigs(final File path) throws ConfigInvalidException, IOException {
    final File cfgFile = new File(path, "replication.config");
    final FileBasedConfig cfg = new FileBasedConfig(cfgFile);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfgFile + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg));
    }
    return Collections.unmodifiableList(r);
}
#method_after
private List<ReplicationConfig> allConfigs(final File path) throws ConfigInvalidException, IOException {
    final File cfgFile = new File(path, "replication.config");
    final FileBasedConfig cfg = new FileBasedConfig(cfgFile);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfgFile + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg, database, replicationUserFactory));
    }
    return Collections.unmodifiableList(r);
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri) {
    try {
        if (!projectControlFactory.controlFor(project).isVisible()) {
            return;
        }
    } catch (NoSuchProjectException e1) {
        log.error("Internal error: project " + project + " not found during replication");
        return;
    }
    synchronized (pending) {
        PushOp e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project.get(), uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri) {
    try {
        if (authEnabled && !projectControlFactory.controlFor(project).isVisible()) {
            return;
        }
    } catch (NoSuchProjectException e1) {
        log.error("Internal error: project " + project + " not found during replication");
        return;
    }
    synchronized (pending) {
        PushOp e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project.get(), uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
    }
}
#end_block

#method_before
@Override
public Set<Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        effectiveGroups = new HashSet<Id>();
        if (authGroupNames == null) {
            effectiveGroups.addAll(authConfig.getAnonymousGroups());
        } else {
            effectiveGroups.addAll(authConfig.getRegisteredGroups());
            for (String authGroupName : authGroupNames) {
                AccountGroup group = groupCache.lookup(authGroupName);
                if (group != null) {
                    effectiveGroups.add(group.getId());
                }
            }
        }
    }
    return effectiveGroups;
}
#method_after
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    return Collections.unmodifiableSet(effectiveGroups);
}
#end_block

#method_before
@Override
public Set<Change.Id> getStarredChanges() {
    return null;
}
#method_after
@Override
public Set<Change.Id> getStarredChanges() {
    return Collections.emptySet();
}
#end_block

#method_before
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg.setFindReplaceList(Gerrit.getConfig().getCommentLinks());
    msg = msg.runFindReplaceList();
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#method_after
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg = msg.replaceAll(Gerrit.getConfig().getCommentLinks());
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#end_block

#method_before
protected void setMessageText(String message) {
    if (message == null) {
        message = "";
    } else {
        message = message.trim();
    }
    messageSummary.setText(summarize(message));
    SafeHtml msg = new SafeHtmlBuilder().append(message);
    msg.setFindReplaceList(Gerrit.getConfig().getCommentLinks());
    SafeHtml.set(messageText, msg.wikify().runFindReplaceList());
}
#method_after
protected void setMessageText(String message) {
    if (message == null) {
        message = "";
    } else {
        message = message.trim();
    }
    messageSummary.setText(summarize(message));
    SafeHtml.set(messageText, new SafeHtmlBuilder().append(message).wikify().replaceAll(Gerrit.getConfig().getCommentLinks()));
}
#end_block

#method_before
private GerritConfig create() {
    final GerritConfig config = new GerritConfig();
    config.setCanonicalUrl(canonicalWebUrl);
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseRepoDownload(cfg.getBoolean("repo", null, "showdownloadcommand", false));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    final String gitwebUrl = cfg.getString("gitweb", null, "url");
    if (gitwebUrl != null) {
        config.setGitwebLink(new GitwebLink(gitwebUrl));
    }
    config.setSshdAddress(sshInfo != null ? sshInfo.getSshdAddress() : null);
    ArrayList<String> commentLinkNames = new ArrayList<String>(cfg.getSubsections("CommentLink"));
    ArrayList<RegexFindReplace> commentLinks = new ArrayList<RegexFindReplace>(commentLinkNames.size());
    for (String commentLinkName : commentLinkNames) {
        String match = cfg.getString("CommentLink", commentLinkName, "match");
        String link = cfg.getString("CommentLink", commentLinkName, "link");
        commentLinks.add(new RegexFindReplace(match, link));
    }
    config.setCommentLinks(commentLinks);
    return config;
}
#method_after
private GerritConfig create() {
    final GerritConfig config = new GerritConfig();
    config.setCanonicalUrl(canonicalWebUrl);
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseRepoDownload(cfg.getBoolean("repo", null, "showdownloadcommand", false));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    final String gitwebUrl = cfg.getString("gitweb", null, "url");
    if (gitwebUrl != null) {
        config.setGitwebLink(new GitwebLink(gitwebUrl));
    }
    config.setSshdAddress(sshInfo != null ? sshInfo.getSshdAddress() : null);
    ArrayList<String> commentLinkNames = new ArrayList<String>(cfg.getSubsections("CommentLink"));
    ArrayList<RegexFindReplace> commentLinks = new ArrayList<RegexFindReplace>(commentLinkNames.size());
    for (String commentLinkName : commentLinkNames) {
        String match = cfg.getString("commentlink", commentLinkName, "match");
        String link = "<a href=\"" + cfg.getString("commentlink", commentLinkName, "link") + "\">$&</a>";
        commentLinks.add(new RegexFindReplace(match, link));
    }
    config.setCommentLinks(commentLinks);
    return config;
}
#end_block

#method_before
private void initReadCategory(final ReviewDb c, final SystemConfig sConfig) throws OrmException {
    final Transaction txn = c.beginTransaction();
    final ApprovalCategory cat;
    final ArrayList<ApprovalCategoryValue> vals;
    cat = new ApprovalCategory(ApprovalCategory.READ, "Read Access");
    cat.setPosition((short) -1);
    cat.setFunctionName(NoOpFunction.NAME);
    vals = new ArrayList<ApprovalCategoryValue>();
    vals.add(value(cat, 2, "Upload permission"));
    vals.add(value(cat, 1, "Read access"));
    vals.add(value(cat, -1, "No access"));
    c.approvalCategories().insert(Collections.singleton(cat), txn);
    c.approvalCategoryValues().insert(vals, txn);
    txn.commit();
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.anonymousGroupId));
        read.setMaxValue((short) 1);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.adminGroupId));
        read.setMaxValue((short) 1);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
}
#method_after
private void initReadCategory(final ReviewDb c, final SystemConfig sConfig) throws OrmException {
    final Transaction txn = c.beginTransaction();
    final ApprovalCategory cat;
    final ArrayList<ApprovalCategoryValue> vals;
    cat = new ApprovalCategory(ApprovalCategory.READ, "Read Access");
    cat.setPosition((short) -1);
    cat.setFunctionName(NoOpFunction.NAME);
    vals = new ArrayList<ApprovalCategoryValue>();
    vals.add(value(cat, 2, "Upload permission"));
    vals.add(value(cat, 1, "Read access"));
    vals.add(value(cat, -1, "No access"));
    c.approvalCategories().insert(Collections.singleton(cat), txn);
    c.approvalCategoryValues().insert(vals, txn);
    txn.commit();
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.anonymousGroupId));
        read.setMaxValue((short) 2);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.adminGroupId));
        read.setMaxValue((short) 1);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    final String reqName = project.getName();
    if (!canUpload()) {
        throw new Failure(1, "fatal: Upload denied for project '" + reqName + "'", new SecurityException("Account lacks Upload permission"));
    }
    if (project.isUseContributorAgreements()) {
        verifyActiveContributorAgreement();
    }
    refLogIdent = currentUser.newPersonIdent();
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    rp = new ReceivePack(repo);
    rp.setAllowCreates(true);
    rp.setAllowDeletes(true);
    rp.setAllowNonFastForwards(true);
    rp.setCheckReceivedObjects(true);
    rp.setRefLogIdent(refLogIdent);
    rp.setPreReceiveHook(new PreReceiveHook() {

        public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            parseCommands(commands);
            if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
                createNewChanges();
            }
            doReplaces();
        }
    });
    rp.setPostReceiveHook(new PostReceiveHook() {

        public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            for (final ReceiveCommand c : commands) {
                if (c.getResult() == Result.OK) {
                    if (isHead(c)) {
                        switch(c.getType()) {
                            case CREATE:
                                insertBranchEntity(c);
                                autoCloseChanges(c);
                                break;
                            case DELETE:
                                deleteBranchEntity(c);
                                break;
                            case UPDATE:
                            case UPDATE_NONFASTFORWARD:
                                autoCloseChanges(c);
                                break;
                        }
                    }
                    if (isHead(c) || isTag(c)) {
                        // We only schedule heads and tags for replication.
                        // Change refs are scheduled when they are created.
                        // 
                        replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                    }
                }
            }
        }
    });
    rp.receive(in, out, err);
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        // Make sure there isn't anything buffered; we want to give the
        // push client a chance to display its status report before we
        // show our own messages on standard error.
        // 
        out.flush();
        final String url = canonicalWebUrl;
        final PrintWriter msg = toPrintWriter(err);
        msg.write("\nNew Changes:\n");
        for (final Change.Id c : allNewChanges) {
            msg.write("  " + url + c.get() + "\n");
        }
        msg.write('\n');
        msg.flush();
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!canUpload()) {
        final String reqName = project.getName();
        throw new Failure(1, "fatal: Upload denied for project '" + reqName + "'", new SecurityException("Account lacks Upload permission"));
    }
    if (project.isUseContributorAgreements()) {
        verifyActiveContributorAgreement();
    }
    refLogIdent = currentUser.newPersonIdent();
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    rp = new ReceivePack(repo);
    rp.setAllowCreates(true);
    rp.setAllowDeletes(true);
    rp.setAllowNonFastForwards(true);
    rp.setCheckReceivedObjects(true);
    rp.setRefLogIdent(refLogIdent);
    rp.setPreReceiveHook(new PreReceiveHook() {

        public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            parseCommands(commands);
            if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
                createNewChanges();
            }
            doReplaces();
        }
    });
    rp.setPostReceiveHook(new PostReceiveHook() {

        public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            for (final ReceiveCommand c : commands) {
                if (c.getResult() == Result.OK) {
                    if (isHead(c)) {
                        switch(c.getType()) {
                            case CREATE:
                                insertBranchEntity(c);
                                autoCloseChanges(c);
                                break;
                            case DELETE:
                                deleteBranchEntity(c);
                                break;
                            case UPDATE:
                            case UPDATE_NONFASTFORWARD:
                                autoCloseChanges(c);
                                break;
                        }
                    }
                    if (isHead(c) || isTag(c)) {
                        // We only schedule heads and tags for replication.
                        // Change refs are scheduled when they are created.
                        // 
                        replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                    }
                }
            }
        }
    });
    rp.receive(in, out, err);
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        // Make sure there isn't anything buffered; we want to give the
        // push client a chance to display its status report before we
        // show our own messages on standard error.
        // 
        out.flush();
        final String url = canonicalWebUrl;
        final PrintWriter msg = toPrintWriter(err);
        msg.write("\nNew Changes:\n");
        for (final Change.Id c : allNewChanges) {
            msg.write("  " + url + c.get() + "\n");
        }
        msg.write('\n');
        msg.flush();
    }
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            who.setDisplayName(m.get(accountFullName));
            who.setSshUserName(m.get(accountSshUserName));
            if (accountEmailAddress != null) {
                who.setEmailAddress(m.get(accountEmailAddress));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setSshUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    final HashMap<String, String> params = new HashMap<String, String>();
    params.put(USERNAME, username);
    if (groupNeedsAccount) {
        if (account == null) {
            account = findAccount(ctx, username);
        }
        for (final String name : groupMemberQueryList.get(0).getParameters()) {
            params.put(name, account.get(name));
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (LdapQuery groupMemberQuery : groupMemberQueryList) {
        for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
            NamingEnumeration groups = r.getAll(memberField).getAll();
            while (groups.hasMore()) {
                final String name = String.valueOf(groups.next());
                final AccountGroup group = groupCache.lookup(name);
                if (group != null && isLdapGroup(group)) {
                    actual.add(group.getId());
                }
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#method_after
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    if (account == null) {
        account = findAccount(ctx, username);
    }
    final HashMap<String, String> params = new HashMap<String, String>();
    params.put(USERNAME, username);
    if (groupNeedsAccount) {
        for (final String name : groupMemberQueryList.get(0).getParameters()) {
            params.put(name, account.get(name));
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (LdapQuery groupMemberQuery : groupMemberQueryList) {
        for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
            final String name = r.get(groupName);
            final AccountGroup group = groupCache.lookup(name);
            if (group != null && isLdapGroup(group)) {
                actual.add(group.getId());
            }
        }
    }
    NamingEnumeration groups = account.getAll(accountMemberField).getAll();
    while (groups.hasMore()) {
        final String dn = (String) groups.next();
        for (String cn : groupsFor(ctx, dn)) {
            AccountGroup group = groupCache.lookup(cn);
            if (null != group && isLdapGroup(group)) {
                actual.add(group.getId());
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#end_block

#method_before
@Override
public List<RealmProperty> getProperties(final AccountGroup group) {
    if (!isLdapGroup(group)) {
        return Collections.emptyList();
    }
    try {
        final DirContext ctx = open();
        try {
            final Map<String, String> params = new HashMap<String, String>();
            params.put(GROUPNAME, group.getName());
            final List<RealmProperty> props = new ArrayList<RealmProperty>();
            final List<LdapQuery.Result> q = new ArrayList<LdapQuery.Result>();
            for (LdapQuery groupByNameQuery : groupByNameQueryList) {
                q.addAll(groupByNameQuery.query(ctx, params));
            }
            switch(q.size()) {
                case 0:
                    log.warn("Group \"" + group.getName() + "\" not found in LDAP.");
                    props.add(new RealmProperty("error", "NOT FOUND"));
                    break;
                case 1:
                    for (final String name : q.get(0).keySet()) {
                        props.add(new RealmProperty(name, q.get(0).get(name)));
                    }
                    Collections.sort(props, new Comparator<RealmProperty>() {

                        @Override
                        public int compare(final RealmProperty a, final RealmProperty b) {
                            int sort = classOf(a) - classOf(b);
                            if (sort == 0)
                                sort = a.getName().compareTo(b.getName());
                            return sort;
                        }

                        private int classOf(final RealmProperty p) {
                            final String n = p.getName();
                            if ("dn".equals(n) || "distinguishedName".equals(n))
                                return 0;
                            if ("cn".equals(n))
                                return 1;
                            return 5000;
                        }
                    });
                    break;
                default:
                    log.warn("Group \"" + group.getName() + "\" has multiple matches in LDAP: " + q);
                    props.add(new RealmProperty("error", "MULTIPLE MATCHES"));
                    break;
            }
            return props;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP directory for group " + group.getName(), e);
        return Collections.emptyList();
    }
}
#method_after
@Override
public List<RealmProperty> getProperties(final AccountGroup group) {
    if (!isLdapGroup(group)) {
        return Collections.emptyList();
    }
    try {
        final DirContext ctx = open();
        try {
            final Map<String, String> params = new HashMap<String, String>();
            params.put(GROUPNAME, group.getName());
            final List<RealmProperty> props = new ArrayList<RealmProperty>();
            final List<LdapQuery.Result> q = new ArrayList<LdapQuery.Result>();
            for (LdapQuery groupByNameQuery : groupByNameQueryList) {
                q.addAll(groupByNameQuery.query(ctx, params));
            }
            switch(q.size()) {
                case 0:
                    log.warn("Group \"" + group.getName() + "\" not found in LDAP.");
                    props.add(new RealmProperty("error", "NOT FOUND"));
                    break;
                case 1:
                    for (final String name : q.get(0).map().keySet()) {
                        props.add(new RealmProperty(name, q.get(0).get(name)));
                    }
                    Collections.sort(props, new Comparator<RealmProperty>() {

                        @Override
                        public int compare(final RealmProperty a, final RealmProperty b) {
                            int sort = classOf(a) - classOf(b);
                            if (sort == 0)
                                sort = a.getName().compareTo(b.getName());
                            return sort;
                        }

                        private int classOf(final RealmProperty p) {
                            final String n = p.getName();
                            if ("dn".equals(n) || "distinguishedName".equals(n))
                                return 0;
                            if ("cn".equals(n))
                                return 1;
                            return 5000;
                        }
                    });
                    break;
                default:
                    log.warn("Group \"" + group.getName() + "\" has multiple matches in LDAP: " + q);
                    props.add(new RealmProperty("error", "MULTIPLE MATCHES"));
                    break;
            }
            return props;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP directory for group " + group.getName(), e);
        return Collections.emptyList();
    }
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            who.setDisplayName(m.get(accountFullName));
            who.setSshUserName(m.get(accountSshUserName));
            if (accountEmailAddress != null) {
                who.setEmailAddress(m.get(accountEmailAddress));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
private void authenticate(String dn, String password) throws AccountException {
    final Properties env = new Properties();
    env.put(Context.INITIAL_CONTEXT_FACTORY, LDAP);
    env.put(Context.PROVIDER_URL, server);
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        new InitialDirContext(env).close();
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#end_block

#method_before
@Override
public String toString() {
    String data = "";
    try {
        String.valueOf(atts.get("dn").get(0));
    } catch (NamingException e) {
    }
    return data;
}
#method_after
@Override
public String toString() {
    try {
        return getDN();
    } catch (NamingException e) {
        return "";
    }
}
#end_block

#method_before
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#method_after
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
@Override
public void changeSshUserName(final String newName, final AsyncCallback<VoidResult> callback) {
    if (!realm.allowsEdit(Account.FieldName.SSH_USER_NAME)) {
        callback.onFailure(new NameAlreadyUsedException());
        return;
    }
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final Account me = db.accounts().get(getAccountId());
            if (me == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (newName != null && !sshUserNamePattern.matcher(newName).matches()) {
                throw new Failure(new InvalidSshUserNameException());
            }
            final Account other;
            if (newName != null) {
                other = db.accounts().bySshUserName(newName);
            } else {
                other = null;
            }
            if (other != null) {
                if (other.getId().equals(me.getId())) {
                    return VoidResult.INSTANCE;
                } else {
                    throw new Failure(new NameAlreadyUsedException());
                }
            }
            final String oldName = me.getSshUserName();
            me.setSshUserName(newName);
            db.accounts().update(Collections.singleton(me));
            uncacheSshKeys(oldName);
            uncacheSshKeys(newName);
            accountCache.evict(me.getId());
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
@Override
public void changeSshUserName(final String newName, final AsyncCallback<VoidResult> callback) {
    if (!realm.allowsEdit(Account.FieldName.SSH_USER_NAME)) {
        callback.onFailure(new NameAlreadyUsedException());
        return;
    }
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final Account me = db.accounts().get(getAccountId());
            if (me == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (newName != null && !SSH_USER_NAME_PATTERN.matcher(newName).matches()) {
                throw new Failure(new InvalidSshUserNameException());
            }
            final Account other;
            if (newName != null) {
                other = db.accounts().bySshUserName(newName);
            } else {
                other = null;
            }
            if (other != null) {
                if (other.getId().equals(me.getId())) {
                    return VoidResult.INSTANCE;
                } else {
                    throw new Failure(new NameAlreadyUsedException());
                }
            }
            final String oldName = me.getSshUserName();
            me.setSshUserName(newName);
            db.accounts().update(Collections.singleton(me));
            uncacheSshKeys(oldName);
            uncacheSshKeys(newName);
            accountCache.evict(me.getId());
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Override
public PersonIdent get() {
    String name = gerritConfig.getString("user", null, "name");
    if (name == null) {
        name = "Gerrit Code Review";
    }
    String email = gerritConfig.get(UserConfig.KEY).getCommitterEmail();
    if (email == null || email.length() == 0) {
        email = "gerrit@localhost";
    }
    return new PersonIdent(name, email);
}
#method_after
@Override
public PersonIdent get() {
    return new PersonIdent(name, email);
}
#end_block

#method_before
private static List<String> optionalList(final Config config, final String name) {
    String[] s = config.getStringList("ldap", null, name);
    if (s == null || s.length == 0) {
        return null;
    }
    final List<String> vlist = new ArrayList<String>();
    for (int i = 0; i < s.length; i++) {
        vlist.add(s[i]);
    }
    return vlist;
}
#method_after
private static List<String> optionalList(final Config config, final String name) {
    String[] s = config.getStringList("ldap", null, name);
    return Arrays.asList(s);
}
#end_block

#method_before
private static List<String> requiredList(final Config config, final String name) {
    List<String> vlist = optionalList(config, name);
    if (vlist == null) {
        throw new IllegalArgumentException("No ldap." + name + " configured");
    }
    return vlist;
}
#method_after
private static List<String> requiredList(final Config config, final String name) {
    List<String> vlist = optionalList(config, name);
    if (vlist.isEmpty()) {
        throw new IllegalArgumentException("No ldap " + name + " configured");
    }
    return vlist;
}
#end_block

#method_before
public void strongestApprovals(final Change.Id id, final AsyncCallback<ApprovalDetail> callback) {
    run(callback, new Action<ApprovalDetail>() {

        public ApprovalDetail run(ReviewDb db) throws OrmException {
            final List<PatchSet> last_pset = db.patchSets().lastChange(id).toList();
            if (last_pset.isEmpty()) {
                return null;
            }
            final PatchSet.Id ps_id = last_pset.get(0).getId();
            final Map<ApprovalCategory.Id, PatchSetApproval> have = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
            for (PatchSetApproval a : db.patchSetApprovals().byPatchSet(ps_id)) {
                boolean keep = true;
                if (have.containsKey(a.getCategoryId())) {
                    final short oldValue = have.get(a.getCategoryId()).getValue();
                    final short newValue = a.getValue();
                    keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                }
                if (keep) {
                    have.put(a.getCategoryId(), a);
                }
            }
            final ApprovalDetail ad = new ApprovalDetail(getAccountId());
            for (PatchSetApproval a : have.values()) {
                ad.add(a);
            }
            return ad;
        }
    });
}
#method_after
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        fs.normalize(approvalTypes.getApprovalType(ca.getCategoryId()), ca);
                        boolean keep = true;
                        if (psas.containsKey(ca.getCategoryId())) {
                            final short oldValue = psas.get(ca.getCategoryId()).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(ca.getCategoryId(), ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /* The user has no access to see this change, so we
             * simply do not provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable(true);
    byOwner = new ChangeTable.Section("", ChangeTable.ApprovalViewType.STRONGEST);
    forReview = new ChangeTable.Section("", ChangeTable.ApprovalViewType.MINE);
    closed = new ChangeTable.Section("", ChangeTable.ApprovalViewType.STRONGEST);
    table.addSection(byOwner);
    table.addSection(forReview);
    table.addSection(closed);
    add(table);
    table.setSavePointerId(Link.toAccountDashboard(ownerId));
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable(true);
    byOwner = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null);
    forReview = new ChangeTable.Section("", ApprovalViewType.USER, ownerId);
    closed = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null);
    table.addSection(byOwner);
    table.addSection(forReview);
    table.addSection(closed);
    add(table);
    table.setSavePointerId(Link.toAccountDashboard(ownerId));
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, S_ICON_CELL);
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, S_DATA_CELL);
    }
    fmt.addStyleName(row, C_ID, S_C_ID);
    fmt.addStyleName(row, C_SUBJECT, S_C_SUBJECT);
    fmt.addStyleName(row, C_PROJECT, S_C_PROJECT);
    fmt.addStyleName(row, C_BRANCH, S_C_PROJECT);
    fmt.addStyleName(row, C_LAST_UPDATE, S_C_LAST_UPDATE);
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, "approvalscore");
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, S_ICON_CELL);
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, S_DATA_CELL);
    }
    fmt.addStyleName(row, C_ID, S_C_ID);
    fmt.addStyleName(row, C_SUBJECT, S_C_SUBJECT);
    fmt.addStyleName(row, C_PROJECT, S_C_PROJECT);
    fmt.addStyleName(row, C_BRANCH, S_C_PROJECT);
    fmt.addStyleName(row, C_LAST_UPDATE, S_C_LAST_UPDATE);
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, final ApprovalViewType viewType) {
    final String idstr = c.getKey().abbreviate();
    table.setWidget(row, C_ARROW, null);
    if (Gerrit.isSignedIn()) {
        setStar(row, c);
    }
    table.setWidget(row, C_ID, new TableChangeLink(idstr, c));
    String s = c.getSubject();
    if (s.length() > 80) {
        s = s.substring(0, 80);
    }
    if (c.getStatus() != null && c.getStatus() != Change.Status.NEW) {
        s += " (" + c.getStatus().name() + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(s, c));
    table.setWidget(row, C_OWNER, link(c.getOwner()));
    table.setWidget(row, C_PROJECT, new ProjectOpenLink(c.getProject().getKey()));
    table.setText(row, C_BRANCH, c.getBranch());
    table.setText(row, C_LAST_UPDATE, mediumFormat(c.getLastUpdatedOn()));
    switch(viewType) {
        case NONE:
            break;
        case MINE:
            PatchUtil.DETAIL_SVC.myApprovals(c.getId(), approvalFormatter(row));
            break;
        case STRONGEST:
            PatchUtil.DETAIL_SVC.strongestApprovals(c.getId(), approvalFormatter(row));
            break;
    }
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c) {
    final String idstr = c.getKey().abbreviate();
    table.setWidget(row, C_ARROW, null);
    if (Gerrit.isSignedIn()) {
        setStar(row, c);
    }
    table.setWidget(row, C_ID, new TableChangeLink(idstr, c));
    String s = c.getSubject();
    if (s.length() > 80) {
        s = s.substring(0, 80);
    }
    if (c.getStatus() != null && c.getStatus() != Change.Status.NEW) {
        s += " (" + c.getStatus().name() + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(s, c));
    table.setWidget(row, C_OWNER, link(c.getOwner()));
    table.setWidget(row, C_PROJECT, new ProjectOpenLink(c.getProject().getKey()));
    table.setText(row, C_BRANCH, c.getBranch());
    table.setText(row, C_LAST_UPDATE, mediumFormat(c.getLastUpdatedOn()));
    setRowItem(row, c);
}
#end_block

#method_before
GerritCallback<ApprovalDetail> approvalFormatter(final int row) {
    return new GerritCallback<ApprovalDetail>() {

        @Override
        public void onSuccess(final ApprovalDetail detail) {
            final CellFormatter fmt = table.getCellFormatter();
            final Map<ApprovalCategory.Id, PatchSetApproval> am = detail.getApprovalMap();
            int col = BASE_COLUMNS;
            for (final ApprovalType type : approvalTypes) {
                final PatchSetApproval ca = am.get(type.getCategory().getId());
                if (ca == null || ca.getValue() == 0) {
                    table.clearCell(row, col);
                } else if (type.isMaxNegative(ca)) {
                    table.setWidget(row, col, Gerrit.ICONS.redNot().createImage());
                } else if (type.isMaxPositive(ca)) {
                    table.setWidget(row, col, Gerrit.ICONS.greenCheck().createImage());
                } else {
                    String vstr = String.valueOf(ca.getValue());
                    if (ca.getValue() > 0) {
                        vstr = "+" + vstr;
                        fmt.removeStyleName(row, col, "negscore");
                        fmt.addStyleName(row, col, "posscore");
                    } else {
                        fmt.addStyleName(row, col, "negscore");
                        fmt.removeStyleName(row, col, "posscore");
                    }
                    table.setText(row, col, vstr);
                }
                col++;
            }
        }
    };
}
#method_after
GerritCallback<ApprovalSummarySet> approvalFormatter(final int dataBegin, final int rows) {
    return new GerritCallback<ApprovalSummarySet>() {

        @Override
        public void onSuccess(final ApprovalSummarySet as) {
            Map<Change.Id, ApprovalSummary> ids = as.getSummaryMap();
            AccountInfoCache aic = as.getAccountInfoCache();
            for (int row = dataBegin; row < dataBegin + rows; row++) {
                final ChangeInfo c = getRowItem(row);
                if (ids.containsKey(c.getId())) {
                    displayApprovals(row, ids.get(c.getId()), aic);
                }
            }
        }
    };
}
#end_block

#method_before
public void display(final List<ChangeInfo> changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    }
    if (sz == 0) {
        if (hadData) {
            parent.insertNoneRow(dataBegin);
        }
    } else {
        if (!hadData) {
            parent.removeRow(dataBegin);
        }
        while (rows < sz) {
            parent.insertChangeRow(dataBegin + rows);
            rows++;
        }
        for (int i = 0; i < sz; i++) {
            parent.populateChangeRow(dataBegin + i, changeList.get(i), viewType);
        }
    }
}
#method_after
public void display(final List<ChangeInfo> changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    }
    if (sz == 0) {
        if (hadData) {
            parent.insertNoneRow(dataBegin);
        }
    } else {
        Set<Change.Id> cids = new HashSet<Change.Id>();
        if (!hadData) {
            parent.removeRow(dataBegin);
        }
        while (rows < sz) {
            parent.insertChangeRow(dataBegin + rows);
            rows++;
        }
        for (int i = 0; i < sz; i++) {
            ChangeInfo c = changeList.get(i);
            parent.populateChangeRow(dataBegin + i, c);
            cids.add(c.getId());
        }
        switch(viewType) {
            case NONE:
                break;
            case USER:
                PatchUtil.DETAIL_SVC.userApprovals(cids, ownerId, parent.approvalFormatter(dataBegin, rows));
                break;
            case STRONGEST:
                PatchUtil.DETAIL_SVC.strongestApprovals(cids, parent.approvalFormatter(dataBegin, rows));
                break;
        }
    }
}
#end_block

#method_before
protected final CmdLineParser newCmdLineParserInstance(final Object bean) {
    Field f = null;
    ApproveCmdLineParser parser = new ApproveCmdLineParser(bean);
    try {
        f = CmdOption.class.getField("value");
        for (CmdOption c : optionList) {
            parser.addOption(new FieldSetter(c, f), c);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return parser;
}
#method_after
protected final CmdLineParser newCmdLineParserInstance(final Object bean) {
    CmdLineParser parser = new CmdLineParser(bean);
    for (CmdOption c : optionList) {
        parser.addOption(c, c);
    }
    return parser;
}
#end_block

#method_before
@Override
public final void start() throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            getApprovalNames();
            parseCommandLine();
            PrintWriter p = toPrintWriter(out);
            validateParameters();
            try {
                final Transaction txn = db.beginTransaction();
                final Change.Id cid = new Change.Id(changeId);
                final Change c = db.changes().get(cid);
                StringBuffer sb = new StringBuffer();
                sb.append("Patch Set: ");
                sb.append(c.currentPatchSetId().get());
                sb.append(" ");
                for (CmdOption co : optionList) {
                    String message = "";
                    Short score = co.value();
                    ApprovalCategory.Id category = new ApprovalCategory.Id(co.approvalKey());
                    if (co.value() != null) {
                        addApproval(c, category, co.value(), txn);
                    } else {
                        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(c.currentPatchSetId(), currentUser.getAccountId(), category);
                        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
                        if (psa == null) {
                            score = null;
                        } else {
                            score = psa.getValue();
                        }
                    }
                    if (score != null) {
                        message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
                    }
                    sb.append(" " + message + ";");
                }
                sb.deleteCharAt(sb.length() - 1);
                sb.append("\n\n");
                if (changeComment != null) {
                    sb.append(changeComment);
                }
                String uuid = ChangeUtil.messageUUID(db);
                ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(cid, uuid), currentUser.getAccountId());
                cm.setMessage(sb.toString());
                db.changeMessages().insert(Collections.singleton(cm), txn);
                ChangeUtil.updated(c);
                db.changes().update(Collections.singleton(c), txn);
                txn.commit();
                sendMail(c, c.currentPatchSetId(), cm);
                p.print(sb.toString() + "\n");
                p.flush();
            } catch (OrmException e) {
                throw new Failure(CMD_ERR, "Error accessing the database\n" + "Detailed message:\n" + e.getMessage());
            } catch (EmailException e) {
                throw new Failure(CMD_ERR, "Error when trying to send email\n" + "Detailed message:\n" + e.getMessage());
            } catch (Exception e) {
                throw new Failure(CMD_ERR, "Received an error\n" + "Detailed message:\n" + e.getMessage());
            }
        }
    });
}
#method_after
@Override
public final void start() throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            getApprovalNames();
            parseCommandLine();
            final Transaction txn = db.beginTransaction();
            final PatchSet ps = db.patchSets().get(patchSetId);
            if (ps == null) {
                throw new UnloggedFailure(CMD_ERR, "Invalid patchset id");
            }
            final Change.Id cid = ps.getId().getParentKey();
            final ChangeControl control = changeControlFactory.validateFor(cid);
            final Change c = control.getChange();
            if (c.getStatus().isClosed()) {
                throw new UnloggedFailure(CMD_ERR, "Change is closed.");
            }
            StringBuffer sb = new StringBuffer();
            sb.append("Patch Set ");
            sb.append(patchSetId.get());
            sb.append(": ");
            for (CmdOption co : optionList) {
                ApprovalCategory.Id category = new ApprovalCategory.Id(co.approvalKey());
                PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
                PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
                Short score = co.value();
                if (score != null) {
                    addApproval(psaKey, score, c, co, txn);
                } else {
                    if (psa == null) {
                        score = 0;
                        addApproval(psaKey, score, c, co, txn);
                    } else {
                        score = psa.getValue();
                    }
                }
                String message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
                sb.append(" " + message + ";");
            }
            sb.deleteCharAt(sb.length() - 1);
            sb.append("\n\n");
            if (changeComment != null) {
                sb.append(changeComment);
            }
            String uuid = ChangeUtil.messageUUID(db);
            ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(cid, uuid), currentUser.getAccountId());
            cm.setMessage(sb.toString());
            db.changeMessages().insert(Collections.singleton(cm), txn);
            ChangeUtil.updated(c);
            db.changes().update(Collections.singleton(c), txn);
            txn.commit();
            sendMail(c, c.currentPatchSetId(), cm);
        }
    });
}
#end_block

#method_before
private void addApproval(final Change c, final ApprovalCategory.Id cat, final short score, final Transaction txn) throws OrmException {
    PatchSetApproval.Key psaKey = new PatchSetApproval.Key(c.currentPatchSetId(), currentUser.getAccountId(), cat);
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    if (psa == null) {
        psa = new PatchSetApproval(psaKey, score);
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        psa.setGranted();
        psa.setValue(score);
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#method_after
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final CmdOption co, final Transaction txn) throws OrmException, UnloggedFailure {
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    boolean insert = false;
    if (psa == null) {
        insert = true;
        psa = new PatchSetApproval(psaKey, score);
    }
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, patchSetId, approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw new UnloggedFailure(CMD_ERR, co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    if (insert) {
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#end_block

#method_before
private void getApprovalNames() throws OrmException {
    SortedMap<Short, String> acvMap = new TreeMap<Short, String>();
    optionList = new ArrayList<CmdOption>();
    ResultSet<ApprovalCategory> rs = db.approvalCategories().all();
    for (ApprovalCategory c : rs) {
        if (c.getFunctionName().equals("MaxWithBlock")) {
            ResultSet<ApprovalCategoryValue> acvrs = db.approvalCategoryValues().byCategory(c.getId());
            short min = Short.MAX_VALUE;
            short max = Short.MIN_VALUE;
            String usage = "";
            for (ApprovalCategoryValue acv : acvrs) {
                if (min > acv.getValue()) {
                    min = acv.getValue();
                }
                if (max < acv.getValue()) {
                    max = acv.getValue();
                }
                acvMap.put(acv.getValue(), acv.getName());
            }
            usage += "Score for " + c.getName() + "\n";
            // This is to make sure that the values are in sorted order.
            Iterator<Short> i = acvMap.keySet().iterator();
            while (i.hasNext()) {
                Short key = i.next();
                usage += String.format("%4d", key) + "  -  " + acvMap.get(key) + "\n";
            }
            optionList.add(new CmdOption("--" + c.getName().toLowerCase().replace(' ', '-'), usage, c.getId().get(), min, max, c.getName()));
            usage = "";
            acvMap.clear();
        }
    }
}
#method_after
private void getApprovalNames() throws OrmException {
    optionList = new ArrayList<CmdOption>();
    for (ApprovalType type : approvalTypes.getApprovalTypes()) {
        String usage = "";
        final ApprovalCategory category = type.getCategory();
        usage = "Score for " + category.getName() + "\n";
        for (ApprovalCategoryValue v : type.getValues()) {
            usage += String.format("%4d", v.getValue()) + "  -  " + v.getName() + "\n";
        }
        optionList.add(new CmdOption("--" + category.getName().toLowerCase().replace(' ', '-'), usage, category.getId().get(), type.getMin().getValue(), type.getMax().getValue(), category.getName()));
    }
}
#end_block

#method_before
public void setHttpServletRequest(final HttpServletRequest req) {
    myUrl = GerritServer.serverUrl(req);
}
#method_after
@Inject(optional = true)
void setHttpServletRequest(final HttpServletRequest req) {
    httpRequestUrl = GerritServer.serverUrl(req);
}
#end_block

#method_before
public void send() throws EmailException {
    if (!server.isOutgoingMailEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            // If we are impersonating a user, make sure they receive a CC of
            // this message so they can always review and audit what we sent
            // on their behalf to others.
            // 
            add(RecipientType.CC, fromId);
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
        }
        try {
            final SMTPClient client = server.createOutgoingMail();
            try {
                if (!client.setSender(smtpFromAddress.email)) {
                    throw new EmailException("SMTP server rejected from " + smtpFromAddress);
                }
                for (String emailAddress : smtpRcptTo) {
                    if (!client.addRecipient(emailAddress)) {
                        String error = client.getReplyString();
                        throw new EmailException("SMTP server rejected rcpt " + emailAddress + ": " + error);
                    }
                }
                if (headers.get("Message-ID").isEmpty()) {
                    final StringBuilder rndid = new StringBuilder();
                    rndid.append("<");
                    rndid.append(System.currentTimeMillis());
                    rndid.append("-");
                    rndid.append(Integer.toString(RNG.nextInt(999999), 36));
                    rndid.append("@");
                    rndid.append(InetAddress.getLocalHost().getCanonicalHostName());
                    rndid.append(">");
                    setHeader("Message-ID", rndid.toString());
                }
                Writer w = client.sendMessageData();
                if (w == null) {
                    throw new EmailException("SMTP server rejected message body");
                }
                w = new BufferedWriter(w);
                for (Map.Entry<String, EmailHeader> h : headers.entrySet()) {
                    if (!h.getValue().isEmpty()) {
                        w.write(h.getKey());
                        w.write(": ");
                        h.getValue().write(w);
                        w.write("\r\n");
                    }
                }
                w.write("\r\n");
                w.write(body.toString());
                w.flush();
                w.close();
                if (!client.completePendingCommand()) {
                    throw new EmailException("SMTP server rejected message body");
                }
                client.logout();
            } finally {
                client.disconnect();
            }
        } catch (IOException e) {
            throw new EmailException("Cannot send outgoing email", e);
        }
    }
}
#method_after
public void send() throws EmailException {
    if (!emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            // If we are impersonating a user, make sure they receive a CC of
            // this message so they can always review and audit what we sent
            // on their behalf to others.
            // 
            add(RecipientType.CC, fromId);
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
        }
        if (headers.get("Message-ID").isEmpty()) {
            final StringBuilder rndid = new StringBuilder();
            rndid.append("<");
            rndid.append(System.currentTimeMillis());
            rndid.append("-");
            rndid.append(Integer.toString(RNG.nextInt(999999), 36));
            rndid.append("@");
            rndid.append(SystemReader.getInstance().getHostname());
            rndid.append(">");
            setHeader("Message-ID", rndid.toString());
        }
        emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#end_block

#method_before
protected void init() {
    smtpFromAddress = computeFrom();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    setHeader("MIME-Version", "1.0");
    setHeader("Content-Type", "text/plain; charset=UTF-8");
    setHeader("Content-Disposition", "inline");
    setHeader("User-Agent", "Gerrit/" + Version.getVersion());
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-ChangeId", "" + change.getChangeId());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (change != null && db != null) {
        if (patchSet == null) {
            try {
                patchSet = db.patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = PatchSetInfoFactory.patchSetInfoFromPatchSetId(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#method_after
protected void init() {
    smtpFromAddress = computeFrom();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-ChangeId", "" + change.getChangeId());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (change != null && db != null) {
        if (patchSet == null) {
            try {
                patchSet = db.patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = patchSetInfoFactory.get(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#end_block

#method_before
private String getGerritHost() {
    if (server.getCanonicalURL() != null) {
        try {
            return new URL(server.getCanonicalURL()).getHost();
        } catch (MalformedURLException e) {
        // Try something else.
        }
    }
    if (myUrl != null) {
        try {
            return new URL(myUrl).getHost();
        } catch (MalformedURLException e) {
        // Try something else.
        }
    }
    // 
    try {
        return InetAddress.getLocalHost().getCanonicalHostName();
    } catch (UnknownHostException e) {
        return "localhost";
    }
}
#method_after
protected String getGerritHost() {
    if (getGerritUrl() != null) {
        try {
            return new URL(getGerritUrl()).getHost();
        } catch (MalformedURLException e) {
        // Try something else.
        }
    }
    // 
    return SystemReader.getInstance().getHostname();
}
#end_block

#method_before
private String getGerritUrl() {
    if (server.getCanonicalURL() != null) {
        return server.getCanonicalURL();
    }
    return myUrl;
}
#method_after
protected String getGerritUrl() {
    if (canonicalWebUrl != null) {
        return canonicalWebUrl;
    }
    return httpRequestUrl;
}
#end_block

#method_before
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr.email);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#method_after
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(DS).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
    bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }).to(new TypeLiteral<Database<ReviewDb>>() {
    });
    bind(new TypeLiteral<Database<ReviewDb>>() {
    }).toProvider(ReviewDbProvider.class).in(SINGLETON);
    bind(SystemConfig.class).toProvider(SystemConfigProvider.class).in(SINGLETON);
    bind(File.class).annotatedWith(SitePath.class).toProvider(SitePathProvider.class);
    bind(Config.class).annotatedWith(GerritServerConfig.class).toProvider(GerritServerConfigProvider.class).in(SINGLETON);
    bind(GerritServer.class);
    bind(ContactStore.class).toProvider(EncryptedContactStoreProvider.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(RegisterNewEmailSender.Factory.class).toProvider(FactoryProvider.newFactory(RegisterNewEmailSender.Factory.class, RegisterNewEmailSender.class));
    bind(AddReviewerSender.Factory.class).toProvider(FactoryProvider.newFactory(AddReviewerSender.Factory.class, AddReviewerSender.class));
    bind(CreateChangeSender.Factory.class).toProvider(FactoryProvider.newFactory(CreateChangeSender.Factory.class, CreateChangeSender.class));
    bind(AbandonedSender.Factory.class).toProvider(FactoryProvider.newFactory(AbandonedSender.Factory.class, AbandonedSender.class));
    bind(CommentSender.Factory.class).toProvider(FactoryProvider.newFactory(CommentSender.Factory.class, CommentSender.class));
}
#method_after
@Override
protected void configure() {
    bind(DS).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
    bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }).to(new TypeLiteral<Database<ReviewDb>>() {
    });
    bind(new TypeLiteral<Database<ReviewDb>>() {
    }).toProvider(ReviewDbProvider.class).in(SINGLETON);
    bind(SystemConfig.class).toProvider(SystemConfigProvider.class).in(SINGLETON);
    bind(File.class).annotatedWith(SitePath.class).toProvider(SitePathProvider.class);
    bind(Config.class).annotatedWith(GerritServerConfig.class).toProvider(GerritServerConfigProvider.class).in(SINGLETON);
    bind(AuthConfig.class);
    bind(CacheManager.class).toProvider(CacheManagerProvider.class).in(SINGLETON);
    bind(SshKeyCache.class);
    bind(DiffCache.class);
    bind(GerritServer.class);
    bind(ContactStore.class).toProvider(EncryptedContactStoreProvider.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(AddReviewerSender.Factory.class).toProvider(FactoryProvider.newFactory(AddReviewerSender.Factory.class, AddReviewerSender.class));
    bind(CreateChangeSender.Factory.class).toProvider(FactoryProvider.newFactory(CreateChangeSender.Factory.class, CreateChangeSender.class));
    bind(AbandonedSender.Factory.class).toProvider(FactoryProvider.newFactory(AbandonedSender.Factory.class, AbandonedSender.class));
    bind(CommentSender.Factory.class).toProvider(FactoryProvider.newFactory(CommentSender.Factory.class, CommentSender.class));
}
#end_block

#method_before
public void patchScript(final Patch.Key patchKey, final PatchSet.Id psa, final PatchSet.Id psb, final PatchScriptSettings s, final AsyncCallback<PatchScript> callback) {
    if (psb == null) {
        callback.onFailure(new NoSuchEntityException());
        return;
    }
    run(callback, new PatchScriptAction(server, registry, patchKey, psa, psb, s));
}
#method_after
public void patchScript(final Patch.Key patchKey, final PatchSet.Id psa, final PatchSet.Id psb, final PatchScriptSettings s, final AsyncCallback<PatchScript> callback) {
    if (psb == null) {
        callback.onFailure(new NoSuchEntityException());
        return;
    }
    run(callback, new PatchScriptAction(server, registry, diffCache, patchKey, psa, psb, s));
}
#end_block

#method_before
public void registerEmail(final String address, final AsyncCallback<VoidResult> cb) {
    final PersonIdent gi = server.newGerritPersonIdent();
    final HttpServletRequest req = GerritJsonServlet.getCurrentCall().getHttpServletRequest();
    try {
        final RegisterNewEmailSender sender;
        sender = this.emailSenderFactory.create(address);
        sender.send();
        cb.onSuccess(VoidResult.INSTANCE);
    } catch (EmailException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    } catch (RuntimeException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    }
}
#method_after
public void registerEmail(final String address, final AsyncCallback<VoidResult> cb) {
    final PersonIdent gi = server.newGerritPersonIdent();
    final HttpServletRequest req = GerritJsonServlet.getCurrentCall().getHttpServletRequest();
    try {
        final RegisterNewEmailSender sender;
        sender = registerNewEmailFactory.create(address);
        sender.send();
        cb.onSuccess(VoidResult.INSTANCE);
    } catch (EmailException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    } catch (RuntimeException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    }
}
#end_block

#method_before
private void createContext(final Grid parent, final int row, final int col) {
    parent.resizeRows(row + 1);
    // Show full files
    final CheckBox cb = new CheckBox(PatchUtil.C.showFullFiles());
    cb.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (event.getValue()) {
                // Show a diff of the full files
                scriptSettings.setContext(WHOLE_FILE_CONTEXT);
            } else {
                // Restore the context lines to the user's preference
                initContextLines();
            }
            refresh(false);
        }
    });
    parent.setWidget(row, col + 1, cb);
    // Keep unreviewed
    if (Gerrit.isSignedIn()) {
        final CheckBox ku = new CheckBox(PatchUtil.C.keepUnreviewed());
        ku.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

            @Override
            public void onValueChange(ValueChangeEvent<Boolean> event) {
                updateReviewedStatus(event.getValue() ? 0 : 1);
            }
        });
        parent.setWidget(row, col + 2, ku);
    }
}
#method_after
private void createContext(final Grid parent, final int row, final int col) {
    parent.resizeRows(row + 1);
    // Show full files
    final CheckBox cb = new CheckBox(PatchUtil.C.showFullFiles());
    cb.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (event.getValue()) {
                // Show a diff of the full files
                scriptSettings.setContext(WHOLE_FILE_CONTEXT);
            } else {
                // Restore the context lines to the user's preference
                initContextLines();
            }
            refresh(false);
        }
    });
    parent.setWidget(row, col + 1, cb);
    // "Reviewed" check box
    if (Gerrit.isSignedIn()) {
        final CheckBox ku = new CheckBox(PatchUtil.C.reviewed());
        ku.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

            @Override
            public void onValueChange(ValueChangeEvent<Boolean> event) {
                setReviewedByCurrentUser(event.getValue());
            }
        });
        // Checked by default
        ku.setValue(true);
        parent.setWidget(row, col + 2, ku);
    }
}
#end_block

#method_before
private Widget createNextPrevLinks() {
    final Grid table = new Grid(1, 3);
    final CellFormatter fmt = table.getCellFormatter();
    table.setStyleName("gerrit-SideBySideScreen-LinkTable");
    fmt.setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    fmt.setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_CENTER);
    fmt.setHorizontalAlignment(0, 2, HasHorizontalAlignment.ALIGN_RIGHT);
    // Next and previous
    if (fileList != null) {
        previousFileLink = fileList.getPreviousPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 0, previousFileLink);
        nextFileLink = fileList.getNextPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 2, nextFileLink);
    }
    // Keep unreviewed
    // Up
    final ChangeLink up = new ChangeLink("", patchKey.getParentKey().getParentKey());
    SafeHtml.set(up, SafeHtml.asis(Util.C.upToChangeIconLink()));
    table.setWidget(0, 1, up);
    return table;
}
#method_after
private Widget createNextPrevLinks() {
    final Grid table = new Grid(1, 3);
    final CellFormatter fmt = table.getCellFormatter();
    table.setStyleName("gerrit-SideBySideScreen-LinkTable");
    fmt.setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    fmt.setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_CENTER);
    fmt.setHorizontalAlignment(0, 2, HasHorizontalAlignment.ALIGN_RIGHT);
    if (fileList != null) {
        previousFileLink = fileList.getPreviousPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 0, previousFileLink);
        nextFileLink = fileList.getNextPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 2, nextFileLink);
    }
    final ChangeLink up = new ChangeLink("", patchKey.getParentKey().getParentKey());
    SafeHtml.set(up, SafeHtml.asis(Util.C.upToChangeIconLink()));
    table.setWidget(0, 1, up);
    return table;
}
#end_block

#method_before
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    // Mark this file reviewed
    if (Gerrit.isSignedIn()) {
        updateReviewedStatus(1);
    }
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                if (isNoDifferences(caught) && !isFirst) {
                    historyTable.enableAll(true);
                    showPatch(false);
                } else {
                    super.onFailure(caught);
                }
            }
        }

        private boolean isNoDifferences(final Throwable caught) {
            if (caught instanceof NoDifferencesException) {
                return true;
            }
            return caught instanceof RemoteJsonException && caught.getMessage().equals(NoDifferencesException.MESSAGE);
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#method_after
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        setReviewedByCurrentUser(true);
    }
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        if (contentTable instanceof SideBySideTable && script.getEdits().isEmpty() && !script.getPatchHeader().isEmpty()) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        // True if there are differences between the two patch sets
        boolean hasEdits = !script.getEdits().isEmpty();
        // True if this change is a mode change or a pure rename/copy
        boolean hasMeta = !script.getPatchHeader().isEmpty();
        boolean hasDifferences = hasEdits || hasMeta;
        boolean pureMetaChange = !hasEdits && hasMeta;
        if (contentTable instanceof SideBySideTable && pureMetaChange) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        if (hasDifferences) {
            contentTable.display(patchKey, idSideA, idSideB, script);
            contentTable.display(comments);
            contentTable.finishDisplay();
        }
        showPatch(hasDifferences);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
public void saveDraft(final PatchLineComment comment, final AsyncCallback<PatchLineComment> callback) {
    run(callback, new Action<PatchLineComment>() {

        public PatchLineComment run(ReviewDb db) throws OrmException, Failure {
            if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                throw new Failure(new IllegalStateException("Comment published"));
            }
            final Patch patch = db.patches().get(comment.getKey().getParentKey());
            final Change change;
            if (patch == null) {
                throw new Failure(new NoSuchEntityException());
            }
            change = db.changes().get(patch.getKey().getParentKey().getParentKey());
            assertCanRead(change);
            final Account.Id me = Common.getAccountId();
            if (comment.getKey().get() == null) {
                final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patch.getKey(), ChangeUtil.messageUUID(db)), comment.getLine(), me);
                nc.setSide(comment.getSide());
                nc.setMessage(comment.getMessage());
                db.patchComments().insert(Collections.singleton(nc));
                return nc;
            } else {
                if (!me.equals(comment.getAuthor())) {
                    throw new Failure(new NoSuchEntityException());
                }
                comment.updated();
                db.patchComments().update(Collections.singleton(comment));
                return comment;
            }
        }
    });
}
#method_after
public void saveDraft(final PatchLineComment comment, final AsyncCallback<PatchLineComment> callback) {
    run(callback, new Action<PatchLineComment>() {

        public PatchLineComment run(ReviewDb db) throws OrmException, Failure {
            if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                throw new Failure(new IllegalStateException("Comment published"));
            }
            final Patch patch = db.patches().get(comment.getKey().getParentKey());
            final Change change;
            if (patch == null) {
                throw new Failure(new NoSuchEntityException());
            }
            change = db.changes().get(patch.getKey().getParentKey().getParentKey());
            assertCanRead(change);
            final Account.Id me = Common.getAccountId();
            if (comment.getKey().get() == null) {
                final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patch.getKey(), ChangeUtil.messageUUID(db)), comment.getLine(), me, comment.getParentUuid());
                nc.setSide(comment.getSide());
                nc.setMessage(comment.getMessage());
                db.patchComments().insert(Collections.singleton(nc));
                return nc;
            } else {
                if (!me.equals(comment.getAuthor())) {
                    throw new Failure(new NoSuchEntityException());
                }
                comment.updated();
                db.patchComments().update(Collections.singleton(comment));
                return comment;
            }
        }
    });
}
#end_block

#method_before
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(S_ICON_CELL);
    m.addStyleName("LeftMostCell");
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName("ChangeTypeCell");
    m.append(p.getChangeType().getCode());
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("FilePathCell");
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("CommentCell");
    appendCommentCount(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(S_DATA_CELL);
        if (Gerrit.isSignedIn() && p.hasBeenReviewedBy(Gerrit.getUserAccount().getSshUserName())) {
            m.append(SafeHtml.asis(Gerrit.ICONS.greenCheck().getHTML()));
        } else {
            m.nbsp();
        }
        m.closeTd();
    }
    m.closeTr();
}
#method_after
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(S_ICON_CELL);
    m.addStyleName("LeftMostCell");
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName("ChangeTypeCell");
    m.append(p.getChangeType().getCode());
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("FilePathCell");
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("CommentCell");
    appendCommentCount(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    // Green check mark if the user is logged in and they reviewed that file
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(S_DATA_CELL);
        if (p.isReviewedByCurrentUser()) {
            m.append(SafeHtml.asis(Gerrit.ICONS.greenCheck().getHTML()));
        } else {
            m.nbsp();
        }
        m.closeTd();
    }
    m.closeTr();
}
#end_block

#method_before
@Override
protected void render(final PatchScript script) {
    final SparseFileContent a = script.getA();
    final SparseFileContent b = script.getB();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    if (directUrlLeft != null || directUrlRight != null) {
        // The left url can be null if a file is being added and the right url can be null if a
        // file is being deleted. They will both be non-null if this change is modifying an existing
        // file.
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("halign", "center");
        nc.openTd();
        maybeAppendImgTag(nc, directUrlLeft);
        nc.closeTd();
        nc.openTd();
        maybeAppendImgTag(nc, directUrlRight);
        nc.closeTd();
        nc.closeTr();
    } else {
        // result
        for (final String line : script.getPatchHeader()) {
            appendFileHeader(nc, line);
        }
    }
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final PatchScript.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.hasNextLine()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && a.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && b.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            }
            hunk.next();
        }
    }
    resetHtml(nc);
    onlyOneHunk = script.getEdits().size() == 1;
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n = "DiffText-" + l.getType().name();
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#method_after
@Override
protected void render(final PatchScript script) {
    final SparseFileContent a = script.getA();
    final SparseFileContent b = script.getB();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            } else {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final PatchScript.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.hasNextLine()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && a.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && b.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            }
            hunk.next();
        }
    }
    resetHtml(nc);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n = "DiffText-" + l.getType().name();
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, final PatchLine.Type type, final SparseFileContent src, final int i) {
    final int len = PatchUtil.DEFAULT_LINE_LENGTH;
    final String text = src.get(i);
    m.openTd();
    m.addStyleName("DiffText");
    m.addStyleName("DiffText-" + type.name());
    switch(type) {
        case CONTEXT:
            if ("".equals(text)) {
                m.nbsp();
            } else {
                m.append(" ");
                m.append(PatchUtil.lineToSafeHtml(text, len, false));
            }
            break;
        case DELETE:
            m.append("-");
            m.append(PatchUtil.lineToSafeHtml(text, len, false));
            break;
        case INSERT:
            m.append("+");
            m.append(PatchUtil.lineToSafeHtml(text, len, true));
            break;
    }
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, final PatchLine.Type type, final SparseFileContent src, final int i) {
    final int len = PatchUtil.DEFAULT_LINE_LENGTH;
    final String text = src.get(i);
    m.openTd();
    m.addStyleName("DiffText");
    m.addStyleName("DiffText-" + type.name());
    switch(type) {
        case CONTEXT:
            m.nbsp();
            break;
        case DELETE:
            m.append("-");
            break;
        case INSERT:
            m.append("+");
            break;
    }
    m.append(PatchUtil.lineToSafeHtml(text, len, false));
    m.closeTd();
}
#end_block

#method_before
private void openLine(final SafeHtmlBuilder m) {
    m.openTr();
    m.setAttribute("valign", "top");
    m.openTd();
    m.setStyleName(S_ICON_CELL);
    m.nbsp();
    m.closeTd();
}
#method_after
private void openLine(final SafeHtmlBuilder m) {
    m.openTr();
    m.setAttribute("valign", "top");
    m.openTd();
    m.setStyleName(S_ICON_CELL);
    m.closeTd();
}
#end_block

#method_before
private void padLineNumber(final SafeHtmlBuilder m) {
    m.openTd();
    m.setStyleName("LineNumber");
    m.nbsp();
    m.closeTd();
}
#method_after
private void padLineNumber(final SafeHtmlBuilder m) {
    m.openTd();
    m.setStyleName("LineNumber");
    m.closeTd();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either side,
    // expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null);
    add(historyPanel);
    initDisplayControls();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
    // This must be done after calling createNextPrevLinks(), which initializes these fields
    if (previousFileLink != null) {
        installLinkShortCut(previousFileLink, SHORTCUT_PREVIOUS_FILE, PatchUtil.C.previousFileHelp());
    }
    if (nextFileLink != null) {
        installLinkShortCut(nextFileLink, SHORTCUT_NEXT_FILE, PatchUtil.C.nextFileHelp());
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either side,
    // expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null);
    add(historyPanel);
    initDisplayControls();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
    // This must be done after calling createNextPrevLinks(), which initializes these fields
    if (previousFileLink != null) {
        installLinkShortCut(previousFileLink, SHORTCUT_PREVIOUS_FILE, PatchUtil.C.previousFileHelp());
    }
    if (nextFileLink != null) {
        installLinkShortCut(nextFileLink, SHORTCUT_NEXT_FILE, PatchUtil.C.nextFileHelp());
    }
}
#end_block

#method_before
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                if (caught instanceof RemoteJsonException && !isFirst) {
                    historyTable.enableAll(true);
                    showPatch(false);
                } else {
                    super.onFailure(caught);
                }
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#method_after
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        if (contentTable instanceof SideBySideTable && script.getEdits().isEmpty() && !script.getPatchHeader().isEmpty()) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        // True if there are differences between the two patch sets
        boolean hasEdits = !script.getEdits().isEmpty();
        // True if this change is a mode change or a pure rename/copy
        boolean hasMeta = !script.getPatchHeader().isEmpty();
        boolean hasDifferences = hasEdits || hasMeta;
        boolean pureMetaChange = !hasEdits && hasMeta;
        if (contentTable instanceof SideBySideTable && pureMetaChange) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        if (hasDifferences) {
            contentTable.display(patchKey, idSideA, idSideB, script);
            contentTable.display(comments);
            contentTable.finishDisplay();
        }
        showPatch(hasDifferences);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
private ResultSet<Change> searchQuery(final ReviewDb db, String query, final int limit, final String key, final Comparator<Change> cmp) throws OrmException {
    final HashSet<Change.Id> want = new HashSet<Change.Id>();
    query = query.trim();
    if (query.matches("^[1-9][0-9]*$")) {
        want.add(Change.Id.parse(query));
    } else if (query.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(query);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet p : patches) {
            want.add(p.getId().getParentKey());
        }
    }
    if (want.isEmpty()) {
        return new ListResultSet<Change>(Collections.<Change>emptyList());
    }
    List<Change> result = new ArrayList<Change>();
    final ResultSet<Change> rs = db.changes().get(want);
    if (cmp == QUERY_PREV) {
        for (Change c : rs) {
            if (c.getSortKey().compareTo(key) > 0) {
                result.add(c);
            }
        }
    } else /* cmp == QUERY_NEXT */
    {
        for (Change c : rs) {
            if (c.getSortKey().compareTo(key) < 0) {
                result.add(c);
            }
        }
    }
    Collections.sort(result, cmp);
    if (limit < result.size()) {
        // GWT emulation unfortunately lacks subList(int,int).
        // 
        final List<Change> r = new ArrayList<Change>(limit);
        for (int i = 0; i < limit; i++) {
            r.add(result.get(i));
        }
        result = r;
    }
    return new ListResultSet<Change>(result);
}
#method_after
private ResultSet<Change> searchQuery(final ReviewDb db, String query, final int limit, final String key, final Comparator<Change> cmp) throws OrmException {
    List<Change> result = new ArrayList<Change>();
    final HashSet<Change.Id> want = new HashSet<Change.Id>();
    query = query.trim();
    if (query.matches("^[1-9][0-9]*$")) {
        want.add(Change.Id.parse(query));
    } else if (query.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(query);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet p : patches) {
            want.add(p.getId().getParentKey());
        }
    } else if (query.contains("owner:")) {
        String[] parsedQuery = query.split(":");
        if (parsedQuery.length > 1) {
            filterBySortKey(result, changesCreatedBy(db, parsedQuery[1]), cmp, key);
        }
    } else if (query.contains("reviewer:")) {
        String[] parsedQuery = query.split(":");
        if (parsedQuery.length > 1) {
            want.addAll(changesReviewedBy(db, parsedQuery[1]));
        }
    }
    if (result.isEmpty() && want.isEmpty()) {
        return new ListResultSet<Change>(Collections.<Change>emptyList());
    }
    filterBySortKey(result, db.changes().get(want), cmp, key);
    Collections.sort(result, cmp);
    if (limit < result.size()) {
        // GWT emulation unfortunately lacks subList(int,int).
        // 
        final List<Change> r = new ArrayList<Change>(limit);
        for (int i = 0; i < limit; i++) {
            r.add(result.get(i));
        }
        result = r;
    }
    return new ListResultSet<Change>(result);
}
#end_block

#method_before
public void changesCreatedBy(final String userName, final AsyncCallback<SingleListChangeInfo> callback) {
    run(callback, new UserNameAction(userName) {

        @Override
        void process(ReviewDb db, AccountInfoCacheFactory ac, Account account, Map<Id, Change> resultChanges) throws OrmException {
            final Set<Change> changes = createdBy(db, account.getId());
            ac.want(account.getId());
            for (Change change : changes) {
                resultChanges.put(change.getId(), change);
            }
        }
    });
}
#method_after
private List<Change> changesCreatedBy(final ReviewDb db, final String userName) throws OrmException {
    final List<Change> resultChanges = new ArrayList<Change>();
    for (Account.Id account : getAccountSources(db, userName)) {
        for (Change change : db.changes().byOwnerOpen(account)) {
            resultChanges.add(change);
        }
        for (Change change : db.changes().byOwnerClosedAll(account)) {
            resultChanges.add(change);
        }
    }
    return resultChanges;
}
#end_block

#method_before
// 
// UserNameAction
// ///
public void changesReviewedBy(final String userName, final AsyncCallback<SingleListChangeInfo> callback) {
    run(callback, new UserNameAction(userName) {

        @Override
        void process(ReviewDb db, AccountInfoCacheFactory ac, Account account, Map<Id, Change> outResultChanges) throws OrmException {
            ChangeApprovalAccess changes = db.changeApprovals();
            ChangeAccess changeAccess = db.changes();
            Iterator<ChangeApproval> changeIterator = changes.reviewedByUser(account.getId()).iterator();
            while (changeIterator.hasNext()) {
                ChangeApproval approval = changeIterator.next();
                Change change = changeAccess.get(approval.getChangeId());
                // This will return null if the change was submitted
                if (change != null) {
                    outResultChanges.put(change.getId(), change);
                }
            }
        }
    });
}
#method_after
private Set<Change.Id> changesReviewedBy(final ReviewDb db, final String userName) throws OrmException {
    final Set<Change.Id> resultChanges = new HashSet<Change.Id>();
    for (Account.Id account : getAccountSources(db, userName)) {
        for (ChangeApproval a : db.changeApprovals().openByUser(account)) {
            resultChanges.add(a.getChangeId());
        }
        for (ChangeApproval a : db.changeApprovals().closedByUserAll(account)) {
            resultChanges.add(a.getChangeId());
        }
    }
    return resultChanges;
}
#end_block

#method_before
public void display(final PatchSet.Id id, final List<Patch> list) {
    psid = id;
    myTable = null;
    final DisplayCommand cmd = new DisplayCommand(list);
    if (cmd.execute()) {
        cmd.initMeter();
        DeferredCommand.addCommand(cmd);
    } else {
        cmd.showTable();
    }
}
#method_after
public void display(final PatchSet.Id id, final List<Patch> list) {
    psid = id;
    myTable = null;
    patchList = list;
    final DisplayCommand cmd = new DisplayCommand(list);
    if (cmd.execute()) {
        cmd.initMeter();
        DeferredCommand.addCommand(cmd);
    } else {
        cmd.showTable();
    }
}
#end_block

#method_before
void initializeRow(List<Patch> patches, int row) {
    Patch patch = patches.get(row - 1);
    PatchSetKeys psk = new PatchSetKeys(patchesToKeys(patches), row - 1, PatchTable.this.psid.getParentKey());
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(patch.getFileName(), psk);
    } else {
        nameCol = new PatchLink.Unified(patch.getFileName(), psk);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName("SourceFilePath");
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), psk));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), psk));
}
#method_after
void initializeRow(int row) {
    Patch patch = PatchTable.this.patchList.get(row - 1);
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(patch.getFileName(), patch.getKey(), row - 1, PatchTable.this);
    } else {
        nameCol = new PatchLink.Unified(patch.getFileName(), patch.getKey(), row - 1, PatchTable.this);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName("SourceFilePath");
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), patch.getKey(), row - 1, PatchTable.this));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), patch.getKey(), row - 1, PatchTable.this));
}
#end_block

#method_before
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
            }
            while (row < list.size()) {
                table.appendRow(nc, list.get(row));
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(list, row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#method_after
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
            }
            while (row < list.size()) {
                table.appendRow(nc, list.get(row));
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    add(historyPanel);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    fileList = null;
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    fp.add(noDifference);
    fp.add(contentTable);
    add(fp);
    // Links to the next/previous file
    FlexTable dp = new FlexTable();
    dp.setStyleName("gerrit-SideBySideScreen-LinkTable");
    dp.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    dp.getFlexCellFormatter().setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_RIGHT);
    if (previousPatchLink != null)
        dp.setWidget(0, 0, previousPatchLink);
    if (nextPatchLink != null)
        dp.setWidget(0, 1, nextPatchLink);
    add(dp);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    add(historyPanel);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    fp.add(noDifference);
    fp.add(contentTable);
    add(fp);
    add(createNextPrevLinks());
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        display();
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
@Override
protected Screen createScreen() {
    return new PatchScreen.SideBySide(patch.getKey(), patch, parentPatchTable());
}
#method_after
@Override
protected Screen createScreen() {
    return new PatchScreen.SideBySide(patchKey, patchIndex, parentPatchTable);
}
#end_block

#method_before
@Override
protected Screen createScreen() {
    return new PatchScreen.Unified(patch.getKey(), patch, parentPatchTable());
}
#method_after
@Override
protected Screen createScreen() {
    return new PatchScreen.Unified(patchKey, patchIndex, parentPatchTable);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName("gerrit-PatchComments");
                draftsPanel.add(panel);
                panel.add(new PatchLink.SideBySide(fn, new PatchSetKeys(patchKey)));
                priorFile = fn;
            }
            Label m;
            m = new DoubleClickLinkLabel(patchKey);
            m.setText(Util.M.lineHeader(c.getLine()));
            m.setStyleName("gerrit-LineHeader");
            panel.add(m);
            m = new DoubleClickLinkLabel(patchKey);
            SafeHtml.set(m.getElement(), LineCommentPanel.toSafeHtml(c));
            m.setStyleName("gerrit-PatchLineComment");
            panel.add(m);
        }
    }
}
#method_after
private void display(final PatchSetPublishDetail r) {
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName("gerrit-PatchComments");
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any next/previous links
                panel.add(new PatchLink.SideBySide(fn, patchKey, 0, null));
                priorFile = fn;
            }
            Label m;
            m = new DoubleClickLinkLabel(patchKey);
            m.setText(Util.M.lineHeader(c.getLine()));
            m.setStyleName("gerrit-LineHeader");
            panel.add(m);
            m = new DoubleClickLinkLabel(patchKey);
            SafeHtml.set(m.getElement(), LineCommentPanel.toSafeHtml(c));
            m.setStyleName("gerrit-PatchLineComment");
            panel.add(m);
        }
    }
}
#end_block

#method_before
private Screen select(final String token) {
    String p;
    if (token == null) {
        return null;
    }
    if (SETTINGS.equals(token) || token.startsWith("settings,")) {
        if (SETTINGS_NEW_AGREEMENT.equals(token)) {
            return new NewAgreementScreen();
        }
        return new AccountSettings(token);
    }
    if (MINE.equals(token)) {
        return new AccountDashboardScreen(Common.getAccountId());
    }
    if (token.startsWith("mine,")) {
        if (MINE_STARRED.equals(token)) {
            return new MineStarredScreen();
        }
        if (MINE_DRAFTS.equals(token)) {
            return new MineDraftsScreen();
        }
    }
    if (token.startsWith("all,")) {
        p = "all,abandoned,";
        if (token.startsWith(p)) {
            return new AllAbandonedChangesScreen(skip(p, token));
        }
        p = "all,merged,";
        if (token.startsWith(p)) {
            return new AllMergedChangesScreen(skip(p, token));
        }
        p = "all,open,";
        if (token.startsWith(p)) {
            return new AllOpenChangesScreen(skip(p, token));
        }
    }
    if (token.startsWith("project,")) {
        p = "project,open,";
        if (token.startsWith(p)) {
            final String s = skip(p, token);
            final int c = s.indexOf(',');
            return new ByProjectOpenChangesScreen(Project.NameKey.parse(s.substring(0, c)), s.substring(c + 1));
        }
    }
    if (token.startsWith("patch,")) {
        p = "patch,sidebyside,";
        if (token.startsWith(p))
            return new PatchScreen.SideBySide(Patch.Key.parse(skip(p, token)), null, /* patch */
            null);
        p = "patch,unified,";
        if (token.startsWith(p))
            return new PatchScreen.Unified(Patch.Key.parse(skip(p, token)), null, /* patch */
            null);
    }
    p = "change,publish,";
    if (token.startsWith(p))
        return new PublishCommentScreen(PatchSet.Id.parse(skip(p, token)));
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    if (token.startsWith("admin,")) {
        p = "admin,group,";
        if (token.startsWith(p))
            return new AccountGroupScreen(AccountGroup.Id.parse(skip(p, token)));
        p = "admin,project,";
        if (token.startsWith(p)) {
            p = skip(p, token);
            final int c = p.indexOf(',');
            final String idstr = p.substring(0, c);
            return new ProjectAdminScreen(Project.Id.parse(idstr), token);
        }
        if (ADMIN_GROUPS.equals(token)) {
            return new GroupListScreen();
        }
        if (ADMIN_PROJECTS.equals(token)) {
            return new ProjectListScreen();
        }
    }
    p = "VE,";
    if (token.startsWith(p)) {
        return new ValidateEmailScreen(skip(p, token));
    }
    return null;
}
#method_after
private Screen select(final String token) {
    String p;
    if (token == null) {
        return null;
    }
    if (SETTINGS.equals(token) || token.startsWith("settings,")) {
        if (SETTINGS_NEW_AGREEMENT.equals(token)) {
            return new NewAgreementScreen();
        }
        return new AccountSettings(token);
    }
    if (MINE.equals(token)) {
        return new AccountDashboardScreen(Common.getAccountId());
    }
    if (token.startsWith("mine,")) {
        if (MINE_STARRED.equals(token)) {
            return new MineStarredScreen();
        }
        if (MINE_DRAFTS.equals(token)) {
            return new MineDraftsScreen();
        }
    }
    if (token.startsWith("all,")) {
        p = "all,abandoned,";
        if (token.startsWith(p)) {
            return new AllAbandonedChangesScreen(skip(p, token));
        }
        p = "all,merged,";
        if (token.startsWith(p)) {
            return new AllMergedChangesScreen(skip(p, token));
        }
        p = "all,open,";
        if (token.startsWith(p)) {
            return new AllOpenChangesScreen(skip(p, token));
        }
    }
    if (token.startsWith("project,")) {
        p = "project,open,";
        if (token.startsWith(p)) {
            final String s = skip(p, token);
            final int c = s.indexOf(',');
            return new ByProjectOpenChangesScreen(Project.NameKey.parse(s.substring(0, c)), s.substring(c + 1));
        }
    }
    if (token.startsWith("patch,")) {
        p = "patch,sidebyside,";
        if (token.startsWith(p))
            return new PatchScreen.SideBySide(Patch.Key.parse(skip(p, token)), 0, /* patchIndex */
            null);
        p = "patch,unified,";
        if (token.startsWith(p))
            return new PatchScreen.Unified(Patch.Key.parse(skip(p, token)), 0, /* patchIndex */
            null);
    }
    p = "change,publish,";
    if (token.startsWith(p))
        return new PublishCommentScreen(PatchSet.Id.parse(skip(p, token)));
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    if (token.startsWith("admin,")) {
        p = "admin,group,";
        if (token.startsWith(p))
            return new AccountGroupScreen(AccountGroup.Id.parse(skip(p, token)));
        p = "admin,project,";
        if (token.startsWith(p)) {
            p = skip(p, token);
            final int c = p.indexOf(',');
            final String idstr = p.substring(0, c);
            return new ProjectAdminScreen(Project.Id.parse(idstr), token);
        }
        if (ADMIN_GROUPS.equals(token)) {
            return new GroupListScreen();
        }
        if (ADMIN_PROJECTS.equals(token)) {
            return new ProjectListScreen();
        }
    }
    p = "VE,";
    if (token.startsWith(p)) {
        return new ValidateEmailScreen(skip(p, token));
    }
    return null;
}
#end_block

#method_before
private void populateAbandonAction() {
    final Button b = new Button(Util.C.buttonAbandonChangeBegin());
    b.addClickListener(new ClickListener() {

        public void onClick(Widget sender) {
            b.setEnabled(false);
            new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<Object>() {

                public void onSuccess(Object result) {
                    actionsPanel.remove(b);
                    fireOnSuggestRefresh();
                }

                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                }
            }).center();
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateAbandonAction() {
    final Button b = new Button(Util.C.buttonAbandonChangeBegin());
    b.addClickListener(new ClickListener() {

        public void onClick(Widget sender) {
            new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<Object>() {

                public void onSuccess(Object result) {
                    actionsPanel.remove(b);
                    fireOnSuggestRefresh();
                }

                public void onFailure(Throwable caught) {
                }
            }).center();
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
public void changeDetail(final Change.Id id, final AsyncCallback<ChangeDetail> callback) {
    run(callback, new Action<ChangeDetail>() {

        public ChangeDetail run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(id);
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final Project proj = db.projects().get(change.getDest().getParentKey());
            if (change == null || patch == null || proj == null) {
                throw new Failure(new NoSuchEntityException());
            }
            assertCanRead(change);
            final boolean anon;
            boolean canAbandon = false;
            if (me == null) {
                // Safe assumption, this wouldn't be allowed if it wasn't.
                // 
                anon = true;
            } else {
                // Ask if the anonymous user can read this project; even if
                // we can that doesn't mean the anonymous user could.
                // 
                anon = canRead(null, change.getDest().getParentKey());
                // The change owner, current patchset uploader, Gerrit administrator,
                // and project administrator can mark the change as abandoned.
                // 
                canAbandon = me.equals(change.getOwner()) || me.equals(patch.getUploader()) || Common.getGroupCache().isAdministrator(me) || Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId());
            }
            final ChangeDetail d = new ChangeDetail();
            d.load(db, new AccountInfoCacheFactory(db), change, anon, canAbandon);
            return d;
        }
    });
}
#method_after
public void changeDetail(final Change.Id id, final AsyncCallback<ChangeDetail> callback) {
    run(callback, new Action<ChangeDetail>() {

        public ChangeDetail run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(id);
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            assertCanRead(change);
            final boolean anon;
            boolean canAbandon = false;
            if (me == null) {
                // Safe assumption, this wouldn't be allowed if it wasn't.
                // 
                anon = true;
            } else {
                // Ask if the anonymous user can read this project; even if
                // we can that doesn't mean the anonymous user could.
                // 
                anon = canRead(null, change.getDest().getParentKey());
                // The change owner, current patchset uploader, Gerrit administrator,
                // and project administrator can mark the change as abandoned.
                // 
                canAbandon = me.equals(change.getOwner()) || me.equals(patch.getUploader()) || Common.getGroupCache().isAdministrator(me) || Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId());
            }
            final ChangeDetail d = new ChangeDetail();
            d.load(db, new AccountInfoCacheFactory(db), change, anon, canAbandon);
            return d;
        }
    });
}
#end_block

#method_before
public void abandonChange(final String message, final PatchSet.Id patchSetId, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final Project proj = db.projects().get(change.getDest().getParentKey());
            if (me == null || change == null || patch == null || proj == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId())) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            db.run(new OrmRunnable<VoidResult, ReviewDb>() {

                public VoidResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, cmsg, db, txn);
                }
            });
            // Email the reviewers
            try {
                final ChangeMail cm = new ChangeMail(server, change);
                cm.setFrom(Common.getAccountId());
                cm.setReviewDb(db);
                cm.setChangeMessage(cmsg);
                cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                cm.sendAbandoned();
            } catch (MessagingException e) {
                log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void abandonChange(final PatchSet.Id patchSetId, final String message, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(patchSetId);
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (me == null || patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId())) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            Boolean dbSuccess = db.run(new OrmRunnable<Boolean, ReviewDb>() {

                public Boolean run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, patchSetId, cmsg, db, txn);
                }
            });
            if (dbSuccess) {
                // Email the reviewers
                try {
                    final ChangeMail cm = new ChangeMail(server, change);
                    cm.setFrom(me);
                    cm.setReviewDb(db);
                    cm.setChangeMessage(cmsg);
                    cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                    cm.sendAbandoned();
                } catch (MessagingException e) {
                    log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                    throw new Failure(e);
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
private VoidResult doAbandonChange(final String message, final Change change, final ChangeMessage cm, final ReviewDb db, final Transaction txn) throws OrmException {
    if (change.getStatus() == Change.Status.NEW) {
        change.setStatus(Change.Status.ABANDONED);
        ChangeUtil.updated(change);
    }
    db.changeMessages().insert(Collections.singleton(cm), txn);
    db.changes().update(Collections.singleton(change), txn);
    return VoidResult.INSTANCE;
}
#method_after
private Boolean doAbandonChange(final String message, final Change change, final PatchSet.Id psid, final ChangeMessage cm, final ReviewDb db, final Transaction txn) throws OrmException {
    // changed while the user was typing an abandon message
    if (change.getStatus() == Change.Status.NEW && change.currentPatchSetId().equals(psid)) {
        change.setStatus(Change.Status.ABANDONED);
        ChangeUtil.updated(change);
        final List<ChangeApproval> approvals = db.changeApprovals().byChange(change.getId()).toList();
        for (ChangeApproval a : approvals) {
            a.cache(change);
        }
        db.changeApprovals().update(approvals, txn);
        db.changeMessages().insert(Collections.singleton(cm), txn);
        db.changes().update(Collections.singleton(change), txn);
        return Boolean.TRUE;
    }
    return Boolean.FALSE;
}
#end_block

#method_before
private void initUI() {
    addStyleName("gerrit-ChangeScreen");
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    dependencies = new ChangeTable();
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    approvals = new ApprovalTable(changeId);
    approvalsPanel = new DisclosurePanel(Util.C.changeScreenApprovals());
    approvalsPanel.setContent(wrap(approvals));
    dependenciesPanel.setWidth("95%");
    add(approvalsPanel);
    patchSetPanels = new FlowPanel();
    add(patchSetPanels);
    messagesContent = new FlowPanel();
    messagesContent.setStyleName("gerrit-ChangeMessages");
    messagesPanel = new DisclosurePanel(Util.C.changeScreenMessages());
    messagesPanel.setContent(messagesContent);
    add(messagesPanel);
}
#method_after
private void initUI() {
    addStyleName("gerrit-ChangeScreen");
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    dependencies = new ChangeTable();
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    approvals = new ApprovalTable();
    approvalsPanel = new DisclosurePanel(Util.C.changeScreenApprovals());
    approvalsPanel.setContent(wrap(approvals));
    dependenciesPanel.setWidth("95%");
    add(approvalsPanel);
    patchSetPanels = new FlowPanel();
    add(patchSetPanels);
    messagesContent = new FlowPanel();
    messagesContent.setStyleName("gerrit-ChangeMessages");
    messagesPanel = new DisclosurePanel(Util.C.changeScreenMessages());
    messagesPanel.setContent(messagesContent);
    add(messagesPanel);
}
#end_block

#method_before
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getSubject());
    refreshOnSignIn = !detail.getChange().getStatus().isClosed();
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getMissingApprovals(), detail.getApprovals());
    addPatchSets(detail);
    addMessages(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    approvalsPanel.setOpen(true);
}
#method_after
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getSubject());
    refreshOnSignIn = !detail.getChange().getStatus().isClosed();
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getChange(), detail.getMissingApprovals(), detail.getApprovals());
    addPatchSets(detail);
    addMessages(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    approvalsPanel.setOpen(true);
}
#end_block

#method_before
public void sendRequestReview() throws MessagingException {
    if (begin("requestReview")) {
        final Account a = Common.getAccountCache().get(fromId);
        if (a == null) {
            body.append("A Gerrit user");
        } else {
            final String e = a.getFullName();
            body.append(e);
        }
        body.append(" has requested that you review a change\n\n");
        if (changeUrl() != null) {
            openFooter();
            body.append("To respond visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
        if (fromId != null) {
            add(RecipientType.CC, fromId);
        }
        send();
    }
}
#method_after
public void sendRequestReview() throws MessagingException {
    if (begin("requestReview")) {
        final Account a = Common.getAccountCache().get(fromId);
        if (a == null || a.getFullName() == null || a.getFullName().length() == 0) {
            body.append("A Gerrit user");
        } else {
            body.append(a.getFullName());
        }
        body.append(" has requested that you review a change:\n\n");
        body.append(change.getChangeId());
        body.append(" - ");
        body.append(change.getSubject());
        body.append("\n\n");
        if (changeUrl() != null) {
            openFooter();
            body.append("To respond visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
        if (fromId != null) {
            add(RecipientType.CC, fromId);
        }
        send();
    }
}
#end_block

#method_before
private String changeMessageThreadId() {
    final StringBuilder r = new StringBuilder();
    r.append('<');
    r.append("gerrit");
    r.append('.');
    r.append(change.getCreatedOn().getTime());
    r.append('.');
    r.append(change.getChangeId());
    if (fromId != null) {
        r.append('.');
        r.append(fromId.get());
    }
    r.append('@');
    r.append(gerritHost());
    r.append('>');
    return r.toString();
}
#method_after
private String changeMessageThreadId() {
    final StringBuilder r = new StringBuilder();
    r.append('<');
    r.append("gerrit");
    r.append('.');
    r.append(change.getCreatedOn().getTime());
    r.append('.');
    r.append(change.getChangeId());
    r.append('@');
    r.append(gerritHost());
    r.append('>');
    return r.toString();
}
#end_block

#method_before
public void display(final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    final int oldcnt = table.getRowCount();
    table.resizeRows(1 + rows.size());
    if (oldcnt < 1 + rows.size()) {
        for (int row = oldcnt; row < 1 + rows.size(); row++) {
            applyEdgeStyles(row);
            applyScoreStyles(row);
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.setVisible(true);
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i));
        }
    }
    missing.clear();
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Label l = new Label(Util.M.needApproval(at.getCategory().getName()));
                l.setStyleName("gerrit-Change-MissingApproval");
                missing.add(l);
                missing.setVisible(true);
            }
        }
    }
    addReviewer.clear();
    if (need != null && Gerrit.isSignedIn()) {
        final Label l = new Label(Util.C.approvalTableAddReviewer());
        l.setStyleName("gerrit-Change-AddReviewer");
        addReviewer.add(l);
        addReviewer.add(addMemberBox);
    }
}
#method_after
public void display(final Change change, final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    changeId = change.getId();
    final int oldcnt = table.getRowCount();
    table.resizeRows(1 + rows.size());
    if (oldcnt < 1 + rows.size()) {
        for (int row = oldcnt; row < 1 + rows.size(); row++) {
            applyEdgeStyles(row);
            applyScoreStyles(row);
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.setVisible(true);
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i));
        }
    }
    missing.clear();
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Label l = new Label(Util.M.needApproval(at.getCategory().getName()));
                l.setStyleName("gerrit-Change-MissingApproval");
                missing.add(l);
                missing.setVisible(true);
            }
        }
    }
    changeIsOpen = change.getStatus().isOpen();
    addReviewer.setVisible(Gerrit.isSignedIn() && changeIsOpen);
}
#end_block

#method_before
private void doAddReviewer() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail == null || nameEmail.length() == 0 || com.google.gerrit.client.admin.Util.C.defaultAccountName().equals(nameEmail)) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = Arrays.asList(nameEmail.split(";"));
    Util.DETAIL_SVC.addReviewers(reviewers, changeId, new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddReviewer() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(nameEmail);
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

