1619
#method_before
public static ReplicationFilter all() {
    return new ReplicationFilter();
}
#method_after
public static ReplicationFilter all() {
    return new ReplicationFilter(Collections.<String>emptyList());
}
#end_block

#method_before
public boolean matches(NameKey name) {
    if (matchAll) {
        return true;
    } else {
        String projectName = name.get();
        for (final String projectMatch : projectsToMatch) {
            if (isRE(projectMatch)) {
                // projectMatch is a regular expression
                if (projectName.matches(projectMatch)) {
                    return true;
                }
            } else if (isWildcard(projectMatch)) {
                // projectMatch is a wildcard
                if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                    return true;
                }
            } else {
                // No special case, so we try to match directly
                if (projectName.equals(projectMatch)) {
                    return true;
                }
            }
        }
        // Nothing matched, so don't push the project
        return false;
    }
}
#method_after
public boolean matches(NameKey name) {
    if (projectPatterns.isEmpty()) {
        return true;
    } else {
        String projectName = name.get();
        for (String pattern : projectPatterns) {
            if (matchesPattern(projectName, pattern)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(new CommandProcessing(this));
    Future<?> future = null;
    ReplicationFilter projectFilter;
    if (all) {
        projectFilter = ReplicationFilter.all();
    } else {
        projectFilter = new ReplicationFilter(projectNames);
    }
    future = pushFactory.create(urlMatch, projectFilter, state).schedule(0, TimeUnit.SECONDS);
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                stateLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                stateLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    if (all && projectPatterns.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(new CommandProcessing(this));
    Future<?> future = null;
    ReplicationFilter projectFilter;
    if (all) {
        projectFilter = ReplicationFilter.all();
    } else {
        projectFilter = new ReplicationFilter(projectPatterns);
    }
    future = pushFactory.create(urlMatch, projectFilter, state).schedule(0, TimeUnit.SECONDS);
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                stateLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                stateLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            stateLog.warn(String.format("project %s is not visible", project), state);
            return;
        }
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.isRE(projectMatch) || ReplicationFilter.isWildcard(projectMatch)) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
@Override
public RestView<ProjectResource> list() throws ResourceNotFoundException, AuthException {
    return list;
}
#method_after
@Override
public RestView<ProjectResource> list() throws ResourceNotFoundException {
    return list;
}
#end_block

#method_before
@Override
public TagResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, Exception {
    String tagName = id.get();
    if (!tagName.startsWith(Constants.R_TAGS)) {
        tagName = Constants.R_TAGS + tagName;
    }
    List<TagInfo> tags = list.apply(parent);
    for (TagInfo t : tags) {
        if (tagName.equals(t.getRef())) {
            return new TagResource(parent.getControl(), t);
        }
    }
    throw new ResourceNotFoundException();
}
#method_after
@Override
public TagResource parse(ProjectResource resource, IdString id) throws ResourceNotFoundException, IOException {
    return new TagResource(resource.getControl(), list.get(resource, id));
}
#end_block

#method_before
@Override
public List<TagInfo> apply(ProjectResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    List<TagInfo> tags = Lists.newArrayList();
    final Repository repo;
    try {
        repo = repoManager.openRepository(resource.getNameKey());
    } catch (RepositoryNotFoundException noGitRepository) {
        throw new ResourceNotFoundException();
    }
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            final Map<String, Ref> all = repo.getRefDatabase().getRefs(Constants.R_TAGS);
            for (Ref ref : all.values()) {
                String name = ref.getName();
                RefControl refControl = resource.getControl().controlForRef(name);
                if (refControl.isVisible()) {
                    RevObject object = rw.parseAny(ref.getObjectId());
                    if (object instanceof RevTag) {
                        // Annotated/signed tag
                        tags.add(createTagInfo((RevTag) object, name));
                    } else if (object instanceof RevCommit) {
                        // Lightweight tag
                        tags.add(createTagInfo((RevCommit) object, name));
                    }
                }
            }
        } finally {
            rw.dispose();
        }
    } finally {
        repo.close();
    }
    Collections.sort(tags, new Comparator<TagInfo>() {

        @Override
        public int compare(TagInfo a, TagInfo b) {
            return a.getRef().compareTo(b.getRef());
        }
    });
    return tags;
}
#method_after
@Override
public List<TagInfo> apply(ProjectResource resource) throws IOException, ResourceNotFoundException {
    List<TagInfo> tags = Lists.newArrayList();
    Repository repo = getRepository(resource.getNameKey());
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            Map<String, Ref> all = visibleTags(resource.getControl(), repo, repo.getRefDatabase().getRefs(Constants.R_TAGS));
            for (Ref ref : all.values()) {
                tags.add(createTagInfo(ref, rw));
            }
        } finally {
            rw.dispose();
        }
    } finally {
        repo.close();
    }
    Collections.sort(tags, new Comparator<TagInfo>() {

        @Override
        public int compare(TagInfo a, TagInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    return tags;
}
#end_block

#method_before
private TagInfo createTagInfo(RevCommit commit, String name) {
    return new TagInfo(name, commit.getName());
}
#method_after
private static TagInfo createTagInfo(Ref ref, RevWalk rw) throws MissingObjectException, IOException {
    RevObject object = rw.parseAny(ref.getObjectId());
    if (object instanceof RevTag) {
        RevTag tag = (RevTag) object;
        // Annotated or signed tag
        return new TagInfo(Constants.R_TAGS + tag.getTagName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), CommonConverters.toGitPerson(tag.getTaggerIdent()));
    } else {
        // Lightweight tag
        return new TagInfo(ref.getName(), ref.getObjectId().getName());
    }
}
#end_block

#method_before
@Override
public Object apply(TagResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    return resource.getTagInfo();
}
#method_after
@Override
public TagInfo apply(TagResource resource) {
    return resource.getTagInfo();
}
#end_block

#method_before
public List<WebLinkInfo> getPatchSetLinks(String project, String commit) {
    List<WebLinkInfo> links = new ArrayList<>(4);
    for (PatchSetWebLink webLink : patchSetLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getPatchSetUrl(project, commit);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getPatchSetLinks(final String project, final String commit) {
    return filterLinks(patchSetLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((PatchSetWebLink) webLink).getPathSetWebLink(project, commit);
        }
    });
}
#end_block

#method_before
public List<WebLinkInfo> getFileLinks(String project, String revision, String file) {
    List<WebLinkInfo> links = new ArrayList<>(4);
    for (FileWebLink webLink : fileLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getFileUrl(project, revision, file);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getFileLinks(final String project, final String revision, final String file) {
    return filterLinks(fileLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((FileWebLink) webLink).getFileWebLink(project, revision, file);
        }
    });
}
#end_block

#method_before
public Iterable<WebLinkInfo> getProjectLinks(String project) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (ProjectWebLink webLink : projectLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getProjectUrl(project);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getProjectLinks(final String project) {
    return filterLinks(projectLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((ProjectWebLink) webLink).getProjectWeblink(project);
        }
    });
}
#end_block

#method_before
public Iterable<WebLinkInfo> getBranchLinks(String project, String branch) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (BranchWebLink webLink : branchLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getBranchUrl(project, branch);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getBranchLinks(final String project, final String branch) {
    return filterLinks(branchLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((BranchWebLink) webLink).getBranchWebLink(project, branch);
        }
    });
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        if (!enabled) {
            RestApiServlet.replyError(req, res, SC_FORBIDDEN, RUN_AS + " disabled by auth.enableRunAs = false", null);
            return;
        }
        CurrentUser self = session.get().getCurrentUser();
        if (!self.getCapabilities().canRunAs()) {
            RestApiServlet.replyError(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS, null);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            RestApiServlet.replyError(req, res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS, e);
            return;
        }
        if (target == null) {
            RestApiServlet.replyError(req, res, SC_FORBIDDEN, "no account matches " + RUN_AS, null);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        if (!enabled) {
            replyError(req, res, SC_FORBIDDEN, RUN_AS + " disabled by auth.enableRunAs = false", null);
            return;
        }
        CurrentUser self = session.get().getCurrentUser();
        if (!self.getCapabilities().canRunAs()) {
            replyError(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS, null);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            replyError(req, res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS, e);
            return;
        }
        if (target == null) {
            replyError(req, res, SC_FORBIDDEN, "no account matches " + RUN_AS, null);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#end_block

#method_before
public static void replyError(HttpServletRequest req, HttpServletResponse res, int statusCode, String msg, CacheControl c, @Nullable Throwable err) throws IOException {
    res.setStatus(statusCode);
    configureCaching(req, res, null, c);
    replyText(req, res, msg);
    if (err != null) {
        req.setAttribute(ATTRIBUTE_ERROR_TRACE, err);
    }
}
#method_after
public static void replyError(HttpServletRequest req, HttpServletResponse res, int statusCode, String msg, CacheControl c, @Nullable Throwable err) throws IOException {
    res.setStatus(statusCode);
    configureCaching(req, res, null, c);
    replyText(req, res, msg);
    if (err != null) {
        RequestUtil.setErrorTraceAttribute(req, err);
    }
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed, boolean allowDraft) {
    if (!allowClosed && getChange().getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(getChange().currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    cd = changeData(db, cd);
    if ((getChange().getStatus() == Change.Status.DRAFT || patchSet.isDraft()) && !allowDraft) {
        return cannotSubmitDraft(db, patchSet, cd);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd, patchSet);
        results = evaluator.setFastEvalLabels(fastEvalLabels).evaluate();
    } catch (OrmException | RuleEvalException e) {
        return logRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    return resultsToSubmitRecord(evaluator.getSubmitRule(), results);
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed, boolean allowDraft) {
    if (!allowClosed && getChange().getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(getChange().currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    cd = changeData(db, cd);
    if ((getChange().getStatus() == Change.Status.DRAFT || patchSet.isDraft()) && !allowDraft) {
        return cannotSubmitDraft(db, patchSet, cd);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd);
        results = evaluator.setPatchSet(patchSet).setFastEvalLabels(fastEvalLabels).evaluate();
    } catch (OrmException | RuleEvalException e) {
        return logRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    return resultsToSubmitRecord(evaluator.getSubmitRule(), results);
}
#end_block

#method_before
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd, patchSet);
        results = evaluator.evaluateSubmitType();
    } catch (OrmException | RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd);
        results = evaluator.evaluateSubmitType();
    } catch (OrmException | RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#end_block

#method_before
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment();
    try {
        submitRule = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + cd.getId() + " of " + getProjectName(), err);
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + cd.getId() + " of " + getProjectName(), err);
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        if (resultsTerm.isList()) {
            List<Term> r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
            return r;
        }
        return Collections.emptyList();
    } finally {
        env.close();
    }
}
#method_after
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment();
    try {
        submitRule = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + cd.getId() + " of " + getProjectName(), err);
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        if (resultsTerm.isList()) {
            List<Term> r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
            return r;
        }
        return Collections.emptyList();
    } finally {
        env.close();
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment() throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new ByteArrayInputStream(rule.getBytes(UTF_8)));
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment() throws RuleEvalException {
    if (patchSet == null) {
        try {
            patchSet = cd.currentPatchSet();
        } catch (OrmException err) {
            throw new RuleEvalException("Missing current patch set on change " + cd.getId() + " of " + getProjectName(), err);
        }
    }
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new ByteArrayInputStream(rule.getBytes(UTF_8)));
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    return env;
}
#end_block

#method_before
@Override
public SubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getChange()), rsrc.getPatchSet());
    List<Term> results;
    try {
        results = evaluator.setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluateSubmitType();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return SubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#method_after
@Override
public SubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl()));
    List<Term> results;
    try {
        results = evaluator.setPatchSet(rsrc.getPatchSet()).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluateSubmitType();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return SubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getChange()), rsrc.getPatchSet());
    List<Term> results;
    try {
        results = evaluator.setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    } catch (RuleEvalException e) {
        String msg = Joiner.on(": ").skipNulls().join(Iterables.transform(Throwables.getCausalChain(e), new Function<Throwable, String>() {

            @Override
            public String apply(Throwable in) {
                return in.getMessage();
            }
        }));
        throw new BadRequestException("rule failed: " + msg);
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solutions", evaluator.getSubmitRule().toString()));
    }
    List<SubmitRecord> records = rsrc.getControl().resultsToSubmitRecord(evaluator.getSubmitRule(), results);
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountInfo.Loader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl()));
    List<Term> results;
    try {
        results = evaluator.setPatchSet(rsrc.getPatchSet()).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    } catch (RuleEvalException e) {
        String msg = Joiner.on(": ").skipNulls().join(Iterables.transform(Throwables.getCausalChain(e), new Function<Throwable, String>() {

            @Override
            public String apply(Throwable in) {
                return in.getMessage();
            }
        }));
        throw new BadRequestException("rule failed: " + msg);
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solutions", evaluator.getSubmitRule().toString()));
    }
    List<SubmitRecord> records = rsrc.getControl().resultsToSubmitRecord(evaluator.getSubmitRule(), results);
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountInfo.Loader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    RevWalk walk = new RevWalk(repo);
    try {
        RevObject obj = walk.parseAny(view.getRevision().getId());
        switch(obj.getType()) {
            case OBJ_COMMIT:
                try (Writer writer = startRenderText(req, res);
                    OutputStream out = BaseEncoding.base64().encodingStream(writer)) {
                    out.write(((RevCommit) obj).getRawBuffer());
                }
                break;
            default:
                // TODO(dborowitz): Support showing other types.
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    ObjectReader reader = repo.newObjectReader();
    try {
        ObjectLoader loader = reader.open(view.getRevision().getId());
        if (loader.getType() != OBJ_COMMIT) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            try (Writer writer = startRenderText(req, res);
                OutputStream out = BaseEncoding.base64().encodingStream(writer)) {
                loader.copyTo(out);
            }
        }
    } finally {
        reader.release();
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    if (regex == null) {
        regex = "^*.*$";
    }
    switch(level.toLowerCase()) {
        case RESET:
            reset();
            break;
        case LEVEL_ALL:
            setLoggingLevel(Level.ALL);
            break;
        case LEVEL_TRACE:
            setLoggingLevel(Level.TRACE);
            break;
        case LEVEL_DEBUG:
            setLoggingLevel(Level.DEBUG);
            break;
        case LEVEL_INFO:
            setLoggingLevel(Level.INFO);
            break;
        case LEVEL_WARN:
            setLoggingLevel(Level.WARN);
            break;
        case LEVEL_ERROR:
            setLoggingLevel(Level.ERROR);
            break;
        case LEVEL_FATAL:
            setLoggingLevel(Level.FATAL);
            break;
        case LEVEL_OFF:
            setLoggingLevel(Level.OFF);
            break;
        default:
            stdout.println("Invalid argument");
            stdout.flush();
            break;
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected void run() throws MalformedURLException {
    if (level == LevelOption.RESET) {
        reset();
    } else {
        for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements(); ) {
            Logger log = logger.nextElement();
            if (name == null || log.getName().contains(name)) {
                log.setLevel(Level.toLevel(level.name()));
            }
        }
    }
}
#end_block

#method_before
private void reset() {
    LogManager.resetConfiguration();
    PropertyConfigurator.configure(getClass().getClassLoader().getResource("log4j.properties"));
}
#method_after
@SuppressWarnings("unchecked")
private static void reset() throws MalformedURLException {
    for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements(); ) {
        logger.nextElement().setLevel(null);
    }
    String path = System.getProperty(JAVA_OPTIONS_LOG_CONFIG);
    if (Strings.isNullOrEmpty(path)) {
        PropertyConfigurator.configure(Loader.getResource(LOG_CONFIGURATION));
    } else {
        PropertyConfigurator.configure(new URL(path));
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (regex == null) {
        regex = "^*.*$";
    }
    printAll();
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected void run() {
    Map<String, String> logs = new TreeMap<>();
    for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements(); ) {
        Logger log = logger.nextElement();
        if (name == null || log.getName().contains(name)) {
            logs.put(log.getName(), log.getEffectiveLevel().toString());
        }
    }
    for (Map.Entry<String, String> e : logs.entrySet()) {
        stdout.println(e.getKey() + ": " + e.getValue());
    }
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(gerrit, SetLoggingLevelCommand.class);
    command(gerrit, ListLoggingLevelCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName logging = Commands.named(gerrit, "logging");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
}
#end_block

#method_before
private static void onRemove(NativeEvent event) {
    String hashtag = getDataId(event);
    if (hashtag != null) {
        final ChangeScreen2 screen = ChangeScreen2.get(event);
        ChangeApi.hashtags(screen.getChangeId().get()).delete(Input.create(hashtag), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#method_after
private static void onRemove(NativeEvent event) {
    String hashtags = getDataId(event);
    if (hashtags != null) {
        final ChangeScreen2 screen = ChangeScreen2.get(event);
        ChangeApi.hashtags(screen.getChangeId().get()).post(PostInput.create(null, hashtags), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#end_block

#method_before
private SafeHtmlBuilder formatHashtags(JsArrayString hashtags) {
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<String> itr = Natives.asList(hashtags).iterator();
    while (itr.hasNext()) {
        String hashtagName = itr.next();
        html.openAnchor().setAttribute("href", "/#/q/hashtag:" + hashtagName).setAttribute("role", "listitem").setAttribute(DATA_ID, hashtagName).setStyleName(style.hashtagName()).append(hashtagName).openElement("button").setAttribute("title", "Remove hashtag").setAttribute("onclick", REMOVE + "(event)").append(new ImageResourceRenderer().render(Resources.I.remove_reviewer())).closeElement("button");
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#method_after
private SafeHtmlBuilder formatHashtags(JsArrayString hashtags) {
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<String> itr = Natives.asList(hashtags).iterator();
    while (itr.hasNext()) {
        String hashtagName = itr.next();
        html.openSpan().setAttribute(DATA_ID, hashtagName).setStyleName(style.hashtagName()).openAnchor().setAttribute("href", "#" + PageLinks.toChangeQuery("hashtag:" + hashtagName)).setAttribute("role", "listitem").append(hashtagName).closeAnchor().openElement("button").setAttribute("title", "Remove hashtag").setAttribute("onclick", REMOVE + "(event)").append(new ImageResourceRenderer().render(Resources.I.remove_reviewer())).closeElement("button").closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#end_block

#method_before
private void addHashtag(final String hashtag) {
    ChangeApi.hashtags(changeId.get()).put(Input.create(hashtag), new GerritCallback<JsArrayString>() {

        public void onSuccess(JsArrayString result) {
            hashtagTextBox.setEnabled(true);
            UIObject.setVisible(error, false);
            error.setInnerText("");
            hashtagTextBox.setText("");
            if (result != null && result.length() > 0) {
                updateHashtagList(result);
            }
        }

        @Override
        public void onFailure(Throwable err) {
            UIObject.setVisible(error, true);
            error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            hashtagTextBox.setEnabled(true);
        }
    });
}
#method_after
private void addHashtag(final String hashtags) {
    ChangeApi.hashtags(changeId.get()).post(PostInput.create(hashtags, null), new GerritCallback<JsArrayString>() {

        public void onSuccess(JsArrayString result) {
            hashtagTextBox.setEnabled(true);
            UIObject.setVisible(error, false);
            error.setInnerText("");
            hashtagTextBox.setText("");
            if (result != null && result.length() > 0) {
                updateHashtagList(result);
            }
        }

        @Override
        public void onFailure(Throwable err) {
            UIObject.setVisible(error, true);
            error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            hashtagTextBox.setEnabled(true);
        }
    });
}
#end_block

#method_before
@UiHandler("followUp")
void onFollowUp(ClickEvent e) {
    if (followUpAction == null) {
        followUpAction = new FollowUpAction(followUp, project, branch, key, changeId);
    }
    followUpAction.show();
}
#method_after
@UiHandler("followUp")
void onFollowUp(ClickEvent e) {
    if (followUpAction == null) {
        followUpAction = new FollowUpAction(followUp, project, branch, key);
    }
    followUpAction.show();
}
#end_block

#method_before
@Override
public Response<ChangeJson.ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeInfoMapper.changeStatus2Status(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#method_after
@Override
public Response<ChangeJson.ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeInfoMapper.changeStatus2Status(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
void send(String message) {
    ChangeApi.createChange(project, branch, message, base, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(PageLinks.toChange(id));
            hide();
        }
    });
}
#method_after
void send(String message) {
    ChangeApi.createChange(project, branch, message, base, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(PageLinks.toChange(result.legacy_id()));
            hide();
        }
    });
}
#end_block

#method_before
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#method_after
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    newChangeForAllNotInTarget.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#end_block

#method_before
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#method_after
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    newChangeForAllNotInTarget = newInheritedBooleanBox();
    saveEnabler.listenTo(newChangeForAllNotInTarget);
    grid.add(Util.C.createNewChangeForAllNotInTarget(), newChangeForAllNotInTarget);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#end_block

#method_before
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#method_after
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(newChangeForAllNotInTarget, result.create_new_change_for_all_not_in_target());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#end_block

#method_before
private void initProjectActions(ConfigInfo info) {
    actionsGrid.clear(true);
    actionsGrid.removeAllRows();
    NativeMap<ActionInfo> actions = info.actions();
    if (actions == null || actions.isEmpty()) {
        return;
    }
    actions.copyKeysIntoChildren("id");
    actionsGrid.addHeader(new SmallHeading(Util.C.headingProjectCommands()));
    FlowPanel actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().projectActions());
    actionsPanel.setVisible(true);
    actionsGrid.add(Util.C.headingCommands(), actionsPanel);
    for (String id : actions.keySet()) {
        if (id.equals("create_change")) {
            ActionInfo create = actions.get(id);
            final Button createChange = new Button(create.label());
            createChange.setTitle(create.title());
            createChange.setEnabled(create.enabled());
            createChange.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    CreateChangeAction.call(createChange, getProjectKey().toString());
                }
            });
            actionsPanel.add(createChange);
        } else {
            actionsPanel.add(new ActionButton(getProjectKey(), actions.get(id)));
        }
    }
}
#method_after
private void initProjectActions(ConfigInfo info) {
    actionsGrid.clear(true);
    actionsGrid.removeAllRows();
    NativeMap<ActionInfo> actions = info.actions();
    if (actions == null || actions.isEmpty()) {
        return;
    }
    actions.copyKeysIntoChildren("id");
    actionsGrid.addHeader(new SmallHeading(Util.C.headingProjectCommands()));
    FlowPanel actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().projectActions());
    actionsPanel.setVisible(true);
    actionsGrid.add(Util.C.headingCommands(), actionsPanel);
    for (String id : actions.keySet()) {
        actionsPanel.add(new ActionButton(getProjectKey(), actions.get(id)));
    }
    if (Gerrit.isSignedIn()) {
        actionsPanel.add(createChangeAction());
    }
}
#end_block

#method_before
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(newChangeForAllNotInTarget), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public static void createChange(String project, String branch, String subject, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    call("create").post(input, cb);
}
#method_after
public static void createChange(String project, String branch, String subject, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    new RestApi("/changes/").post(input, cb);
}
#end_block

#method_before
static void call(Button b, final String project) {
    // TODO Replace CreateChangeDialog with a nicer looking display.
    b.setEnabled(false);
    new CreateChangeDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText("Create");
            message.setText("Insert the description of the change.");
        }

        @Override
        public void onSend() {
            ChangeApi.createChange(project, this.getDestinationBranch(), this.message.getText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final String project) {
    // TODO Replace CreateChangeDialog with a nicer looking display.
    b.setEnabled(false);
    new CreateChangeDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCreate());
            message.setText(Util.C.buttonCreateDescription());
        }

        @Override
        public void onSend() {
            ChangeApi.createChange(project, getDestinationBranch(), message.getText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
@Override
public String getDisplayString() {
    final String refsHeads = "refs/heads/";
    if (branch.ref().startsWith(refsHeads)) {
        return branch.ref().substring(refsHeads.length());
    }
    return branch.ref();
}
#method_after
@Override
public String getDisplayString() {
    if (branch.ref().startsWith(Branch.R_HEADS)) {
        return branch.ref().substring(Branch.R_HEADS.length());
    }
    return branch.ref();
}
#end_block

#method_before
@Override
public boolean match(String ref, String username) {
    if (!ref.startsWith(prefix) || username == null) {
        return false;
    }
    String u;
    if (isRE(template.getPattern())) {
        u = Pattern.quote(username);
    } else {
        u = username;
    }
    RefPatternMatcher next = getMatcher(evaluate(template, u));
    return next != null ? next.match(evaluate(ref, u), username) : false;
}
#method_after
@Override
public boolean match(String ref, String username) {
    if (!ref.startsWith(prefix) || username == null) {
        return false;
    }
    String u;
    if (isRE(template.getPattern())) {
        u = Pattern.quote(username);
    } else {
        u = username;
    }
    RefPatternMatcher next = getMatcher(expand(template, u));
    return next != null ? next.match(expand(ref, u), username) : false;
}
#end_block

#method_before
@Override
public void onPreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, NameKey destBranch, Id patchSetId) throws MergeValidationException {
    try {
        db = schemaFactory.open();
        PatchSetApproval psa = approvalsUtil.getSubmitter(db, commit.notes(), patchSetId);
        if (psa == null) {
            throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
        }
        final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
        if (!submitter.getCapabilities().canAdministrateServer()) {
            throw new MergeValidationException(CommitMergeStatus.MISSING_DEPENDENCY);
        }
    } catch (OrmException e) {
        throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#method_after
@Override
public void onPreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId) throws MergeValidationException {
    PatchSetApproval psa = approvalsUtil.getSubmitter(reviewDb.get(), commit.notes(), patchSetId);
    if (psa == null) {
        throw new MergeValidationException(CommitMergeStatus.NO_PATCH_SET);
    }
    IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
    if (!submitter.getCapabilities().canAdministrateServer()) {
        throw new MergeValidationException(CommitMergeStatus.MISSING_DEPENDENCY);
    }
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitilesAccess access = getAccess(req);
        DateFormatter df = new DateFormatter(access, Format.DEFAULT);
        // Allow the user to select a logView variant with the "pretty" param.
        String pretty = Iterables.getFirst(view.getParameters().get(PRETTY_PARAM), "default");
        Map<String, Object> data = Maps.newHashMapWithExpectedSize(2);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        try (OutputStream out = startRenderStreamingHtml(req, res, "gitiles.logDetail", data);
            Writer w = newWriter(out, res)) {
            new LogSoyData(req, access, pretty).renderStreaming(paginator, null, renderer, w, df);
        }
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitilesAccess access = getAccess(req);
        DateFormatter df = new DateFormatter(access, Format.DEFAULT);
        // Allow the user to select a logView variant with the "pretty" param.
        String pretty = Iterables.getFirst(view.getParameters().get(PRETTY_PARAM), "default");
        Map<String, Object> data = Maps.newHashMapWithExpectedSize(2);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        try (OutputStream out = startRenderStreamingHtml(req, res, "gitiles.logDetail", data)) {
            Writer w = newWriter(out, res);
            new LogSoyData(req, access, pretty).renderStreaming(paginator, null, renderer, w, df);
            w.flush();
        }
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setRewriteParents(false);
        walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    return walk;
}
#method_after
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setRewriteParents(false);
        walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    String author = Iterables.getFirst(view.getParameters().get("author"), null);
    if (author != null) {
        walk.setRevFilter(new AuthorRevFilter(author));
    }
    return walk;
}
#end_block

#method_before
private static Paginator newPaginator(Repository repo, GitilesView view) throws IOException {
    if (view == null) {
        return null;
    }
    RevWalk walk = null;
    try {
        walk = newWalk(repo, view);
    } catch (IncorrectObjectTypeException e) {
        return null;
    }
    Optional<ObjectId> start;
    try {
        start = getStart(view.getParameters(), walk.getObjectReader());
    } catch (IOException e) {
        walk.release();
        throw e;
    }
    if (start == null) {
        return null;
    }
    return new Paginator(walk, getLimit(view), start.orNull(), PaginatorFilters.fromQuery(view.getParameters()));
}
#method_after
private static Paginator newPaginator(Repository repo, GitilesView view) throws IOException {
    if (view == null) {
        return null;
    }
    RevWalk walk = null;
    try {
        walk = newWalk(repo, view);
    } catch (IncorrectObjectTypeException e) {
        return null;
    }
    Optional<ObjectId> start;
    try {
        start = getStart(view.getParameters(), walk.getObjectReader());
    } catch (IOException e) {
        walk.release();
        throw e;
    }
    if (start == null) {
        return null;
    }
    return new Paginator(walk, getLimit(view), start.orNull());
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // on the last ps or not
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.setRevisions(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()));
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.setRevisions(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()));
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#method_after
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    // to navigate to edit dialog instead of to SBS2.
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#end_block

#method_before
private Runnable upToChange(final boolean openReplyBox) {
    return new Runnable() {

        public void run() {
            CallbackGroup group = new CallbackGroup();
            commentManager.saveAllDrafts(group);
            group.done();
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    String b = base != null ? base.getId() : null;
                    String rev = revision.getId();
                    Gerrit.display(PageLinks.toChange(changeId, b, rev), new ChangeScreen2(changeId, b, rev, openReplyBox, false));
                }
            });
        }
    };
}
#method_after
private Runnable upToChange(final boolean openReplyBox) {
    return new Runnable() {

        public void run() {
            CallbackGroup group = new CallbackGroup();
            commentManager.saveAllDrafts(group);
            group.done();
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    String b = base != null ? base.getId() : null;
                    String rev = revision.getId();
                    Gerrit.display(PageLinks.toChange(changeId, b, rev), new ChangeScreen2(changeId, b, rev, openReplyBox, FileTable.Mode.REVIEW));
                }
            });
        }
    };
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        boolean editMode = false;
        if (panel != null && panel.startsWith("edit")) {
            editMode = true;
            panel = null;
        }
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, null, false, editMode) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base = null;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        psIdStr = psIdStr.substring(dotdot + 2);
    }
    ps = toPsId(id, psIdStr);
    if (!rest.isEmpty()) {
        DisplaySide side = DisplaySide.B;
        int line = 0;
        int at = rest.lastIndexOf('@');
        if (at > 0) {
            String l = rest.substring(at + 1);
            if (l.startsWith("a")) {
                side = DisplaySide.A;
                l = l.substring(1);
            }
            line = Integer.parseInt(l);
            rest = rest.substring(0, at);
        }
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, side, line, 0, null, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, base != null ? String.valueOf(base.get()) : null, String.valueOf(ps.get()), false, false) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        FileTable.Mode mode = FileTable.Mode.REVIEW;
        if (panel != null && (panel.equals("edit") || panel.startsWith("edit/"))) {
            mode = FileTable.Mode.EDIT;
            panel = null;
        }
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, null, false, mode) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base = null;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        psIdStr = psIdStr.substring(dotdot + 2);
    }
    ps = toPsId(id, psIdStr);
    if (!rest.isEmpty()) {
        DisplaySide side = DisplaySide.B;
        int line = 0;
        int at = rest.lastIndexOf('@');
        if (at > 0) {
            String l = rest.substring(at + 1);
            if (l.startsWith("a")) {
                side = DisplaySide.A;
                l = l.substring(1);
            }
            line = Integer.parseInt(l);
            rest = rest.substring(0, at);
        }
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, side, line, 0, null, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, base != null ? String.valueOf(base.get()) : null, String.valueOf(ps.get()), false, FileTable.Mode.REVIEW) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
static ChangeScreen2 get(NativeEvent in) {
    com.google.gwt.user.client.Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#method_after
static ChangeScreen2 get(NativeEvent in) {
    Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeApi.editWithFiles(changeId.get(), group.add(new GerritCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    }));
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.WEB_LINKS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                RevisionInfo revisionInfo = revisions.get(i + offset);
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisionInfo._number(), revisionInfo.edit())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    RevisionInfo revisionInfo = info.revision(revision);
    String currentlyViewedPatchSet = revisionInfo.id();
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision) {
    String currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision()).id();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1).id();
    }
    String currentlyViewedPatchSet = info.revision(revision).id();
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
}
#end_block

#method_before
private void initProjectLinks(final ChangeInfo info) {
    projectQuery.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            Gerrit.display(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
        }
    }, ClickEvent.getType());
    projectLink.setText(info.project());
    projectLink.setTargetHistoryToken(PageLinks.toProject(info.project_name_key()));
}
#method_after
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.project_name_key()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.project_name_key()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
}
#end_block

#method_before
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), info.topic())));
}
#method_after
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), null)));
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.setRevisions(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()));
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    ChangeApi.revision(changeId.get(), rev.name()).view("commit").get(group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.is_edit()) {
        return;
    }
    ChangeApi.revision(changeId.get(), rev.name()).view("commit").get(group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(r.id())) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#method_after
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(String.valueOf(r._number()))) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    RevisionInfo revisionInfo = info.revision(revision);
    if (revisionInfo.edit()) {
        statusText.setInnerText(Util.C.revisionEdit());
    } else {
        if (!current && info.status() == Change.Status.NEW) {
            statusText.setInnerText(Util.C.notCurrent());
        } else {
            statusText.setInnerText(Util.toLongString(info.status()));
        }
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    quickApprove.set(info, revision, replyAction);
    if (current) {
        loadSubmitType(info.status(), canSubmit);
    } else {
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    String email = info.owner().email() != null ? info.owner().email() : name;
    ownerText.setInnerText(name);
    ownerText.setTitle(email);
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#end_block

#method_before
private void renderSubmitType(String action) {
    try {
        SubmitType type = Project.SubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#method_after
private void renderSubmitType(String action) {
    try {
        SubmitType type = SubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(r.id())) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    com.google.gwt.user.client.Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#method_after
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS, ListChangesOption.DRAFT_COMMENTS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    if (!loaded) {
        CallbackGroup group = new CallbackGroup();
        if (Gerrit.isSignedIn()) {
            // TODO(davido): It shouldn't be necessary to make this call.
            // PatchSetsBox is constructed via PatchSetsAction which is
            // only initialized by CS2 after loading the EditInfo in that path.
            ChangeApi.edit(changeId.get(), group.add(new GerritCallback<EditInfo>() {

                @Override
                public void onSuccess(EditInfo result) {
                    edit = result;
                }
            }));
        }
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS, ListChangesOption.DRAFT_COMMENTS));
        call.get(group.addFinal(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                if (edit != null) {
                    edit.set_name(edit.commit().commit());
                    result.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
                }
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id());
    if (r.draft()) {
        sb.append(Resources.C.draft()).append(' ');
    }
    if (r.has_draft_comments()) {
        sb.openSpan().addStyleName(style.draft_comment()).setAttribute("title", Resources.C.draftCommentsTooltip()).append(new ImageResourceRenderer().render(Gerrit.RESOURCES.draftComments())).closeSpan().append(' ');
    }
    sb.append(r.id());
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : null;
    String cn = c.committer() != null ? c.committer().name() : null;
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#method_after
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id());
    if (r.draft()) {
        sb.append(Resources.C.draft()).append(' ');
    }
    if (r.has_draft_comments()) {
        sb.openSpan().addStyleName(style.draft_comment()).setAttribute("title", Resources.C.draftCommentsTooltip()).append(new ImageResourceRenderer().render(Gerrit.RESOURCES.draftComments())).closeSpan().append(' ');
    }
    sb.append(r._number());
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : "";
    String cn = c.committer() != null ? c.committer().name() : "";
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#end_block

#method_before
private String url(RevisionInfo r) {
    return PageLinks.toChange(changeId, r.id());
}
#method_after
private String url(RevisionInfo r) {
    return PageLinks.toChange(changeId, String.valueOf(r._number()));
}
#end_block

#method_before
private IndexedChangeQuery query(Predicate<ChangeData> p) throws QueryParseException {
    return query(p, IndexRewriteImpl.DEFAULT_MAX_LIMIT);
}
#method_after
private IndexedChangeQuery query(Predicate<ChangeData> p) throws QueryParseException {
    return query(p, DEFAULT_MAX_QUERY_LIMIT);
}
#end_block

#method_before
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in, int start) throws QueryParseException {
    ChangeIndex index = indexes.getSearchIndex();
    in = basicRewrites.rewrite(in);
    int limit = Objects.firstNonNull(ChangeQueryBuilder.getLimit(in), DEFAULT_MAX_LIMIT);
    // Increase the limit rather than skipping, since we don't know how many
    // skipped results would have been filtered out by the enclosing AndSource.
    limit += start;
    limit = Math.max(limit, 1);
    Predicate<ChangeData> out = rewriteImpl(in, index, limit);
    if (in == out || out instanceof IndexPredicate) {
        return new IndexedChangeQuery(index, out, limit);
    } else if (out == null) /* cannot rewrite */
    {
        return in;
    } else {
        return out;
    }
}
#method_after
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in, int start) throws QueryParseException {
    ChangeIndex index = indexes.getSearchIndex();
    in = basicRewrites.rewrite(in);
    int limit = Objects.firstNonNull(ChangeQueryBuilder.getLimit(in), DEFAULT_MAX_QUERY_LIMIT);
    // Increase the limit rather than skipping, since we don't know how many
    // skipped results would have been filtered out by the enclosing AndSource.
    limit += start;
    limit = Math.max(limit, 1);
    Predicate<ChangeData> out = rewriteImpl(in, index, limit);
    if (in == out || out instanceof IndexPredicate) {
        return new IndexedChangeQuery(index, out, limit);
    } else if (out == null) /* cannot rewrite */
    {
        return in;
    } else {
        return out;
    }
}
#end_block

#method_before
@Override
protected Reader wrapReader(String fieldName, Reader reader) {
    NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();
    for (Entry<String, String> e : customMappings.entrySet()) {
        builder.add(e.getKey(), e.getValue());
    }
    NormalizeCharMap normMap = builder.build();
    return new MappingCharFilter(normMap, reader);
}
#method_after
@Override
protected Reader wrapReader(String fieldName, Reader reader) {
    NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();
    for (Map.Entry<String, String> e : customMappings.entrySet()) {
        builder.add(e.getKey(), e.getValue());
    }
    return new MappingCharFilter(builder.build(), reader);
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PutReview.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    Git git = cloneProject(sshSession.getUrl() + "/" + project.get());
    sshSession.close();
    db = reviewDbProvider.open();
    String changeId = newChange(git, admin.getIdent());
    change = getChange(changeId);
    ps = getCurrentPatchSet(changeId);
    assertNotNull(ps);
    changeId = newChange2(git, admin.getIdent());
    change2 = getChange(changeId);
    assertNotNull(change2);
    ps2 = getCurrentPatchSet(changeId);
    assertNotNull(ps2);
    session = new RestSession(server, admin);
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
}
#method_after
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(git, admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(git, admin.getIdent(), changeId);
    change = getChange(changeId);
    assertNotNull(ps);
    String changeId2 = newChange2(git, admin.getIdent());
    change2 = getChange(changeId2);
    assertNotNull(change2);
    ps2 = getCurrentPatchSet(changeId2);
    assertNotNull(ps2);
    session = new RestSession(server, admin);
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#end_block

#method_before
@After
public void cleanup() {
    db.close();
}
#method_after
@After
public void cleanup() {
    DateTimeUtils.setCurrentMillisSystem();
    db.close();
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    editUtil.publish(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#method_after
@Test
public void publishEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW2));
    editUtil.publish(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    RestResponse r = session.get(urlGet());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    Map<String, EditInfo> result = toEditInfoMap(r);
    assertEquals(1, result.size());
    EditInfo info = Iterables.getOnlyElement(result.values());
    assertEquals(0, info._number);
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlGet());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    assertEquals(0, toEditInfoMap(r).size());
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo();
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Input in = new Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(204, session.putRaw(urlPut(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlPut());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(new String(CONTENT_NEW2, UTF_8), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    put(CHANGE_EDIT_KIND, "/").to(PutContent.class);
    delete(CHANGE_EDIT_KIND).to(DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(GetEditFileContent.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ListChangeEdits.Factory.class);
            factory(CreateOrModifyChangeEdit.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteEdit.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "rebase_edit").to(RebaseChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteEdit.Factory.class);
        }
    });
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, oldCurrentPatchSet));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertFalse(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId()));
}
#end_block

#method_before
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(HttpStatus.SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Put.Input in = new Put.Input();
    in.restore = true;
    assertEquals(SC_NO_CONTENT, session.post(urlEditFile2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertEquals(SC_NO_CONTENT, session.post(urlEdit2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void createEmptyEditRest() throws Exception {
    Put.Input in = new Put.Input();
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createEmptyEditRest() throws Exception {
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#end_block

#method_before
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#end_block

#method_before
@Override
public RestView<ChangeResource> list() {
    return detail.get();
}
#method_after
@Override
public RestView<ChangeResource> list() {
    return detail;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Create post(ChangeResource parent) throws RestApiException {
    return createFactory.create(parent.getChange(), null);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Post post(ChangeResource parent) throws RestApiException {
    return post;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wipped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on to pof current patch set by deleting path
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new ResourceConflictException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new BadRequestException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    String path = rsrc.getPath();
    byte[] content = null;
    if (input.content != null) {
        content = ByteStreams.toByteArray(input.content.getInputStream());
    }
    try {
        if (input.restore) {
            editModifier.restoreFile(rsrc.getChangeEdit(), path);
        } else {
            editModifier.modifyFile(rsrc.getChangeEdit(), path, content);
        }
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceConflictException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public BinaryResult apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException, InvalidChangeOperationException {
    try {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath());
    } catch (ResourceNotFoundException rnfe) {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getBasePatchSet().getRevision().get(), rsrc.getPath());
    }
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException {
    try {
        return Response.ok(fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, oldCurrentPatchSet));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertFalse(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId()));
}
#end_block

#method_before
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(HttpStatus.SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo();
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#end_block

#method_before
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    RestResponse r = session.get(urlGetFiles());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    Map<String, FileInfo> result = toFileInfoMap(r);
    assertEquals(2, result.size());
    List<String> l = Lists.newArrayList(result.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#method_after
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    EditInfo info = toEditInfo(true);
    assertEquals(2, info.files.size());
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Put.Input in = new Put.Input();
    in.restore = true;
    assertEquals(SC_NO_CONTENT, session.post(urlEditFile2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertEquals(SC_NO_CONTENT, session.post(urlEdit2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void createEmptyEditRest() throws Exception {
    Put.Input in = new Put.Input();
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createEmptyEditRest() throws Exception {
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#end_block

#method_before
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#end_block

#method_before
private EditInfo toEditInfo() throws IOException {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#method_after
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = session.get(files ? urlGetFiles() : urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Create post(ChangeResource parent) throws RestApiException {
    return createFactory.create(parent.getChange(), null);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Post post(ChangeResource parent) throws RestApiException {
    return post;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wipped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new ResourceConflictException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new BadRequestException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc) throws AuthException, IOException, NoSuchChangeException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent()) {
        if (list) {
            PatchSet basePatchSet = null;
            if (base != null) {
                RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
                basePatchSet = baseResource.getPatchSet();
            }
            try {
                return Response.ok(fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet));
            } catch (PatchListNotAvailableException e) {
                throw new ResourceNotFoundException(e.getMessage());
            }
        } else {
            return Response.ok(editJson.toEditInfo(edit.get()));
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<EditInfo> apply(ChangeResource rsrc) throws AuthException, IOException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        return Response.none();
    }
    EditInfo editInfo = editJson.toEditInfo(edit.get());
    if (list) {
        PatchSet basePatchSet = null;
        if (base != null) {
            RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
            basePatchSet = baseResource.getPatchSet();
        }
        try {
            editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet);
        } catch (PatchListNotAvailableException e) {
            throw new ResourceNotFoundException(e.getMessage());
        }
    }
    return Response.ok(editInfo);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    String path = rsrc.getPath();
    byte[] content = null;
    if (input.content != null) {
        content = ByteStreams.toByteArray(input.content.getInputStream());
    }
    try {
        if (input.restore) {
            editModifier.restoreFile(rsrc.getChangeEdit(), path);
        } else {
            editModifier.modifyFile(rsrc.getChangeEdit(), path, content);
        }
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceConflictException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public BinaryResult apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException, InvalidChangeOperationException {
    try {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath());
    } catch (ResourceNotFoundException rnfe) {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getBasePatchSet().getRevision().get(), rsrc.getPath());
    }
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException {
    try {
        return Response.ok(fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    put(FILE_KIND, "content").to(PutContent.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
        }
    });
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    util = new Util();
    project = new ProjectConfig(new Project.NameKey("project"));
    InMemoryRepository inMemoryRepo = util.add(project);
    repo = new TestRepository<InMemoryRepository>(inMemoryRepo);
}
#method_after
@Before
public void setUp() throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    user = userFactory.create(userId);
    Project.NameKey name = new Project.NameKey("project");
    InMemoryRepository inMemoryRepo = repoManager.createRepository(name);
    project = new ProjectConfig(name);
    project.load(inMemoryRepo);
    repo = new TestRepository<InMemoryRepository>(inMemoryRepo);
}
#end_block

#method_before
@Test
public void canReadCommitWhenAllRefsVisible() throws Exception {
    allow(project, READ, DEVS, "refs/*");
    ObjectId id = repo.branch("master").commit().create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id)));
}
#method_after
@Test
public void canReadCommitWhenAllRefsVisible() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/*");
    ObjectId id = repo.branch("master").commit().create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id)));
}
#end_block

#method_before
@Test
public void canReadCommitIfRefVisible() throws Exception {
    allow(project, READ, DEVS, "refs/heads/branch1");
    deny(project, READ, DEVS, "refs/heads/branch2");
    ObjectId id1 = repo.branch("branch1").commit().create();
    ObjectId id2 = repo.branch("branch2").commit().create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(id2)));
}
#method_after
@Test
public void canReadCommitIfRefVisible() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/heads/branch1");
    deny(project, READ, REGISTERED_USERS, "refs/heads/branch2");
    ObjectId id1 = repo.branch("branch1").commit().create();
    ObjectId id2 = repo.branch("branch2").commit().create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id2)));
}
#end_block

#method_before
@Test
public void canReadCommitIfReachableFromVisibleRef() throws Exception {
    allow(project, READ, DEVS, "refs/heads/branch1");
    deny(project, READ, DEVS, "refs/heads/branch2");
    RevCommit parent1 = repo.commit().create();
    repo.branch("branch1").commit().parent(parent1).create();
    RevCommit parent2 = repo.commit().create();
    repo.branch("branch2").commit().parent(parent2).create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(parent2)));
}
#method_after
@Test
public void canReadCommitIfReachableFromVisibleRef() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/heads/branch1");
    deny(project, READ, REGISTERED_USERS, "refs/heads/branch2");
    RevCommit parent1 = repo.commit().create();
    repo.branch("branch1").commit().parent(parent1).create();
    RevCommit parent2 = repo.commit().create();
    repo.branch("branch2").commit().parent(parent2).create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(parent2)));
}
#end_block

#method_before
@Test
public void cannotReadAfterRollbackWithRestrictedRead() throws Exception {
    allow(project, READ, DEVS, "refs/heads/branch1");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(id1)));
}
#method_after
@Test
public void cannotReadAfterRollbackWithRestrictedRead() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/heads/branch1");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
}
#end_block

#method_before
@Test
public void canReadAfterRollbackWithAllRefsVisible() throws Exception {
    allow(project, READ, DEVS, "refs/*");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(id1)));
}
#method_after
@Test
public void canReadAfterRollbackWithAllRefsVisible() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/*");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
}
#end_block

#method_before
public boolean allRefsAreVisible() {
    return allRefsAreVisibleExcept(Collections.<String>emptySet());
}
#method_after
public boolean allRefsAreVisible() {
    return allRefsAreVisible(Collections.<String>emptySet());
}
#end_block

#method_before
public boolean allRefsAreVisible() {
    return allRefsAreVisibleExcept(Collections.<String>emptySet());
}
#method_after
public boolean allRefsAreVisible(Set<String> ignore) {
    return user instanceof InternalUser || canPerformOnAllRefs(Permission.READ, ignore);
}
#end_block

#method_before
private boolean canPerformOnAllRefs(String permission, Set<String> except) {
    boolean canPerform = false;
    Set<String> patterns = allRefPatterns(permission);
    if (patterns.contains(AccessSection.ALL)) {
        // 
        for (final String pattern : patterns) {
            if (controlForRef(pattern).canPerform(permission)) {
                canPerform = true;
            } else if (except.contains(pattern)) {
                continue;
            } else {
                return false;
            }
        }
    }
    return canPerform;
}
#method_after
private boolean canPerformOnAllRefs(String permission, Set<String> ignore) {
    boolean canPerform = false;
    Set<String> patterns = allRefPatterns(permission);
    if (patterns.contains(AccessSection.ALL)) {
        // 
        for (final String pattern : patterns) {
            if (controlForRef(pattern).canPerform(permission)) {
                canPerform = true;
            } else if (ignore.contains(pattern)) {
                continue;
            } else {
                return false;
            }
        }
    }
    return canPerform;
}
#end_block

#method_before
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    Project.NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            RefDatabase refDb = repo.getRefDatabase();
            List<Ref> allRefs = Lists.newLinkedList();
            allRefs.addAll(refDb.getRefs(Constants.R_HEADS).values());
            allRefs.addAll(refDb.getRefs(Constants.R_TAGS).values());
            List<Ref> canReadRefs = Lists.newLinkedList();
            for (Ref r : allRefs) {
                if (controlForRef(r.getName()).canPerform(Permission.READ)) {
                    canReadRefs.add(r);
                }
            }
            if (!canReadRefs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, canReadRefs)) {
                return true;
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return false;
}
#method_after
public boolean canReadCommit(ReviewDb db, RevWalk rw, RevCommit commit) {
    try {
        Repository repo = repoManager.openRepository(getProject().getNameKey());
        try {
            VisibleRefFilter filter = new VisibleRefFilter(tagCache, changeCache, repo, this, db, true);
            Map<String, Ref> visibleRefs = filter.filter(repo.getAllRefs(), true);
            if (!visibleRefs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, visibleRefs.values())) {
                return true;
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey());
        log.error(msg, e);
    }
    return false;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw error("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("abandon and delete actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw error("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("publish and delete actions are mutually exclusive");
        }
    }
    boolean ok = true;
    for (final PatchSet patchSet : patchSets) {
        try {
            approveOne(patchSet);
        } catch (UnloggedFailure e) {
            ok = false;
            writeError("error: " + e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal: internal server error while approving " + patchSet.getId() + "\n");
            log.error("internal error while approving " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw error("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("abandon and delete actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw error("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw error("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw error("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw error("json and message are mutually exclusive");
        }
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error: " + e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal: internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw error("one or more reviews failed; review output above");
    }
}
#end_block

#method_before
private void applyReview(PatchSet patchSet, final ReviewInput review) throws Exception {
    gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#method_after
private void applyReview(PatchSet patchSet, final ReviewInput review) throws RestApiException {
    gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#end_block

#method_before
public void testBlockLabelRange_ParentBlocksChild() {
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    grantLabel(util.getParentConfig(), LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*").setBlock();
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -1", range.contains(-1));
    assertTrue("u can vote +1", range.contains(1));
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#method_after
public void testBlockLabelRange_ParentBlocksChild() {
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    grant(util.getParentConfig(), LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*").setBlock();
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -1", range.contains(-1));
    assertTrue("u can vote +1", range.contains(1));
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#end_block

#method_before
public void testUnblockRange() {
    grantLabel(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -2", range.contains(-2));
    assertTrue("u can vote +2", range.contains(2));
}
#method_after
public void testUnblockRange() {
    grant(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -2", range.contains(-2));
    assertTrue("u can vote +2", range.contains(2));
}
#end_block

#method_before
public void testUnblockRangeOnMoreSpecificRef_Fails() {
    grantLabel(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/master");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#method_after
public void testUnblockRangeOnMoreSpecificRef_Fails() {
    grant(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/master");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#end_block

#method_before
public void testUnblockRangeOnLargerScope_Fails() {
    grantLabel(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/master").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#method_after
public void testUnblockRangeOnLargerScope_Fails() {
    grant(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/master").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#end_block

#method_before
public void testUnblockInLocalRange_Fails() {
    grantLabel(util.getParentConfig(), LABEL + "Code-Review", -1, 1, ANONYMOUS, "refs/heads/*").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#method_after
public void testUnblockInLocalRange_Fails() {
    grant(util.getParentConfig(), LABEL + "Code-Review", -1, 1, ANONYMOUS, "refs/heads/*").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static public PermissionRule grant(ProjectConfig project, String permissionName, int min, int max, AccountGroup.UUID group, String ref) {
    PermissionRule rule = newRule(project, group);
    rule.setMin(min);
    rule.setMax(max);
    return grant(project, permissionName, rule, ref);
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static private PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#end_block

#method_before
private ProjectState newProjectState(ProjectConfig local) {
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager gitMgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    SitePaths sitePaths = null;
    List<CommentLinkInfo> commentLinks = null;
    all.put(local.getProject().getNameKey(), new ProjectState(sitePaths, projectCache, allProjectsName, projectControlFactory, envFactory, gitMgr, rulesCache, commentLinks, local));
    return all.get(local.getProject().getNameKey());
}
#method_after
private ProjectState newProjectState(ProjectConfig local) {
    add(local);
    return all.get(local.getProject().getNameKey());
}
#end_block

#method_before
@Override
public void onChangeEvent(ChangeEvent event) {
    if (!(event instanceof PatchSetCreatedEvent)) {
        return;
    }
    PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
    Project.NameKey projectName = new Project.NameKey(e.change.project);
    // TODO(davido): we have to cache per project configuration
    ReviewersConfig config = configFactory.create(projectName);
    List<ReviewerFilterSection> sections = config.getReviewerFilterSections();
    if (sections.isEmpty()) {
        return;
    }
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    final RevWalk rw = new RevWalk(git);
    try {
        reviewDb = schemaFactory.open();
        try {
            Change.Id changeId = new Change.Id(Integer.parseInt(e.change.number));
            PatchSet.Id psId = new PatchSet.Id(changeId, Integer.parseInt(e.patchSet.number));
            PatchSet ps = reviewDb.patchSets().get(psId);
            if (ps == null) {
                log.warn("Patch set " + psId.get() + " not found.");
                return;
            }
            final Change change = reviewDb.changes().get(psId.getParentKey());
            if (change == null) {
                log.warn("Change " + changeId.get() + " not found.");
                return;
            }
            ReviewerFilterSection found = findReviewerSection(sections, reviewDb, change);
            if (found == null || found.getReviewers().isEmpty()) {
                return;
            }
            final Runnable task = reviewersFactory.create(change, toAccounts(found.getReviewers(), projectName, e.uploader.email));
            workQueue.getDefaultQueue().submit(new Runnable() {

                public void run() {
                    RequestContext old = tl.setContext(new RequestContext() {

                        @Override
                        public CurrentUser getCurrentUser() {
                            return identifiedUserFactory.create(change.getOwner());
                        }

                        @Override
                        public Provider<ReviewDb> getReviewDbProvider() {
                            return new Provider<ReviewDb>() {

                                @Override
                                public ReviewDb get() {
                                    if (db == null) {
                                        try {
                                            db = schemaFactory.open();
                                        } catch (OrmException e) {
                                            throw new ProvisionException("Cannot open ReviewDb", e);
                                        }
                                    }
                                    return db;
                                }
                            };
                        }
                    });
                    try {
                        task.run();
                    } finally {
                        tl.setContext(old);
                        if (db != null) {
                            db.close();
                            db = null;
                        }
                    }
                }
            });
        } catch (OrmException | QueryParseException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        rw.release();
        git.close();
    }
}
#method_after
@Override
public void onChangeEvent(ChangeEvent event) {
    if (!(event instanceof PatchSetCreatedEvent)) {
        return;
    }
    PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
    Project.NameKey projectName = new Project.NameKey(e.change.project);
    // TODO(davido): we have to cache per project configuration
    ReviewersConfig config = configFactory.create(projectName);
    List<ReviewerFilterSection> sections = config.getReviewerFilterSections();
    if (sections.isEmpty()) {
        return;
    }
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    final RevWalk rw = new RevWalk(git);
    try {
        reviewDb = schemaFactory.open();
        try {
            Change.Id changeId = new Change.Id(Integer.parseInt(e.change.number));
            PatchSet.Id psId = new PatchSet.Id(changeId, Integer.parseInt(e.patchSet.number));
            PatchSet ps = reviewDb.patchSets().get(psId);
            if (ps == null) {
                log.warn("Patch set " + psId.get() + " not found.");
                return;
            }
            final Change change = reviewDb.changes().get(psId.getParentKey());
            if (change == null) {
                log.warn("Change " + changeId.get() + " not found.");
                return;
            }
            Set<String> reviewers = findReviewers(sections, reviewDb, change);
            if (reviewers.isEmpty()) {
                return;
            }
            final Runnable task = reviewersFactory.create(change, toAccounts(reviewers, projectName, e.uploader.email));
            workQueue.getDefaultQueue().submit(new Runnable() {

                public void run() {
                    RequestContext old = tl.setContext(new RequestContext() {

                        @Override
                        public CurrentUser getCurrentUser() {
                            return identifiedUserFactory.create(change.getOwner());
                        }

                        @Override
                        public Provider<ReviewDb> getReviewDbProvider() {
                            return new Provider<ReviewDb>() {

                                @Override
                                public ReviewDb get() {
                                    if (db == null) {
                                        try {
                                            db = schemaFactory.open();
                                        } catch (OrmException e) {
                                            throw new ProvisionException("Cannot open ReviewDb", e);
                                        }
                                    }
                                    return db;
                                }
                            };
                        }
                    });
                    try {
                        task.run();
                    } finally {
                        tl.setContext(old);
                        if (db != null) {
                            db.close();
                            db = null;
                        }
                    }
                }
            });
        } catch (OrmException | QueryParseException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        rw.release();
        git.close();
    }
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key.get()).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "");
    builder.append('}');
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "");
    builder.append('}');
    return builder.toString();
}
#end_block

#method_before
public List<PatchLineComment> publishedByChangeFile(ReviewDb db, ChangeNotes notes, Change.Id changeId, String file) throws OrmException {
    if (!migration.readPublishedComments()) {
        return db.patchComments().publishedByChangeFile(changeId, file).toList();
    }
    notes.load();
    List<PatchLineComment> commentsOnFile = new ArrayList<PatchLineComment>();
    // We must iterate through all comments to find the ones on this file.
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    Collections.sort(commentsOnFile, ChangeNotes.PatchLineCommentComparator);
    return commentsOnFile;
}
#method_after
public List<PatchLineComment> publishedByChangeFile(ReviewDb db, ChangeNotes notes, Change.Id changeId, String file) throws OrmException {
    if (!migration.readPublishedComments()) {
        return db.patchComments().publishedByChangeFile(changeId, file).toList();
    }
    notes.load();
    List<PatchLineComment> commentsOnFile = new ArrayList<PatchLineComment>();
    // We must iterate through all comments to find the ones on this file.
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    addCommentsInFile(commentsOnFile, notes.getPatchSetComments().values(), file);
    Collections.sort(commentsOnFile, ChangeNotes.PatchLineCommentComparator);
    return commentsOnFile;
}
#end_block

#method_before
private Collection<PatchLineComment> addCommentsInFile(Collection<PatchLineComment> commentsOnFile, Collection<PatchLineComment> allComments, String file) {
    for (PatchLineComment c : allComments) {
        String currentFilename = c.getKey().getParentKey().getFileName();
        if (currentFilename.equals(file)) {
            commentsOnFile.add(c);
        }
    }
    return commentsOnFile;
}
#method_after
private static Collection<PatchLineComment> addCommentsInFile(Collection<PatchLineComment> commentsOnFile, Collection<PatchLineComment> allComments, String file) {
    for (PatchLineComment c : allComments) {
        String currentFilename = c.getKey().getParentKey().getFileName();
        if (currentFilename.equals(file)) {
            commentsOnFile.add(c);
        }
    }
    return commentsOnFile;
}
#end_block

#method_before
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    ChangeNotes notes = control.getNotes();
    for (final PatchLineComment c : plcUtil.publishedByPatchSet(db, notes, psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user.isIdentifiedUser()) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(changes.parse(control), patchSet), Providers.of(user)))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#method_after
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    ChangeNotes notes = control.getNotes();
    for (PatchLineComment c : plcUtil.publishedByPatchSet(db, notes, psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user.isIdentifiedUser()) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(changes.parse(control), patchSet), Providers.of(user)))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    @SuppressWarnings("unchecked")
    final DynamicMap<RestView<CommentResource>> views = createMock(DynamicMap.class);
    final TypeLiteral<DynamicMap<RestView<CommentResource>>> viewsType = new TypeLiteral<DynamicMap<RestView<CommentResource>>>() {
    };
    final AccountInfo.Loader.Factory alf = createMock(AccountInfo.Loader.Factory.class);
    final ReviewDb db = createMock(ReviewDb.class);
    final FakeAccountCache accountCache = new FakeAccountCache();
    final PersonIdent serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    @SuppressWarnings("unused")
    InMemoryRepository repo = repoManager.createRepository(project);
    AbstractModule mod = new AbstractModule() {

        @Override
        protected void configure() {
            bind(viewsType).toInstance(views);
            bind(AccountInfo.Loader.Factory.class).toInstance(alf);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(db));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(config);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            install(new GitModule());
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(CapabilityControl.Factory.class).toProvider(Providers.<CapabilityControl.Factory>of(null));
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
        }
    };
    injector = Guice.createInjector(mod);
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account.Id ownerId = co.getId();
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    Account.Id otherUserId = ou.getId();
    IdentifiedUser.GenericFactory userFactory = injector.getInstance(IdentifiedUser.GenericFactory.class);
    changeOwner = userFactory.create(ownerId);
    IdentifiedUser otherUser = userFactory.create(otherUserId);
    AccountInfo.Loader accountLoader = createMock(AccountInfo.Loader.class);
    accountLoader.fill();
    expectLastCall().anyTimes();
    expect(accountLoader.get(ownerId)).andReturn(new AccountInfo(ownerId)).anyTimes();
    expect(accountLoader.get(otherUserId)).andReturn(new AccountInfo(otherUserId)).anyTimes();
    expect(alf.create(true)).andReturn(accountLoader).anyTimes();
    replay(accountLoader, alf);
    PatchLineCommentAccess plca = createMock(PatchLineCommentAccess.class);
    expect(db.patchComments()).andReturn(plca).anyTimes();
    Change change = newChange();
    PatchSet.Id psId1 = new PatchSet.Id(change.getId(), 1);
    PatchSet ps1 = new PatchSet(psId1);
    PatchSet.Id psId2 = new PatchSet.Id(change.getId(), 2);
    PatchSet ps2 = new PatchSet(psId2);
    long timeBase = TimeUtil.nowMs();
    plc1 = newPatchLineComment(psId1, "Comment1", null, "FileOne.txt", Side.REVISION, 3, ownerId, timeBase, "First Comment", new CommentRange(1, 2, 3, 4));
    plc1.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc2 = newPatchLineComment(psId1, "Comment2", "Comment1", "FileOne.txt", Side.REVISION, 3, otherUserId, timeBase + 1000, "Reply to First Comment", new CommentRange(1, 2, 3, 4));
    plc2.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc3 = newPatchLineComment(psId1, "Comment3", "Comment1", "FileOne.txt", Side.PARENT, 3, ownerId, timeBase + 2000, "First Parent Comment", new CommentRange(1, 2, 3, 4));
    plc3.setRevId(new RevId("CDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEF"));
    expect(plca.publishedByPatchSet(psId1)).andAnswer(results(plc1, plc2, plc3)).anyTimes();
    expect(plca.publishedByPatchSet(psId2)).andAnswer(results()).anyTimes();
    replay(db, plca);
    // Here, we are writing the comments to the notedb so that we can
    // read from and test the notedb when the noteDb config is enabled.
    ChangeUpdate update = newUpdate(change, changeOwner);
    update.setPatchSetId(psId1);
    update.putComment(plc1);
    update.putComment(plc3);
    update.commit();
    update = newUpdate(change, otherUser);
    update.setPatchSetId(psId1);
    update.putComment(plc2);
    update.commit();
    ChangeControl ctl = stubChangeControl(change);
    revRes1 = new RevisionResource(new ChangeResource(ctl), ps1);
    revRes2 = new RevisionResource(new ChangeResource(ctl), ps2);
}
#method_after
@Before
public void setUp() throws Exception {
    @SuppressWarnings("unchecked")
    final DynamicMap<RestView<CommentResource>> views = createMock(DynamicMap.class);
    final TypeLiteral<DynamicMap<RestView<CommentResource>>> viewsType = new TypeLiteral<DynamicMap<RestView<CommentResource>>>() {
    };
    final AccountInfo.Loader.Factory alf = createMock(AccountInfo.Loader.Factory.class);
    final ReviewDb db = createMock(ReviewDb.class);
    final FakeAccountCache accountCache = new FakeAccountCache();
    final PersonIdent serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    @SuppressWarnings("unused")
    InMemoryRepository repo = repoManager.createRepository(project);
    AbstractModule mod = new AbstractModule() {

        @Override
        protected void configure() {
            bind(viewsType).toInstance(views);
            bind(AccountInfo.Loader.Factory.class).toInstance(alf);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(db));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(config);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            install(new GitModule());
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(CapabilityControl.Factory.class).toProvider(Providers.<CapabilityControl.Factory>of(null));
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
        }
    };
    injector = Guice.createInjector(mod);
    NotesMigration migration = injector.getInstance(NotesMigration.class);
    plcUtil = new PatchLineCommentsUtil(migration);
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account.Id ownerId = co.getId();
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    Account.Id otherUserId = ou.getId();
    IdentifiedUser.GenericFactory userFactory = injector.getInstance(IdentifiedUser.GenericFactory.class);
    changeOwner = userFactory.create(ownerId);
    IdentifiedUser otherUser = userFactory.create(otherUserId);
    AccountInfo.Loader accountLoader = createMock(AccountInfo.Loader.class);
    accountLoader.fill();
    expectLastCall().anyTimes();
    expect(accountLoader.get(ownerId)).andReturn(new AccountInfo(ownerId)).anyTimes();
    expect(accountLoader.get(otherUserId)).andReturn(new AccountInfo(otherUserId)).anyTimes();
    expect(alf.create(true)).andReturn(accountLoader).anyTimes();
    replay(accountLoader, alf);
    PatchLineCommentAccess plca = createMock(PatchLineCommentAccess.class);
    expect(db.patchComments()).andReturn(plca).anyTimes();
    Change change = newChange();
    PatchSet.Id psId1 = new PatchSet.Id(change.getId(), 1);
    PatchSet ps1 = new PatchSet(psId1);
    PatchSet.Id psId2 = new PatchSet.Id(change.getId(), 2);
    PatchSet ps2 = new PatchSet(psId2);
    long timeBase = TimeUtil.nowMs();
    plc1 = newPatchLineComment(psId1, "Comment1", null, "FileOne.txt", Side.REVISION, 3, ownerId, timeBase, "First Comment", new CommentRange(1, 2, 3, 4));
    plc1.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc2 = newPatchLineComment(psId1, "Comment2", "Comment1", "FileOne.txt", Side.REVISION, 3, otherUserId, timeBase + 1000, "Reply to First Comment", new CommentRange(1, 2, 3, 4));
    plc2.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc3 = newPatchLineComment(psId1, "Comment3", "Comment1", "FileOne.txt", Side.PARENT, 3, ownerId, timeBase + 2000, "First Parent Comment", new CommentRange(1, 2, 3, 4));
    plc3.setRevId(new RevId("CDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEF"));
    List<PatchLineComment> commentsByOwner = Lists.newArrayList();
    commentsByOwner.add(plc1);
    commentsByOwner.add(plc3);
    List<PatchLineComment> commentsByReviewer = Lists.newArrayList();
    commentsByReviewer.add(plc2);
    plca.upsert(commentsByOwner);
    expectLastCall().anyTimes();
    plca.upsert(commentsByReviewer);
    expectLastCall().anyTimes();
    expect(plca.publishedByPatchSet(psId1)).andAnswer(results(plc1, plc2, plc3)).anyTimes();
    expect(plca.publishedByPatchSet(psId2)).andAnswer(results()).anyTimes();
    replay(db, plca);
    ChangeUpdate update = newUpdate(change, changeOwner);
    update.setPatchSetId(psId1);
    plcUtil.addPublishedComments(db, update, commentsByOwner);
    update.commit();
    update = newUpdate(change, otherUser);
    update.setPatchSetId(psId1);
    plcUtil.addPublishedComments(db, update, commentsByReviewer);
    update.commit();
    ChangeControl ctl = stubChangeControl(change);
    revRes1 = new RevisionResource(new ChangeResource(ctl), ps1);
    revRes2 = new RevisionResource(new ChangeResource(ctl), ps2);
}
#end_block

#method_before
private ChangeControl stubChangeControl(Change c) throws OrmException {
    return ChangesForTestUtil.stubChangeControl(repoManager, c, changeOwner);
}
#method_after
private ChangeControl stubChangeControl(Change c) throws OrmException {
    return TestChanges.stubChangeControl(repoManager, c, changeOwner);
}
#end_block

#method_before
private Change newChange() {
    return ChangesForTestUtil.newChange(project, changeOwner);
}
#method_after
private Change newChange() {
    return TestChanges.newChange(project, changeOwner);
}
#end_block

#method_before
private ChangeUpdate newUpdate(Change c, final IdentifiedUser user) throws Exception {
    return ChangesForTestUtil.newUpdate(injector, repoManager, c, user);
}
#method_after
private ChangeUpdate newUpdate(Change c, final IdentifiedUser user) throws Exception {
    return TestChanges.newUpdate(injector, repoManager, c, user);
}
#end_block

#method_before
private static void assertComment(PatchLineComment plc, CommentInfo ci) {
    assertEquals(plc.getKey().get(), ci.id);
    assertEquals(plc.getParentUuid(), ci.inReplyTo);
    assertEquals(plc.getMessage(), ci.message);
    assertNotNull(ci.author);
    assertEquals(plc.getAuthor(), ci.author._id);
    assertEquals(plc.getLine(), (int) ci.line);
    assertEquals(plc.getSide() == 0 ? Side.PARENT : Side.REVISION, Objects.firstNonNull(ci.side, Side.REVISION));
    assertEquals(roundTimestampToSecond(plc.getWrittenOn()), roundTimestampToSecond(ci.updated));
    assertEquals(plc.getRange(), ci.range);
}
#method_after
private static void assertComment(PatchLineComment plc, CommentInfo ci) {
    assertEquals(plc.getKey().get(), ci.id);
    assertEquals(plc.getParentUuid(), ci.inReplyTo);
    assertEquals(plc.getMessage(), ci.message);
    assertNotNull(ci.author);
    assertEquals(plc.getAuthor(), ci.author._id);
    assertEquals(plc.getLine(), (int) ci.line);
    assertEquals(plc.getSide() == 0 ? Side.PARENT : Side.REVISION, Objects.firstNonNull(ci.side, Side.REVISION));
    assertEquals(TimeUtil.roundTimestampToSecond(plc.getWrittenOn()), TimeUtil.roundTimestampToSecond(ci.updated));
    assertEquals(plc.getRange(), ci.range);
}
#end_block

#method_before
private Change newChange() {
    return ChangesForTestUtil.newChange(project, changeOwner);
}
#method_after
private Change newChange() {
    return TestChanges.newChange(project, changeOwner);
}
#end_block

#method_before
private ChangeUpdate newUpdate(Change c, final IdentifiedUser user) throws Exception {
    return ChangesForTestUtil.newUpdate(injector, repoManager, c, user);
}
#method_after
private ChangeUpdate newUpdate(Change c, IdentifiedUser user) throws Exception {
    return TestChanges.newUpdate(injector, repoManager, c, user);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RemoteCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RemoteCacheAdminModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException {
    File tmp = File.createTempFile(prefix, suffix, dir);
    boolean keep = false;
    try {
        FileOutputStream out = new FileOutputStream(tmp);
        try {
            byte[] data = new byte[8192];
            int n;
            while ((n = in.read(data)) > 0) {
                out.write(data, 0, n);
            }
            keep = true;
            return tmp;
        } finally {
            out.close();
        }
    } finally {
        if (!keep) {
            tmp.delete();
        }
    }
}
#method_after
static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException {
    File tmp = File.createTempFile(prefix, suffix, dir);
    boolean keep = false;
    try (FileOutputStream out = new FileOutputStream(tmp)) {
        byte[] data = new byte[8192];
        int n;
        while ((n = in.read(data)) > 0) {
            out.write(data, 0, n);
        }
        keep = true;
        return tmp;
    } finally {
        if (!keep) {
            tmp.delete();
        }
    }
}
#end_block

#method_before
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(file)) {
            log.warn("Skipping non-plugin file " + fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(file)) {
            log.warn("No Plugin provider was found that handles this file format: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        if (newPlugin.getCleanupHandle() != null) {
            cleanupHandles.put(newPlugin, newPlugin.getCleanupHandle());
        }
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        if (newPlugin.getCleanupHandle() != null) {
            cleanupHandles.put(newPlugin, newPlugin.getCleanupHandle());
        }
        /*
       * Pluggable plugin provider may have assigned a plugin name that could be
       * actually different from the initial one assigned during scan. It is
       * safer then to reassign it.
       */
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        name = serverPluginFactory.getPluginName(srcPlugin);
        return loadServerPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        return loadServerPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#end_block

#method_before
private ServerPlugin loadServerPlugin(String name, File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    return serverPluginFactory.get(scriptFile, pluginUserFactory.create(name), snapshot, getPluginCanonicalWebUrl(name), getPluginDataDir(name));
}
#method_after
private ServerPlugin loadServerPlugin(File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    String name = serverPluginFactory.getPluginName(scriptFile);
    return serverPluginFactory.get(scriptFile, snapshot, new PluginDescription(pluginUserFactory.create(name), getPluginCanonicalWebUrl(name), getPluginDataDir(name)));
}
#end_block

#method_before
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name. Values are
// the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#method_after
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#end_block

#method_before
@Override
public String getPluginName(File srcFile) {
    try {
        return Objects.firstNonNull(getGerritJarPluginName(srcFile), PluginLoader.nameOf(srcFile));
    } catch (IOException e) {
        throw new IllegalArgumentException("Invalid plugin file " + srcFile + ": cannot get plugin name", e);
    }
}
#method_after
@Override
public String getPluginName(File srcFile) {
    try {
        return Objects.firstNonNull(getJarPluginName(srcFile), PluginLoader.nameOf(srcFile));
    } catch (IOException e) {
        throw new IllegalArgumentException("Invalid plugin file " + srcFile + ": cannot get plugin name", e);
    }
}
#end_block

#method_before
@Override
public ServerPlugin get(File srcFile, PluginUser pluginUser, FileSnapshot snapshot, String pluginCanonicalWebUrl, File pluginDataDir) throws InvalidPluginException {
    try {
        File tmp;
        String name = getPluginName(srcFile);
        FileInputStream in = new FileInputStream(srcFile);
        String extension = getExtension(srcFile);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
            return loadJarPlugin(name, srcFile, snapshot, tmp, pluginCanonicalWebUrl, pluginUser, pluginDataDir);
        } finally {
            in.close();
        }
    } catch (IOException | ClassNotFoundException e) {
        throw new InvalidPluginException("Cannot load Jar plugin " + srcFile, e);
    }
}
#method_after
@Override
public ServerPlugin get(File srcFile, FileSnapshot snapshot, PluginDescription description) throws InvalidPluginException {
    try {
        String name = getPluginName(srcFile);
        String extension = getExtension(srcFile);
        try (FileInputStream in = new FileInputStream(srcFile)) {
            File tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
            return loadJarPlugin(name, srcFile, snapshot, tmp, description);
        }
    } catch (IOException | ClassNotFoundException e) {
        throw new InvalidPluginException("Cannot load Jar plugin " + srcFile, e);
    }
}
#end_block

#method_before
private ServerPlugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp, String pluginCanonicalWebUrl, PluginUser pluginUser, File pluginDataDir) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        ServerPlugin plugin = new ServerPlugin(name, pluginCanonicalWebUrl, pluginUser, srcJar, snapshot, new JarScanner(srcJar), pluginDataDir, pluginLoader);
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private ServerPlugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp, PluginDescription description) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        ServerPlugin plugin = new ServerPlugin(name, description.canonicalUrl, description.user, srcJar, snapshot, new JarScanner(srcJar), description.dataDir, pluginLoader);
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Injector getPluginInjector(File jarFile) throws IOException {
    final String pluginName = Objects.firstNonNull(JarPluginProvider.getGerritJarPluginName(jarFile), PluginLoader.nameOf(jarFile));
    return initInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
        }
    });
}
#method_after
private Injector getPluginInjector(final File jarFile) throws IOException {
    final String pluginName = Objects.firstNonNull(JarPluginProvider.getJarPluginName(jarFile), PluginLoader.nameOf(jarFile));
    return initInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
        }
    });
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    change.revision(revision);
    setWebLinks(change, revision, revInfo);
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
}
#end_block

#method_before
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            addWebLink(link.linkUrl(), link.linkName());
        }
    }
}
#method_after
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            addWebLink(link.link_url(), link.link_name());
        }
    }
}
#end_block

#method_before
private Map<String, LabelInfo> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(changes.parse(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    out.webLinks = Lists.newArrayList();
    for (WebLinks.Link link : webLinkFactory.create().getPatchSetLinks(project, in.getRevision().get())) {
        out.webLinks.add(new RevisionInfo.WebLinkInfo(link.name, link.url));
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(changes.parse(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        out.webLinks = Lists.newArrayList();
        for (WebLinks.Link link : webLinks.get().getPatchSetLinks(project, in.getRevision().get())) {
            out.webLinks.add(new RevisionInfo.WebLinkInfo(link.name, link.url));
        }
    }
    return out;
}
#end_block

#method_before
public Iterable<Link> getPatchSetLinks(final String project, final String commit) {
    ArrayList<Link> links = new ArrayList<Link>();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#method_after
public Iterable<Link> getPatchSetLinks(final String project, final String commit) {
    List<Link> links = Lists.newArrayList();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(WebLinks.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
public void setPatchSetId(PatchSet.Id psId) {
    checkArgument(psId == null || psId.getParentKey().equals(getChange().getKey()));
    this.psId = psId;
}
#method_after
public void setPatchSetId(PatchSet.Id psId) {
    checkArgument(psId == null || psId.getParentKey().equals(getChange().getId()));
    this.psId = psId;
}
#end_block

#method_before
public void putComment(PatchLineComment comment) {
    commentsToAdd.add(comment);
}
#method_after
public void putComment(PatchLineComment comment) {
    checkArgument(psId != null, "setPatchSetId must be called before putComment");
    checkArgument(getCommentPsId(comment).equals(psId), "Comment on %s doesn't match previous patch set %s", getCommentPsId(comment), psId);
    checkArgument(comment.getRevId() != null);
    if (comment.getSide() == 0) {
        commentsForBase.add(comment);
    } else {
        commentsForPs.add(comment);
    }
}
#end_block

#method_before
private void storeCommentsInNotes(RevCommit c) throws OrmException, IOException {
    if (commentsToAdd.isEmpty()) {
        return;
    }
    // assume you can only add comments to one patchset at a time
    PatchSet.Id psId = commentsToAdd.get(0).getKey().getParentKey().getParentKey();
    ChangeNotes notes = ctl.getNotes();
    LinkedListMultimap<PatchSet.Id, PatchLineComment> allComments = LinkedListMultimap.create(notes.getPublishedComments());
    List<PatchLineComment> commentsOnSamePs = allComments.get(psId);
    // add all comments and re-sort list
    commentsOnSamePs.addAll(commentsToAdd);
    commentsOnSamePs = ChangeNotes.COMMENT_ORDERING.sortedCopy(commentsOnSamePs);
    String noteContents = PatchLineCommentsUtil.buildNote(accountCache, commentsOnSamePs);
    AnyObjectId oId = c.getId();
    NoteMap noteMap = notes.getNoteMap();
    noteMap.set(oId, noteContents, this.inserter);
    this.inserter.flush();
}
#method_after
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (commentsForPs.isEmpty() && commentsForBase.isEmpty()) {
        return null;
    }
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnBases = notes.getBaseComments();
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnPs = notes.getPatchSetComments();
    // This writes all comments for the base of this PS to the note map.
    if (!commentsForBase.isEmpty()) {
        writeCommentsToNoteMap(noteMap, allCommentsOnBases, commentsForBase);
    }
    // This write all comments for this PS to the note map.
    if (!commentsForPs.isEmpty()) {
        writeCommentsToNoteMap(noteMap, allCommentsOnPs, commentsForPs);
    }
    return noteMap.writeTree(inserter);
}
#end_block

#method_before
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        batch.write(new CommitBuilder());
        RevCommit c = batch.commit();
        storeCommentsInNotes(c);
        return c;
    } catch (OrmException e) {
        // TODO(yyonas): what to do with this exception?
        return null;
    } finally {
        batch.close();
    }
}
#method_after
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        CommitBuilder builder = new CommitBuilder();
        if (migration.write()) {
            ObjectId treeId = storeCommentsInNotes();
            if (treeId != null) {
                builder.setTreeId(treeId);
            }
        }
        batch.write(builder);
        RevCommit c = batch.commit();
        return c;
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        batch.close();
    }
}
#end_block

#method_before
private boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#method_after
private boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && commentsForBase.isEmpty() && commentsForPs.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#end_block

#method_before
private void parseComments(RevCommit commit) throws IOException, ConfigInvalidException, ParseException {
    Ref sharedMeta = repo.getRef(ChangeNoteUtil.changeRefName(changeId));
    if (sharedMeta != null) {
        RevCommit sharedBaseCommit = walk.parseCommit(sharedMeta.getObjectId());
        publishedCommentNoteMap = NoteMap.read(walk.getObjectReader(), sharedBaseCommit);
    }
    Iterator<Note> notes = publishedCommentNoteMap.iterator();
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes);
        if (result == null) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        publishedComments.putAll(psId, result);
    }
}
#method_after
private void parseComments(RevCommit commit) throws IOException, ConfigInvalidException, ParseException {
    Ref sharedMeta = repo.getRef(ChangeNoteUtil.changeRefName(changeId));
    if (sharedMeta != null) {
        RevCommit sharedBaseCommit = walk.parseCommit(sharedMeta.getObjectId());
        commentNoteMap = NoteMap.read(walk.getObjectReader(), sharedBaseCommit);
    }
    Iterator<Note> notes = commentNoteMap.iterator();
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = CommentsInNotesUtil.parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
}
#end_block

#method_before
private ConfigInvalidException parseException(String fmt, Object... args) {
    return new ConfigInvalidException("Change " + changeId + ": " + String.format(fmt, args));
}
#method_after
private ConfigInvalidException parseException(String fmt, Object... args) {
    return ChangeNotes.parseException(changeId, fmt, args);
}
#end_block

#method_before
public NoteMap getNoteMap() {
    return noteMap;
}
#method_after
NoteMap getNoteMap() {
    return noteMap;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        publishedComments = ImmutableListMultimap.copyOf(parser.publishedComments);
        noteMap = parser.publishedCommentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
    // TODO(yyonas): figure out how to handle this exception
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
    publishedComments = ImmutableListMultimap.of();
}
#method_after
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
    commentsForBase = ImmutableListMultimap.of();
    commentsForPS = ImmutableListMultimap.of();
}
#end_block

#method_before
public String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile)).toLowerCase();
}
#method_after
public String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile));
}
#end_block

#method_before
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        ArrayList<Plugin> plugins = new ArrayList<Plugin>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#method_after
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        List<Plugin> plugins = new ArrayList<>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    env.onStopPlugin(plugin);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) {
            log.warn("Skipping non-plugin file " + fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) {
            log.warn("File is not a JAR nor JS plugin and " + "no Plugin provider was found that handles it: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        // Pluggable plugin provider may have assigned
        name = newPlugin.getName();
        // a plugin name that could be actually
        // different from the initial
        // one assigned during scan. It is safer then
        // to reassign it.
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (externalPluginFactory.handles(srcPlugin)) {
        name = externalPluginFactory.getPluginName(srcPlugin);
        return loadExternalPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (externalPluginFactory.handles(srcPlugin)) {
        return loadExternalPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new ServerPlugin(name, getPluginCanonicalWebUrl(name), pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), getPluginDataDir(name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private ServerPlugin loadExternalPlugin(String name, File scriptFile, FileSnapshot snapshot) {
    return externalPluginFactory.get(name, scriptFile, pluginUserFactory.create(name), snapshot);
}
#method_after
private ServerPlugin loadExternalPlugin(File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    String name = externalPluginFactory.getPluginName(scriptFile);
    return externalPluginFactory.get(scriptFile, snapshot, new PluginDescription(pluginUserFactory.create(name), getPluginCanonicalWebUrl(name), getPluginDataDir(name)));
}
#end_block

#method_before
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name. Values are
// the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#method_after
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#end_block

#method_before
public static String getGerritJarPluginName(File srcFile) throws IOException {
    JarFile jarFile = new JarFile(srcFile);
    try {
        return jarFile.getManifest().getMainAttributes().getValue("Gerrit-PluginName");
    } finally {
        jarFile.close();
    }
}
#method_after
public static String getGerritJarPluginName(File srcFile) throws IOException {
    try (JarFile jarFile = new JarFile(srcFile)) {
        return jarFile.getManifest().getMainAttributes().getValue("Gerrit-PluginName");
    }
}
#end_block

#method_before
public Collection<InitStep> getInitSteps() {
    List<File> jars = scanJarsInPluginsDirectory();
    ArrayList<InitStep> pluginsInitSteps = new ArrayList<InitStep>();
    for (File jar : jars) {
        InitStep init = loadInitStep(jar);
        if (init != null) {
            pluginsInitSteps.add(init);
        }
    }
    return pluginsInitSteps;
}
#method_after
public Collection<InitStep> getInitSteps() {
    List<File> jars = scanJarsInPluginsDirectory();
    ArrayList<InitStep> pluginsInitSteps = new ArrayList<>();
    for (File jar : jars) {
        InitStep init = loadInitStep(jar);
        if (init != null) {
            pluginsInitSteps.add(init);
        }
    }
    return pluginsInitSteps;
}
#end_block

#method_before
private Manifest getPluginManifest(PluginScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#method_after
private Manifest getPluginManifest(PluginContentScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#end_block

#method_before
@Override
public ServerPlugin get(String name, File srcFile, PluginUser pluginUser, FileSnapshot snapshot) {
    return providerOf(srcFile).get(name, srcFile, pluginUser, snapshot);
}
#method_after
@Override
public ServerPlugin get(File srcFile, FileSnapshot snapshot, PluginDescription pluginDescription) throws InvalidPluginException {
    return providerOf(srcFile).get(srcFile, snapshot, pluginDescription);
}
#end_block

#method_before
@Override
public boolean handles(File srcFile) {
    for (ServerPluginProvider scriptingFactory : serverPluginProviders) {
        if (scriptingFactory.handles(srcFile)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean handles(File srcFile) {
    List<ServerPluginProvider> providers = providersForHandlingPlugin(srcFile);
    switch(providers.size()) {
        case 1:
            return true;
        case 0:
            return false;
        default:
            throw new MultipleProvidersForPluginException(srcFile, providers);
    }
}
#end_block

#method_before
private ServerPluginProvider providerOf(File srcFile) {
    for (ServerPluginProvider provider : serverPluginProviders) {
        if (provider.handles(srcFile)) {
            return provider;
        }
    }
    throw new IllegalArgumentException(srcFile.getAbsolutePath() + " is not a supported Gerrit plugin format");
}
#method_after
private ServerPluginProvider providerOf(File srcFile) {
    List<ServerPluginProvider> providers = providersForHandlingPlugin(srcFile);
    switch(providers.size()) {
        case 1:
            return providers.get(0);
        case 0:
            throw new IllegalArgumentException("No ServerPluginProvider found/loaded to handle plugin file " + srcFile.getAbsolutePath());
        default:
            throw new MultipleProvidersForPluginException(srcFile, providers);
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPreUploadHook(uploadValidatorsFactory.create(project, repo));
    try {
        up.upload(in, out, err);
    } catch (UploadValidationException e) {
    // UploadValidationException is used by the UploadValidationListener to
    // stop the uploadPack. We do not want this exception to go beyond this
    // point otherwise it would print a stacktrace in the logs and return an
    // internal server error to the client.
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    List<PreUploadHook> allPreUploadHooks = Lists.newArrayList(preUploadHooks);
    allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString()));
    up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks));
    try {
        up.upload(in, out, err);
    } catch (UploadValidationException e) {
        // internal server error to the client.
        if (!e.isOutput()) {
            up.sendMessage(e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(preUploadHooks)));
    return up;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    up.setPreUploadHook(uploadValidatorsFactory.create(pc.getProject(), repo));
    if (!pc.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    }
    next.doFilter(request, response);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR
    // may have been overridden by a proxy server -- we'll try to avoid this.
    UploadValidators uploadValidators = uploadValidatorsFactory.create(pc.getProject(), repo, request.getRemoteHost());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(up.getPreUploadHook(), uploadValidators)));
    if (!pc.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    }
    next.doFilter(request, response);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<>(rp.getAdvertisedObjects())));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public void onSendPack(UploadPack up, Collection<? extends ObjectId> wants, Collection<? extends ObjectId> haves) throws ServiceMayNotContinueException {
    for (UploadValidationListener validator : uploadValidationListeners) {
        validator.onPreUpload(repository, project, wants, haves);
    }
}
#method_after
@Override
public void onSendPack(UploadPack up, Collection<? extends ObjectId> wants, Collection<? extends ObjectId> haves) throws ServiceMayNotContinueException {
    for (UploadValidationListener validator : uploadValidationListeners) {
        try {
            validator.onPreUpload(repository, project, remoteHost, up, wants, haves);
        } catch (ValidationException e) {
            throw new UploadValidationException(e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public synchronized void schedule(final Branch.NameKey branch) {
    MergeEntry e = active.get(branch);
    if (e == null) {
        e = new MergeEntry(branch);
        active.put(branch, e);
        e.needMerge = true;
        scheduleJob(e);
    }
}
#method_after
@Override
public synchronized void schedule(final Branch.NameKey branch) {
    MergeEntry e = active.get(branch);
    if (e == null) {
        e = new MergeEntry(branch);
        active.put(branch, e);
        e.needMerge = true;
        scheduleJob(e);
    } else {
        e.needMerge = true;
    }
}
#end_block

#method_before
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (messageIsForChange()) {
        update.commit();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        if (changeMessage != null) {
            Change otherChange = db.changes().get(changeMessage.getPatchSetId().getParentKey());
            ChangeControl otherControl = refControl.getProjectControl().controlFor(otherChange);
            ChangeUpdate updateForOtherChange = updateFactory.create(otherControl, change.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, updateForOtherChange, changeMessage);
            updateForOtherChange.commit();
        }
    }
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    return change;
}
#method_after
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (messageIsForChange()) {
        update.commit();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    return change;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO atomic update was not propagated
        update = updateFactory.create(control);
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    f.checkedGet();
    return result;
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO(yyonas): atomic update was not propagated
        update = updateFactory.create(control);
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    f.checkedGet();
    return result;
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            if (changeMessage != null) {
                Change otherChange = db.changes().get(changeMessage.getPatchSetId().getParentKey());
                ChangeControl otherControl = ctlFactory.controlFor(otherChange, user);
                ChangeUpdate updateForOtherChange = updateFactory.create(otherControl, updatedChange.getLastUpdatedOn());
                cmUtil.addChangeMessage(db, updateForOtherChange, changeMessage);
                updateForOtherChange.commit();
            }
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(updatedChange).reindex().runAsync();
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            commitMessageNotForChange(updatedChange);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(updatedChange).reindex().runAsync();
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO atomic update was not propagated
        update = updateFactory.create(control, change.getLastUpdatedOn());
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO(yyonas): atomic update was not propagated
        update = updateFactory.create(control, change.getLastUpdatedOn());
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
public static List<ChangeMessage> sortChangeMessages(Iterable<ChangeMessage> changeMessage) {
    return ChangeNotes.MESSAGE_BY_TIME.sortedCopy(changeMessage);
}
#method_after
private static List<ChangeMessage> sortChangeMessages(Iterable<ChangeMessage> changeMessage) {
    return ChangeNotes.MESSAGE_BY_TIME.sortedCopy(changeMessage);
}
#end_block

#method_before
public List<ChangeMessage> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    List<ChangeMessage> changeMessages;
    if (!migration.readChangeMessages()) {
        ImmutableListMultimap.Builder<PatchSet.Id, ChangeMessage> result = ImmutableListMultimap.builder();
        for (ChangeMessage cm : db.changeMessages().byChange(notes.getChangeId())) {
            result.put(cm.getPatchSetId(), cm);
        }
        changeMessages = sortChangeMessages(result.build().values());
    } else {
        changeMessages = sortChangeMessages(notes.load().getChangeMessages().values());
    }
    return changeMessages;
}
#method_after
public List<ChangeMessage> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChangeMessages()) {
        return sortChangeMessages(db.changeMessages().byChange(notes.getChangeId()));
    } else {
        return sortChangeMessages(notes.load().getChangeMessages().values());
    }
}
#end_block

#method_before
public ChangeMessage getConflictMessage(RevisionResource rsrc) throws OrmException {
    List<ChangeMessage> cms = cmUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), rsrc.getPatchSet().getId());
    return Iterables.getFirst(Iterables.filter(Lists.reverse(cms), new Predicate<ChangeMessage>() {

        @Override
        public boolean apply(ChangeMessage input) {
            return input.getAuthor() == null;
        }
    }), null);
}
#method_after
public ChangeMessage getConflictMessage(RevisionResource rsrc) throws OrmException {
    return FluentIterable.from(cmUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), rsrc.getPatchSet().getId())).filter(new Predicate<ChangeMessage>() {

        @Override
        public boolean apply(ChangeMessage input) {
            return input.getAuthor() == null;
        }
    }).last().orNull();
}
#end_block

#method_before
private boolean isChangeReviewed(Account.Id self, ChangeData cd, List<ChangeMessage> msgs) throws OrmException {
    // Sort messages to keep the most recent ones at the beginning.
    Collections.sort(msgs, new Comparator<ChangeMessage>() {

        @Override
        public int compare(ChangeMessage a, ChangeMessage b) {
            return b.getWrittenOn().compareTo(a.getWrittenOn());
        }
    });
    Account.Id changeOwnerId = cd.change().getOwner();
    for (ChangeMessage cm : msgs) {
        if (self.equals(cm.getAuthor())) {
            return true;
        } else if (changeOwnerId.equals(cm.getAuthor())) {
            return false;
        }
    }
    return false;
}
#method_after
private boolean isChangeReviewed(Account.Id self, ChangeData cd, List<ChangeMessage> msgs) throws OrmException {
    // Sort messages to keep the most recent ones at the beginning.
    msgs = ChangeNotes.MESSAGE_BY_TIME.sortedCopy(msgs);
    Account.Id changeOwnerId = cd.change().getOwner();
    for (ChangeMessage cm : msgs) {
        if (self.equals(cm.getAuthor())) {
            return true;
        } else if (changeOwnerId.equals(cm.getAuthor())) {
            return false;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to " + newTopicName;
        } else if (newTopicName.isEmpty()) {
            summary = "Topic " + oldTopicName + " removed";
        } else {
            summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        cmsg.setMessage(summary);
        ChangeUpdate update;
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            // TODO atomic update was not propagated
            update = updateFactory.create(control);
            cmUtil.addChangeMessage(db, update, cmsg);
            db.commit();
        } finally {
            db.rollback();
        }
        update.commit();
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#method_after
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to " + newTopicName;
        } else if (newTopicName.isEmpty()) {
            summary = "Topic " + oldTopicName + " removed";
        } else {
            summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        cmsg.setMessage(summary);
        ChangeUpdate update;
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            // TODO(yyonas): atomic update was not propagated
            update = updateFactory.create(control);
            cmUtil.addChangeMessage(db, update, cmsg);
            db.commit();
        } finally {
            db.rollback();
        }
        update.commit();
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException, NoSuchChangeException {
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        ChangeControl control = changeControlFactory.controlFor(c, identifiedUserFactory.create(submitter.getAccountId()));
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // I didn't see how this function was going to do anything different
        // if I did what was below or put it in the function and kept the lines in
        // there...I commented out the method below because ATM, it's not used.
        // addMergedMessage(submitter, msg);
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    update.commit();
}
#method_after
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException, NoSuchChangeException {
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        ChangeControl control = commit.getControl();
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // TODO(yyonas): we need to be able to change the author of the message
        // is not the person for whom the change was made. addMergedMessage
        // did this in the past.
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    update.commit();
}
#end_block

#method_before
// private void addMergedMessage(PatchSetApproval submitter, ChangeMessage msg)
// throws OrmException {
// if (msg != null) {
// if (submitter != null && msg.getAuthor() == null) {
// msg.setAuthor(submitter.getAccountId());
// }
// db.changeMessages().insert(Collections.singleton(msg));
// }
// }
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO: atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change.getId());
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#method_after
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO(yyonas): atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change.getId());
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#end_block

#method_before
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    ChangeUpdate update = updateFactory.create(control, change.getCreatedOn());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#method_after
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    // TODO(dborowitz): support InternalUser in ChangeUpdate
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    ChangeUpdate update = updateFactory.create(control);
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO(yyonas): atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#end_block

#method_before
@Override
public void run() {
    try {
        rc.processCommands(commands, progress);
    } catch (NoSuchChangeException e) {
        // TODO(yyonas): Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
@Override
public void run() {
    rc.processCommands(commands, progress);
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) throws NoSuchChangeException {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case DELETE:
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, NoSuchChangeException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        cmUtil.addChangeMessage(db, update, msg);
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        cmUtil.addChangeMessage(db, update, msg);
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException, NoSuchChangeException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result) throws OrmException, IOException, NoSuchChangeException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        ChangeControl control = ctlFactory.controlFor(change, currentUser);
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    return new UiAction.Description().setLabel(label).setTitle(String.format(tooltip, resource.getPatchSet().getPatchSetId(), resource.getChange().getDest().getShortName())).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
    return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#end_block

#method_before
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            ActionInfo actionInfo = actions.get("submit");
            submit.setTitle(actionInfo.title());
            submit.setText(actionInfo.label());
        }
        a2b(actions, "/", deleteRevision);
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#method_after
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            ActionInfo action = actions.get("submit");
            submit.setTitle(action.title());
            submit.setHTML(new SafeHtmlBuilder().openDiv().append(action.label()).closeDiv());
        }
        a2b(actions, "/", deleteRevision);
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#end_block

#method_before
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (Map.Entry<String, Cache<?, ?>> entry : getCaches().entrySet()) {
        cacheInfos.put(entry.getKey(), new CacheInfo(entry.getValue()));
    }
    return cacheInfos;
}
#method_after
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) {
        cacheInfos.put(cacheNameOf(e.getPluginName(), e.getExportName()), new CacheInfo(e.getProvider().get()));
    }
    return cacheInfos;
}
#end_block

#method_before
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s";
    }
    return String.format("%4.1f%s", ns, suffix).trim();
}
#end_block

#method_before
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix);
}
#method_after
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix).trim();
}
#end_block

#method_before
@Override
public CacheResource parse(ConfigResource parent, IdString id) throws AuthException, ResourceNotFoundException {
    final CurrentUser user = self.get();
    if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!(user.isIdentifiedUser())) {
        throw new ResourceNotFoundException();
    }
    if (!user.getCapabilities().canViewCaches()) {
        throw new AuthException("not allowed to view caches");
    }
    String cacheName = id.get();
    String pluginName = "gerrit";
    int i = cacheName.indexOf('.');
    if (i != -1) {
        pluginName = cacheName.substring(0, i);
        cacheName = cacheName.length() > i + 1 ? cacheName.substring(i + 1) : "";
    }
    Provider<Cache<?, ?>> cacheProvider = cacheMap.byPlugin(pluginName).get(cacheName);
    if (cacheProvider == null) {
        throw new ResourceNotFoundException(id);
    }
    return new CacheResource(pluginName, cacheName, cacheProvider);
}
#method_after
@Override
public CacheResource parse(ConfigResource parent, IdString id) throws AuthException, ResourceNotFoundException {
    CurrentUser user = self.get();
    if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!user.isIdentifiedUser()) {
        throw new ResourceNotFoundException();
    } else if (!user.getCapabilities().canViewCaches()) {
        throw new AuthException("not allowed to view caches");
    }
    String cacheName = id.get();
    String pluginName = "gerrit";
    int i = cacheName.lastIndexOf('-');
    if (i != -1) {
        pluginName = cacheName.substring(0, i);
        cacheName = cacheName.length() > i + 1 ? cacheName.substring(i + 1) : "";
    }
    Provider<Cache<?, ?>> cacheProvider = cacheMap.byPlugin(pluginName).get(cacheName);
    if (cacheProvider == null) {
        throw new ResourceNotFoundException(id);
    }
    return new CacheResource(pluginName, cacheName, cacheProvider);
}
#end_block

#method_before
private void printMemoryCoreCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (!cache.name.contains(".") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#method_after
private void printMemoryCoreCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (!cache.name.contains("-") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#end_block

#method_before
private void printMemoryPluginCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (cache.name.contains(".") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#method_after
private void printMemoryPluginCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (cache.name.contains("-") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#end_block

#method_before
private void printCache(CacheInfo cache) {
    stdout.print(String.format("%1s %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", CacheType.DISK.equals(cache.type) ? "D" : "", cache.name, nullToEmpty(cache.entries.mem), nullToEmpty(cache.entries.disk), Strings.nullToEmpty(cache.entries.space), Strings.nullToEmpty(cache.averageGet), formatAsProcent(cache.hitRatio.mem), formatAsProcent(cache.hitRatio.disk)));
}
#method_after
private void printCache(CacheInfo cache) {
    stdout.print(String.format("%1s %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", CacheType.DISK.equals(cache.type) ? "D" : "", cache.name, nullToEmpty(cache.entries.mem), nullToEmpty(cache.entries.disk), Strings.nullToEmpty(cache.entries.space), Strings.nullToEmpty(cache.averageGet), formatAsPercent(cache.hitRatio.mem), formatAsPercent(cache.hitRatio.disk)));
}
#end_block

#method_before
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (Map.Entry<String, Cache<?, ?>> entry : getCaches().entrySet()) {
        cacheInfos.put(entry.getKey(), new CacheInfo(entry.getValue()));
    }
    return cacheInfos;
}
#method_after
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) {
        cacheInfos.put(cacheNameOf(e.getPluginName(), e.getExportName()), new CacheInfo(e.getProvider().get()));
    }
    return cacheInfos;
}
#end_block

#method_before
private static String cacheNameOf(String plugin, String name) {
    if ("gerrit".equals(plugin)) {
        return name;
    } else {
        return plugin + "." + name;
    }
}
#method_after
private static String cacheNameOf(String plugin, String name) {
    if ("gerrit".equals(plugin)) {
        return name;
    } else {
        return plugin + "-" + name;
    }
}
#end_block

#method_before
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s";
    }
    return String.format("%4.1f%s", ns, suffix).trim();
}
#end_block

#method_before
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix);
}
#method_after
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix).trim();
}
#end_block

#method_before
@Override
public ListRequest list() {
    return new ListRequest() {

        @Override
        public List<ProjectInfo> get() throws RestApiException {
            return ProjectsImpl.this.list(this);
        }
    };
}
#method_after
@Override
public ListRequest list() {
    return new ListRequest() {

        @Override
        public List<ProjectInfo> get() throws RestApiException {
            return list(this);
        }
    };
}
#end_block

#method_before
private List<ProjectInfo> list(final ListRequest request) throws RestApiException {
    ListProjects lp = listProvider.get();
    lp.setShowDescription(request.getDescription());
    lp.setLimit(request.getLimit());
    lp.setStart(request.getStart());
    lp.setMatchPrefix(request.getPrefix());
    Map<String, ProjectInfo> result = lp.apply();
    return ImmutableList.copyOf(result.values());
}
#method_after
private List<ProjectInfo> list(ListRequest request) throws RestApiException {
    ListProjects lp = listProvider.get();
    lp.setShowDescription(request.getDescription());
    lp.setLimit(request.getLimit());
    lp.setStart(request.getStart());
    lp.setMatchPrefix(request.getPrefix());
    return ImmutableList.copyOf(lp.apply().values());
}
#end_block

#method_before
@Test
public void listProjects() throws Exception {
    List<ProjectInfo> initialProjects = gApi.projects().list().get();
    createProject(sshSession, "foo");
    createProject(sshSession, "bar");
    List<ProjectInfo> results = gApi.projects().list().get();
    assertEquals(initialProjects.size() + 2, results.size());
}
#method_after
@Test
public void listProjects() throws Exception {
    List<ProjectInfo> initialProjects = gApi.projects().list().get();
    gApi.projects().name("foo").create();
    gApi.projects().name("bar").create();
    List<ProjectInfo> allProjects = gApi.projects().list().get();
    assertEquals(initialProjects.size() + 2, allProjects.size());
    List<ProjectInfo> projectsWithDescription = gApi.projects().list().withDescription(true).get();
    assertNotNull(projectsWithDescription.get(0).description);
    List<ProjectInfo> projectsWithoutDescription = gApi.projects().list().withDescription(false).get();
    assertNull(projectsWithoutDescription.get(0).description);
    List<ProjectInfo> noMatchingProjects = gApi.projects().list().withPrefix("fox").get();
    assertEquals(0, noMatchingProjects.size());
    List<ProjectInfo> matchingProject = gApi.projects().list().withPrefix("fo").get();
    assertEquals(1, matchingProject.size());
    List<ProjectInfo> limitOneProject = gApi.projects().list().withLimit(1).get();
    assertEquals(1, limitOneProject.size());
    List<ProjectInfo> startAtOneProjects = gApi.projects().list().withStart(1).get();
    assertEquals(allProjects.size() - 1, startAtOneProjects.size());
}
#end_block

#method_before
void setVisibleA(boolean show) {
    visibleA = show;
    if (show) {
        removeStyleName(style.hideA());
    } else {
        addStyleName(style.hideA());
    }
}
#method_after
void setVisibleA(boolean show) {
    visibleA = show;
    if (show) {
        removeStyleName(style.hideA());
        // match B's viewport
        parent.syncScroll(DisplaySide.B);
    } else {
        addStyleName(style.hideA());
    }
}
#end_block

#method_before
void set(JsArray<RevisionInfo> list, DiffInfo info) {
    patchSetSelectBoxA.setUpPatchSetNav(list, info.meta_a());
    patchSetSelectBoxB.setUpPatchSetNav(list, info.meta_b());
    JsArrayString hdr = info.diff_header();
    if (hdr != null) {
        StringBuilder b = new StringBuilder();
        for (int i = 1; i < hdr.length(); i++) {
            String s = hdr.get(i);
            if (s.startsWith("diff --git ") || s.startsWith("index ") || s.startsWith("+++ ") || s.startsWith("--- ")) {
                continue;
            }
            b.append(s).append('\n');
        }
        String hdrTxt = b.toString().trim();
        header = !hdrTxt.isEmpty();
        diffHeaderText.setInnerText(hdrTxt);
        UIObject.setVisible(diffHeaderRow, header);
    } else {
        header = false;
        UIObject.setVisible(diffHeaderRow, false);
    }
    if (info.change_type() == ChangeType.ADDED) {
        // TODO(davido): Add user preference to control it,
        // as not all users would probably like this per default
        setVisibleA(false);
    }
}
#method_after
void set(DiffPreferences prefs, JsArray<RevisionInfo> list, DiffInfo info) {
    this.changeType = info.change_type();
    patchSetSelectBoxA.setUpPatchSetNav(list, info.meta_a());
    patchSetSelectBoxB.setUpPatchSetNav(list, info.meta_b());
    JsArrayString hdr = info.diff_header();
    if (hdr != null) {
        StringBuilder b = new StringBuilder();
        for (int i = 1; i < hdr.length(); i++) {
            String s = hdr.get(i);
            if (s.startsWith("diff --git ") || s.startsWith("index ") || s.startsWith("+++ ") || s.startsWith("--- ")) {
                continue;
            }
            b.append(s).append('\n');
        }
        String hdrTxt = b.toString().trim();
        header = !hdrTxt.isEmpty();
        diffHeaderText.setInnerText(hdrTxt);
        UIObject.setVisible(diffHeaderRow, header);
    } else {
        header = false;
        UIObject.setVisible(diffHeaderRow, false);
    }
    setHideEmptyPane(prefs.hideEmptyPane());
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId base = projectConfig.getRevision();
            projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(base, projectConfig.getRevision())) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, GitRepositoryManager.REF_CONFIG), base, projectConfig.getRevision(), user.getAccount());
            }
            ;
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, GitRepositoryManager.REF_CONFIG), baseRev, commitRev, user.getAccount());
            }
            ;
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#end_block

#method_before
@Override
public Object apply(ProjectResource resource, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new Input();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = (IdentifiedUser) ctl.getCurrentUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try {
        MetaDataUpdate md = updateFactory.create(resource.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setDescription(Strings.emptyToNull(input.description));
            String msg = Objects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
            if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            ObjectId base = config.getRevision();
            config.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(base, config.getRevision())) {
                hooks.doRefUpdatedHook(new Branch.NameKey(resource.getNameKey(), GitRepositoryManager.REF_CONFIG), base, config.getRevision(), user.getAccount());
            }
            cache.evict(ctl.getProject());
            gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
            return Strings.isNullOrEmpty(project.getDescription()) ? Response.none() : project.getDescription();
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Object apply(ProjectResource resource, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new Input();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = (IdentifiedUser) ctl.getCurrentUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try {
        MetaDataUpdate md = updateFactory.create(resource.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setDescription(Strings.emptyToNull(input.description));
            String msg = Objects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
            if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            ObjectId baseRev = config.getRevision();
            ObjectId commitRev = config.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                hooks.doRefUpdatedHook(new Branch.NameKey(resource.getNameKey(), GitRepositoryManager.REF_CONFIG), baseRev, commitRev, user.getAccount());
            }
            cache.evict(ctl.getProject());
            gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
            return Strings.isNullOrEmpty(project.getDescription()) ? Response.none() : project.getDescription();
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    return obj instanceof SecureStoreData && storeName.hashCode() == obj.hashCode();
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj instanceof SecureStoreData) {
        SecureStoreData o = (SecureStoreData) obj;
        return storeName.equals(o.storeName);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return storeName.hashCode();
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(storeName);
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data;
        // Allow the user to select a logView variant with the "pretty" param.
        List<String> pretty_values = view.getParameters().get(PRETTY_PARAM);
        if (pretty_values.isEmpty()) {
            data = new LogSoyData(req, view).toSoyData(paginator, null, df);
            GitilesConfig.putVariant(getAccess(req).getConfig(), "logEntry", "logEntryVariant", data);
        } else {
            data = new LogSoyData(req, view, true).toSoyData(paginator, null, df);
            String variant = pretty_values.get(0);
            data.put("logPrettyVariant", pretty_values.get(0));
        }
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitilesAccess access = getAccess(req);
        Config config = access.getConfig();
        DateFormatter df = new DateFormatter(access, Format.DEFAULT);
        // Allow the user to select a logView variant with the "pretty" param.
        String pretty = Iterables.getFirst(view.getParameters().get(PRETTY_PARAM), "default");
        Map<String, Object> data = new LogSoyData(req, view, config.getBoolean("logFormat", pretty, "verbose", false)).toSoyData(paginator, null, df);
        String variant = config.getString("logFormat", pretty, "variant");
        data.put("logEntryPretty", pretty);
        data.put("logEntryVariant", Objects.firstNonNull(variant, pretty));
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        DateFormatter df = new DateFormatter(getAccess(req), Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setTreeFilter(AndTreeFilter.create(PathFilter.create(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    return walk;
}
#method_after
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setRewriteParents(false);
        walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    return walk;
}
#end_block

#method_before
public Map<String, Object> toSoyData(Paginator paginator, @Nullable String revision, GitDateFormatter df) throws IOException {
    Map<String, Object> data = Maps.newHashMapWithExpectedSize(3);
    List<Map<String, Object>> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
    for (RevCommit c : paginator) {
        if (verbose) {
            entries.add(new CommitSoyData().setRevWalk(paginator.getWalk()).toSoyData(req, c, VERBOSE_FIELDS, df));
        } else {
            entries.add(new CommitSoyData().toSoyData(req, c, FIELDS, df));
        }
    }
    data.put("entries", entries);
    ObjectId next = paginator.getNextStart();
    // TODO(mmoss): These urls don't include the n or pretty params.
    if (next != null) {
        data.put("nextUrl", copyAndCanonicalize(view, revision).replaceParam(LogServlet.START_PARAM, next.name()).toUrl());
    }
    ObjectId prev = paginator.getPreviousStart();
    if (prev != null) {
        GitilesView.Builder prevView = copyAndCanonicalize(view, revision);
        if (!prevView.getRevision().getId().equals(prev)) {
            prevView.replaceParam(LogServlet.START_PARAM, prev.name());
        }
        data.put("previousUrl", prevView.toUrl());
    }
    return data;
}
#method_after
public Map<String, Object> toSoyData(RevWalk walk, int limit, @Nullable String revision, @Nullable ObjectId start, DateFormatter df) throws IOException {
    return toSoyData(new Paginator(walk, limit, start), revision, df);
}
#end_block

#method_before
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String sid, String auth) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = now();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (sid == null) {
        sid = newUniqueToken(who);
    }
    if (auth == null) {
        auth = newUniqueToken(who);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth);
    self.get().put(key.token, val);
    return val;
}
#method_after
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String sid, String auth) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = nowMs();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (sid == null) {
        sid = newUniqueToken(who);
    }
    if (auth == null) {
        auth = newUniqueToken(who);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth);
    self.put(key.token, val);
    return val;
}
#end_block

#method_before
Val get(final Key key) {
    Val val = self.get().getIfPresent(key.token);
    if (val != null && val.expiresAt <= now()) {
        self.get().invalidate(key.token);
        return null;
    }
    return val;
}
#method_after
Val get(final Key key) {
    Val val = self.getIfPresent(key.token);
    if (val != null && val.expiresAt <= nowMs()) {
        self.invalidate(key.token);
        return null;
    }
    return val;
}
#end_block

#method_before
void destroy(final Key key) {
    self.get().invalidate(key.token);
}
#method_after
void destroy(final Key key) {
    self.invalidate(key.token);
}
#end_block

#method_before
boolean needsCookieRefresh() {
    return refreshCookieAt <= now();
}
#method_after
boolean needsCookieRefresh() {
    return refreshCookieAt <= nowMs();
}
#end_block

#method_before
@UiHandler("addme")
void onAddMe(ClickEvent e) {
    String reviewer = Gerrit.getUserAccountInfo().name();
    if (!reviewer.isEmpty()) {
        addReviewer(reviewer, false);
    }
}
#method_after
@UiHandler("addme")
void onAddMe(ClickEvent e) {
    String accountId = String.valueOf(Gerrit.getUserAccountInfo()._account_id());
    addReviewer(accountId, false);
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        final LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        AccountApi.self().view("preferences").get(new AsyncCallback<Preferences>() {

            @Override
            public void onSuccess(Preferences prefs) {
                for (TopMenuItem item : Natives.asList(prefs.my())) {
                    addExtensionLink(myBar, item);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen && currentMenu == null) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        final LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        AccountApi.self().view("preferences").get(new AsyncCallback<Preferences>() {

            @Override
            public void onSuccess(Preferences prefs) {
                for (TopMenuItem item : Natives.asList(prefs.my())) {
                    addExtensionLink(myBar, item);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#end_block

#method_before
public void onScreenLoad(ScreenLoadEvent event) {
    if (event.getScreen().getToken().equals(getTargetHistoryToken())) {
        Gerrit.currentMenu = null;
        addStyleName(Gerrit.RESOURCES.css().activeRow());
    } else {
        removeStyleName(Gerrit.RESOURCES.css().activeRow());
    }
}
#method_after
public void onScreenLoad(ScreenLoadEvent event) {
    if (match(event.getScreen().getToken())) {
        Gerrit.selectMenu(bar);
        addStyleName(Gerrit.RESOURCES.css().activeRow());
    } else {
        removeStyleName(Gerrit.RESOURCES.css().activeRow());
    }
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    boolean admin;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            admin = getCurrentUser().getCapabilities().canAdministrateServer();
            break;
        default:
            owner = false;
            admin = false;
    }
    if (object instanceof RevCommit) {
        return admin || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
protected ProjectAccess updateProjectConfig(ProjectConfig config, MetaDataUpdate md) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    hooks.doRefUpdatedHook(new Branch.NameKey(config.getProject().getNameKey(), GitRepositoryManager.REF_CONFIG), commit.getParent(0).getId(), commit.getId(), user.getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#method_after
@Override
protected ProjectAccess updateProjectConfig(ProjectConfig config, MetaDataUpdate md) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    hooks.doRefUpdatedHook(new Branch.NameKey(config.getProject().getNameKey(), GitRepositoryManager.REF_CONFIG), base, commit.getId(), user.getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    config.setGitBasicAuth(authConfig.isGitBasicAuth() && authConfig.isLdapAuthType());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordSettingsEnabled(!authConfig.isGitBasicAuth());
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (!authConfig.isLdapAuthType() && !passwordMatchesTheUserGeneratedOne(who, username, password)) {
        log.warn("Authentication failed for " + username + ": password do not match the ones stored in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        WebSession ws = session.get();
        ws.setUserAccountId(whoAuthResult.getAccountId());
        ws.setAccessPathOk(AccessPath.GIT, true);
        ws.setAccessPathOk(AccessPath.REST_API, true);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (!authConfig.isLdapAuthType() && !passwordMatchesTheUserGeneratedOne(who, username, password)) {
        log.warn("Authentication failed for " + username + ": password does not match the one stored in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        WebSession ws = session.get();
        ws.setUserAccountId(whoAuthResult.getAccountId());
        ws.setAccessPathOk(AccessPath.GIT, true);
        ws.setAccessPathOk(AccessPath.REST_API, true);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
@Override
public void stop() {
    if (executor != null) {
        try {
            cleanup.shutdownNow();
            List<Runnable> pending = executor.shutdownNow();
            if (executor.awaitTermination(15, TimeUnit.MINUTES)) {
                if (pending != null && !pending.isEmpty()) {
                    log.info(String.format("Finishing %d disk cache updates", pending.size()));
                    for (Runnable update : pending) {
                        update.run();
                    }
                }
            } else {
                log.info("Timeout waiting for disk cache to close");
            }
        } catch (InterruptedException e) {
            log.warn("Interrupted waiting for disk cache to shutdown");
        }
    }
    for (H2CacheImpl<?, ?> cache : caches) {
        cache.stop();
    }
}
#method_after
@Override
public void stop() {
    if (executor != null) {
        try {
            cleanup.shutdownNow();
            List<Runnable> pending = executor.shutdownNow();
            if (executor.awaitTermination(15, TimeUnit.MINUTES)) {
                if (pending != null && !pending.isEmpty()) {
                    log.info(String.format("Finishing %d disk cache updates", pending.size()));
                    for (Runnable update : pending) {
                        update.run();
                    }
                }
            } else {
                log.info("Timeout waiting for disk cache to close");
            }
        } catch (InterruptedException e) {
            log.warn("Interrupted waiting for disk cache to shutdown");
        }
    }
    synchronized (caches) {
        for (H2CacheImpl<?, ?> cache : caches) {
            cache.stop();
        }
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "cast" })
@Override
public <K, V> Cache<K, V> build(CacheBinding<K, V> def) {
    long limit = config.getLong("cache", def.name(), "diskLimit", 128 << 20);
    if (cacheDir == null || limit <= 0) {
        return defaultFactory.build(def);
    }
    SqlStore<K, V> store = newSqlStore(def.name(), def.keyType(), limit);
    H2CacheImpl<K, V> cache = new H2CacheImpl<K, V>(executor, store, def.keyType(), (Cache<K, ValueHolder<V>>) defaultFactory.create(def, true).build());
    caches.add(cache);
    return cache;
}
#method_after
@SuppressWarnings({ "unchecked", "cast" })
@Override
public <K, V> Cache<K, V> build(CacheBinding<K, V> def) {
    long limit = config.getLong("cache", def.name(), "diskLimit", 128 << 20);
    if (cacheDir == null || limit <= 0) {
        return defaultFactory.build(def);
    }
    SqlStore<K, V> store = newSqlStore(def.name(), def.keyType(), limit);
    H2CacheImpl<K, V> cache = new H2CacheImpl<K, V>(executor, store, def.keyType(), (Cache<K, ValueHolder<V>>) defaultFactory.create(def, true).build());
    synchronized (caches) {
        caches.add(cache);
    }
    return cache;
}
#end_block

#method_before
private static void addExtensionLink(LinkMenuBar m, TopMenuItem item) {
    Anchor atag;
    if (item.getUrl() != null && isAbsolute(item.getUrl())) {
        atag = anchor(item.getName(), item.getUrl());
    } else {
        atag = anchor(item.getName(), selfRedirect(item.getUrl()));
    }
    atag.setTarget(item.getTarget());
    if (item.getId() != null) {
        atag.getElement().setAttribute("id", item.getId());
    }
    m.add(atag);
}
#method_after
private static void addExtensionLink(LinkMenuBar m, TopMenuItem item) {
    Anchor atag = anchor(item.getName(), isAbsolute(item.getUrl()) ? item.getUrl() : selfRedirect(item.getUrl()));
    atag.setTarget(item.getTarget());
    if (item.getId() != null) {
        atag.getElement().setAttribute("id", item.getId());
    }
    m.add(atag);
}
#end_block

#method_before
private static boolean isAbsolute(String url) {
    String pattern = "^https?://.*";
    return url.matches(pattern);
}
#method_after
private static boolean isAbsolute(String url) {
    return url.matches("^https?://.*");
}
#end_block

#method_before
@Override
public void addDocument(Iterable<? extends IndexableField> doc) throws IOException {
    super.addDocument(doc);
}
#method_after
@Override
public void addDocument(Iterable<? extends IndexableField> doc) throws IOException {
    super.addDocument(doc);
    autoFlush();
}
#end_block

#method_before
@Override
public void deleteDocuments(Term... terms) throws IOException {
    super.deleteDocuments(terms);
    autoFlush();
}
#method_after
@Override
public void deleteDocuments(Term term) throws IOException {
    super.deleteDocuments(term);
    autoFlush();
}
#end_block

#method_before
@Override
public void deleteDocuments(Query... queries) throws IOException {
    super.deleteDocuments(queries);
    autoFlush();
}
#method_after
@Override
public void deleteDocuments(Term... terms) throws IOException {
    super.deleteDocuments(terms);
    autoFlush();
}
#end_block

#method_before
@Override
public void deleteDocuments(Query... queries) throws IOException {
    super.deleteDocuments(queries);
    autoFlush();
}
#method_after
@Override
public void deleteDocuments(Query query) throws IOException {
    super.deleteDocuments(query);
    autoFlush();
}
#end_block

#method_before
void manualFlush() throws IOException {
    flush(true, true);
}
#method_after
void manualFlush() throws IOException {
    flush(true, true);
    if (autoCommit) {
        commit();
    }
}
#end_block

#method_before
private Change.Id createNewChange(Repository git, RevWalk revWalk, Change.Key changeKey, Project.NameKey project, PatchSet.Id patchSetId, Ref destRef, RevCommit cherryPickCommit, RefControl refControl) throws OrmException, InvalidChangeOperationException, IOException {
    Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), currentUser.getAccountId(), new Branch.NameKey(project, destRef.getName()), TimeUtil.nowTs());
    ChangeInserter ins = changeInserterFactory.create(refControl, change, cherryPickCommit);
    PatchSet newPatchSet = ins.getPatchSet();
    CommitValidators commitValidators = commitValidatorsFactory.create(refControl, new NoSshInfo(), git);
    CommitReceivedEvent commitReceivedEvent = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), cherryPickCommit.getId(), newPatchSet.getRefName()), refControl.getProjectControl().getProject(), refControl.getRefName(), cherryPickCommit, currentUser);
    try {
        commitValidators.validateForGerritCommits(commitReceivedEvent);
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
    final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(cherryPickCommit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    ins.setMessage(buildChangeMessage(patchSetId, change)).insert();
    return change.getId();
}
#method_after
private Change.Id createNewChange(Repository git, RevWalk revWalk, Change.Key changeKey, Project.NameKey project, PatchSet.Id patchSetId, Ref destRef, RevCommit cherryPickCommit, RefControl refControl) throws OrmException, InvalidChangeOperationException, IOException {
    Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), currentUser.getAccountId(), new Branch.NameKey(project, destRef.getName()), TimeUtil.nowTs());
    ChangeInserter ins = changeInserterFactory.create(refControl, change, cherryPickCommit);
    PatchSet newPatchSet = ins.getPatchSet();
    CommitValidators commitValidators = commitValidatorsFactory.create(refControl, new NoSshInfo(), git);
    CommitReceivedEvent commitReceivedEvent = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), cherryPickCommit.getId(), newPatchSet.getRefName()), refControl.getProjectControl().getProject(), refControl.getRefName(), cherryPickCommit, currentUser);
    try {
        commitValidators.validateForGerritCommits(commitReceivedEvent);
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
    final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(cherryPickCommit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    ins.setMessage(buildChangeMessage(patchSetId, change, cherryPickCommit)).insert();
    return change.getId();
}
#end_block

#method_before
private ChangeMessage buildChangeMessage(PatchSet.Id patchSetId, Change dest) throws OrmException {
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(patchSetId.getParentKey(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), patchSetId);
    StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Cherry Picked");
    msgBuf.append("\n\n");
    msgBuf.append("This patchset was cherry picked to branch: " + dest.getDest().get());
    cmsg.setMessage(msgBuf.toString());
    return cmsg;
}
#method_after
private ChangeMessage buildChangeMessage(PatchSet.Id patchSetId, Change dest, RevCommit cherryPickCommit) throws OrmException {
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(patchSetId.getParentKey(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), patchSetId);
    String destBranchName = dest.getDest().get();
    StringBuilder msgBuf = new StringBuilder("Patch Set ").append(patchSetId.get()).append(": Cherry Picked").append("\n\n").append("This patchset was cherry picked to branch ").append(destBranchName.substring(destBranchName.indexOf("refs/heads/") + "refs/heads/".length())).append(" as commit ").append(cherryPickCommit.getId().getName());
    cmsg.setMessage(msgBuf.toString());
    return cmsg;
}
#end_block

#method_before
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, xsrfToken);
    self.put(key, val);
    return val;
}
#method_after
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = now();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, xsrfToken, expiresAt);
    self.put(key.token, val);
    return val;
}
#end_block

#method_before
Val get(final Key key) {
    return self.getIfPresent(key.token);
}
#method_after
Val get(final Key key) {
    Val val = self.getIfPresent(key.token);
    if (val != null && val.expiresAt <= now()) {
        self.invalidate(key.token);
        return null;
    }
    return val;
}
#end_block

#method_before
private void writeObject(final ObjectOutputStream out) throws IOException {
    writeVarInt32(out, 1);
    writeVarInt32(out, accountId.get());
    writeVarInt32(out, 2);
    writeFixInt64(out, refreshCookieAt);
    writeVarInt32(out, 3);
    writeVarInt32(out, persistentCookie ? 1 : 0);
    if (externalId != null) {
        writeVarInt32(out, 4);
        writeString(out, externalId.get());
    }
    writeVarInt32(out, 5);
    writeString(out, xsrfToken);
    writeVarInt32(out, 0);
}
#method_after
private void writeObject(final ObjectOutputStream out) throws IOException {
    writeVarInt32(out, 1);
    writeVarInt32(out, accountId.get());
    writeVarInt32(out, 2);
    writeFixInt64(out, refreshCookieAt);
    writeVarInt32(out, 3);
    writeVarInt32(out, persistentCookie ? 1 : 0);
    if (externalId != null) {
        writeVarInt32(out, 4);
        writeString(out, externalId.get());
    }
    writeVarInt32(out, 5);
    writeString(out, xsrfToken);
    writeVarInt32(out, 6);
    writeFixInt64(out, expiresAt);
    writeVarInt32(out, 0);
}
#end_block

#method_before
private void readObject(final ObjectInputStream in) throws IOException {
    PARSE: for (; ; ) {
        final int tag = readVarInt32(in);
        switch(tag) {
            case 0:
                break PARSE;
            case 1:
                accountId = new Account.Id(readVarInt32(in));
                continue;
            case 2:
                refreshCookieAt = readFixInt64(in);
                continue;
            case 3:
                persistentCookie = readVarInt32(in) != 0;
                continue;
            case 4:
                externalId = new AccountExternalId.Key(readString(in));
                continue;
            case 5:
                xsrfToken = readString(in);
                continue;
            default:
                throw new IOException("Unknown tag found in object: " + tag);
        }
    }
}
#method_after
private void readObject(final ObjectInputStream in) throws IOException {
    PARSE: for (; ; ) {
        final int tag = readVarInt32(in);
        switch(tag) {
            case 0:
                break PARSE;
            case 1:
                accountId = new Account.Id(readVarInt32(in));
                continue;
            case 2:
                refreshCookieAt = readFixInt64(in);
                continue;
            case 3:
                persistentCookie = readVarInt32(in) != 0;
                continue;
            case 4:
                externalId = new AccountExternalId.Key(readString(in));
                continue;
            case 5:
                xsrfToken = readString(in);
                continue;
            case 6:
                expiresAt = readFixInt64(in);
                continue;
            default:
                throw new IOException("Unknown tag found in object: " + tag);
        }
    }
    if (expiresAt == 0) {
        expiresAt = refreshCookieAt + TimeUnit.HOURS.toMillis(2);
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InMemoryCacheModule());
    modules.add(new H2BackedPersistentCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new MasterNodeStartup());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new MasterNodeStartup());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sshInjector.getInstance(WebModule.class));
    modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sshInjector.getInstance(WebModule.class));
    modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(FILE_NAME, PatchListKey.class, PatchList.class).memoryLimit(// very large items, cache only a few
            128).populateWith(PatchListLoader.class);
            persist(INTRA_NAME, IntraLineDiffKey.class, IntraLineDiff.class).memoryLimit(// very large items, cache only a few
            128).populateWith(IntraLineLoader.class);
            bind(PatchListCacheImpl.class);
            bind(PatchListCache.class).to(PatchListCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(FILE_NAME, PatchListKey.class, PatchList.class).maximumWeight(10 << 20).loader(PatchListLoader.class).weigher(PatchListWeigher.class);
            persist(INTRA_NAME, IntraLineDiffKey.class, IntraLineDiff.class).maximumWeight(10 << 20).loader(IntraLineLoader.class).weigher(IntraLineWeigher.class);
            bind(PatchListCacheImpl.class);
            bind(PatchListCache.class).to(PatchListCacheImpl.class);
        }
    };
}
#end_block

#method_before
public PatchList get(PatchListKey key) {
    try {
        return fileCache.get(key);
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        // TODO Handle PatchList errors in callers.
        return null;
    }
}
#method_after
@Override
public PatchList get(PatchListKey key) throws PatchListNotAvailableException {
    try {
        return fileCache.get(key);
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        throw new PatchListNotAvailableException(e.getCause());
    }
}
#end_block

#method_before
public PatchList get(final Change change, final PatchSet patchSet) {
    final Project.NameKey projectKey = change.getProject();
    final ObjectId a = null;
    final ObjectId b = ObjectId.fromString(patchSet.getRevision().get());
    final Whitespace ws = Whitespace.IGNORE_NONE;
    return get(new PatchListKey(projectKey, a, b, ws));
}
#method_after
@Override
public PatchList get(final Change change, final PatchSet patchSet) throws PatchListNotAvailableException {
    final Project.NameKey projectKey = change.getProject();
    final ObjectId a = null;
    final ObjectId b = ObjectId.fromString(patchSet.getRevision().get());
    final Whitespace ws = Whitespace.IGNORE_NONE;
    return get(new PatchListKey(projectKey, a, b, ws));
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).populateWith(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Inject
void setPersistentCacheFactory(@Nullable PersistentCacheFactory factory) {
    this.store = factory;
}
#method_after
@Inject(optional = true)
void setPersistentCacheFactory(@Nullable PersistentCacheFactory factory) {
    this.persistentCacheFactory = factory;
}
#end_block

#method_before
CacheBinding<K, V> persist(boolean p) {
    persist = p;
    return this;
}
#method_after
CacheBinding<K, V> persist(boolean p) {
    Preconditions.checkState(!frozen, "binding frozen, cannot be modified");
    persist = p;
    return this;
}
#end_block

#method_before
@Override
public Cache<K, V> get() {
    CacheBuilder<K, V> builder = newCacheBuilder();
    builder.maximumSize(maxSize);
    if (0 < maxAge) {
        builder.expireAfterWrite(maxAge, TimeUnit.SECONDS);
    }
    if (loader != null) {
        CacheLoader<K, V> ldr = loader.get();
        if (persist && store != null) {
            return store.build(name, keyType, valType, builder, ldr);
        }
        return builder.build(ldr);
    } else if (persist && store != null) {
        return store.build(name, keyType, valType, builder);
    } else {
        return builder.build();
    }
}
#method_after
@Override
public Cache<K, V> get() {
    frozen = true;
    if (loader != null) {
        CacheLoader<K, V> ldr = loader.get();
        if (persist && persistentCacheFactory != null) {
            return persistentCacheFactory.build(this, ldr);
        }
        return memoryCacheFactory.build(this, ldr);
    } else if (persist && persistentCacheFactory != null) {
        return persistentCacheFactory.build(this);
    } else {
        return memoryCacheFactory.build(this);
    }
}
#end_block

#method_before
protected <K, V> CacheBinding<K, V> cache(String name, TypeLiteral<K> keyType, TypeLiteral<V> valType) {
    Type type = Types.newParameterizedType(Cache.class, keyType.getType(), valType.getType());
    @SuppressWarnings("unchecked")
    Key<Cache<K, V>> key = (Key<Cache<K, V>>) Key.get(type, Names.named(name));
    CacheProvider<K, V> m = new CacheProvider<K, V>(name, keyType, valType, this);
    bind(key).toProvider(m).in(Scopes.SINGLETON);
    bind(ANY_CACHE).annotatedWith(Exports.named(name)).to(key);
    return m.memoryLimit(1024);
}
#method_after
protected <K, V> CacheBinding<K, V> cache(String name, TypeLiteral<K> keyType, TypeLiteral<V> valType) {
    Type type = Types.newParameterizedType(Cache.class, keyType.getType(), valType.getType());
    @SuppressWarnings("unchecked")
    Key<Cache<K, V>> key = (Key<Cache<K, V>>) Key.get(type, Names.named(name));
    CacheProvider<K, V> m = new CacheProvider<K, V>(this, name, keyType, valType);
    bind(key).toProvider(m).in(Scopes.SINGLETON);
    bind(ANY_CACHE).annotatedWith(Exports.named(name)).to(key);
    return m.maximumWeight(1024);
}
#end_block

#method_before
<K, V> Provider<CacheLoader<K, V>> bindCacheLoader(CacheProvider<K, V> m, Class<? extends CacheLoader<K, V>> impl) {
    Type type = Types.newParameterizedType(Cache.class, m.keyType.getType(), m.valType.getType());
    Type loadingType = Types.newParameterizedType(LoadingCache.class, m.keyType.getType(), m.valType.getType());
    Type loaderType = Types.newParameterizedType(CacheLoader.class, m.keyType.getType(), m.valType.getType());
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> key = (Key<LoadingCache<K, V>>) Key.get(type, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> loadingKey = (Key<LoadingCache<K, V>>) Key.get(loadingType, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<CacheLoader<K, V>> loaderKey = (Key<CacheLoader<K, V>>) Key.get(loaderType, Names.named(m.name));
    bind(loaderKey).to(impl).in(Scopes.SINGLETON);
    bind(loadingKey).to(key);
    return getProvider(loaderKey);
}
#method_after
<K, V> Provider<CacheLoader<K, V>> bindCacheLoader(CacheProvider<K, V> m, Class<? extends CacheLoader<K, V>> impl) {
    Type type = Types.newParameterizedType(Cache.class, m.keyType().getType(), m.valueType().getType());
    Type loadingType = Types.newParameterizedType(LoadingCache.class, m.keyType().getType(), m.valueType().getType());
    Type loaderType = Types.newParameterizedType(CacheLoader.class, m.keyType().getType(), m.valueType().getType());
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> key = (Key<LoadingCache<K, V>>) Key.get(type, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> loadingKey = (Key<LoadingCache<K, V>>) Key.get(loadingType, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<CacheLoader<K, V>> loaderKey = (Key<CacheLoader<K, V>>) Key.get(loaderType, Names.named(m.name));
    bind(loaderKey).to(impl).in(Scopes.SINGLETON);
    bind(loadingKey).to(key);
    return getProvider(loaderKey);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(WebSessionManager.CACHE_NAME, String.class, Val.class).memoryLimit(// reasonable default for many sites
            1024).maxAge(MAX_AGE_MINUTES, // expire sessions if they are inactive
            MINUTES);
            bind(WebSessionManager.class);
            bind(WebSession.class).to(CacheBasedWebSession.class).in(RequestScoped.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(WebSessionManager.CACHE_NAME, String.class, Val.class).maximumWeight(// reasonable default for many sites
            1024).expireAfterWrite(MAX_AGE_MINUTES, // expire sessions if they are inactive
            MINUTES);
            bind(WebSessionManager.class);
            bind(WebSession.class).to(CacheBasedWebSession.class).in(RequestScoped.class);
        }
    };
}
#end_block

#method_before
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, "");
}
#method_after
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, "", 0);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, ProjectState.class).populateWith(Loader.class);
            cache(CACHE_LIST, ListKey.class, new TypeLiteral<SortedSet<Project.NameKey>>() {
            }).memoryLimit(1).populateWith(Lister.class);
            bind(ProjectCacheImpl.class);
            bind(ProjectCache.class).to(ProjectCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, ProjectState.class).loader(Loader.class);
            cache(CACHE_LIST, ListKey.class, new TypeLiteral<SortedSet<Project.NameKey>>() {
            }).maximumWeight(1).loader(Lister.class);
            bind(ProjectCacheImpl.class);
            bind(ProjectCache.class).to(ProjectCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYINCLUDE_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).populateWith(ByIncludeLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYINCLUDE_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).loader(ByIncludeLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
protected void run() {
    nw = columns - 50;
    Date now = new Date();
    stdout.format("%-25s %-20s      now  %16s\n", "Gerrit Code Review", Version.getVersion() != null ? Version.getVersion() : "", new SimpleDateFormat("HH:mm:ss   zzz").format(now));
    stdout.format("%-25s %-20s   uptime %16s\n", "", "", uptime(now.getTime() - serverStarted));
    stdout.print('\n');
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%-21s|  %-5s |%-9s|\n", // 
    "", // 
    "Name", // 
    "Entries", // 
    "AvgGet", // 
    "Hit Ratio"));
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%6s %6s %7s|  %-5s  |%-4s %-4s|\n", // 
    "", // 
    "", // 
    "Mem", // 
    "Disk", // 
    "Space", // 
    "", // 
    "Mem", // 
    "Disk"));
    stdout.print("--");
    for (int i = 0; i < nw; i++) {
        stdout.print('-');
    }
    stdout.print("+---------------------+---------+---------+\n");
    Map<String, H2BackedCache<?, ?>> disks = Maps.newTreeMap();
    printMemoryCaches(disks, sortedCoreCaches());
    printMemoryCaches(disks, sortedPluginCaches());
    for (Map.Entry<String, H2BackedCache<?, ?>> entry : disks.entrySet()) {
        H2BackedCache<?, ?> cache = entry.getValue();
        CacheStats stat = cache.stats();
        H2BackedCache.DiskStats disk = cache.diskStats();
        stdout.print(String.format("D %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), count(disk.size()), bytes(disk.space()), duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), percent(disk.hitCount(), disk.requestCount())));
    }
    stdout.print('\n');
    if (gc) {
        System.gc();
        System.runFinalization();
        System.gc();
    }
    sshSummary();
    taskSummary();
    memSummary();
    if (showJVM) {
        jvmSummary();
    }
    stdout.flush();
}
#method_after
@Override
protected void run() {
    nw = columns - 50;
    Date now = new Date();
    stdout.format("%-25s %-20s      now  %16s\n", "Gerrit Code Review", Version.getVersion() != null ? Version.getVersion() : "", new SimpleDateFormat("HH:mm:ss   zzz").format(now));
    stdout.format("%-25s %-20s   uptime %16s\n", "", "", uptime(now.getTime() - serverStarted));
    stdout.print('\n');
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%-21s|  %-5s |%-9s|\n", // 
    "", // 
    "Name", // 
    "Entries", // 
    "AvgGet", // 
    "Hit Ratio"));
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%6s %6s %7s|  %-5s  |%-4s %-4s|\n", // 
    "", // 
    "", // 
    "Mem", // 
    "Disk", // 
    "Space", // 
    "", // 
    "Mem", // 
    "Disk"));
    stdout.print("--");
    for (int i = 0; i < nw; i++) {
        stdout.print('-');
    }
    stdout.print("+---------------------+---------+---------+\n");
    Map<String, H2CacheImpl<?, ?>> disks = Maps.newTreeMap();
    printMemoryCaches(disks, sortedCoreCaches());
    printMemoryCaches(disks, sortedPluginCaches());
    for (Map.Entry<String, H2CacheImpl<?, ?>> entry : disks.entrySet()) {
        H2CacheImpl<?, ?> cache = entry.getValue();
        CacheStats stat = cache.stats();
        H2CacheImpl.DiskStats disk = cache.diskStats();
        stdout.print(String.format("D %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), count(disk.size()), bytes(disk.space()), duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), percent(disk.hitCount(), disk.requestCount())));
    }
    stdout.print('\n');
    if (gc) {
        System.gc();
        System.runFinalization();
        System.gc();
    }
    sshSummary();
    taskSummary();
    memSummary();
    if (showJVM) {
        jvmSummary();
    }
    stdout.flush();
}
#end_block

#method_before
private void printMemoryCaches(Map<String, H2BackedCache<?, ?>> disks, Map<String, Cache<?, ?>> caches) {
    for (Map.Entry<String, Cache<?, ?>> entry : caches.entrySet()) {
        Cache<?, ?> cache = entry.getValue();
        if (cache instanceof H2BackedCache) {
            disks.put(entry.getKey(), (H2BackedCache<?, ?>) cache);
            continue;
        }
        CacheStats stat = cache.stats();
        stdout.print(String.format("  %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), "", "", duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), ""));
    }
}
#method_after
private void printMemoryCaches(Map<String, H2CacheImpl<?, ?>> disks, Map<String, Cache<?, ?>> caches) {
    for (Map.Entry<String, Cache<?, ?>> entry : caches.entrySet()) {
        Cache<?, ?> cache = entry.getValue();
        if (cache instanceof H2CacheImpl) {
            disks.put(entry.getKey(), (H2CacheImpl<?, ?>) cache);
            continue;
        }
        CacheStats stat = cache.stats();
        stdout.print(String.format("  %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), "", "", duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), ""));
    }
}
#end_block

#method_before
private String duration(double ns) {
    if (Math.abs(ns) < 0.01) {
        return "";
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private String duration(double ns) {
    if (ns < 0.5) {
        return "";
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Set<Account.Id>>() {
            }).populateWith(Loader.class);
            bind(AccountByEmailCacheImpl.class);
            bind(AccountByEmailCache.class).to(AccountByEmailCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Set<Account.Id>>() {
            }).loader(Loader.class);
            bind(AccountByEmailCacheImpl.class);
            bind(AccountByEmailCache.class).to(AccountByEmailCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, Account.Id.class, AccountState.class).populateWith(ByIdLoader.class);
            cache(BYUSER_NAME, String.class, new TypeLiteral<Optional<Account.Id>>() {
            }).populateWith(ByNameLoader.class);
            bind(AccountCacheImpl.class);
            bind(AccountCache.class).to(AccountCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, Account.Id.class, AccountState.class).loader(ByIdLoader.class);
            cache(BYUSER_NAME, String.class, new TypeLiteral<Optional<Account.Id>>() {
            }).loader(ByNameLoader.class);
            bind(AccountCacheImpl.class);
            bind(AccountCache.class).to(AccountCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByUUIDLoader.class);
            cache(BYEXT_NAME, String.class, new TypeLiteral<Collection<AccountGroup>>() {
            }).populateWith(ByExternalNameLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByUUIDLoader.class);
            cache(BYEXT_NAME, String.class, new TypeLiteral<Collection<AccountGroup>>() {
            }).loader(ByExternalNameLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InMemoryCacheModule());
    modules.add(new H2BackedPersistentCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).maxAge(1, HOURS).populateWith(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).populateWith(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
}
#method_after
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new InMemoryCacheModule());
            install(new H2BackedPersistentCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new DefaultCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, AdvertisedObjectsCacheKey.class, new TypeLiteral<Set<ObjectId>>() {
            }).memoryLimit(4096).maxAge(10, TimeUnit.MINUTES);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, AdvertisedObjectsCacheKey.class, new TypeLiteral<Set<ObjectId>>() {
            }).maximumWeight(4096).expireAfterWrite(10, TimeUnit.MINUTES);
        }
    });
}
#end_block

#method_before
private void setLabelScores(LabelType type, LabelInfo label, short score, Account.Id accountId) throws OrmException {
    if (label.approved != null || label.rejected != null) {
        return;
    }
    if (type.getMin() == null || type.getMax() == null) {
        // Can't set score for unknown or misconfigured type.
        return;
    }
    if (score != 0) {
        if (score == type.getMin().getValue()) {
            if (type.getFunctionName().equalsIgnoreCase("NoBlock")) {
                label.disliked = accountLoader.get(accountId);
            } else {
                label.rejected = accountLoader.get(accountId);
            }
        } else if (score == type.getMax().getValue()) {
            label.approved = accountLoader.get(accountId);
        } else if (score < 0) {
            label.disliked = accountLoader.get(accountId);
            label.value = score;
        } else if (score > 0 && label.disliked == null) {
            label.recommended = accountLoader.get(accountId);
            label.value = score;
        }
    }
    return;
}
#method_after
private void setLabelScores(LabelType type, LabelInfo label, short score, Account.Id accountId) throws OrmException {
    if (label.approved != null || label.rejected != null) {
        return;
    }
    if (type.getMin() == null || type.getMax() == null) {
        // Can't set score for unknown or misconfigured type.
        return;
    }
    if (score < 0) {
        label.disliked = accountLoader.get(accountId);
        label.value = score;
    } else if (score > 0 && label.disliked == null) {
        label.recommended = accountLoader.get(accountId);
        label.value = score;
    }
}
#end_block

#method_before
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            if (configEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                p.values = Arrays.asList(cfg.getStringList(e.getExportName()));
            } else {
                p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
            }
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#method_after
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                p.values = Arrays.asList(cfg.getStringList(e.getExportName()));
            } else {
                p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
            }
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else if ("MULTIPLE".equals(param.type())) {
                w = renderTextArea(g, param);
            } else {
                continue;
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            switch(param.type()) {
                case "STRING":
                case "INT":
                case "LONG":
                    w = renderTextBox(g, param);
                    break;
                case "BOOLEAN":
                    w = renderCheckBox(g, param);
                    break;
                case "LIST":
                    w = renderListBox(g, param);
                    break;
                case "ARRAY":
                    w = renderTextArea(g, param);
                    break;
                default:
                    throw new UnsupportedOperationException("unsupported widget type");
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = param.type().equals("STRING") ? new NpTextBox() : new NpIntTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#method_after
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    if (param.permittedValues() == null) {
        return null;
    }
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#end_block

#method_before
private NpTextArea renderTextArea(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextArea txtArea = new NpTextArea();
    txtArea.setVisibleLines(4);
    txtArea.setCharacterWidth(40);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < param.values().length(); i++) {
        String v = param.values().get(i);
        sb.append(v).append("\n");
    }
    txtArea.setText(sb.toString());
    if (param.editable()) {
        saveEnabler.listenTo(txtArea);
    } else {
        txtArea.setEnabled(false);
    }
    addWidget(g, txtArea, param);
    param.values();
    return txtArea;
}
#method_after
private NpTextArea renderTextArea(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextArea txtArea = new NpTextArea();
    txtArea.setVisibleLines(4);
    txtArea.setCharacterWidth(40);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < param.values().length(); i++) {
        String v = param.values().get(i);
        sb.append(v).append("\n");
    }
    txtArea.setText(sb.toString());
    if (param.editable()) {
        saveEnabler.listenTo(txtArea);
    } else {
        txtArea.setEnabled(false);
    }
    addWidget(g, txtArea, param);
    return txtArea;
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), value);
            } else if (widget instanceof NpTextArea) {
                NpTextArea txtArea = (NpTextArea) widget;
                values.put(e2.getKey(), txtArea.getText().trim());
            } else {
                throw new UnsupportedOperationException("unupported widget type");
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, ConfigParameterValue>> getPluginConfigValues() {
    Map<String, Map<String, ConfigParameterValue>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, ConfigParameterValue> values = new HashMap<>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(((TextBox) widget).getValue().trim()));
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(Boolean.toString(((CheckBox) widget).getValue())));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), ConfigParameterValue.create().value(value));
            } else if (widget instanceof NpTextArea) {
                String text = ((NpTextArea) widget).getText().trim();
                values.put(e2.getKey(), ConfigParameterValue.create().values(text.split("\n")));
            } else {
                throw new UnsupportedOperationException("unsupported widget type");
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                }
                if (v.getValue() != null) {
                    if (!v.getValue().equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(v.getValue());
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(v.getValue());
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(v.getValue());
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(v.getValue())) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.getValue(), v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), v.getValue());
                                    break;
                                case MULTIPLE:
                                    cfg.setStringList(v.getKey(), Lists.newArrayList(Splitter.on("\n").split(v.getValue())));
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
private static List<PluginData> listPlugins(SitePaths site, boolean deleteTempPluginFile, GerritDistributionLocator distroLocator) throws IOException {
    final File myWar = distroLocator.locate();
    final List<PluginData> result = Lists.newArrayList();
    try {
        if (myWar.isFile()) {
            final ZipFile zf = new ZipFile(myWar);
            try {
                final Enumeration<? extends ZipEntry> e = zf.entries();
                while (e.hasMoreElements()) {
                    final ZipEntry ze = e.nextElement();
                    if (ze.isDirectory()) {
                        continue;
                    }
                    if (ze.getName().startsWith(PLUGIN_DIR) && ze.getName().endsWith(JAR)) {
                        final String pluginJarName = new File(ze.getName()).getName();
                        final String pluginName = pluginJarName.substring(0, pluginJarName.length() - JAR.length());
                        final InputStream in = zf.getInputStream(ze);
                        final File tmpPlugin = PluginLoader.storeInTemp(pluginName, in, site);
                        final String pluginVersion = getVersion(tmpPlugin);
                        if (deleteTempPluginFile) {
                            tmpPlugin.delete();
                        }
                        result.add(new PluginData(pluginName, pluginVersion, tmpPlugin));
                    }
                }
            } finally {
                zf.close();
            }
        } else {
            File pluginDir = new File(myWar, PLUGIN_DIR);
            for (File p : pluginDir.listFiles()) {
                String pluginJarName = p.getName();
                String pluginName = pluginJarName.substring(0, pluginJarName.length() - JAR.length());
                File tmpPlugin;
                InputStream in = new FileInputStream(p);
                try {
                    tmpPlugin = PluginLoader.storeInTemp(pluginName, in, site);
                } finally {
                    in.close();
                }
                String pluginVersion = getVersion(tmpPlugin);
                if (deleteTempPluginFile) {
                    tmpPlugin.delete();
                }
                result.add(new PluginData(pluginName, pluginVersion, tmpPlugin));
            }
        }
    } catch (IOException e) {
        throw new IOException("Failure during plugin installation", e);
    }
    return result;
}
#method_after
public static List<PluginData> listPlugins(SitePaths site, PluginsDistribution pluginsDistribution) throws IOException {
    return listPlugins(site, false, pluginsDistribution);
}
#end_block

#method_before
public static List<PluginData> listPluginsAndRemoveTempFiles(SitePaths site, GerritDistributionLocator distroLocator) throws IOException {
    return listPlugins(site, true, distroLocator);
}
#method_after
public static List<PluginData> listPluginsAndRemoveTempFiles(SitePaths site, PluginsDistribution pluginsDistribution) throws IOException {
    return listPlugins(site, true, pluginsDistribution);
}
#end_block

#method_before
private void installPlugins() throws IOException {
    List<PluginData> plugins = listPlugins(site, distroLocator);
    for (PluginData plugin : plugins) {
        String pluginName = plugin.name;
        try {
            final File tmpPlugin = plugin.pluginFile;
            if (!(initFlags.installPlugins.contains(pluginName) || ui.yesno(false, "Install plugin %s version %s", pluginName, plugin.version))) {
                tmpPlugin.delete();
                continue;
            }
            final File p = new File(site.plugins_dir, plugin.name + ".jar");
            if (p.exists()) {
                final String installedPluginVersion = getVersion(p);
                if (!ui.yesno(false, "version %s is already installed, overwrite it", installedPluginVersion)) {
                    tmpPlugin.delete();
                    continue;
                }
                if (!p.delete()) {
                    throw new IOException("Failed to delete plugin " + pluginName + ": " + p.getAbsolutePath());
                }
            }
            if (!tmpPlugin.renameTo(p)) {
                throw new IOException("Failed to install plugin " + pluginName + ": " + tmpPlugin.getAbsolutePath() + " -> " + p.getAbsolutePath());
            }
        } finally {
            if (plugin.pluginFile.exists()) {
                plugin.pluginFile.delete();
            }
        }
    }
    if (plugins.isEmpty()) {
        ui.message("No plugins found.");
    }
}
#method_after
private void installPlugins() throws IOException {
    List<PluginData> plugins = listPlugins(site, pluginsDistribution);
    for (PluginData plugin : plugins) {
        String pluginName = plugin.name;
        try {
            final File tmpPlugin = plugin.pluginFile;
            if (!(initFlags.installPlugins.contains(pluginName) || ui.yesno(false, "Install plugin %s version %s", pluginName, plugin.version))) {
                tmpPlugin.delete();
                continue;
            }
            final File p = new File(site.plugins_dir, plugin.name + ".jar");
            if (p.exists()) {
                final String installedPluginVersion = getVersion(p);
                if (!ui.yesno(false, "version %s is already installed, overwrite it", installedPluginVersion)) {
                    tmpPlugin.delete();
                    continue;
                }
                if (!p.delete()) {
                    throw new IOException("Failed to delete plugin " + pluginName + ": " + p.getAbsolutePath());
                }
            }
            if (!tmpPlugin.renameTo(p)) {
                throw new IOException("Failed to install plugin " + pluginName + ": " + tmpPlugin.getAbsolutePath() + " -> " + p.getAbsolutePath());
            }
        } finally {
            if (plugin.pluginFile.exists()) {
                plugin.pluginFile.delete();
            }
        }
    }
    if (plugins.isEmpty()) {
        ui.message("No plugins found.");
    }
}
#end_block

#method_before
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, distroLocator);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#method_after
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, pluginsDistribution);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (standalone) {
        step().to(InitDatabase.class);
    }
    step().to(InitIndex.class);
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    step().to(InitPlugins.class);
}
#method_after
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (initDb) {
        step().to(InitDatabase.class);
    }
    step().to(InitIndex.class);
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    step().to(InitPlugins.class);
}
#end_block

#method_before
public void init() {
    try {
        if (sitePath != null) {
            File site = new File(sitePath);
            LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
            new BaseInit(site, false, distroLocator).run();
            return;
        }
        Connection conn = connectToDb();
        try {
            File site = getSiteFromReviewDb(conn);
            if (site == null && initPath != null) {
                site = new File(initPath);
            }
            if (site != null) {
                LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
                new BaseInit(site, new ReviewDbDataSourceProvider(), false, distroLocator).run();
            }
        } finally {
            conn.close();
        }
    } catch (Exception e) {
        LOG.error("Site init failed", e);
        throw new RuntimeException(e);
    }
}
#method_after
public void init() {
    try {
        if (sitePath != null) {
            File site = new File(sitePath);
            LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
            new BaseInit(site, false, true, pluginsDistribution).run();
            return;
        }
        Connection conn = connectToDb();
        try {
            File site = getSiteFromReviewDb(conn);
            if (site == null && initPath != null) {
                site = new File(initPath);
            }
            if (site != null) {
                LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
                new BaseInit(site, new ReviewDbDataSourceProvider(), false, false, pluginsDistribution).run();
            }
        } finally {
            conn.close();
        }
    } catch (Exception e) {
        LOG.error("Site init failed", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
protected List<String> getInstallPlugins() {
    File root;
    try {
        root = distroLocator.locate();
    } catch (FileNotFoundException e) {
        log.warn("Couldn't open folder containing plugins." + " No plugin will be installed");
        return null;
    }
    ArrayList<String> result = Lists.newArrayList();
    File plugins = new File(root, InitPlugins.PLUGIN_DIR);
    for (File p : plugins.listFiles()) {
        String pluginJarName = p.getName();
        String pluginName = pluginJarName.substring(0, pluginJarName.length() - InitPlugins.JAR.length());
        result.add(pluginName);
    }
    return result;
}
#method_after
protected List<String> getInstallPlugins() {
    try {
        return pluginsDistribution.listPluginNames();
    } catch (FileNotFoundException e) {
        log.warn("Couldn't find distribution archive location." + " No plugin will be installed");
        return null;
    }
}
#end_block

#method_before
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<Module>();
    m.add(new InitModule(standalone));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = Objects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(GerritDistributionLocator.class).toInstance(distroLocator);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#method_after
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<Module>();
    m.add(new InitModule(standalone, initDb));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = Objects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#end_block

#method_before
private synchronized void init() {
    if (manager == null) {
        final String path = System.getProperty("gerrit.site_path");
        if (path != null) {
            sitePath = new File(path);
        }
        if (System.getProperty("gerrit.init") != null) {
            new SiteInitializer(path, System.getProperty("gerrit.init_path"), new WebAppLocator(servletContext)).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            log.error(buf.toString(), first.getCause());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setCfgInjector(cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#method_after
private synchronized void init() {
    if (manager == null) {
        final String path = System.getProperty("gerrit.site_path");
        if (path != null) {
            sitePath = new File(path);
        }
        if (System.getProperty("gerrit.init") != null) {
            new SiteInitializer(path, System.getProperty("gerrit.init_path"), new UnzippedDistribution(servletContext)).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            log.error(buf.toString(), first.getCause());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setCfgInjector(cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, Input input) throws MethodNotAllowedException, ResourceNotFoundException, OrmException {
    if (input == null) {
        input = new Input();
    }
    ReviewDb db = dbProvider.get();
    Account a = db.accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    if (!realm.allowsEdit(FieldName.FULL_NAME)) {
        if (realm instanceof LdapRealm && db.accountExternalIds().get(new AccountExternalId.Key(SCHEME_GERRIT, a.getUserName())) == null) {
        // make it possible to update the full name of manually created account
        // in Gerrit using LDAP backend.
        } else {
            throw new MethodNotAllowedException("realm does not allow editing name");
        }
    }
    a.setFullName(input.name);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.<String>none() : Response.ok(a.getFullName());
}
#method_after
public Response<String> apply(IdentifiedUser user, Input input) throws MethodNotAllowedException, ResourceNotFoundException, OrmException {
    if (input == null) {
        input = new Input();
    }
    ReviewDb db = dbProvider.get();
    Account a = db.accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    if (!realm.allowsEdit(FieldName.FULL_NAME) && !(realm instanceof LdapRealm && db.accountExternalIds().get(new AccountExternalId.Key(SCHEME_GERRIT, a.getUserName())) == null)) {
        throw new MethodNotAllowedException("realm does not allow editing name");
    }
    a.setFullName(input.name);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.<String>none() : Response.ok(a.getFullName());
}
#end_block

#method_before
@Override
public String toString() {
    return "push " + uri;
}
#method_after
@Override
public String toString() {
    if (retryCount == 0) {
        return "push " + uri;
    }
    return "(retry " + retryCount + ") " + "push " + uri;
}
#end_block

#method_before
void setToRetry() {
    retrying = true;
}
#method_after
void setToRetry() {
    retrying = true;
    retryCount++;
}
#end_block

#method_before
@Override
public void run() {
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() {
                runPushOperation();
                return null;
            }
        }).call();
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
}
#method_after
@Override
public void run() {
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() {
                runPushOperation();
                return null;
            }
        }).call();
    } catch (Exception e) {
        throw Throwables.propagate(e);
    } finally {
        statesCleanUp();
    }
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    pool.notifyStarting(this);
    // since the canceled flag would be set locking the queue.
    if (!canceled) {
        try {
            git = gitManager.openRepository(projectName);
            runImpl();
        } catch (RepositoryNotFoundException e) {
            log.error("Cannot replicate " + projectName + "; " + e.getMessage());
        } catch (NoRemoteRepositoryException e) {
            log.error("Cannot replicate to " + uri + "; repository not found");
        } catch (NotSupportedException e) {
            log.error("Cannot replicate to " + uri, e);
        } catch (TransportException e) {
            Throwable cause = e.getCause();
            if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
                log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
            } else if (e instanceof RemoteRepositoryException && e.getMessage().endsWith("failed to lock")) {
                // The RemoteRepositoryException message contains both URI and reason
                // for this intermediate failure.
                log.error("Cannot replicate to " + e.getMessage());
            } else {
                log.error("Cannot replicate to " + uri, e);
            }
            // The remote push operation should be retried.
            pool.reschedule(this);
        } catch (IOException e) {
            log.error("Cannot replicate to " + uri, e);
        } catch (RuntimeException e) {
            log.error("Unexpected error during replication to " + uri, e);
        } catch (Error e) {
            log.error("Unexpected error during replication to " + uri, e);
        } finally {
            if (git != null) {
                git.close();
            }
        }
    }
}
#method_after
private void runPushOperation() {
    // 
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            log.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    try {
        git = gitManager.openRepository(projectName);
        runImpl();
    } catch (RepositoryNotFoundException e) {
        wrappedLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        final String msg = e.getMessage();
        if (msg.contains("access denied")) {
            createRepository();
        } else {
            log.error("Cannot replicate " + projectName + "; Remote repository error: " + msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            log.error("Cannot replicate to " + e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            } else {
                log.error("Giving up after " + lockRetryCount + " of this error during replication to " + e.getMessage());
            }
        } else {
            log.error("Cannot replicate to " + uri, e);
            // The remote push operation should be retried.
            pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
        }
    } catch (IOException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } catch (Error e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#end_block

#method_before
private void runImpl() throws IOException {
    Transport tn = Transport.open(git, uri);
    PushResult res;
    try {
        res = pushVia(tn);
    } finally {
        try {
            tn.close();
        } catch (Throwable e2) {
            log.warn("Unexpected error while closing " + uri, e2);
        }
    }
    for (RemoteRefUpdate u : res.getRemoteUpdates()) {
        switch(u.getStatus()) {
            case OK:
            case UP_TO_DATE:
            case NON_EXISTING:
                break;
            case NOT_ATTEMPTED:
            case AWAITING_REPORT:
            case REJECTED_NODELETE:
            case REJECTED_NONFASTFORWARD:
            case REJECTED_REMOTE_CHANGED:
                log.error(String.format("Failed replicate of %s to %s: status %s", u.getRemoteName(), uri, u.getStatus()));
                break;
            case REJECTED_OTHER_REASON:
                if ("non-fast-forward".equals(u.getMessage())) {
                    log.error(String.format("Failed replicate of %s to %s" + ", remote rejected non-fast-forward push." + "  Check receive.denyNonFastForwards variable in config file" + " of destination repository.", u.getRemoteName(), uri));
                } else if ("failed to lock".equals(u.getMessage())) {
                    throw new RemoteRepositoryException(uri, u.getMessage());
                } else {
                    log.error(String.format("Failed replicate of %s to %s, reason: %s", u.getRemoteName(), uri, u.getMessage()));
                }
                break;
        }
    }
}
#method_after
private void runImpl() throws IOException {
    Transport tn = Transport.open(git, uri);
    PushResult res;
    try {
        res = pushVia(tn);
    } finally {
        try {
            tn.close();
        } catch (Throwable e2) {
            log.warn("Unexpected error while closing " + uri, e2);
        }
    }
    updateStates(res.getRemoteUpdates());
}
#end_block

#method_before
private PushResult pushVia(Transport tn) throws IOException, NotSupportedException, TransportException {
    tn.applyConfig(config);
    tn.setCredentialsProvider(credentialsProvider);
    List<RemoteRefUpdate> todo = generateUpdates(tn);
    if (todo.isEmpty()) {
        // send back an empty result.
        return new PushResult();
    }
    return tn.push(NullProgressMonitor.INSTANCE, todo);
}
#method_after
private PushResult pushVia(Transport tn) throws IOException, NotSupportedException, TransportException {
    tn.applyConfig(config);
    tn.setCredentialsProvider(credentialsProvider);
    List<RemoteRefUpdate> todo = generateUpdates(tn);
    if (todo.isEmpty()) {
        // send back an empty result.
        return new PushResult();
    }
    log.info("Push to " + uri + " references: " + todo);
    return tn.push(NullProgressMonitor.INSTANCE, todo);
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#method_after
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            wrappedLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (noPerms && GitRepositoryManager.REF_CONFIG.equals(src.getName())) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (!canPushRef(src.getName(), noPerms)) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            if (srcRef != null && !(noPerms && GitRepositoryManager.REF_CONFIG.equals(src))) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            if (srcRef != null && canPushRef(src, noPerms)) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    ResultSet<Account> accounts = db.accounts().all();
    for (Account account : accounts) {
        String out = new StringBuilder().append(account.getId().toString()).append(" |").append(Strings.isNullOrEmpty(account.getFullName()) ? "" : " " + account.getFullName()).append(" |").append(Strings.isNullOrEmpty(account.getPreferredEmail()) ? "" : " " + account.getPreferredEmail()).toString();
        stdout.println(out);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    ResultSet<Account> accounts = db.accounts().iterateAllEntities();
    for (Account account : accounts) {
        String out = new StringBuilder().append(account.getId().toString()).append(" |").append(Strings.isNullOrEmpty(account.getFullName()) ? "" : " " + account.getFullName()).append(" |").append(Strings.isNullOrEmpty(account.getPreferredEmail()) ? "" : " " + account.getPreferredEmail()).toString();
        stdout.println(out);
    }
}
#end_block

#method_before
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    if (doBind(meta.mode())) {
        bind(Commands.key(parent, meta.name(), meta.description())).to(clazz);
    }
}
#method_after
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    if (meta.runsAt().isSupported(slaveMode)) {
        bind(Commands.key(parent, meta.name(), meta.description())).to(clazz);
    }
}
#end_block

#method_before
void populate(final int row, final PluginInfo plugin) {
    if (plugin.disabled() || plugin.indexUrl() == null) {
        table.setText(row, 1, plugin.name());
    } else {
        HorizontalPanel p = new HorizontalPanel();
        p.setStyleName(Gerrit.RESOURCES.css().pluginName());
        p.add(new Anchor(plugin.name(), Gerrit.selfRedirect(plugin.indexUrl()), "_blank"));
        if (plugin.adminUrl() != null) {
            Anchor adminScreenAcnhcor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.gear()), Gerrit.selfRedirect(plugin.adminUrl()));
            adminScreenAcnhcor.setTitle(Util.C.pluginAdminToolTip());
            p.add(adminScreenAcnhcor);
        }
        table.setWidget(row, 1, p);
    }
    table.setText(row, 2, plugin.version());
    table.setText(row, 3, plugin.disabled() ? Util.C.pluginDisabled() : Util.C.pluginEnabled());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#method_after
void populate(final int row, final PluginInfo plugin) {
    if (plugin.disabled() || plugin.indexUrl() == null) {
        table.setText(row, 1, plugin.name());
    } else {
        table.setWidget(row, 1, new Anchor(plugin.name(), Gerrit.selfRedirect(plugin.indexUrl()), "_blank"));
        if (new ExtensionScreen(plugin.name() + "/settings").isFound()) {
            InlineHyperlink adminScreenLink = new InlineHyperlink();
            adminScreenLink.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.gear()));
            adminScreenLink.setTargetHistoryToken("/x/" + plugin.name() + "/settings");
            adminScreenLink.setTitle(Util.C.pluginSettingsToolTip());
            table.setWidget(row, 2, adminScreenLink);
        }
    }
    table.setText(row, 3, plugin.version());
    table.setText(row, 4, plugin.disabled() ? Util.C.pluginDisabled() : Util.C.pluginEnabled());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#end_block

#method_before
@Override
public ChangeDescription get(EnumSet<ListChangesOption> options) throws RestApiException {
    try {
        // TODO(davido): respect options in mapping
        return info2Description(changeJson.addOptions(options).format(change));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return new ChangeInfoMapper(s).map(changeJson.addOptions(s).format(change));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Test
public void get() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    String triplet = "p~master~" + r.getChangeId();
    ChangeDescription c = gApi.changes().id(triplet).get(EnumSet.noneOf(ListChangesOption.class));
    assertEquals(triplet, c.id);
    assertEquals("p", c.project);
    assertEquals("master", c.branch);
    assertEquals(ChangeStatus.NEW, c.status);
    assertEquals("test commit", c.subject);
    assertEquals(true, c.mergeable);
    assertEquals(r.getChangeId(), c.changeId);
    assertEquals(c.created, c.updated);
}
#method_after
@Test
public void get() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    String triplet = "p~master~" + r.getChangeId();
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.noneOf(ListChangesOption.class));
    assertEquals(triplet, c.id);
    assertEquals("p", c.project);
    assertEquals("master", c.branch);
    assertEquals(ChangeStatus.NEW, c.status);
    assertEquals("test commit", c.subject);
    assertEquals(true, c.mergeable);
    assertEquals(r.getChangeId(), c.changeId);
    assertEquals(c.created, c.updated);
}
#end_block

#method_before
@Test
public void revert() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(approve());
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).submit();
    gApi.changes().id("p~master~" + r.getChangeId()).revert();
}
#method_after
@Test
public void revert() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).submit();
    gApi.changes().id("p~master~" + r.getChangeId()).revert();
}
#end_block

#method_before
public PluginConfig getFromGerritConfig(String pluginName) {
    return new PluginConfig(pluginName, getGerritConfig());
}
#method_after
public PluginConfig getFromGerritConfig(String pluginName) {
    return getFromGerritConfig(pluginName, false);
}
#end_block

#method_before
public PluginConfig getFromGerritConfig(String pluginName) {
    return new PluginConfig(pluginName, getGerritConfig());
}
#method_after
public PluginConfig getFromGerritConfig(String pluginName, boolean refresh) {
    if (refresh && cfgSnapshot.isModified(site.gerrit_config)) {
        cfgSnapshot = FileSnapshot.save(site.gerrit_config);
        cfg = cfgProvider.get();
    }
    return new PluginConfig(pluginName, cfg);
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : Natives.keys(info.pluginConfigParameters())) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        for (ConfigParameterInfo param : Natives.asList(info.pluginConfigParameter(pluginName))) {
            FocusWidget w;
            if ("STRING".equals(param.type()) || "INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        g.add(getDisplayName(param), p);
    } else {
        textBox.setValue(param.value());
        g.add(getDisplayName(param), textBox);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        g.add(getDisplayName(param), p);
    } else {
        textBox.setValue(param.value());
        g.add(getDisplayName(param), textBox);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox();
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(getDisplayName(param), checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#method_after
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox(getDisplayName(param));
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(null, checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                String value = listBox.getValue(listBox.getSelectedIndex());
                if (value.matches(Util.M.pluginProjectInheritedListValue(".*"))) {
                    value = null;
                }
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, List<ConfigValueInput>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, List<ConfigValueInput>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (ConfigValueInput v : e.getValue()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.name);
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.name)) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.name));
                    continue;
                }
                if (v.value == null) {
                    cfg.unset(v.name);
                } else {
                    try {
                        switch(projectConfigEntry.getType()) {
                            case BOOLEAN:
                                cfg.setBoolean(v.name, Boolean.parseBoolean(v.value));
                                break;
                            case INT:
                                cfg.setInt(v.name, Integer.parseInt(v.value));
                                break;
                            case LONG:
                                cfg.setLong(v.name, Long.parseLong(v.value));
                                break;
                            case LIST:
                                if (!projectConfigEntry.getPermittedValues().contains(v.value)) {
                                    throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.value, v.name));
                                }
                            case STRING:
                                cfg.setString(v.name, v.value);
                                break;
                            default:
                                log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.name));
                                continue;
                        }
                    } catch (NumberFormatException ex) {
                        throw new BadRequestException(String.format("The value '%s' of config paramter '%s' of plugin '%s' is invalid: %s", v.value, v.name, pluginName, ex.getMessage()));
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config paramter '%s' of plugin '%s' does not exist.", v.name, pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                if (v.getValue() != null) {
                    try {
                        switch(projectConfigEntry.getType()) {
                            case BOOLEAN:
                                cfg.setBoolean(v.getKey(), Boolean.parseBoolean(v.getValue()));
                                break;
                            case INT:
                                cfg.setInt(v.getKey(), Integer.parseInt(v.getValue()));
                                break;
                            case LONG:
                                cfg.setLong(v.getKey(), Long.parseLong(v.getValue()));
                                break;
                            case LIST:
                                if (!projectConfigEntry.getPermittedValues().contains(v.getValue())) {
                                    throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.getValue(), v.getKey()));
                                }
                            case STRING:
                                cfg.setString(v.getKey(), v.getValue());
                                break;
                            default:
                                log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                        }
                    } catch (NumberFormatException ex) {
                        throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                    }
                } else {
                    cfg.unset(v.getKey());
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type()) || "INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = new NpTextBox();
    textBox.setValue(param.value());
    g.add(getDisplayName(param), textBox);
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    textBox.setValue(param.value());
    g.add(getDisplayName(param), textBox);
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox();
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(getDisplayName(param), checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#method_after
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox(getDisplayName(param));
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(null, checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#end_block

#method_before
static Config parseFromSystemProperty() throws ConfigInvalidException, IOException {
    Config cfg = new Config();
    String name = System.getProperty(CONFIG_PKG + "BaseConfig");
    if (!Strings.isNullOrEmpty(name)) {
        URL url = ConfigAnnotationParser.class.getResource(CONFIG_DIR + name);
        if (url != null) {
            cfg.fromText(Resources.toString(url, Charsets.UTF_8));
        }
    }
    return cfg;
}
#method_after
static Config parseFromSystemProperty() throws ConfigInvalidException, IOException {
    Config cfg = new Config();
    String name = System.getProperty(CONFIG_PKG + "BaseConfig");
    if (!Strings.isNullOrEmpty(name)) {
        String resource = CONFIG_DIR + name + ".config";
        URL url = checkNotNull(ConfigAnnotationParser.class.getResource(resource), "test config resource not found: %s", resource);
        cfg.fromText(Resources.toString(url, Charsets.UTF_8));
    }
    return cfg;
}
#end_block

#method_before
static Config parse(Config base, GerritConfigs annotation) {
    if (annotation == null) {
        return null;
    }
    Config cfg = new Config(base);
    for (GerritConfig c : annotation.value()) {
        parse(cfg, c);
    }
    return cfg;
}
#method_after
static Config parse(Config base, GerritConfigs annotation) {
    if (annotation == null) {
        return null;
    }
    Config cfg = new Config(base);
    for (GerritConfig c : annotation.value()) {
        parseAnnotation(cfg, c);
    }
    return cfg;
}
#end_block

#method_before
@Override
protected void configure() {
    super.configure();
    install(ThreadLocalRequestContext.module());
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(QueryDocumentationExecutor.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    cfgInjector = createCfgInjector();
    limitThreads();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    index.markReady(false);
    index.deleteAll();
    int result = indexAll();
    index.markReady(true);
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    limitThreads();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    index.markReady(false);
    index.deleteAll();
    int result = indexAll();
    index.markReady(true);
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(version, threads, outputBase);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(false, threads, outputBase);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    // modules.add(new LogFileCompressor.Module());
    // modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModuleBase.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(NoSshKeyCache.module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(CurrentUser.class).toProvider(new Provider<CurrentUser>() {

                @Override
                public CurrentUser get() {
                    return null;
                }
            });
            bind(IdentifiedUser.class).toProvider(new Provider<IdentifiedUser>() {

                @Override
                public IdentifiedUser get() {
                    return null;
                }
            });
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(version, threads, outputBase);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(false, threads, outputBase);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new FactoryModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
            factory(ChangeData.Factory.class);
            factory(ProjectState.Factory.class);
            bind(new TypeLiteral<List<CommentLinkInfo>>() {
            }).toProvider(CommentLinkProvider.class).in(SINGLETON);
            bind(CurrentUser.class).toProvider(Providers.<CurrentUser>of(null));
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class);
            factory(IncludingGroupMembership.Factory.class);
            bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
            DynamicSet.setOf(binder(), GroupBackend.class);
            bind(InternalGroupBackend.class).in(SINGLETON);
            DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
            DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
            factory(InternalUser.Factory.class);
            factory(PatchSetInserter.Factory.class);
            bind(ChangeHooks.class).to(DisabledChangeHooks.class);
            bind(ReplacePatchSetSender.Factory.class).toProvider(Providers.<ReplacePatchSetSender.Factory>of(null));
            factory(CapabilityControl.Factory.class);
            factory(MergeUtil.Factory.class);
            DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
            DynamicSet.setOf(binder(), CommitValidationListener.class);
            factory(CommitValidators.Factory.class);
        }
    });
    modules.add(AccountCacheImpl.module());
    modules.add(AccountByEmailCacheImpl.module());
    modules.add(ChangeKindCache.module());
    modules.add(GroupCacheImpl.module());
    modules.add(GroupIncludeCacheImpl.module());
    modules.add(ProjectCacheImpl.module());
    modules.add(SectionSortCache.module());
    modules.add(new AccessControlModule());
    modules.add(new GitModule());
    modules.add(new PrologModule());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @MergeabilityChecksExecutor
        public WorkQueue.Executor createMergeabilityChecksExecutor(WorkQueue queues) {
            return queues.createQueue(1, "MergeabilityChecks");
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(Event event) {
    String ref = event.getRefName();
    if (ref.startsWith(Constants.R_HEADS) || ref.equals(GitRepositoryManager.REF_CONFIG)) {
        executor.submit(new RefUpdateTask(schemaFactory, new Project.NameKey(event.getProjectName()), ref));
    }
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    String ref = event.getRefName();
    if (ref.startsWith(Constants.R_HEADS) || ref.equals(RefNames.REFS_CONFIG)) {
        executor.submit(new BranchUpdateTask(schemaFactory, new Project.NameKey(event.getProjectName()), ref));
    }
    if (ref.equals(RefNames.REFS_CONFIG)) {
        Project.NameKey p = new Project.NameKey(event.getProjectName());
        try {
            ProjectConfig oldCfg = parseConfig(p, event.getOldObjectId());
            ProjectConfig newCfg = parseConfig(p, event.getNewObjectId());
            if (recheckMerges(oldCfg, newCfg)) {
                try {
                    new ProjectUpdateTask(schemaFactory, p, true).call();
                } catch (Exception e) {
                    String msg = "Failed to update mergeability flags for project " + p.get() + " on update of " + RefNames.REFS_CONFIG;
                    log.error(msg, e);
                    Throwables.propagateIfPossible(e);
                    throw new RuntimeException(msg, e);
                }
            }
        } catch (ConfigInvalidException | IOException e) {
            String msg = "Failed to update mergeability flags for project " + p.get() + " on update of " + RefNames.REFS_CONFIG;
            log.error(msg, e);
            throw new RuntimeException(msg, e);
        }
    }
}
#end_block

#method_before
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change)), MAPPER);
}
#method_after
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return updateAsync(change, false);
}
#end_block

#method_before
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change)), MAPPER);
}
#method_after
private CheckedFuture<Boolean, IOException> updateAsync(Change change, boolean force) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change, force)), MAPPER);
}
#end_block

#method_before
public CheckedFuture<?, IOException> updateAndIndexAsync(final Change change) {
    return Futures.makeChecked(Futures.transform(updateAsync(change), new AsyncFunction<Boolean, Object>() {

        @SuppressWarnings("unchecked")
        @Override
        public ListenableFuture<Object> apply(Boolean indexUpdated) throws Exception {
            if (!indexUpdated) {
                return (ListenableFuture<Object>) indexer.indexAsync(change);
            }
            return Futures.immediateFuture(null);
        }
    }), MAPPER);
}
#method_after
public CheckedFuture<?, IOException> updateAndIndexAsync(Change change) {
    final Change.Id id = change.getId();
    return Futures.makeChecked(Futures.transform(updateAsync(change), new AsyncFunction<Boolean, Object>() {

        @SuppressWarnings("unchecked")
        @Override
        public ListenableFuture<Object> apply(Boolean indexUpdated) throws Exception {
            if (!indexUpdated) {
                return (ListenableFuture<Object>) indexer.indexAsync(id);
            }
            return Futures.immediateFuture(null);
        }
    }), MAPPER);
}
#end_block

#method_before
public boolean update(Change change) throws IOException {
    try {
        return new ChangeUpdateTask(schemaFactory, change).call();
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw MAPPER.apply(e);
    }
}
#method_after
public void update(Project.NameKey project) throws IOException {
    try {
        for (CheckedFuture<?, IOException> f : new ProjectUpdateTask(schemaFactory, project, false).call()) {
            f.checkedGet();
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw MAPPER.apply(e);
    }
}
#end_block

#method_before
@Override
public Boolean call() throws Exception {
    mergeabilityCheckQueue.updatingMergeabilityFlag(change);
    RequestContext context = new RequestContext() {

        @Override
        public CurrentUser getCurrentUser() {
            return identifiedUserFactory.create(change.getOwner());
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    if (reviewDb == null) {
                        try {
                            reviewDb = schemaFactory.open();
                        } catch (OrmException e) {
                            throw new ProvisionException("Cannot open ReviewDb", e);
                        }
                    }
                    return reviewDb;
                }
            };
        }
    };
    RequestContext old = tl.setContext(context);
    ReviewDb db = context.getReviewDbProvider().get();
    try {
        PatchSet ps = db.patchSets().get(change.currentPatchSetId());
        MergeableInfo info = mergeable.get().apply(new RevisionResource(new ChangeResource(changeControlFactory.controlFor(change, context.getCurrentUser())), ps));
        return change.isMergeable() != info.mergeable;
    } catch (ResourceConflictException e) {
        // change is closed
        return false;
    } finally {
        tl.setContext(old);
        if (reviewDb != null) {
            reviewDb.close();
            reviewDb = null;
        }
    }
}
#method_after
@Override
public Boolean call() throws Exception {
    mergeabilityCheckQueue.updatingMergeabilityFlag(change, force);
    RequestContext context = new RequestContext() {

        @Override
        public CurrentUser getCurrentUser() {
            return identifiedUserFactory.create(change.getOwner());
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    if (reviewDb == null) {
                        try {
                            reviewDb = schemaFactory.open();
                        } catch (OrmException e) {
                            throw new ProvisionException("Cannot open ReviewDb", e);
                        }
                    }
                    return reviewDb;
                }
            };
        }
    };
    RequestContext old = tl.setContext(context);
    ReviewDb db = context.getReviewDbProvider().get();
    try {
        PatchSet ps = db.patchSets().get(change.currentPatchSetId());
        Mergeable m = mergeable.get();
        m.setForce(force);
        ChangeControl control = changeControlFactory.controlFor(change.getId(), context.getCurrentUser());
        MergeableInfo info = m.apply(new RevisionResource(new ChangeResource(control), ps));
        return change.isMergeable() != info.mergeable;
    } catch (ResourceConflictException e) {
        // change is closed
        return false;
    } finally {
        tl.setContext(old);
        if (reviewDb != null) {
            reviewDb.close();
            reviewDb = null;
        }
    }
}
#end_block

#method_before
public Result indexAll(ChangeIndex index, Iterable<Project.NameKey> projects, int numProjects, int numChanges, OutputStream progressOut, OutputStream verboseOut) {
    if (progressOut == null) {
        progressOut = NullOutputStream.INSTANCE;
    }
    PrintWriter verboseWriter = verboseOut != null ? new PrintWriter(verboseOut) : null;
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", numProjects >= 0 ? numProjects : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, numChanges >= 0 ? numChanges : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = Lists.newArrayList();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        final ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(index), project, doneTask, failedTask, verboseWriter));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    fail(project, e);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    try {
        mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
        // TODO(davido): include indexing of mergeable field in MPM above
        for (Project.NameKey project : projects) {
            List<CheckedFuture<?, IOException>> f = checker.reindexProject(project);
            for (CheckedFuture<?, IOException> checkedFuture : f) {
                checkedFuture.checkedGet();
            }
        }
    } catch (ExecutionException | IOException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#method_after
public Result indexAll(ChangeIndex index, Iterable<Project.NameKey> projects, int numProjects, int numChanges, OutputStream progressOut, OutputStream verboseOut) {
    if (progressOut == null) {
        progressOut = NullOutputStream.INSTANCE;
    }
    PrintWriter verboseWriter = verboseOut != null ? new PrintWriter(verboseOut) : null;
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", numProjects >= 0 ? numProjects : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, numChanges >= 0 ? numChanges : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = Lists.newArrayList();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        try {
            mergeabilityChecker.update(project);
        } catch (IOException e) {
            log.error("Error in mergeability checker", e);
            ok.set(false);
        }
        final ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(index), project, doneTask, failedTask, verboseWriter));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    fail(project, e);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    try {
        mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#end_block

#method_before
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = null;
            try {
                repo = repoManager.openRepository(project);
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                for (Change c : db.get().changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), new ChangeData(c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            } finally {
                if (repo != null) {
                    repo.close();
                }
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#method_after
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = null;
            ReviewDb db = null;
            try {
                repo = repoManager.openRepository(project);
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                db = schemaFactory.open();
                for (Change c : db.changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), changeDataFactory.create(db, c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            } finally {
                if (db != null) {
                    db.close();
                }
                if (repo != null) {
                    repo.close();
                }
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#end_block

#method_before
private static ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return new ChangeData(new Change.Id(id));
    }
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = new ChangeData(change);
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    return cd;
}
#method_after
private ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return changeDataFactory.create(db.get(), new Change.Id(id));
    }
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    return cd;
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    NIOFSDirectory directory = new NIOFSDirectory(tmpdir);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    zipDir(tmpdir, "", zip);
    zip.close();
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    try {
        ProjectResource projectResource = new ProjectResource(project);
        CreateBranch.Input input = new CreateBranch.Input();
        input.ref = ref;
        input.revision = revision;
        createBranchFactory.create(ref).apply(projectResource, input);
    } catch (IOException e) {
        throw new RestApiException("Cannot create branch", e);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        BranchInput in = new BranchInput();
        in.revision = revision;
        gApi.projects().name(project.getProject().getNameKey().get()).branch(name).create(in);
    } catch (RestApiException e) {
        throw new UnloggedFailure(1, "fatal: " + e.getMessage(), e);
    }
}
#end_block

#method_before
private ItsAssociationPolicy getItsAssociationPolicy() {
    return gerritConfig.getEnum("commentLink", pluginsName, "association", ItsAssociationPolicy.OPTIONAL);
}
#method_after
private ItsAssociationPolicy getItsAssociationPolicy() {
    return gerritConfig.getEnum("commentLink", pluginName, "association", ItsAssociationPolicy.OPTIONAL);
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || (canPerform(Permission.CREATE) && projectControl.canReadCommit(rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
        case SSH_COMMAND:
            return getCurrentUser().getCapabilities().canAdministrateServer() || (isOwner() && !isForceBlocked(Permission.PUSH)) || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
public List<PermissionRange> getLabelRanges() {
    List<PermissionRange> r = new ArrayList<PermissionRange>();
    for (Map.Entry<String, List<PermissionRule>> e : relevant.getDeclaredPermissions()) {
        if (Permission.isLabel(e.getKey())) {
            int min = 0;
            int max = 0;
            for (PermissionRule rule : e.getValue()) {
                if (projectControl.match(rule)) {
                    min = Math.min(min, rule.getMin());
                    max = Math.max(max, rule.getMax());
                }
            }
            if (min != 0 || max != 0) {
                r.add(new PermissionRange(e.getKey(), min, max));
            }
        }
    }
    return r;
}
#method_after
public List<PermissionRange> getLabelRanges(boolean isChangeOwner) {
    List<PermissionRange> r = new ArrayList<PermissionRange>();
    for (Map.Entry<String, List<PermissionRule>> e : relevant.getDeclaredPermissions()) {
        if (Permission.isLabel(e.getKey())) {
            int min = 0;
            int max = 0;
            for (PermissionRule rule : e.getValue()) {
                if (projectControl.match(rule, isChangeOwner)) {
                    min = Math.min(min, rule.getMin());
                    max = Math.max(max, rule.getMax());
                }
            }
            if (min != 0 || max != 0) {
                r.add(new PermissionRange(e.getKey(), min, max));
            }
        }
    }
    return r;
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission) {
    return getRange(permission, false);
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission, boolean isChangeOwner) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission, isChangeOwner));
    }
    return null;
}
#end_block

#method_before
private List<PermissionRule> access(String permissionName) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0))) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#method_after
private List<PermissionRule> access(String permissionName) {
    return access(permissionName, false);
}
#end_block

#method_before
private List<PermissionRule> access(String permissionName) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0))) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#method_after
private List<PermissionRule> access(String permissionName, boolean isChangeOwner) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0), isChangeOwner)) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule, isChangeOwner)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#end_block

#method_before
public ChangeControl validateFor(Change.Id id, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(id, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
public ChangeControl validateFor(Change change, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(change, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    return getProjectControl().getLabelTypes();
}
#method_after
public LabelTypes getLabelTypes() {
    String destBranch = getChange().getDest().get();
    List<LabelType> all = getProjectControl().getLabelTypes().getLabelTypes();
    List<LabelType> r = Lists.newArrayListWithCapacity(all.size());
    for (LabelType l : all) {
        List<String> refs = l.getRefPatterns();
        if (refs == null) {
            r.add(l);
        } else {
            for (String refPattern : refs) {
                if (RefConfigSection.isValid(refPattern) && match(destBranch, refPattern)) {
                    r.add(l);
                    break;
                }
            }
        }
    }
    return new LabelTypes(r);
}
#end_block

#method_before
public List<PermissionRange> getLabelRanges() {
    return getRefControl().getLabelRanges();
}
#method_after
public List<PermissionRange> getLabelRanges() {
    return getRefControl().getLabelRanges(isOwner());
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    List<PermissionRule> rules = getRefControl().getRules(permission);
    if (isOwner() && rulesContainGroup(rules, AccountGroup.CHANGE_OWNERS)) {
        return getRefControl().getLabelRange(permission);
    } else {
        return getRefControl().getRange(permission);
    }
}
#method_after
public PermissionRange getRange(String permission) {
    return getRefControl().getRange(permission, isOwner());
}
#end_block

#method_before
public boolean isOwner() {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser().isIdentifiedUser()) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("may".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.MAY;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return logInvalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return logInvalidResult(submitRule, submitRecord, e.getMessage());
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record, String reason) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record + (reason == null ? "" : ". Reason: " + reason));
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logInvalidResult(rule, record, null);
}
#end_block

#method_before
private void appliedBy(SubmitRecord.Label label, Term status) {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        }
    }
}
#method_after
private void appliedBy(SubmitRecord.Label label, Term status) throws UserTermExpected {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        } else {
            throw new UserTermExpected(label);
        }
    }
}
#end_block

#method_before
@Test
public void systemGroupsCreated_ssh() throws JSchException, IOException {
    SshSession session = new SshSession(server, admin);
    String result = session.exec("gerrit ls-groups");
    assertTrue(result.contains("Administrators"));
    assertTrue(result.contains("Anonymous Users"));
    assertTrue(result.contains("Change Owners"));
    assertTrue(result.contains("Non-Interactive Users"));
    assertTrue(result.contains("Project Owners"));
    assertTrue(result.contains("Registered Users"));
    session.close();
}
#method_after
@Test
public void systemGroupsCreated_ssh() throws JSchException, IOException {
    SshSession session = new SshSession(server, admin);
    String result = session.exec("gerrit ls-groups");
    assertTrue(result.contains("Administrators"));
    assertTrue(result.contains("Anonymous Users"));
    assertTrue(result.contains("Change Owner"));
    assertTrue(result.contains("Non-Interactive Users"));
    assertTrue(result.contains("Project Owners"));
    assertTrue(result.contains("Registered Users"));
    session.close();
}
#end_block

#method_before
@Test
public void systemGroupsCreated_rest() throws IOException {
    RestSession session = new RestSession(server, admin);
    RestResponse r = session.get("/groups/");
    Gson gson = new Gson();
    Map<String, GroupInfo> result = gson.fromJson(r.getReader(), new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
    Set<String> names = result.keySet();
    assertTrue(names.contains("Administrators"));
    assertTrue(names.contains("Anonymous Users"));
    assertTrue(names.contains("Change Owners"));
    assertTrue(names.contains("Non-Interactive Users"));
    assertTrue(names.contains("Project Owners"));
    assertTrue(names.contains("Registered Users"));
}
#method_after
@Test
public void systemGroupsCreated_rest() throws IOException {
    RestSession session = new RestSession(server, admin);
    RestResponse r = session.get("/groups/");
    Gson gson = new Gson();
    Map<String, GroupInfo> result = gson.fromJson(r.getReader(), new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
    Set<String> names = result.keySet();
    assertTrue(names.contains("Administrators"));
    assertTrue(names.contains("Anonymous Users"));
    assertTrue(names.contains("Change Owner"));
    assertTrue(names.contains("Non-Interactive Users"));
    assertTrue(names.contains("Project Owners"));
    assertTrue(names.contains("Registered Users"));
}
#end_block

#method_before
@Test
public void systemGroupsCreated_internals() throws OrmException {
    ReviewDb db = reviewDbProvider.open();
    try {
        Set<String> names = Sets.newHashSet();
        for (AccountGroup g : db.accountGroups().all()) {
            names.add(g.getName());
        }
        assertTrue(names.contains("Administrators"));
        assertTrue(names.contains("Anonymous Users"));
        assertTrue(names.contains("Change Owners"));
        assertTrue(names.contains("Non-Interactive Users"));
        assertTrue(names.contains("Project Owners"));
        assertTrue(names.contains("Registered Users"));
    } finally {
        db.close();
    }
}
#method_after
@Test
public void systemGroupsCreated_internals() throws OrmException {
    ReviewDb db = reviewDbProvider.open();
    try {
        Set<String> names = Sets.newHashSet();
        for (AccountGroup g : db.accountGroups().all()) {
            names.add(g.getName());
        }
        assertTrue(names.contains("Administrators"));
        assertTrue(names.contains("Anonymous Users"));
        assertTrue(names.contains("Change Owner"));
        assertTrue(names.contains("Non-Interactive Users"));
        assertTrue(names.contains("Project Owners"));
        assertTrue(names.contains("Registered Users"));
    } finally {
        db.close();
    }
}
#end_block

#method_before
private SystemConfig initSystemConfig(final ReviewDb c) throws OrmException {
    admin = newGroup(c, "Administrators", null);
    admin.setDescription("Gerrit Site Administrators");
    admin.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(admin));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(admin)));
    anonymous = newGroup(c, "Anonymous Users", AccountGroup.ANONYMOUS_USERS);
    anonymous.setDescription("Any user, signed-in or not");
    anonymous.setOwnerGroupUUID(admin.getGroupUUID());
    anonymous.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(anonymous));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(anonymous)));
    registered = newGroup(c, "Registered Users", AccountGroup.REGISTERED_USERS);
    registered.setDescription("Any signed-in user");
    registered.setOwnerGroupUUID(admin.getGroupUUID());
    registered.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(registered));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(registered)));
    batch = newGroup(c, "Non-Interactive Users", null);
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    batch.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(batch));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(batch)));
    owners = newGroup(c, "Project Owners", AccountGroup.PROJECT_OWNERS);
    owners.setDescription("Any owner of the project");
    owners.setOwnerGroupUUID(admin.getGroupUUID());
    owners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(owners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(owners)));
    changeOwners = newGroup(c, "Change Owners", AccountGroup.CHANGE_OWNERS);
    changeOwners.setDescription("The owners of a change");
    changeOwners.setOwnerGroupUUID(admin.getGroupUUID());
    changeOwners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(changeOwners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(changeOwners)));
    final SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.getCanonicalPath();
    } catch (IOException e) {
        s.sitePath = site_path.getAbsolutePath();
    }
    c.systemConfig().insert(Collections.singleton(s));
    return s;
}
#method_after
private SystemConfig initSystemConfig(final ReviewDb c) throws OrmException {
    admin = newGroup(c, "Administrators", null);
    admin.setDescription("Gerrit Site Administrators");
    admin.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(admin));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(admin)));
    anonymous = newGroup(c, "Anonymous Users", AccountGroup.ANONYMOUS_USERS);
    anonymous.setDescription("Any user, signed-in or not");
    anonymous.setOwnerGroupUUID(admin.getGroupUUID());
    anonymous.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(anonymous));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(anonymous)));
    registered = newGroup(c, "Registered Users", AccountGroup.REGISTERED_USERS);
    registered.setDescription("Any signed-in user");
    registered.setOwnerGroupUUID(admin.getGroupUUID());
    registered.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(registered));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(registered)));
    batch = newGroup(c, "Non-Interactive Users", null);
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    batch.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(batch));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(batch)));
    owners = newGroup(c, "Project Owners", AccountGroup.PROJECT_OWNERS);
    owners.setDescription("Any owner of the project");
    owners.setOwnerGroupUUID(admin.getGroupUUID());
    owners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(owners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(owners)));
    changeOwner = newGroup(c, "Change Owner", AccountGroup.CHANGE_OWNER);
    changeOwner.setDescription("The owner of a change");
    changeOwner.setOwnerGroupUUID(admin.getGroupUUID());
    changeOwner.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(changeOwner));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(changeOwner)));
    final SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.getCanonicalPath();
    } catch (IOException e) {
        s.sitePath = site_path.getAbsolutePath();
    }
    c.systemConfig().insert(Collections.singleton(s));
    return s;
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info, DisplaySide side) {
    CodeMirror cm = getCmFromSide(side);
    final DraftBox box = new DraftBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info, DisplaySide side) {
    CodeMirror cm = getCmFromSide(side);
    final DraftBox box = new DraftBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    box.setVisible(true);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() : skip.getStartB();
    int markEnd = markStart + size;
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    Configuration markerConfig = Configuration.create().set("collapsed", true).set("inclusiveLeft", true).set("inclusiveRight", true);
    Configuration lineWidgetConfig = Configuration.create().set("coverGutter", true).set("noHScroll", true);
    if (markStart == 0) {
        bar.setWidget(addLineWidget(cm, markEnd + 1, bar, lineWidgetConfig.set("above", true)));
    } else {
        bar.setWidget(addLineWidget(cm, markStart - 1, bar, lineWidgetConfig));
    }
    bar.setMarker(cm.markText(CodeMirror.pos(markStart, 0), CodeMirror.pos(markEnd), markerConfig), size);
    return bar;
}
#method_after
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() : skip.getStartB();
    int markEnd = markStart + size - 1;
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    Configuration markerConfig = Configuration.create().set("collapsed", true).set("inclusiveLeft", true).set("inclusiveRight", true);
    Configuration lineWidgetConfig = Configuration.create().set("coverGutter", true).set("noHScroll", true);
    if (markStart == 0) {
        bar.setWidget(addLineWidget(cm, markEnd + 1, bar, lineWidgetConfig.set("above", true)));
    } else {
        bar.setWidget(addLineWidget(cm, markStart - 1, bar, lineWidgetConfig));
    }
    bar.setMarker(cm.markText(CodeMirror.pos(markStart, 0), CodeMirror.pos(markEnd), markerConfig), size);
    return bar;
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveBase(info, base);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (Gerrit.getConfig().testChangeMerge()) {
                if (canSubmit) {
                    actions.setSubmitEnabled(changeInfo.mergeable());
                    if (status == Change.Status.NEW) {
                        statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                    }
                }
                setVisible(notMergeable, !changeInfo.mergeable());
            }
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    if (revision == null) {
        revision = info.current_revision();
    } else if (!info.revisions().containsKey(revision)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revision.equals(String.valueOf(r._number()))) {
                revision = r.name();
                break;
            }
        }
    }
    RevisionInfo rev = revision != null ? info.revision(revision) : null;
    if (rev != null) {
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.current_revision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        loadSubmitType(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = -1;
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null) {
            if (base.equals(String.valueOf(r._number()))) {
                selectedIdx = i;
            }
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    if (base != null) {
        diffBase.setSelectedIndex(selectedIdx - 1);
    } else {
        diffBase.setSelectedIndex(diffBase.getItemCount() - 1);
    }
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, null, false) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, null, String.valueOf(ps.get()), false) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, null, false) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, base != null ? String.valueOf(base.get()) : null, String.valueOf(ps.get()), false) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, null);
        }
    });
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, fg && revision != null ? ListChangesOption.ALL_REVISIONS : ListChangesOption.CURRENT_REVISION));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, reviewersText);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            reload.reload();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'K', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (revision != null) {
                JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
                RevisionInfo.sortRevisionInfoByNumber(revisions);
                boolean found = false;
                for (RevisionInfo r : Natives.asList(revisions)) {
                    if (revision.equals(r.name())) {
                        found = true;
                        continue;
                    }
                    if (found) {
                        Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), r._number())));
                        break;
                    }
                }
            }
        }
    });
    keysNavigation.add(new KeyCommand(0, 'J', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (revision == null) {
                revision = changeInfo.current_revision();
                if (changeInfo.revision(revision)._number() == 1) {
                    return;
                }
                loadChangeInfo(false, new AsyncCallback<ChangeInfo>() {

                    @Override
                    public void onSuccess(ChangeInfo info) {
                        goToPreviousPatchSet(info);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                    }
                });
            } else {
                goToPreviousPatchSet(changeInfo);
            }
        }

        private void goToPreviousPatchSet(ChangeInfo info) {
            if (changeInfo.revision(revision)._number() == 1) {
                return;
            }
            JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(revisions);
            RevisionInfo prevRev = null;
            for (RevisionInfo r : Natives.asList(revisions)) {
                if (revision.equals(r.name())) {
                    if (prevRev != null) {
                        Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), prevRev._number())));
                    }
                    break;
                }
                prevRev = r;
            }
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, reviewersText);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
    related.registerKeys();
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    startPoller();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    commit.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    startPoller();
}
#end_block

#method_before
private void onReply() {
    if (Gerrit.isSignedIn()) {
        replyAction.onReply();
    } else {
        Gerrit.doSignIn(getToken());
    }
}
#method_after
private void onReply() {
    if (Gerrit.isSignedIn()) {
        replyAction.onReply(null);
    } else {
        Gerrit.doSignIn(getToken());
    }
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(rev, myLastReply(info), group);
    loadCommit(rev, group);
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.add(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
    group.done();
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(info.revisions().get(base), rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.setRevisions(null, new PatchSet.Id(changeId, rev._number()));
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.setRevisions(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()));
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderOwner(info);
    renderActionTextDate(info);
    renderHistory(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#method_after
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                Gerrit.display(PageLinks.toChange(changeId));
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#end_block

#method_before
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    Element element = context.getElement().getFirstChildElement();
    while (element.getPropertyInt("value") != AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        element = element.getNextSiblingElement();
    }
    if (element.getPropertyInt("value") == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        if (enableSmallFileFeatures) {
            element.removeAttribute("disabled");
        } else {
            element.setAttribute("disabled", "disabled");
            if (AccountDiffPreference.CONTEXT_CHOICES[context.getSelectedIndex()] == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
                for (int i = 0; i < AccountDiffPreference.CONTEXT_CHOICES.length; i++) {
                    if (AccountDiffPreference.CONTEXT_CHOICES[i] == PatchScreen.LARGE_FILE_CONTEXT) {
                        context.setSelectedIndex(i);
                        break;
                    }
                }
            }
        }
    }
    toggleEnabledStatus(save.isEnabled());
}
#method_after
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    NodeList<OptionElement> options = context.getElement().<SelectElement>cast().getOptions();
    // WHOLE_FILE_CONTEXT is the last option in the list.
    int lastIndex = options.getLength() - 1;
    OptionElement currOption = options.getItem(lastIndex);
    if (enableSmallFileFeatures) {
        currOption.setDisabled(false);
    } else {
        currOption.setDisabled(true);
        if (context.getSelectedIndex() == lastIndex) {
            // Select the next longest context from WHOLE_FILE_CONTEXT
            context.setSelectedIndex(lastIndex - 1);
        }
    }
    toggleEnabledStatus(save.isEnabled());
}
#end_block

#method_before
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
        parentProjectBox.setVisible(editing && value.canChangeParent());
        parentProjectBox.setProjectName(value.getInheritsFrom());
        parentProject.setVisible(!parentProjectBox.isVisible());
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(value != null && editing && !value.getOwnerOf().isEmpty());
}
#method_after
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
        parentProjectBox.setVisible(editing && value.canChangeParent());
        parentProjectBox.setProject(value.getProjectName());
        parentProjectBox.setParentProject(value.getInheritsFrom());
        parentProject.setVisible(!parentProjectBox.isVisible());
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getGitwebLink();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(editing && (!value.getOwnerOf().isEmpty() || value.canUpload()));
}
#end_block

#method_before
@Override
public void flush() {
    List<AccessSection> src = local.getList();
    List<AccessSection> keep = new ArrayList<AccessSection>(src.size());
    for (int i = 0; i < src.size(); i++) {
        AccessSectionEditor e = (AccessSectionEditor) localContainer.getWidget(i);
        if (!e.isDeleted() && !src.get(i).getPermissions().isEmpty()) {
            keep.add(src.get(i));
        }
    }
    value.setLocal(keep);
    value.setInheritsFrom(parentProjectBox.getProjectName());
}
#method_after
@Override
public void flush() {
    List<AccessSection> src = local.getList();
    List<AccessSection> keep = new ArrayList<AccessSection>(src.size());
    for (int i = 0; i < src.size(); i++) {
        AccessSectionEditor e = (AccessSectionEditor) localContainer.getWidget(i);
        if (!e.isDeleted() && !src.get(i).getPermissions().isEmpty()) {
            keep.add(src.get(i));
        }
    }
    value.setLocal(keep);
    value.setInheritsFrom(parentProjectBox.getParentProjectName());
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    detail.setCanChangeParent(pc.getCurrentUser().getCapabilities().canAdministrateServer());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = open();
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    final RefControl metaConfigControl = pc.controlForRef(GitRepositoryManager.REF_CONFIG);
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    detail.setCanChangeParent(pc.getCurrentUser().getCapabilities().canAdministrateServer());
    detail.setConfigVisible(pc.isOwner() || metaConfigControl.isVisible());
    detail.setLabelTypes(pc.getLabelTypes());
    return detail;
}
#end_block

#method_before
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, Project.NameKey parentProjectName, AsyncCallback<ProjectAccess> cb) {
    ObjectId base = ObjectId.fromString(baseRevision);
    changeProjectAccessFactory.create(projectName, base, sections, parentProjectName, msg).to(cb);
}
#method_after
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, Project.NameKey parentProjectName, AsyncCallback<ProjectAccess> cb) {
    changeProjectAccessFactory.create(projectName, getBase(baseRevision), sections, parentProjectName, msg).to(cb);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.projectAccess(getProjectKey(), new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    ConfigServerApi.capabilities(cbs.add(new AsyncCallback<NativeMap<CapabilityInfo>>() {

        @Override
        public void onSuccess(NativeMap<CapabilityInfo> result) {
            capabilityMap = result;
        }

        @Override
        public void onFailure(Throwable caught) {
        // Handled by ScreenLoadCallback.onFailure().
        }
    }));
    Util.PROJECT_SVC.projectAccess(getProjectKey(), cbs.addFinal(new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    }));
    savedPanel = ACCESS;
}
#end_block

#method_before
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty());
    edit.setEnabled(!access.getOwnerOf().isEmpty());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#method_after
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    Map<String, String> allCapabilities = new HashMap<String, String>();
    for (CapabilityInfo c : Natives.asList(capabilityMap.values())) {
        allCapabilities.put(c.id(), c.name());
    }
    this.access.setCapabilities(allCapabilities);
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty() || access.canUpload());
    edit.setEnabled(!access.getOwnerOf().isEmpty() || access.canUpload());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent event) {
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    accessEditor.setEditing(true);
    driver.edit(access);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent event) {
    resetEditors();
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    commit.setVisible(!access.getOwnerOf().isEmpty());
    review.setVisible(access.canUpload());
    accessEditor.setEditing(true);
    driver.edit(access);
}
#end_block

#method_before
@UiHandler("commit")
void onCommit(ClickEvent event) {
    ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), // 
    access.getInheritsFrom(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess access) {
            enable(true);
            commitMessage.setText("");
            displayReadOnly(access);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            super.onFailure(caught);
        }
    });
}
#method_after
@UiHandler("commit")
void onCommit(ClickEvent event) {
    final ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), // 
    access.getInheritsFrom(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess newAccess) {
            enable(true);
            commitMessage.setText("");
            error.clear();
            final Set<String> diffs = getDiffs(access, newAccess);
            if (diffs.isEmpty()) {
                displayReadOnly(newAccess);
            } else {
                error.add(new Label(Gerrit.C.projectAccessError()));
                for (final String diff : diffs) {
                    error.add(new Label(diff));
                }
                if (access.canUpload()) {
                    error.add(new Label(Gerrit.C.projectAccessProposeForReviewHint()));
                }
            }
        }

        private Set<String> getDiffs(ProjectAccess wantedAccess, ProjectAccess newAccess) {
            final List<AccessSection> wantedSections = mergeSections(removeEmptyPermissionsAndSections(wantedAccess.getLocal()));
            final HashSet<AccessSection> same = new HashSet<AccessSection>(wantedSections);
            final HashSet<AccessSection> different = new HashSet<AccessSection>(wantedSections.size() + newAccess.getLocal().size());
            different.addAll(wantedSections);
            different.addAll(newAccess.getLocal());
            same.retainAll(newAccess.getLocal());
            different.removeAll(same);
            final Set<String> differentNames = new HashSet<String>();
            for (final AccessSection s : different) {
                differentNames.add(s.getName());
            }
            return differentNames;
        }

        @Override
        public void onFailure(Throwable caught) {
            error.clear();
            enable(true);
            if (caught instanceof RemoteJsonException && caught.getMessage().startsWith(UpdateParentFailedException.MESSAGE)) {
                new ErrorDialog(Gerrit.M.parentUpdateFailed(caught.getMessage().substring(UpdateParentFailedException.MESSAGE.length() + 1))).center();
            } else {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void enable(boolean enabled) {
    commitMessage.setEnabled(enabled);
    commit.setEnabled(enabled);
    cancel1.setEnabled(enabled);
    cancel2.setEnabled(enabled);
}
#method_after
private void enable(boolean enabled) {
    commitMessage.setEnabled(enabled);
    commit.setEnabled(enabled ? !access.getOwnerOf().isEmpty() : false);
    review.setEnabled(enabled ? access.canUpload() : false);
    cancel1.setEnabled(enabled);
    cancel2.setEnabled(enabled);
}
#end_block

#method_before
public void setCanChangeParent(final boolean canChangeParent) {
    this.canChangeParent = canChangeParent;
}
#method_after
public void setCanChangeParent(boolean canChangeParent) {
    this.canChangeParent = canChangeParent;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(admin.getId())));
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
}
#end_block

#method_before
@Test
public void reviewId() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(approve());
}
#method_after
@Test
public void reviewId() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).current().review(approve());
}
#end_block

#method_before
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    RevisionApi rApi = gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name());
    rApi.review(approve());
    rApi.submit(new SubmitInput());
}
#method_after
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    RevisionApi rApi = gApi.changes().id("p~master~" + r.getChangeId()).current();
    rApi.review(approve());
    rApi.submit();
}
#end_block

#method_before
private static ReviewInput approve() {
    ReviewInput in = new ReviewInput();
    in.message = "Looks good!";
    in.labels = Maps.newHashMap();
    in.labels.put("Code-Review", (short) 2);
    return in;
}
#method_after
private static ReviewInput approve() {
    return new ReviewInput().message("Looks good!").label("Code-Review", 2);
}
#end_block

#method_before
@Override
public void submit(SubmitInput in) throws RestApiException {
    try {
        submit.get().apply(revision, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot submit change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot submit change", e);
    }
}
#method_after
@Override
public void submit() throws RestApiException {
    SubmitInput in = new SubmitInput();
    in.waitForMerge = true;
    submit(in);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(admin.getId())));
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
}
#end_block

#method_before
@Test
public void abandon() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon(new AbandonInput());
}
#method_after
@Test
public void abandon() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon();
}
#end_block

#method_before
@Test
public void restore() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon(new AbandonInput());
    gApi.changes().id("p~master~" + r.getChangeId()).restore(new RestoreInput());
}
#method_after
@Test
public void restore() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon();
    gApi.changes().id("p~master~" + r.getChangeId()).restore();
}
#end_block

#method_before
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = changeComment;
            applyReview(patchSet, review);
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).abandon(input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = changeComment;
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).restore(input);
                applyReview(patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(patchSet, review);
        }
        if (submitChange) {
            SubmitInput input = new SubmitInput();
            input.waitForMerge = true;
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).submit(input);
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).deleteDraftPatchSet(new DeleteDraftPatchSetInput());
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    } catch (RestApiException e) {
        throw error(e.getMessage());
    }
}
#method_after
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = changeComment;
            applyReview(patchSet, review);
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).abandon(input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = changeComment;
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).restore(input);
                applyReview(patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(patchSet, review);
        }
        if (submitChange) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).submit();
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).delete();
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    } catch (RestApiException e) {
        throw error(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon review", e);
    }
}
#method_after
@Override
public void abandon() throws RestApiException {
    abandon(new AbandonInput());
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon review", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore review", e);
    }
}
#method_after
@Override
public void restore() throws RestApiException {
    restore(new RestoreInput());
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore review", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
private void approve(String changeId) throws IOException {
    ReviewInput in = new ReviewInput();
    in.labels = Maps.newHashMap();
    in.labels.put("Code-Review", (short) 2);
    RestResponse r = session.post("/changes/" + changeId + "/revisions/current/review", in);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#method_after
private void approve(String changeId) throws IOException {
    RestResponse r = session.post("/changes/" + changeId + "/revisions/current/review", new ReviewInput().label("Code-Review", 2));
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#end_block

#method_before
@Override
public Object apply(ChangeResource req, AbandonInput input) throws BadRequestException, AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    Object result = input.render ? json.format(change) : Response.none();
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public Object apply(ChangeResource req, AbandonInput input) throws BadRequestException, AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
@Override
public Object apply(ChangeResource req, RestoreInput input) throws OrmException, IOException, AuthException, ResourceConflictException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    Object result = input.render ? json.format(change) : Response.none();
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public Object apply(ChangeResource req, RestoreInput input) throws OrmException, IOException, AuthException, ResourceConflictException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
@Override
protected Object getRowItemKey(final DocInfo item) {
    return item.url();
}
#method_after
@Override
protected Object getRowItemKey(DocInfo item) {
    return item.url();
}
#end_block

#method_before
@Override
protected void onOpenRow(final int row) {
    final DocInfo d = getRowItem(row);
    Gerrit.display("/" + d.url());
}
#method_after
@Override
protected void onOpenRow(int row) {
    DocInfo d = getRowItem(row);
    Window.Location.assign(d.getFullUrl());
}
#end_block

#method_before
private void insertNoneRow(final int row) {
    insertRow(row);
    table.setText(row, 0, Util.C.docTableNone());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.setColSpan(row, 0, columns);
    fmt.setStyleName(row, 0, Gerrit.RESOURCES.css().emptySection());
}
#method_after
private void insertNoneRow(int row) {
    table.insertRow(row);
    table.setText(row, 0, Util.C.docTableNone());
    FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.setStyleName(row, 0, Gerrit.RESOURCES.css().emptySection());
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().cSUBJECT());
}
#method_after
@Override
protected void applyDataRowStyle(int row) {
    super.applyDataRowStyle(row);
    CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().cSUBJECT());
}
#end_block

#method_before
private void populateDocRow(final int row, final DocInfo d) {
    String title = com.google.gerrit.client.changes.Util.cropSubject(d.title());
    table.setWidget(row, C_TITLE, new DocLink(d));
    setRowItem(row, d);
}
#method_after
private void populateDocRow(int row, DocInfo d) {
    table.setWidget(row, C_TITLE, new DocLink(d));
    setRowItem(row, d);
}
#end_block

#method_before
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/doc/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/Documentation/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
private static void docSearch(final String token) {
    Gerrit.display(token, new DocScreen(skip(token)));
}
#method_after
private static void docSearch(final String token) {
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, new DocScreen(skip(token)));
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new DocTable() {

        {
            keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadSearch()) {

                @Override
                public void onKeyPress(final KeyPressEvent event) {
                    Gerrit.display(getToken());
                }
            });
        }
    };
    section = new DocTable.Section();
    table.addSection(section);
    table.setSavePointerId(query);
    add(table);
    setWindowTitle(Util.M.docQueryWindowTitle(query));
    setPageTitle(Util.M.docQueryPageTitle(query));
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new DocTable();
    table.setSavePointerId(query);
    add(table);
    setWindowTitle(Util.M.docQueryWindowTitle(query));
    setPageTitle(Util.M.docQueryPageTitle(query));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    docs.query(loadCallback(), query);
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    doQuery();
}
#end_block

#method_before
protected AsyncCallback<DocList> loadCallback() {
    return new GerritCallback<DocList>() {

        @Override
        public final void onSuccess(DocList result) {
            display(result);
            DocScreen.this.display();
        }
    };
}
#method_after
private AsyncCallback<JsArray<DocInfo>> loadCallback() {
    return new GerritCallback<JsArray<DocInfo>>() {

        @Override
        public void onSuccess(JsArray<DocInfo> result) {
            displayResults(result);
            display();
        }
    };
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    bind(DocQueryProcessor.class).to(DocQueryLucene.class);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?docsearch/(.*)$").with(DocSearchRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
    serve("/robots.txt").with(RobotsServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    filter("/Documentation/").through(QueryDocumentationFilter.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
    serve("/robots.txt").with(RobotsServlet.class);
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(DocQueryLucene.DOC_FIELD, reader));
        doc.add(new StringField(DocQueryLucene.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(DocQueryLucene.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStatsAttribute stats = new QueryStatsAttribute();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            ChangeAttribute c = null;
            for (ChangeData d : results) {
                LabelTypes labelTypes = changeControlFactory.controlFor(d.getChange()).getLabelTypes();
                c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                ChangeResource rsrc = new ChangeResource(changeControlFactory.controlFor(d.getChange()));
                eventFactory.currentreviewers(c, rsrc, includeApprovals ? d.approvalsMap(db).asMap() : null);
                if (includeSubmitRecords) {
                    PatchSet.Id psId = d.getChange().currentPatchSetId();
                    PatchSet patchSet = db.get().patchSets().get(psId);
                    List<SubmitRecord> submitResult = // 
                    d.changeControl().canSubmit(db.get(), patchSet, null, false, true, true);
                    eventFactory.addSubmitRecords(c, submitResult);
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, includeFiles, d.change(db), labelTypes);
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, labelTypes);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(db), labelTypes);
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            if (moreResults) {
                stats.resumeSortKey = c.sortKey;
            }
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        } catch (NoSuchChangeException e) {
            log.error("Missing change: " + e.getMessage(), e);
            ErrorMessage m = new ErrorMessage();
            m.message = "missing change " + e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStatsAttribute stats = new QueryStatsAttribute();
            stats.runTimeMilliseconds = TimeUtil.nowMs();
            List<ChangeData> results = queryChanges(queryString);
            ChangeAttribute c = null;
            for (ChangeData d : results) {
                LabelTypes labelTypes = changeControlFactory.controlFor(d.getChange()).getLabelTypes();
                c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeAllReviewers) {
                    eventFactory.addAllReviewers(c, d.getChange());
                }
                if (includeSubmitRecords) {
                    PatchSet.Id psId = d.getChange().currentPatchSetId();
                    PatchSet patchSet = db.get().patchSets().get(psId);
                    List<SubmitRecord> submitResult = // 
                    d.changeControl().canSubmit(db.get(), patchSet, null, false, true, true);
                    eventFactory.addSubmitRecords(c, submitResult);
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, includeFiles, d.change(db), labelTypes);
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, labelTypes);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(db), labelTypes);
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            if (moreResults) {
                stats.resumeSortKey = c.sortKey;
            }
            stats.runTimeMilliseconds = TimeUtil.nowMs() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        } catch (NoSuchChangeException e) {
            log.error("Missing change: " + e.getMessage(), e);
            ErrorMessage m = new ErrorMessage();
            m.message = "missing change " + e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setInnerText(revision);
    formatLink(commit.author(), authorNameEmail, authorDate, change.owner(), change.status());
    format(commit.committer(), committerNameEmail, committerDate);
    commitMessageText.setInnerSafeHtml(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        browserLink.setInnerText(gw.getLinkName());
        browserLink.setHref(gw.toRevision(change.project(), revision));
    } else {
        UIObject.setVisible(browserLink, false);
    }
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setInnerText(revision);
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    commitMessageText.setInnerSafeHtml(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        browserLink.setInnerText(gw.getLinkName());
        browserLink.setHref(gw.toRevision(change.project(), revision));
    } else {
        UIObject.setVisible(browserLink, false);
    }
}
#end_block

#method_before
private void formatLink(GitPerson person, InlineHyperlink name, Element date, AccountInfo a, Status status) {
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(AccountLinkPanel.owner(a), status));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#method_after
private static void formatLink(GitPerson person, InlineHyperlink name, Element date, Status status) {
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), status));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#end_block

#method_before
public static void updateMenus(Screen view) {
    LinkMenuBar diffBar = menuBars.get(GerritTopMenus.DIFFERENCES.menuName);
    if (view instanceof PatchScreen) {
        patchScreen = (PatchScreen) view;
        menuLeft.setVisible(diffBar, true);
        menuLeft.selectTab(menuLeft.getWidgetIndex(diffBar));
    } else {
        if (patchScreen != null && menuLeft.getSelectedWidget() == diffBar) {
            menuLeft.selectTab(isSignedIn() ? 1 : 0);
        }
        patchScreen = null;
        menuLeft.setVisible(diffBar, false);
    }
}
#method_after
public static void updateMenus(Screen view) {
    LinkMenuBar diffBar = menuBars.get(GerritTopMenu.DIFFERENCES.menuName);
    if (view instanceof PatchScreen) {
        patchScreen = (PatchScreen) view;
        menuLeft.setVisible(diffBar, true);
        menuLeft.selectTab(menuLeft.getWidgetIndex(diffBar));
    } else {
        if (patchScreen != null && menuLeft.getSelectedWidget() == diffBar) {
            menuLeft.selectTab(isSignedIn() ? 1 : 0);
        }
        patchScreen = null;
        menuLeft.setVisible(diffBar, false);
    }
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<String, LinkMenuBar>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenus.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenus.MY.menuName, m);
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenus.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenus.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenus.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenus.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenus.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<String, LinkMenuBar>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#end_block

#method_before
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccountInfo();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    userSummaryPanel.add(new InlineLabel(" ▾"));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#method_after
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccountInfo();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    // "BLACK DOWN-POINTING SMALL TRIANGLE"
    userSummaryPanel.add(new InlineLabel(" \u25be"));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#end_block

#method_before
public Change.Id cherryPick(final PatchSet.Id patchSetId, final String message, final String destinationBranch, final RefControl refControl) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, MergeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (destinationBranch == null || destinationBranch.length() == 0) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = db.changes().get(changeId).getProject();
    final Repository git;
    try {
        git = gitManager.openRepository(project);
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            Ref destRef = git.getRef(destinationBranch);
            if (destRef == null) {
                throw new InvalidChangeOperationException("Branch " + destinationBranch + " does not exist.");
            }
            final RevCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
            RevCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent committerIdent = currentUser.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            RevCommit cherryPickCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ProjectState projectState = refControl.getProjectControl().getProjectState();
                cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, message, revWalk);
            } finally {
                oi.release();
            }
            if (cherryPickCommit == null) {
                throw new MergeException("Could not create a merge commit during the cherry pick");
            }
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(cherryPickCommit.getTree(), mergeTip, cherryPickCommit.getAuthorIdent(), myIdent, message);
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            List<Change> destChanges = db.changes().byBranchKey(new Branch.NameKey(db.changes().get(changeId).getProject(), destRef.getName()), changeKey).toList();
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " resides on the same branch. " + "Cannot create a new patch set.");
            } else if (destChanges.size() == 1) {
                // will be added as a new patch set.
                return insertPatchSet(git, revWalk, destChanges.get(0), patchSetId, cherryPickCommit, refControl);
            } else {
                // change.
                return createNewChange(git, revWalk, changeKey, project, patchSetId, destRef, cherryPickCommit, refControl);
            }
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public Change.Id cherryPick(final PatchSet.Id patchSetId, final String message, final String destinationBranch, final RefControl refControl) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, MergeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (destinationBranch == null || destinationBranch.length() == 0) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = db.changes().get(changeId).getProject();
    final Repository git;
    try {
        git = gitManager.openRepository(project);
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            Ref destRef = git.getRef(destinationBranch);
            if (destRef == null) {
                throw new InvalidChangeOperationException("Branch " + destinationBranch + " does not exist.");
            }
            final RevCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
            RevCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent committerIdent = currentUser.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), myIdent, message);
            String commitMessage = ChangeIdUtil.insertId(message, computedChangeId);
            RevCommit cherryPickCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ProjectState projectState = refControl.getProjectControl().getProjectState();
                cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk);
            } finally {
                oi.release();
            }
            if (cherryPickCommit == null) {
                throw new MergeException("Could not create a merge commit during the cherry pick");
            }
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            List<Change> destChanges = db.changes().byBranchKey(new Branch.NameKey(db.changes().get(changeId).getProject(), destRef.getName()), changeKey).toList();
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " resides on the same branch. " + "Cannot create a new patch set.");
            } else if (destChanges.size() == 1) {
                // will be added as a new patch set.
                return insertPatchSet(git, revWalk, destChanges.get(0), patchSetId, cherryPickCommit, refControl);
            } else {
                // change.
                return createNewChange(git, revWalk, changeKey, project, patchSetId, destRef, cherryPickCommit, refControl);
            }
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, PatchSet.Id patchSetId, RevCommit cherryPickCommit, RefControl refControl) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, refControl, currentUser, change, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(patchSetId.getParentKey(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), newPatchSetId);
    cmsg.setMessage("Uploaded patch set " + newPatchSetId.get() + ".");
    inserter.setMessage(cmsg).insert();
    return change.getId();
}
#method_after
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, PatchSet.Id patchSetId, RevCommit cherryPickCommit, RefControl refControl) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, refControl, currentUser, change, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").insert();
    return change.getId();
}
#end_block

#method_before
private void createSkipLine(int row, SkippedLine line, boolean isWholeFile) {
    FlowPanel p = new FlowPanel();
    InlineLabel l1 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionStart() + " ");
    InlineLabel l2 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionEnd() + " ");
    Anchor all = new Anchor(String.valueOf(line.getSize()));
    all.addClickHandler(expandAllListener);
    all.setStyleName(Gerrit.RESOURCES.css().skipLine());
    if (line.getSize() > 30 && isWholeFile) {
        // Only show the expand before/after if skipped more than 30 lines.
        Anchor b = new Anchor(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND), true);
        Anchor a = new Anchor(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND), true);
        b.addClickHandler(expandBeforeListener);
        a.addClickHandler(expandAfterListener);
        b.setStyleName(Gerrit.RESOURCES.css().skipLine());
        a.setStyleName(Gerrit.RESOURCES.css().skipLine());
        p.add(b);
        p.add(l1);
        p.add(all);
        p.add(l2);
        p.add(a);
    } else if (isWholeFile) {
        p.add(l1);
        p.add(all);
        p.add(l2);
    } else {
        p.add(l1);
        InlineLabel allLabel = new InlineLabel(" " + String.valueOf(line.getSize()) + " ");
        p.add(allLabel);
        p.add(l2);
        ;
    }
    table.setWidget(row, 1, p);
}
#method_after
private void createSkipLine(int row, SkippedLine line, boolean isWholeFile) {
    FlowPanel p = new FlowPanel();
    InlineLabel l1 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionStart() + " ");
    InlineLabel l2 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionEnd() + " ");
    Anchor all = new Anchor(String.valueOf(line.getSize()));
    all.addClickHandler(expandAllListener);
    all.setStyleName(Gerrit.RESOURCES.css().skipLine());
    if (line.getSize() > 30 && isWholeFile) {
        // Only show the expand before/after if skipped more than 30 lines.
        Anchor b = new Anchor(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND), true);
        Anchor a = new Anchor(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND), true);
        b.addClickHandler(expandBeforeListener);
        a.addClickHandler(expandAfterListener);
        b.setStyleName(Gerrit.RESOURCES.css().skipLine());
        a.setStyleName(Gerrit.RESOURCES.css().skipLine());
        p.add(b);
        p.add(l1);
        p.add(all);
        p.add(l2);
        p.add(a);
    } else if (isWholeFile) {
        p.add(l1);
        p.add(all);
        p.add(l2);
    } else {
        p.add(l1);
        p.add(new InlineLabel(" " + line.getSize() + " "));
        p.add(l2);
    }
    table.setWidget(row, 1, p);
}
#end_block

#method_before
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, final R resource) {
    return Iterables.filter(Iterables.transform(views, new Function<DynamicMap.Entry<RestView<R>>, UiAction.Description>() {

        @Override
        @Nullable
        public UiAction.Description apply(DynamicMap.Entry<RestView<R>> e) {
            int d = e.getExportName().indexOf('.');
            if (d < 0) {
                return null;
            }
            RestView<R> view;
            try {
                view = e.getProvider().get();
            } catch (RuntimeException err) {
                log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
                return null;
            }
            if (!(view instanceof UiAction)) {
                return null;
            }
            UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
            if (dsc == null || dsc.isVisible()) {
                return null;
            }
            String name = e.getExportName().substring(d + 1);
            PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
            PrivateInternals_UiActionDescription.setId(dsc, "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name);
            return dsc;
        }
    }), Predicates.notNull());
}
#method_after
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, final R resource) {
    return Iterables.filter(Iterables.transform(views, new Function<DynamicMap.Entry<RestView<R>>, UiAction.Description>() {

        @Override
        @Nullable
        public UiAction.Description apply(DynamicMap.Entry<RestView<R>> e) {
            int d = e.getExportName().indexOf('.');
            if (d < 0) {
                return null;
            }
            RestView<R> view;
            try {
                view = e.getProvider().get();
            } catch (RuntimeException err) {
                log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
                return null;
            }
            if (!(view instanceof UiAction)) {
                return null;
            }
            UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
            if (dsc == null || !dsc.isVisible()) {
                return null;
            }
            String name = e.getExportName().substring(d + 1);
            PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
            PrivateInternals_UiActionDescription.setId(dsc, "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name);
            return dsc;
        }
    }), Predicates.notNull());
}
#end_block

#method_before
private void populateCommands(final PatchSetDetail detail) {
    for (final UiCommandDetail cmd : detail.getCommands()) {
        final Button b = new Button();
        b.setText(cmd.label);
        b.setEnabled(cmd.enabled);
        b.setTitle(cmd.title);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                AsyncCallback<NativeString> cb = new AsyncCallback<NativeString>() {

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        new ErrorDialog(caught).center();
                    }

                    @Override
                    public void onSuccess(NativeString msg) {
                        b.setEnabled(true);
                        if (msg != null && !msg.asString().isEmpty()) {
                            Window.alert(msg.asString());
                        }
                    }
                };
                RestApi api = ChangeApi.revision(patchSet.getId()).view(cmd.id);
                if ("PUT".equalsIgnoreCase(cmd.method)) {
                    api.put(JavaScriptObject.createObject(), cb);
                } else if ("DELETE".equalsIgnoreCase(cmd.method)) {
                    api.delete(cb);
                } else {
                    api.post(JavaScriptObject.createObject(), cb);
                }
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateCommands(final PatchSetDetail detail) {
    for (final UiCommandDetail cmd : detail.getCommands()) {
        final Button b = new Button();
        b.setText(cmd.label);
        b.setEnabled(cmd.enabled);
        b.setTitle(cmd.title);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                AsyncCallback<NativeString> cb = new AsyncCallback<NativeString>() {

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        new ErrorDialog(caught).center();
                    }

                    @Override
                    public void onSuccess(NativeString msg) {
                        b.setEnabled(true);
                        if (msg != null && !msg.asString().isEmpty()) {
                            Window.alert(msg.asString());
                        }
                        Gerrit.display(PageLinks.toChange(patchSet.getId()));
                    }
                };
                RestApi api = ChangeApi.revision(patchSet.getId()).view(cmd.id);
                if ("PUT".equalsIgnoreCase(cmd.method)) {
                    api.put(JavaScriptObject.createObject(), cb);
                } else if ("DELETE".equalsIgnoreCase(cmd.method)) {
                    api.delete(cb);
                } else {
                    api.post(JavaScriptObject.createObject(), cb);
                }
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void initChangeActions(ChangeInfo info, boolean hasUser) {
    NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    if (hasUser) {
        a2b(actions, "abandon", abandon);
        a2b(actions, "/", deleteDraftChange);
        a2b(actions, "restore", restore);
        a2b(actions, "revert", revert);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, actions.get(id)));
        }
    }
}
#method_after
private void initChangeActions(ChangeInfo info, boolean hasUser) {
    NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    if (hasUser) {
        a2b(actions, "/", deleteChange);
        a2b(actions, "abandon", abandon);
        a2b(actions, "restore", restore);
        a2b(actions, "revert", revert);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, actions.get(id)));
        }
    }
}
#end_block

#method_before
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            submit.setTitle(actions.get("submit").title());
        }
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "/", deleteDraftPatchSet);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#method_after
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            submit.setTitle(actions.get("submit").title());
        }
        a2b(actions, "/", deleteRevision);
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#end_block

#method_before
static void publish(final Change.Id id, String revision) {
    ChangeApi.publish(id.get(), revision, cs(id));
}
#method_after
static void publish(Change.Id id, String revision) {
    ChangeApi.publish(id.get(), revision, cs(id));
}
#end_block

#method_before
static void delete(final Change.Id id, String revision) {
    ChangeApi.deleteDraftPatchSet(id.get(), revision, cs(id));
}
#method_after
static void delete(Change.Id id, String revision) {
    ChangeApi.deleteRevision(id.get(), revision, cs(id));
}
#end_block

#method_before
static void delete(final Change.Id id) {
    ChangeApi.deleteDraftChange(id.get(), mine());
}
#method_after
static void delete(Change.Id id) {
    ChangeApi.deleteChange(id.get(), mine());
}
#end_block

#method_before
private static GerritCallback<JavaScriptObject> cs(final Change.Id id) {
    return new GerritCallback<JavaScriptObject>() {

        public void onSuccess(JavaScriptObject result) {
            redisplay();
        }

        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                redisplay();
            } else {
                super.onFailure(err);
            }
        }

        private void redisplay() {
            Gerrit.display(PageLinks.toChange2(id));
        }
    };
}
#method_after
private static GerritCallback<JavaScriptObject> cs(final Change.Id id) {
    return new GerritCallback<JavaScriptObject>() {

        public void onSuccess(JavaScriptObject result) {
            Gerrit.display(PageLinks.toChange(id));
        }

        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                Gerrit.display(PageLinks.toChange(id));
            } else {
                super.onFailure(err);
            }
        }
    };
}
#end_block

#method_before
private static AsyncCallback<JavaScriptObject> mine() {
    return new GerritCallback<JavaScriptObject>() {

        public void onSuccess(JavaScriptObject result) {
            redisplay();
        }

        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                redisplay();
            } else {
                super.onFailure(err);
            }
        }

        private void redisplay() {
            Gerrit.display(PageLinks.MINE);
        }
    };
}
#method_after
private static AsyncCallback<JavaScriptObject> mine() {
    return new GerritCallback<JavaScriptObject>() {

        public void onSuccess(JavaScriptObject result) {
            Gerrit.display(PageLinks.MINE);
        }

        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                Gerrit.display(PageLinks.MINE);
            } else {
                super.onFailure(err);
            }
        }
    };
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static public PermissionRule grant(ProjectConfig project, String permissionName, int min, int max, AccountGroup.UUID group, String ref) {
    PermissionRule rule = newRule(project, group);
    rule.setMin(min);
    rule.setMax(max);
    return grant(project, permissionName, rule, ref);
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static private PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#end_block

#method_before
private ProjectState newProjectState(ProjectConfig local) {
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager gitMgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    SitePaths sitePaths = null;
    List<CommentLinkInfo> commentLinks = null;
    all.put(local.getProject().getNameKey(), new ProjectState(sitePaths, projectCache, allProjectsName, projectControlFactory, envFactory, gitMgr, rulesCache, commentLinks, local));
    return all.get(local.getProject().getNameKey());
}
#method_after
private ProjectState newProjectState(ProjectConfig local) {
    add(local);
    return all.get(local.getProject().getNameKey());
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    util = new Util();
    load("gerrit", "gerrit_common_test.pl", new AbstractModule() {

        @Override
        protected void configure() {
            bind(PrologEnvironment.Args.class).toInstance(new PrologEnvironment.Args(null, null, null, null, null, null));
        }
    });
    local = new ProjectConfig(localKey);
    local.createInMemory();
    V.setRefPatterns(Arrays.asList("sameAsAccess"));
    Q.setRefPatterns(Arrays.asList("refs/heads/develop"));
    local.getLabelSections().put(V.getName(), V);
    local.getLabelSections().put(Q.getName(), Q);
    util.add(local);
    grantLabel(local, LABEL + V.getName(), -1, +1, REGISTERED, "refs/heads/*");
    grantLabel(local, LABEL + Q.getName(), -1, +1, REGISTERED, "refs/heads/master");
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    util = new Util();
    load("gerrit", "gerrit_common_test.pl", new AbstractModule() {

        @Override
        protected void configure() {
            bind(PrologEnvironment.Args.class).toInstance(new PrologEnvironment.Args(null, null, null, null, null, null));
        }
    });
    local = new ProjectConfig(localKey);
    local.createInMemory();
    Q.setRefPatterns(Arrays.asList("refs/heads/develop"));
    local.getLabelSections().put(V.getName(), V);
    local.getLabelSections().put(Q.getName(), Q);
    util.add(local);
    grant(local, LABEL + V.getName(), -1, +1, REGISTERED, "refs/heads/*");
    grant(local, LABEL + Q.getName(), -1, +1, REGISTERED, "refs/heads/master");
}
#end_block

#method_before
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        labelSections.put(name, label);
    }
}
#method_after
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#end_block

#method_before
private void loadPluginSections(Config rc) {
    pluginConfigs = Maps.newHashMap();
    Set<String> pluginSubsections = rc.getSubsections(PLUGIN);
    for (String plugin : pluginSubsections) {
        LinkedListMultimap<String, String> pluginConfig = LinkedListMultimap.create();
        pluginConfigs.put(plugin, pluginConfig);
        for (String name : rc.getNames(PLUGIN, plugin)) {
            pluginConfig.putAll(name, Arrays.asList(rc.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#method_after
private void loadPluginSections(Config rc) {
    pluginConfigs = Maps.newHashMap();
    for (String plugin : rc.getSubsections(PLUGIN)) {
        Config pluginConfig = new Config();
        pluginConfigs.put(plugin, pluginConfig);
        for (String name : rc.getNames(PLUGIN, plugin)) {
            pluginConfig.setStringList(PLUGIN, plugin, name, Arrays.asList(rc.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#end_block

#method_before
public LinkedListMultimap<String, String> getPluginConfig(String pluginName) {
    LinkedListMultimap<String, String> pluginConfig = pluginConfigs.get(pluginName);
    if (pluginConfig == null) {
        pluginConfig = LinkedListMultimap.create();
        pluginConfigs.put(pluginName, pluginConfig);
    }
    return pluginConfig;
}
#method_after
public PluginConfig getPluginConfig(String pluginName) {
    Config pluginConfig = pluginConfigs.get(pluginName);
    if (pluginConfig == null) {
        pluginConfig = new Config();
        pluginConfigs.put(pluginName, pluginConfig);
    }
    return new PluginConfig(pluginName, pluginConfig);
}
#end_block

#method_before
private void savePluginSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(PLUGIN));
    for (String name : existing) {
        rc.unsetSection(PLUGIN, name);
    }
    for (Entry<String, LinkedListMultimap<String, String>> e : pluginConfigs.entrySet()) {
        String plugin = e.getKey();
        LinkedListMultimap<String, String> pluginConfig = e.getValue();
        for (String name : pluginConfig.keySet()) {
            rc.setStringList(PLUGIN, plugin, name, pluginConfig.get(name));
        }
    }
}
#method_after
private void savePluginSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(PLUGIN));
    for (String name : existing) {
        rc.unsetSection(PLUGIN, name);
    }
    for (Entry<String, Config> e : pluginConfigs.entrySet()) {
        String plugin = e.getKey();
        Config pluginConfig = e.getValue();
        for (String name : pluginConfig.getNames(PLUGIN, plugin)) {
            rc.setStringList(PLUGIN, plugin, name, Arrays.asList(pluginConfig.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#end_block

#method_before
public PluginConfig get(String pluginName) {
    LinkedListMultimap<String, String> pluginConfig = LinkedListMultimap.create();
    for (String name : cfg.getNames(PLUGIN, pluginName)) {
        pluginConfig.putAll(name, Arrays.asList(cfg.getStringList(PLUGIN, pluginName, name)));
    }
    return new PluginConfig(pluginName, pluginConfig);
}
#method_after
public PluginConfig get(String pluginName) {
    return new PluginConfig(pluginName, cfg);
}
#end_block

#method_before
public String getString(String name, String defaultValue) {
    return getValue(name, Functions.<String>identity(), defaultValue);
}
#method_after
public String getString(String name) {
    return cfg.getString(PLUGIN, pluginName, name);
}
#end_block

#method_before
public String getString(String name, String defaultValue) {
    return getValue(name, Functions.<String>identity(), defaultValue);
}
#method_after
public String getString(String name, String defaultValue) {
    return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
}
#end_block

#method_before
public int getInt(String name, int defaultValue) {
    return getValue(name, new Function<String, Integer>() {

        @Override
        public Integer apply(String stringVal) {
            return Integer.parseInt(stringVal);
        }
    }, defaultValue);
}
#method_after
public int getInt(String name, int defaultValue) {
    return cfg.getInt(PLUGIN, pluginName, name, defaultValue);
}
#end_block

#method_before
public long getLong(String name, long defaultValue) {
    return getValue(name, new Function<String, Long>() {

        @Override
        public Long apply(String stringVal) {
            return Long.parseLong(stringVal);
        }
    }, defaultValue);
}
#method_after
public long getLong(String name, long defaultValue) {
    return cfg.getLong(PLUGIN, pluginName, name, defaultValue);
}
#end_block

#method_before
public boolean getBoolean(String name, boolean defaultValue) {
    return getValue(name, new Function<String, Boolean>() {

        @Override
        public Boolean apply(String stringVal) {
            return Boolean.parseBoolean(stringVal);
        }
    }, defaultValue);
}
#method_after
public boolean getBoolean(String name, boolean defaultValue) {
    return cfg.getBoolean(PLUGIN, pluginName, name, defaultValue);
}
#end_block

#method_before
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<Patch.Key, Patch>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    for (final PatchLineComment c : db.patchComments().publishedByPatchSet(psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user instanceof IdentifiedUser) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(new ChangeResource(control), patchSet), new Provider<CurrentUser>() {

        @Override
        public CurrentUser get() {
            return user;
        }
    }))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#method_after
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<Patch.Key, Patch>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    for (final PatchLineComment c : db.patchComments().publishedByPatchSet(psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user instanceof IdentifiedUser) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(new ChangeResource(control), patchSet), Providers.of(user)))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(registerDatabaseHandler());
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            post(PROJECT_KIND, "delete-project").to(UiDeleteAction.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(registerDatabaseHandler());
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            delete(PROJECT_KIND).to(DeleteProject.class);
            post(PROJECT_KIND, "delete").to(DeleteProject.class);
        }
    });
}
#end_block

#method_before
private Class<? extends DatabaseDeleteHandler> registerDatabaseHandler() {
    int schemaVersion = SchemaVersion.guessVersion(SchemaVersion.C);
    // Injection of version dependent database handlers
    Class<? extends DatabaseDeleteHandler> databaseDeleteHandlerClass = null;
    switch(schemaVersion) {
        case 73:
        case 74:
        case 75:
        case 76:
            databaseDeleteHandlerClass = Schema73DatabaseDeleteHandler.class;
            break;
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
            databaseDeleteHandlerClass = Schema77DatabaseDeleteHandler.class;
            break;
        default:
            throw new RuntimeException("This version of the delete-project plugin is not " + "compatible with your current schema version (Version: " + schemaVersion + "). Please update the plugin.");
    }
    assert databaseDeleteHandlerClass != null : "No database handler set";
    return databaseDeleteHandlerClass;
}
#method_after
private Class<? extends DatabaseDeleteHandler> registerDatabaseHandler() {
    int schemaVersion = SchemaVersion.guessVersion(SchemaVersion.C);
    // Injection of version dependent database handlers
    Class<? extends DatabaseDeleteHandler> databaseDeleteHandlerClass = null;
    switch(schemaVersion) {
        case 73:
        case 74:
        case 75:
        case 76:
            databaseDeleteHandlerClass = Schema73DatabaseDeleteHandler.class;
            break;
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
            databaseDeleteHandlerClass = Schema77DatabaseDeleteHandler.class;
            break;
        default:
            throw new RuntimeException("This version of the delete-project plugin is not " + "compatible with your current schema version (Version: " + schemaVersion + "). Please update the plugin.");
    }
    assert databaseDeleteHandlerClass != null : "No database handler set";
    return databaseDeleteHandlerClass;
}
#end_block

#method_before
private void initEditMessageAction() {
    NativeMap<ActionInfo> actions = changeInfo.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(changeInfo.legacy_id(), revision, changeInfo.revision(revision).commit().message(), style, editMessage, reply);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#method_after
private void initEditMessageAction(ChangeInfo info, String revision) {
    NativeMap<ActionInfo> actions = info.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(info.legacy_id(), revision, info.revision(revision).commit().message(), style, editMessage, reply);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    downloadPatch.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction();
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderDownload(info, revision);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderRevisions(ChangeInfo info) {
    if (info.revisions().size() == 1) {
        UIObject.setVisible(revisionParent, false);
        return;
    }
    JsArray<RevisionInfo> list = info.revisions().values();
    Collections.sort(Natives.asList(list), new Comparator<RevisionInfo>() {

        @Override
        public int compare(RevisionInfo a, RevisionInfo b) {
            return a._number() - b._number();
        }
    });
    int selected = -1;
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        revisionList.addItem(r._number() + ": " + r.name().substring(0, 6), "" + r._number());
        if (revision.equals(r.name())) {
            selected = i;
        }
    }
    if (0 <= selected) {
        revisionList.setSelectedIndex(selected);
    }
}
#method_after
private void renderRevisions(ChangeInfo info) {
    if (info.revisions().size() == 1) {
        UIObject.setVisible(revisionParent, false);
        return;
    }
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isReversePatchSetOrder()) {
        Collections.reverse(Natives.asList(list));
    }
    int selected = -1;
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        revisionList.addItem(r._number() + ": " + r.name().substring(0, 6), "" + r._number());
        if (revision.equals(r.name())) {
            selected = i;
        }
    }
    if (0 <= selected) {
        revisionList.setSelectedIndex(selected);
    }
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws ResourceNotFoundException, ResourceConflictException {
    Project.NameKey project = rsrc.getControl().getProject().getNameKey();
    boolean close = true;
    try {
        final Repository repo = repoManager.openRepository(project);
        try {
            final RevWalk rw = new RevWalk(repo);
            try {
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
                RevCommit[] parents = commit.getParents();
                if (parents.length > 1) {
                    throw new ResourceConflictException("Revision has more than 1 parent.");
                } else if (parents.length == 0) {
                    throw new ResourceConflictException("Revision has no parent.");
                }
                final RevCommit base = parents[0];
                rw.parseBody(base);
                BinaryResult bin = new BinaryResult() {

                    @Override
                    public void writeTo(OutputStream out) throws IOException {
                        out.write(formatEmailHeader(commit).getBytes(UTF_8));
                        DiffFormatter fmt = new DiffFormatter(out);
                        fmt.setRepository(repo);
                        fmt.format(base.getTree(), commit.getTree());
                        fmt.flush();
                    }

                    @Override
                    public void close() throws IOException {
                        rw.release();
                        repo.close();
                    }
                }.setContentType("application/mbox").base64();
                if (download) {
                    bin.setAttachmentName(String.format("%s.diff.base64", rw.getObjectReader().abbreviate(commit, 8).name()));
                }
                close = false;
                return bin;
            } finally {
                if (close) {
                    rw.release();
                }
            }
        } finally {
            if (close) {
                repo.close();
            }
        }
    } catch (IOException e) {
        throw new ResourceNotFoundException();
    }
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws ResourceNotFoundException, ResourceConflictException {
    Project.NameKey project = rsrc.getControl().getProject().getNameKey();
    boolean close = true;
    try {
        final Repository repo = repoManager.openRepository(project);
        try {
            final RevWalk rw = new RevWalk(repo);
            try {
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
                RevCommit[] parents = commit.getParents();
                if (parents.length > 1) {
                    throw new ResourceConflictException("Revision has more than 1 parent.");
                } else if (parents.length == 0) {
                    throw new ResourceConflictException("Revision has no parent.");
                }
                final RevCommit base = parents[0];
                rw.parseBody(base);
                BinaryResult bin = new BinaryResult() {

                    @Override
                    public void writeTo(OutputStream out) throws IOException {
                        if (zip) {
                            ZipOutputStream zos = new ZipOutputStream(out);
                            ZipEntry e = new ZipEntry(fileName(rw, commit));
                            e.setTime(commit.getCommitTime() * 1000L);
                            zos.putNextEntry(e);
                            format(zos);
                            zos.closeEntry();
                            zos.finish();
                        } else {
                            format(out);
                        }
                    }

                    private void format(OutputStream out) throws IOException {
                        out.write(formatEmailHeader(commit).getBytes(UTF_8));
                        DiffFormatter fmt = new DiffFormatter(out);
                        fmt.setRepository(repo);
                        fmt.format(base.getTree(), commit.getTree());
                        fmt.flush();
                    }

                    @Override
                    public void close() throws IOException {
                        rw.release();
                        repo.close();
                    }
                };
                if (zip) {
                    bin.disableGzip().setContentType("application/zip").setAttachmentName(fileName(rw, commit) + ".zip");
                } else {
                    bin.base64().setContentType("application/mbox").setAttachmentName(download ? fileName(rw, commit) + ".base64" : null);
                }
                close = false;
                return bin;
            } finally {
                if (close) {
                    rw.release();
                }
            }
        } finally {
            if (close) {
                repo.close();
            }
        }
    } catch (IOException e) {
        throw new ResourceNotFoundException();
    }
}
#end_block

#method_before
private ViewData view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return new ViewData(p.get(0), view);
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return new ViewData(null, core);
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        Map.Entry<String, RestView<RestResource>> entry = Iterables.getOnlyElement(r.entrySet());
        return new ViewData(entry.getKey(), entry.getValue());
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private ViewData view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return new ViewData(p.get(0), view);
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return new ViewData(null, core);
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        Map.Entry<String, RestView<RestResource>> entry = Iterables.getOnlyElement(r.entrySet());
        return new ViewData(entry.getKey(), entry.getValue());
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: %s", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    return Integer.valueOf(startLine).hashCode() + Integer.valueOf(startCharacter).hashCode() + Integer.valueOf(endLine).hashCode() + Integer.valueOf(endCharacter).hashCode();
}
#method_after
@Override
public int hashCode() {
    int h = startLine;
    h = h * 31 + startCharacter;
    h = h * 31 + endLine;
    h = h * 31 + endCharacter;
    return h;
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            throw new ResourceConflictException("Cannot update " + projectName);
        }
        return new ConfigInfo(projectStateFactory.create(projectConfig), config);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            throw new ResourceConflictException("Cannot update " + projectName);
        }
        return new ConfigInfo(projectStateFactory.create(projectConfig), config);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#end_block

#method_before
@UiHandler("editCommitMessage")
void onEditMessage(ClickEvent e) {
    if (Gerrit.isSignedIn()) {
        editCommitMessageAction.onEdit();
    } else {
        Gerrit.doSignIn(getToken());
    }
}
#method_after
@UiHandler("editMessage")
void onEditMessage(ClickEvent e) {
    editMessageAction.onEdit();
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    initEditCommitMessageAction();
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction();
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "edit_commit_message").to(EditCommitMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#end_block

#method_before
static void invoke(ChangeInfo change, ActionInfo action, RestApi api) {
    final Change.Id id = change.legacy_id();
    AsyncCallback<JavaScriptObject> cb = new GerritCallback<JavaScriptObject>() {

        @Override
        public void onSuccess(JavaScriptObject msg) {
            if (msg instanceof NativeString) {
                NativeString str = (NativeString) msg;
                if (str != null && !str.asString().isEmpty()) {
                    Window.alert(str.asString());
                }
            }
            Gerrit.display(PageLinks.toChange2(id));
        }
    };
    if ("PUT".equalsIgnoreCase(action.method())) {
        api.put(JavaScriptObject.createObject(), cb);
    } else if ("DELETE".equalsIgnoreCase(action.method())) {
        api.delete(cb);
    } else {
        api.post(JavaScriptObject.createObject(), cb);
    }
}
#method_after
static void invoke(ChangeInfo change, ActionInfo action, RestApi api) {
    final Change.Id id = change.legacy_id();
    AsyncCallback<JavaScriptObject> cb = new GerritCallback<JavaScriptObject>() {

        @Override
        public void onSuccess(JavaScriptObject msg) {
            if (NativeString.is(msg)) {
                NativeString str = (NativeString) msg;
                if (!str.asString().isEmpty()) {
                    Window.alert(str.asString());
                }
            }
            Gerrit.display(PageLinks.toChange2(id));
        }
    };
    if ("PUT".equalsIgnoreCase(action.method())) {
        api.put(JavaScriptObject.createObject(), cb);
    } else if ("DELETE".equalsIgnoreCase(action.method())) {
        api.delete(cb);
    } else {
        api.post(JavaScriptObject.createObject(), cb);
    }
}
#end_block

#method_before
private void removeUI() {
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    clearRange();
    setRangeHighlight(false);
    Side side = comment.side();
    removeFromParent();
    if (!getCommentInfo().has_line()) {
        parent.removeFileCommentBox(this, side);
        return;
    }
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    parent.removeDraft(this, side, comment.line() - 1);
    getCm().focus();
    getSelfWidgetWrapper().getWidget().clear();
    getGutterWrapper().remove();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            resizePaddingWidget();
        }
    });
}
#method_after
private void removeUI() {
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    clearRange();
    setRangeHighlight(false);
    removeFromParent();
    if (!getCommentInfo().has_line()) {
        parent.removeFileCommentBox(this);
        return;
    }
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    parent.removeDraft(this, comment.line() - 1);
    getCm().focus();
    getSelfWidgetWrapper().getWidget().clear();
    getGutterWrapper().remove();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            resizePaddingWidget();
        }
    });
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(getCommentCallback(false)));
    }
    CommentApi.comments(revision, group.add(getCommentCallback(false)));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(getCommentCallback(true)));
        }
        CommentApi.drafts(revision, group.add(getCommentCallback(true)));
    } else {
        drafts = JsArray.createArray().cast();
    }
    ConfigInfoCache.get(revision.getParentKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(getCommentCallback(DisplaySide.A, false)));
    }
    CommentApi.comments(revision, group.add(getCommentCallback(DisplaySide.B, false)));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(getCommentCallback(DisplaySide.A, true)));
        }
        CommentApi.drafts(revision, group.add(getCommentCallback(DisplaySide.B, true)));
    }
    ConfigInfoCache.get(revision.getParentKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
}
#end_block

#method_before
private GerritCallback<NativeMap<JsArray<CommentInfo>>> getCommentCallback(final boolean toDrafts) {
    return new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            JsArray<CommentInfo> in = result.get(path);
            if (in != null) {
                addAllToCommentList(in, toDrafts);
            }
        }
    };
}
#method_after
private GerritCallback<NativeMap<JsArray<CommentInfo>>> getCommentCallback(final DisplaySide side, final boolean toDrafts) {
    return new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            JsArray<CommentInfo> in = result.get(path);
            if (in != null) {
                if (toDrafts) {
                    if (side == DisplaySide.A) {
                        draftsBase = in;
                    } else {
                        draftsRevision = in;
                    }
                } else {
                    if (side == DisplaySide.A) {
                        publishedBase = in;
                    } else {
                        publishedRevision = in;
                    }
                }
            }
        }
    };
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (publishedBase != null || publishedRevision != null) {
        publishedMap = new HashMap<String, PublishedBox>();
    }
    if (publishedBase != null) {
        renderPublished(publishedBase);
    }
    if (publishedRevision != null) {
        renderPublished(publishedRevision);
    }
    if (draftsBase != null) {
        renderDrafts(draftsBase);
    }
    if (draftsRevision != null) {
        renderDrafts(draftsRevision);
    }
    renderSkips();
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
CommentInfo createReply(CommentInfo replyTo) {
    if (!replyTo.has_line()) {
        return CommentInfo.createFile(path, replyTo.side(), replyTo.id(), null);
    } else {
        return CommentInfo.createRange(path, replyTo.side(), replyTo.line(), replyTo.id(), null, null);
    }
}
#method_after
CommentInfo createReply(CommentInfo replyTo) {
    if (!replyTo.has_line() && replyTo.range() == null) {
        return CommentInfo.createFile(path, replyTo.side(), replyTo.id(), null);
    } else {
        return CommentInfo.createRange(path, replyTo.side(), replyTo.line(), replyTo.id(), null, replyTo.range());
    }
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info) {
    Side side = info.side();
    CodeMirror cm = getCmFromSide(info.side());
    final DraftBox box = new DraftBox(this, cm, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info, DisplaySide side) {
    CodeMirror cm = getCmFromSide(side);
    final DraftBox box = new DraftBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    DiffChunkInfo myChunk = getDiffChunk(mySide, line);
    DiffChunkInfo otherChunk = getDiffChunk(getSideFromCm(other), lineToPad);
    PaddingManager otherManager;
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        otherManager = linePaddingManagerMap.get(otherHandle);
    } else {
        otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
    }
    if ((myChunk == null && otherChunk == null) || (myChunk != null && otherChunk != null)) {
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (otherChunk == null) {
        box.setDiffChunkInfo(myChunk);
    }
    box.setGutterWrapper(diffTable.sidePanel.addGutter(cm, info.line() - 1, box instanceof DraftBox ? SidePanel.GutterType.DRAFT : SidePanel.GutterType.COMMENT));
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    DisplaySide side = box.getSide();
    CodeMirror cm = getCmFromSide(side);
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(side, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    DiffChunkInfo myChunk = getDiffChunk(side, line);
    DiffChunkInfo otherChunk = getDiffChunk(getSideFromCm(other), lineToPad);
    PaddingManager otherManager;
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        otherManager = linePaddingManagerMap.get(otherHandle);
    } else {
        otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
    }
    if ((myChunk == null && otherChunk == null) || (myChunk != null && otherChunk != null)) {
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (otherChunk == null) {
        box.setDiffChunkInfo(myChunk);
    }
    box.setGutterWrapper(diffTable.sidePanel.addGutter(cm, info.line() - 1, box instanceof DraftBox ? SidePanel.GutterType.DRAFT : SidePanel.GutterType.COMMENT));
    return box;
}
#end_block

#method_before
void removeDraft(DraftBox box, Side side, int line) {
    LineHandle handle = getCmFromSide(side).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#method_after
void removeDraft(DraftBox box, int line) {
    LineHandle handle = getCmFromSide(box.getSide()).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#end_block

#method_before
void addFileCommentBox(CommentBox box, Side side) {
    diffTable.addFileCommentBox(box, side);
}
#method_after
void addFileCommentBox(CommentBox box) {
    diffTable.addFileCommentBox(box);
}
#end_block

#method_before
void removeFileCommentBox(DraftBox box, Side side) {
    diffTable.onRemoveDraftBox(box, side);
}
#method_after
void removeFileCommentBox(DraftBox box) {
    diffTable.onRemoveDraftBox(box);
}
#end_block

#method_before
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, commentLinkProcessor, getPatchSetIdFromSide(side), info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished(JsArray<CommentInfo> published) {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        DisplaySide side;
        if (info.side() == Side.PARENT) {
            if (base != null) {
                continue;
            }
            side = DisplaySide.A;
        } else {
            side = published == publishedBase ? DisplaySide.A : DisplaySide.B;
        }
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, getPatchSetIdFromSide(side), info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderDrafts(JsArray<CommentInfo> drafts) {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        DisplaySide side;
        if (info.side() == Side.PARENT) {
            if (base != null) {
                continue;
            }
            side = DisplaySide.A;
        } else {
            side = drafts == draftsBase ? DisplaySide.A : DisplaySide.B;
        }
        DraftBox box = new DraftBox(this, getCmFromSide(side), side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
        if (publishedBase != null || publishedRevision != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box);
            continue;
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private PatchSet.Id getPatchSetIdFromSide(Side side) {
    return side == Side.PARENT && base != null ? base : revision;
}
#method_after
private PatchSet.Id getPatchSetIdFromSide(DisplaySide side) {
    return side == DisplaySide.A && base != null ? base : revision;
}
#end_block

#method_before
private CodeMirror getCmFromSide(Side side) {
    return side == Side.PARENT ? cmA : cmB;
}
#method_after
private CodeMirror getCmFromSide(DisplaySide side) {
    return side == DisplaySide.A ? cmA : cmB;
}
#end_block

#method_before
private Side getSideFromCm(CodeMirror cm) {
    return cm == cmA ? Side.PARENT : Side.REVISION;
}
#method_after
private DisplaySide getSideFromCm(CodeMirror cm) {
    return cm == cmA ? DisplaySide.A : DisplaySide.B;
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, NativeEvent clickEvent) {
            instance.setCursor(LineCharacter.create(line));
            instance.setActiveLine(instance.getLineHandle(line));
            insertNewDraft(instance).run();
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, NativeEvent clickEvent) {
            if (!(cm.hasActiveLine() && instance.getLineNumber(cm.getActiveLine()) == line)) {
                instance.setCursor(LineCharacter.create(line));
                instance.setActiveLine(cm.getLineHandle(line));
            }
            insertNewDraft(cm).run();
        }
    };
}
#end_block

#method_before
private Runnable insertNewDraft(final CodeMirror cm) {
    if (!Gerrit.isSignedIn()) {
        return new Runnable() {

            @Override
            public void run() {
                Gerrit.doSignIn(getToken());
            }
        };
    }
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addDraftBox(CommentInfo.createRange(path, getSideFromCm(cm), line + 1, null, null, cm.somethingSelected() ? CommentRange.fromFromTo(cm.getSelectedRange()) : null)));
            } else if (box instanceof DraftBox) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).doReply();
            }
        }
    };
}
#method_after
private Runnable insertNewDraft(final CodeMirror cm) {
    if (!Gerrit.isSignedIn()) {
        return new Runnable() {

            @Override
            public void run() {
                Gerrit.doSignIn(getToken());
            }
        };
    }
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            FromTo fromTo = cm.getSelectedRange();
            if (cm.somethingSelected()) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line, fromTo.getTo().getLine() == line ? fromTo : null));
            } else if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line, null));
            } else if (box instanceof DraftBox) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).doReply();
            }
        }
    };
}
#end_block

#method_before
private DiffChunkInfo getDiffChunk(Side side, int line) {
    for (DiffChunkInfo info : diffChunks) {
        if (info.getSide() == side && info.getStart() <= line && line <= info.getEnd()) {
            return info;
        }
    }
    return null;
}
#method_after
private DiffChunkInfo getDiffChunk(DisplaySide side, int line) {
    for (DiffChunkInfo info : diffChunks) {
        if (info.getSide() == side && info.getStart() <= line && line <= info.getEnd()) {
            return info;
        }
    }
    return null;
}
#end_block

#method_before
void resizePaddingOnOtherSide(Side mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    int otherPaddingHeight = otherPadding.getOffsetHeight();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        int myPaddingHeight = myPadding.getOffsetHeight();
        myChunkHeight -= myPaddingHeight;
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPaddingHeight;
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            if (myPaddingHeight != 0) {
                setHeightInPx(myPadding, 0);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != delta) {
                setHeightInPx(otherPadding, delta);
                otherWrapper.getWidget().changed();
            }
        } else {
            if (myPaddingHeight != -delta) {
                setHeightInPx(myPadding, -delta);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != 0) {
                setHeightInPx(otherPadding, 0);
                otherWrapper.getWidget().changed();
            }
        }
    } else if (otherPaddingHeight != myChunkHeight) {
        setHeightInPx(otherPadding, myChunkHeight);
        otherWrapper.getWidget().changed();
    }
}
#method_after
void resizePaddingOnOtherSide(DisplaySide mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    int otherPaddingHeight = otherPadding.getOffsetHeight();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        int myPaddingHeight = myPadding.getOffsetHeight();
        myChunkHeight -= myPaddingHeight;
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPaddingHeight;
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            if (myPaddingHeight != 0) {
                setHeightInPx(myPadding, 0);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != delta) {
                setHeightInPx(otherPadding, delta);
                otherWrapper.getWidget().changed();
            }
        } else {
            if (myPaddingHeight != -delta) {
                setHeightInPx(myPadding, -delta);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != 0) {
                setHeightInPx(otherPadding, 0);
                otherWrapper.getWidget().changed();
            }
        }
    } else if (otherPaddingHeight != myChunkHeight) {
        setHeightInPx(otherPadding, myChunkHeight);
        otherWrapper.getWidget().changed();
    }
}
#end_block

#method_before
private RenderLineHandler resizeLinePadding(final Side side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, Element element) {
            if (lineActiveBoxMap.containsKey(handle)) {
                lineActiveBoxMap.get(handle).resizePaddingWidget();
            }
            if (linePaddingOnOtherSideMap.containsKey(handle)) {
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        resizePaddingOnOtherSide(side, instance.getLineNumber(handle));
                    }
                });
            }
        }
    };
}
#method_after
private RenderLineHandler resizeLinePadding(final DisplaySide side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, Element element) {
            if (lineActiveBoxMap.containsKey(handle)) {
                lineActiveBoxMap.get(handle).resizePaddingWidget();
            }
            if (linePaddingOnOtherSideMap.containsKey(handle)) {
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        resizePaddingOnOtherSide(side, instance.getLineNumber(handle));
                    }
                });
            }
        }
    };
}
#end_block

#method_before
Side getSide() {
    return side;
}
#method_after
DisplaySide getSide() {
    return side;
}
#end_block

#method_before
public static FromTo create(LineCharacter from, LineCharacter to) {
    FromTo fromTo = createObject().cast();
    fromTo.setFrom(from);
    fromTo.setTo(to);
    return fromTo;
}
#method_after
public static FromTo create(CommentRange range) {
    return create(LineCharacter.create(range.start_line() - 1, range.start_character()), LineCharacter.create(range.end_line() - 1, range.end_character()));
}
#end_block

#method_before
DraftBox addReplyBox() {
    DraftBox box = parent.addDraftBox(parent.createReply(comment));
    registerReplyBox(box);
    return box;
}
#method_after
DraftBox addReplyBox() {
    DraftBox box = parent.addDraftBox(parent.createReply(comment), getSide());
    registerReplyBox(box);
    return box;
}
#end_block

#method_before
void doReply() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        DraftBox box = addReplyBox();
        if (!getCommentInfo().has_line()) {
            parent.addFileCommentBox(box, comment.side());
        }
    } else {
        openReplyBox();
    }
}
#method_after
void doReply() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        DraftBox box = addReplyBox();
        if (!getCommentInfo().has_line()) {
            parent.addFileCommentBox(box);
        }
    } else {
        openReplyBox();
    }
}
#end_block

#method_before
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(parent.createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = parent.addDraftBox(result);
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    parent.addFileCommentBox(box, comment.side());
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#method_after
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(parent.createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = parent.addDraftBox(result, getSide());
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    parent.addFileCommentBox(box);
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#end_block

#method_before
public static CommentRange create(int sl, int sc, int el, int ec) {
    CommentRange r = createObject().cast();
    r.set(sl, sc, el, ec);
    return r;
}
#method_after
public static CommentRange create(FromTo fromTo) {
    if (fromTo == null) {
        return null;
    }
    LineCharacter from = fromTo.getFrom();
    LineCharacter to = fromTo.getTo();
    return create(from.getLine() + 1, from.getCh(), to.getLine() + 1, to.getCh());
}
#end_block

#method_before
private FileCommentPanel getPanelFromSide(Side side) {
    return side == Side.PARENT ? fileCommentPanelA : fileCommentPanelB;
}
#method_after
private FileCommentPanel getPanelFromSide(DisplaySide side) {
    return side == DisplaySide.A ? fileCommentPanelA : fileCommentPanelB;
}
#end_block

#method_before
void createOrEditFileComment(Side side) {
    getPanelFromSide(side).createOrEditFileComment();
    updateFileCommentVisibility(false);
}
#method_after
void createOrEditFileComment(DisplaySide side) {
    getPanelFromSide(side).createOrEditFileComment();
    updateFileCommentVisibility(false);
}
#end_block

#method_before
void addFileCommentBox(CommentBox box, Side side) {
    getPanelFromSide(side).addFileComment(box);
}
#method_after
void addFileCommentBox(CommentBox box) {
    getPanelFromSide(box.getSide()).addFileComment(box);
}
#end_block

#method_before
void onRemoveDraftBox(DraftBox box, Side side) {
    getPanelFromSide(side).onRemoveDraftBox(box);
}
#method_after
void onRemoveDraftBox(DraftBox box) {
    getPanelFromSide(box.getSide()).onRemoveDraftBox(box);
}
#end_block

#method_before
void resizePaddingWidget() {
    if (!getCommentInfo().has_line()) {
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            assert selfWidgetWrapper != null;
            selfWidgetWrapper.getWidget().changed();
            if (diffChunkInfo != null) {
                parent.resizePaddingOnOtherSide(getCommentInfo().side(), diffChunkInfo.getEnd());
            } else {
                assert widgetManager != null;
                widgetManager.resizePaddingWidget();
            }
        }
    });
}
#method_after
void resizePaddingWidget() {
    if (!getCommentInfo().has_line()) {
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            assert selfWidgetWrapper != null;
            selfWidgetWrapper.getWidget().changed();
            if (diffChunkInfo != null) {
                parent.resizePaddingOnOtherSide(side, diffChunkInfo.getEnd());
            } else {
                assert widgetManager != null;
                widgetManager.resizePaddingWidget();
            }
        }
    });
}
#end_block

#method_before
@Override
public void initConfig(Section databaseSection) {
    final String defPort = "1521";
    databaseSection.string("Server hostname", "hostname", "localhost");
    databaseSection.string("Server port", "port", defPort, true);
    databaseSection.string("Database name", "database", "xe");
    databaseSection.string("Database username", "username", username());
    databaseSection.password("username", "password");
}
#method_after
@Override
public void initConfig(Section databaseSection) {
    final String defPort = "1521";
    databaseSection.string("Server hostname", "hostname", "localhost");
    databaseSection.string("Server port", "port", defPort, false);
    databaseSection.string("Instance name", "instance", "xe");
    databaseSection.string("Database username", "username", username());
    databaseSection.password("username", "password");
}
#end_block

#method_before
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbc = new ConfigSection(cfg, "database");
    b.append("jdbc:oracle:thin:@");
    b.append(hostname(dbc.optional("hostname")));
    b.append(port(dbc.optional("port")));
    b.append(":");
    b.append(dbc.required("database"));
    return b.toString();
}
#method_after
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbc = new ConfigSection(cfg, "database");
    b.append("jdbc:oracle:thin:@");
    b.append(hostname(dbc.optional("hostname")));
    b.append(port(dbc.optional("port")));
    b.append(":");
    b.append(dbc.required("instance"));
    return b.toString();
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    if (all) {
        pushAllFactory.create(urlMatch).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch);
            } else {
                throw new UnloggedFailure(1, "error: '" + name + "': not a Gerrit project");
            }
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(ReplicationType.COMMAND, this);
    Future<?> future = null;
    if (all) {
        future = pushAllFactory.create(urlMatch, state).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch, state);
            } else {
                writeStdErrSync("error: '" + name + "': not a Gerrit project");
            }
        }
        state.markAllPushTasksScheduled();
    }
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                wrappedLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                wrappedLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#end_block

#method_before
@Test
public void testList() throws Exception {
    Map<String, CapabilityInfo> m = injector.getInstance(ListCapabilities.class).apply(new ConfigResource());
    for (String id : GlobalCapability.getAllNames()) {
        assertTrue("contains " + id, m.containsKey(id));
        assertEquals(id, m.get(id).id);
        assertNotNull(id + " has name", m.get(id).name);
    }
    String pluginCapability = "gerrit-printHello";
    assertTrue("contains " + pluginCapability, m.containsKey(pluginCapability));
}
#method_after
@Test
public void testList() throws Exception {
    Map<String, CapabilityInfo> m = injector.getInstance(ListCapabilities.class).apply(new ConfigResource());
    for (String id : GlobalCapability.getAllNames()) {
        assertTrue("contains " + id, m.containsKey(id));
        assertEquals(id, m.get(id).id);
        assertNotNull(id + " has name", m.get(id).name);
    }
    String pluginCapability = "gerrit-printHello";
    assertTrue("contains " + pluginCapability, m.containsKey(pluginCapability));
    assertEquals(pluginCapability, m.get(pluginCapability).id);
    assertEquals("Print Hello", m.get(pluginCapability).name);
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final CommandProvider p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.getProvider().get();
        checkRequiresCapability(getName(), cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final CommandProvider p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.getProvider().get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#end_block

#method_before
private void checkRequiresCapability(String baseName, Command cmd) throws UnloggedFailure {
    RequiresCapability rc = cmd.getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            // then it must be a plugin-owned capability
            if (!GlobalCapability.isCapability(rc.value())) {
                if (ctl.canPerform(String.format("%s-%s", baseName, rc.value()))) {
                    return;
                }
            }
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), rc.value());
            throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
        }
    }
}
#method_after
private void checkRequiresCapability(Command cmd) throws UnloggedFailure {
    RequiresCapability rc = cmd.getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        String capability = rc.value();
        if (cmd instanceof BaseCommand) {
            String pluginName = ((BaseCommand) cmd).getPluginName();
            if (pluginName != null && !"gerrit".equals(pluginName) && (rc.scope() == CapabilityScope.PLUGIN || rc.scope() == CapabilityScope.CONTEXT)) {
                capability = String.format("%s-%s", pluginName, rc.value());
            } else if (rc.scope() == CapabilityScope.PLUGIN) {
                log.error(String.format("Class %s uses @%s(scope=%s), but is not within a plugin", cmd.getClass().getName(), RequiresCapability.class.getSimpleName(), CapabilityScope.PLUGIN.name()));
                throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, "fatal: cannot check capability");
            }
        }
        if (!ctl.canPerform(capability) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), capability);
            throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#end_block

#method_before
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        // because it might be provided by plugin
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#method_after
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#end_block

#method_before
private static LabelValue parseLabelValue(String src) {
    List<String> parts = ImmutableList.copyOf(Splitter.on(CharMatcher.WHITESPACE).omitEmptyStrings().limit(2).split(src));
    if (parts.isEmpty()) {
        throw new IllegalArgumentException("empty value");
    }
    return new LabelValue(Shorts.checkedCast(PermissionRule.parseInt(parts.get(0))), parts.get(1));
}
#method_after
private static LabelValue parseLabelValue(String src) {
    List<String> parts = ImmutableList.copyOf(Splitter.on(CharMatcher.WHITESPACE).omitEmptyStrings().limit(2).split(src));
    if (parts.isEmpty()) {
        throw new IllegalArgumentException("empty value");
    }
    String valueText = parts.size() > 1 ? parts.get(1) : "";
    return new LabelValue(Shorts.checkedCast(PermissionRule.parseInt(parts.get(0))), valueText);
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
private void saveAccessSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            // because it might be provided by plugin
            if (!have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = Permission.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
}
#method_after
private void saveAccessSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (!have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = Permission.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Class.forName(org.postgresql.Driver.class.getName());
    // Oracle HR instance is available in express edition 11.g
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", "oracle.jdbc.driver.OracleDriver");
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    try {
        Class.forName(ORACLE_DRIVER);
    } catch (Exception e) {
        assumeNoException(e);
    }
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", ORACLE_DRIVER);
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#end_block

#method_before
@Override
public Set<String> listTables(final Connection db) throws SQLException {
    Statement s = db.createStatement();
    try {
        ResultSet rs = s.executeQuery("SELECT table_name FROM user_tables");
        try {
            HashSet<String> sequences = new HashSet<String>();
            while (rs.next()) {
                sequences.add(rs.getString(1).toLowerCase());
            }
            return sequences;
        } finally {
            rs.close();
        }
    } finally {
        s.close();
    }
}
#method_after
@Override
public Set<String> listTables(final Connection db) throws SQLException {
    Statement s = db.createStatement();
    try {
        ResultSet rs = s.executeQuery("SELECT table_name FROM user_tables");
        try {
            HashSet<String> tables = new HashSet<String>();
            while (rs.next()) {
                tables.add(rs.getString(1).toLowerCase());
            }
            return tables;
        } finally {
            rs.close();
        }
    } finally {
        s.close();
    }
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create(repo);
        try {
            mergeValidators.validatePreMerge(commit, destProject, destBranch);
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMergedPatchSet(chg.getId(), ps.getId());
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#end_block

#method_before
public void validatePreMerge(CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch) throws MergeValidationException {
    List<MergeValidationListener> validators = Lists.newLinkedList();
    validators.add(new PluginMergeValidationListener(mergeValidationListeners));
    validators.add(new ProjectConfigValidator(repo, allProjectsName, db, ps, projectCache, identifiedUserFactory));
    for (MergeValidationListener validator : validators) {
        validator.onPreMerge(commit, destProject, destBranch);
    }
}
#method_after
public void validatePreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId) throws MergeValidationException {
    List<MergeValidationListener> validators = Lists.newLinkedList();
    validators.add(new PluginMergeValidationListener(mergeValidationListeners));
    validators.add(projectConfigValidatorFactory.create());
    for (MergeValidationListener validator : validators) {
        validator.onPreMerge(repo, commit, destProject, destBranch, patchSetId);
    }
}
#end_block

#method_before
@Override
public void onPreMerge(final CodeReviewCommit commit, final ProjectState destProject, final Branch.NameKey destBranch) throws MergeValidationException {
    if (GitRepositoryManager.REF_CONFIG.equals(destBranch.get())) {
        final Project.NameKey newParent;
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, commit);
            newParent = cfg.getProject().getParent(allProjectsName);
        } catch (Exception e) {
            throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION);
        }
        final Project.NameKey oldParent = destProject.getProject().getParent(allProjectsName);
        if (oldParent == null) {
            // update of the 'All-Projects' project
            if (newParent != null) {
                throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT);
            }
        } else {
            if (!oldParent.equals(newParent)) {
                final PatchSetApproval psa = getSubmitter(db, ps.getId());
                if (psa == null) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
                if (!submitter.getCapabilities().canAdministrateServer()) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                if (projectCache.get(newParent) == null) {
                    throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND);
                }
            }
        }
    }
}
#method_after
@Override
public void onPreMerge(final Repository repo, final CodeReviewCommit commit, final ProjectState destProject, final Branch.NameKey destBranch, final PatchSet.Id patchSetId) throws MergeValidationException {
    if (GitRepositoryManager.REF_CONFIG.equals(destBranch.get())) {
        final Project.NameKey newParent;
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, commit);
            newParent = cfg.getProject().getParent(allProjectsName);
        } catch (Exception e) {
            throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION);
        }
        final Project.NameKey oldParent = destProject.getProject().getParent(allProjectsName);
        if (oldParent == null) {
            // update of the 'All-Projects' project
            if (newParent != null) {
                throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT);
            }
        } else {
            if (!oldParent.equals(newParent)) {
                final PatchSetApproval psa = getSubmitter(db, patchSetId);
                if (psa == null) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
                if (!submitter.getCapabilities().canAdministrateServer()) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                if (projectCache.get(newParent) == null) {
                    throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void onPreMerge(CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch) throws MergeValidationException {
    for (MergeValidationListener validator : mergeValidationListeners) {
        validator.onPreMerge(commit, destProject, destBranch);
    }
}
#method_after
@Override
public void onPreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId) throws MergeValidationException {
    for (MergeValidationListener validator : mergeValidationListeners) {
        validator.onPreMerge(repo, commit, destProject, destBranch, patchSetId);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
                published = m.get(path);
            }
        }));
    }
    CommentApi.comments(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
            if (published == null) {
                published = m.get(path);
            } else {
                JsArray<CommentInfo> publishedInRevision = m.get(path);
                for (int i = 0; i < publishedInRevision.length(); i++) {
                    published.push(publishedInRevision.get(i));
                }
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

                @Override
                public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
                    drafts = m.get(path);
                }
            }));
        }
        CommentApi.drafts(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
                if (drafts == null) {
                    drafts = m.get(path);
                } else {
                    JsArray<CommentInfo> draftsInRevision = m.get(path);
                    for (int i = 0; i < draftsInRevision.length(); i++) {
                        drafts.push(draftsInRevision.get(i));
                    }
                }
            }
        }));
    } else {
        drafts = JsArray.createArray().cast();
    }
    ConfigInfoCache.get(revision.getParentKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(getCommentCallback(false)));
    }
    CommentApi.comments(revision, group.add(getCommentCallback(false)));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(getCommentCallback(true)));
        }
        CommentApi.drafts(revision, group.add(getCommentCallback(true)));
    } else {
        drafts = JsArray.createArray().cast();
    }
    ConfigInfoCache.get(revision.getParentKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
}
#end_block

#method_before
private void setupNav(Nav nav, FileInfo info) {
    final String url = url(info);
    if (info != null) {
        String fileName = getFileNameOnly(info.path());
        if (nav == Nav.PREV) {
            prevUrl = url;
            prevLink.setHTML(Util.C.prevPatchLinkIcon() + fileName);
        } else {
            nextUrl = url;
            nextLink.setHTML(fileName + Util.C.nextPatchLinkIcon());
        }
    }
    if (keys != null) {
        if (cmds[nav.cmd] != null) {
            keys.remove(cmds[nav.cmd]);
        }
        if (url != null) {
            cmds[nav.cmd] = new KeyCommand(0, nav.key, nav.help) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    Gerrit.display(url);
                }
            };
        } else {
            cmds[nav.cmd] = new UpToChangeCommand2(patchSetId, 0, nav.key);
        }
        keys.add(cmds[nav.cmd]);
    }
}
#method_after
private void setupNav(Anchor anchor, int key, String help, FileInfo info) {
    final String url = url(info);
    if (info != null) {
        String fileName = getFileNameOnly(info.path());
        anchor.setHref("#" + url);
        if (anchor == prevLink) {
            anchor.setHTML(new SafeHtmlBuilder().append(SafeHtml.asis(Util.C.prevPatchLinkIcon())).append(SafeHtml.asis(fileName)).toSafeHtml());
        } else {
            anchor.setHTML(new SafeHtmlBuilder().append(SafeHtml.asis(fileName)).append(SafeHtml.asis(Util.C.nextPatchLinkIcon())).toSafeHtml());
        }
    }
    if (url != null) {
        keys.add(new KeyCommand(0, key, help) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                Gerrit.display(url);
            }
        });
    } else {
        keys.add(new UpToChangeCommand2(patchSetId, 0, key));
    }
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    Gerrit.display(PageLinks.toChange2(revision.getParentKey(), String.valueOf(revision)));
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    Gerrit.display(PageLinks.toChange2(revision.getParentKey(), String.valueOf(revision.get())));
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    handlers.add(UserAgent.addDialogVisibleHandler(new DialogVisibleHandler() {

        @Override
        public void onDialogVisible(DialogVisibleEvent event) {
            diffTable.getElement().getStyle().setVisibility(event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE);
        }
    }));
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
            resizeCodeMirror();
        }
    });
    (cmB != null ? cmB : cmA).focus();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    handlers.add(UserAgent.addDialogVisibleHandler(new DialogVisibleHandler() {

        @Override
        public void onDialogVisible(DialogVisibleEvent event) {
            diffTable.getElement().getStyle().setVisibility(event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE);
        }
    }));
    resizeCodeMirror();
    Window.enableScrolling(false);
    cmA.setOption("viewportMargin", 10);
    cmB.setOption("viewportMargin", 10);
    cmB.focus();
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    cmA.getWrapperElement().removeFromParent();
    cmB.getWrapperElement().removeFromParent();
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm)));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)));
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)));
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    allBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
            resizeBoxPaddings();
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength);
            }
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength);
            }
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
            if (aLength == 0 || bLength == 0) {
                diffTable.sidePanel.addGutter(cmB, origLineB, aLength == 0 ? SidePanel.GutterType.INSERT : SidePanel.GutterType.DELETE);
            } else {
                diffTable.sidePanel.addGutter(cmB, origLineB, SidePanel.GutterType.EDIT);
            }
        }
    }
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, commentLinkProcessor, revision, info);
    if (info.id() == null) {
        box.setOpen(true);
        box.setEdit(true);
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info) {
    CodeMirror cm = getCmFromSide(info.side());
    final DraftBox box = new DraftBox(this, cm, commentLinkProcessor, revision, info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (getDiffChunk(getSideFromCm(other), lineToPad) == null) {
        box.setDiffChunkInfo(getDiffChunk(mySide, line));
    }
    allBoxes.add(box);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    DiffChunkInfo myChunk = getDiffChunk(mySide, line);
    DiffChunkInfo otherChunk = getDiffChunk(getSideFromCm(other), lineToPad);
    PaddingManager otherManager;
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        otherManager = linePaddingManagerMap.get(otherHandle);
    } else {
        otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
    }
    if ((myChunk == null && otherChunk == null) || (myChunk != null && otherChunk != null)) {
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (otherChunk == null) {
        box.setDiffChunkInfo(myChunk);
    }
    box.setGutterWrapper(diffTable.sidePanel.addGutter(cm, info.line() - 1, box instanceof DraftBox ? SidePanel.GutterType.DRAFT : SidePanel.GutterType.COMMENT));
    return box;
}
#end_block

#method_before
void removeDraft(DraftBox box, Side side, int line) {
    LineHandle handle = getCmFromSide(side).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
    allBoxes.remove(box);
}
#method_after
void removeDraft(DraftBox box, Side side, int line) {
    LineHandle handle = getCmFromSide(side).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#end_block

#method_before
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, commentLinkProcessor, revision, info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, commentLinkProcessor, revision, info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, revision, info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, revision, info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                LineHandle activeLine = cm.getActiveLine();
                cm.removeLineClass(activeLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(activeLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                LineHandle otherActiveLine = other.getActiveLine();
                other.removeLineClass(otherActiveLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(otherActiveLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(handle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle));
            int oLine = info.getLine();
            LineHandle oLineHandle = other.getLineHandle(oLine);
            if (info.isAligned()) {
                other.setActiveLine(oLineHandle);
                other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLineHandle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                LineHandle activeLine = cm.getActiveLine();
                cm.removeLineClass(activeLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(activeLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                LineHandle otherActiveLine = other.getActiveLine();
                other.removeLineClass(otherActiveLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(otherActiveLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(handle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle));
            if (info.isAligned()) {
                LineHandle oLineHandle = other.getLineHandle(info.getLine());
                other.setActiveLine(oLineHandle);
                other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLineHandle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, MouseDownEvent clickEvent) {
            instance.setCursor(LineCharacter.create(line));
            instance.setActiveLine(instance.getLineHandle(line));
            insertNewDraft(instance).run();
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, NativeEvent clickEvent) {
            instance.setCursor(LineCharacter.create(line));
            instance.setActiveLine(instance.getLineHandle(line));
            insertNewDraft(instance).run();
        }
    };
}
#end_block

#method_before
void resizePaddingOnOtherSide(Side mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        myChunkHeight -= myPadding.getOffsetHeight();
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPadding.getOffsetHeight();
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            setHeightInPx(myPadding, 0);
            setHeightInPx(otherPadding, delta);
        } else {
            setHeightInPx(myPadding, -delta);
            setHeightInPx(otherPadding, 0);
        }
        myWrapper.getWidget().changed();
    } else {
        setHeightInPx(otherPadding, myChunkHeight);
    }
    otherWrapper.getWidget().changed();
}
#method_after
void resizePaddingOnOtherSide(Side mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    int otherPaddingHeight = otherPadding.getOffsetHeight();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        int myPaddingHeight = myPadding.getOffsetHeight();
        myChunkHeight -= myPaddingHeight;
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPaddingHeight;
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            if (myPaddingHeight != 0) {
                setHeightInPx(myPadding, 0);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != delta) {
                setHeightInPx(otherPadding, delta);
                otherWrapper.getWidget().changed();
            }
        } else {
            if (myPaddingHeight != -delta) {
                setHeightInPx(myPadding, -delta);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != 0) {
                setHeightInPx(otherPadding, 0);
                otherWrapper.getWidget().changed();
            }
        }
    } else if (otherPaddingHeight != myChunkHeight) {
        setHeightInPx(otherPadding, myChunkHeight);
        otherWrapper.getWidget().changed();
    }
}
#end_block

#method_before
void resizeCodeMirror() {
    // TODO: Probably need horizontal resize
    int h = Gerrit.getHeaderFooterHeight() + reviewed.getOffsetHeight() + navLinks.getOffsetHeight() + diffTable.getHeaderHeight() + // Estimate
    5;
    if (cmA != null) {
        cmA.setHeight(Window.getClientHeight() - h);
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.setHeight(Window.getClientHeight() - h);
        cmB.refresh();
    }
}
#method_after
void resizeCodeMirror() {
    if (cmA == null) {
        return;
    }
    int h = Gerrit.getHeaderFooterHeight() + reviewed.getOffsetHeight() + navLinks.getOffsetHeight() + diffTable.getHeaderHeight() + // Estimate
    10;
    cmA.setHeight(Window.getClientHeight() - h);
    cmA.refresh();
    cmB.setHeight(Window.getClientHeight() - h);
    cmB.refresh();
    diffTable.sidePanel.adjustGutters(cmB);
}
#end_block

#method_before
void createOrEditFileComment() {
    if (boxes.isEmpty()) {
        CommentInfo info = CommentInfo.create(path, side, null, null, null);
        addFileComment(host.addDraftBox(info, false));
    } else {
        CommentBox box = boxes.get(boxes.size() - 1);
        if (box.isDraft()) {
            ((DraftBox) box).setEdit(true);
        } else {
            addFileComment(((PublishedBox) box).addReplyBox("", false));
        }
    }
}
#method_after
void createOrEditFileComment() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
        return;
    }
    if (boxes.isEmpty()) {
        CommentInfo info = CommentInfo.createFile(path, side, null, null);
        addFileComment(parent.addDraftBox(info));
    } else {
        CommentBox box = boxes.get(boxes.size() - 1);
        if (box instanceof DraftBox) {
            ((DraftBox) box).setEdit(true);
        } else {
            addFileComment(((PublishedBox) box).addReplyBox());
        }
    }
}
#end_block

#method_before
void addFileComment(CommentBox box) {
    boxes.add(box);
    table.updateVisibility(false);
    ((HTMLPanel) getWidget()).add(box);
    box.registerDiffTable(table);
}
#method_after
void addFileComment(CommentBox box) {
    boxes.add(box);
    body.add(box);
    table.updateFileCommentVisibility(false);
}
#end_block

#method_before
void onRemoveDraftBox(DraftBox box) {
    boxes.remove(box);
    table.updateVisibility(false);
}
#method_after
void onRemoveDraftBox(DraftBox box) {
    boxes.remove(box);
    table.updateFileCommentVisibility(false);
}
#end_block

#method_before
void createOrEditFileComment(Side side) {
    getPanelFromSide(side).createOrEditFileComment();
    patchSelectBoxA.toggleVisible(true);
}
#method_after
void createOrEditFileComment(Side side) {
    getPanelFromSide(side).createOrEditFileComment();
    updateFileCommentVisibility(false);
}
#end_block

#method_before
private void expandText() {
    double cols = editArea.getCharacterWidth();
    int rows = 2;
    for (String line : editArea.getText().split("\n")) {
        rows += Math.ceil((1.0 + line.length()) / cols);
    }
    rows = Math.max(INITIAL_LINES, Math.min(rows, MAX_LINES));
    if (editArea.getVisibleLines() != rows) {
        editArea.setVisibleLines(rows);
    }
    resizePaddingWidget();
}
#method_after
private void expandText() {
    double cols = editArea.getCharacterWidth();
    int rows = 2;
    for (String line : editArea.getValue().split("\n")) {
        rows += Math.ceil((1.0 + line.length()) / cols);
    }
    rows = Math.max(INITIAL_LINES, Math.min(rows, MAX_LINES));
    if (editArea.getVisibleLines() != rows) {
        editArea.setVisibleLines(rows);
    }
    resizePaddingWidget();
}
#end_block

#method_before
void setEdit(boolean edit) {
    if (edit) {
        setOpen(true);
        removeStyleName(draftStyle.view());
        addStyleName(draftStyle.edit());
        editArea.setText(getOriginal().message());
        expandText();
        editArea.setReadOnly(false);
        editArea.setFocus(true);
        disableClickFocusHandler();
    } else {
        expandTimer.cancel();
        editArea.setReadOnly(true);
        removeStyleName(draftStyle.edit());
        addStyleName(draftStyle.view());
        enableClickFocusHandler();
    }
    resizePaddingWidget();
}
#method_after
void setEdit(boolean edit) {
    UIObject.setVisible(summary, false);
    UIObject.setVisible(p_view, !edit);
    UIObject.setVisible(p_edit, edit);
    if (edit) {
        final String msg = comment.message() != null ? comment.message().trim() : "";
        editArea.setValue(msg);
        editArea.setFocus(true);
        cancel.setVisible(!isNew());
        expandText();
        if (msg.length() > 0) {
            Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

                @Override
                public boolean execute() {
                    editArea.setCursorPos(msg.length());
                    return false;
                }
            }, 0);
        }
    } else {
        expandTimer.cancel();
    }
    resizePaddingWidget();
}
#end_block

#method_before
private void removeUI() {
    setEdit(false);
    expandTimer.cancel();
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    removeFromParent();
    getCm().focus();
    if (isFileComment()) {
        getDiffTable().onRemoveDraftBox(this, getSide());
        return;
    }
    CommentInfo info = getOriginal();
    getDiffView().removeDraft(this, getSide(), info.line() - 1);
    getSelfWidget().clear();
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    manager.resizePaddingWidget();
}
#method_after
private void removeUI() {
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    Side side = comment.side();
    removeFromParent();
    if (!getCommentInfo().has_line()) {
        parent.removeFileCommentBox(this, side);
        return;
    }
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    parent.removeDraft(this, side, comment.line() - 1);
    cm.focus();
    getSelfWidgetWrapper().getWidget().clear();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            resizePaddingWidget();
        }
    });
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent e) {
    setEdit(true);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent e) {
    e.stopPropagation();
    setEdit(true);
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    setEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    e.stopPropagation();
    onSave();
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    setEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
private void onSave() {
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo original = comment;
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    enableEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            set(result);
            if (result.message().length() < 70) {
                UIObject.setVisible(p_edit, false);
                setOpen(false);
            } else {
                setEdit(false);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            super.onFailure(e);
        }
    };
    if (original.id() == null) {
        CommentApi.createDraft(psId, input, cb);
    } else {
        CommentApi.updateDraft(psId, original.id(), input, cb);
    }
    cm.focus();
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    setEdit(false);
    getCm().focus();
}
#method_after
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    e.stopPropagation();
    if (isNew() && !isDirty()) {
        removeUI();
    } else {
        setEdit(false);
        cm.focus();
    }
}
#end_block

#method_before
@UiHandler("discard")
void onDiscard(ClickEvent e) {
    if (isNew) {
        removeUI();
    } else {
        setEdit(false);
        CommentApi.deleteDraft(getPatchSetId(), getOriginal().id(), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                removeUI();
            }
        });
    }
}
#method_after
@UiHandler({ "discard1", "discard2" })
void onDiscard(ClickEvent e) {
    e.stopPropagation();
    if (isNew()) {
        removeUI();
    } else {
        setEdit(false);
        CommentApi.deleteDraft(psId, comment.id(), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                removeUI();
            }
        });
    }
}
#end_block

#method_before
DraftBox addReplyBox(String initMessage, boolean doSave) {
    DraftBox box = getDiffView().addReply(getOriginal(), initMessage, doSave);
    registerReplyBox(box);
    return box;
}
#method_after
DraftBox addReplyBox() {
    DraftBox box = parent.addDraftBox(parent.createReply(comment));
    registerReplyBox(box);
    return box;
}
#end_block

#method_before
@UiHandler("reply")
void onReply(ClickEvent e) {
    checkAndAddReply("", false);
}
#method_after
@UiHandler("reply")
void onReply(ClickEvent e) {
    e.stopPropagation();
    doReply();
}
#end_block

#method_before
@UiHandler("replyDone")
void onReplyDone(ClickEvent e) {
    checkAndAddReply(PatchUtil.C.cannedReplyDone(), true);
}
#method_after
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(parent.createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = parent.addDraftBox(result);
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    parent.addFileCommentBox(box, comment.side());
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
        }
    });
    resizeBoxPaddings();
    (cmB != null ? cmB : cmA).focus();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    handlers.add(UserAgent.addDialogVisibleHandler(new DialogVisibleHandler() {

        @Override
        public void onDialogVisible(DialogVisibleEvent event) {
            diffTable.getElement().getStyle().setVisibility(event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE);
        }
    }));
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
            resizeCodeMirror();
        }
    });
    (cmB != null ? cmB : cmA).focus();
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : keyHandlers) {
        h.removeHandler();
    }
    keyHandlers.clear();
}
#method_after
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : handlers) {
        h.removeHandler();
    }
    handlers.clear();
}
#end_block

#method_before
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(cm));
    cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm)));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)));
    cm.addKeyMap(KeyMap.create().on("'k'", moveCursorDown(cm, -1)));
    cm.addKeyMap(KeyMap.create().on("'u'", upToChange()));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    CodeMirror.defineVimEx("up", "u", upToChange());
    CodeMirror.defineVimEx("mark", "m", toggleReviewed());
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
    /**
     * TODO: Work on a better way for customizing keybindings and remove
     * temporary navigation hacks.
     */
    for (String s : new String[] { "C", "J", "K", "O", "R", "U", "Ctrl-C", "Enter" }) {
        CodeMirror.disableUnwantedKey("vim", s);
    }
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm)));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)));
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', PatchUtil.C.upToChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange().run();
        }
    });
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new KeyCommand(0, 'm', PatchUtil.C.toggleReviewed()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            toggleReviewed().run();
        }
    });
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    keyHandlers.add(GlobalKey.add(this, keysNavigation));
    keyHandlers.add(GlobalKey.add(this, keysAction));
    keyHandlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        keyHandlers.add(GlobalKey.add(this, keysComment));
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', PatchUtil.C.upToChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange().run();
        }
    });
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            toggleReviewed().run();
        }
    });
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    handlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        handlers.add(GlobalKey.add(this, keysComment));
    }
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingWidgetMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    lineElementMap = new HashMap<LineHandle, Element>();
    render(diffInfo);
    allBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
            resizeBoxPaddings();
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    allBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
            resizeBoxPaddings();
        }
    });
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("lineWrapping", true).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents).setInfinity("viewportMargin");
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("lineWrapping", true).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents).setInfinity("viewportMargin");
    int h = Gerrit.getHeaderFooterHeight() + 18;
    CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - h);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), mapper.getLineB(), insertCnt, false);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), mapper.getLineA(), deleteCnt, false);
                mapper.appendDelete(deleteCnt);
            }
            insertEmptyLines(cmA, mapper.getLineA(), origLineB, commonCnt, true);
            insertEmptyLines(cmB, mapper.getLineB(), origLineA, commonCnt, true);
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength);
            }
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
private DraftBox addNewDraft(CodeMirror cm, int line) {
    Side side = getSideFromCm(cm);
    CommentInfo info = CommentInfo.create(path, side, line + 1, null, null);
    return addDraftBox(info, false);
}
#method_after
private DraftBox addNewDraft(CodeMirror cm, int line) {
    return addDraftBox(CommentInfo.createLine(path, getSideFromCm(cm), line + 1, null, null));
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info, boolean doSave) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, revision, info, commentLinkProcessor, true, doSave);
    if (!doSave) {
        box.setEdit(true);
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, commentLinkProcessor, revision, info);
    if (info.id() == null) {
        box.setOpen(true);
        box.setEdit(true);
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 28, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 28, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    allBoxes.add(box);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (getDiffChunk(getSideFromCm(other), lineToPad) == null) {
        box.setDiffChunkInfo(getDiffChunk(mySide, line));
    }
    allBoxes.add(box);
    return box;
}
#end_block

#method_before
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, revision, info, commentLinkProcessor);
        box.setOpen(false);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        publishedMap.put(info.id(), box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, commentLinkProcessor, revision, info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), revision, info, commentLinkProcessor, false, false);
        box.setOpen(false);
        box.setEdit(false);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, revision, info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderSkips() {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        return;
    }
    /**
     * TODO: This is not optimal, but shouldn't bee too costly in most cases.
     * Maybe rewrite after done keeping track of diff chunk positions.
     */
    for (CommentBox box : lineActiveBoxMap.values()) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < -context || deltaAfter < -context) {
                // Size guaranteed to be greater than 1
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, before);
                checkAndAddSkip(temp, skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                checkAndAddSkip(temp, skip);
            }
        }
        if (temp.isEmpty()) {
            return;
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        return;
    }
    /**
     * TODO: This is not optimal, but shouldn't bee too costly in most cases.
     * Maybe rewrite after done keeping track of diff chunk positions.
     */
    for (CommentBox box : lineActiveBoxMap.values()) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getCommentInfo();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < -context || deltaAfter < -context) {
                // Size guaranteed to be greater than 1
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, before);
                checkAndAddSkip(temp, skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                checkAndAddSkip(temp, skip);
            }
        }
        if (temp.isEmpty()) {
            return;
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private Runnable doScroll(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            // Hack to prevent feedback loop, Chrome seems fine but Firefox chokes.
            if (cm.isScrollSetByOther()) {
                return;
            }
            other.scrollToY(cm.getScrollInfo().getTop());
            other.setScrollSetByOther(true);
            Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

                @Override
                public boolean execute() {
                    other.setScrollSetByOther(false);
                    return false;
                }
            }, 0);
        }
    };
}
#method_after
private Runnable doScroll(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            // Hack to prevent feedback loop, Chrome seems fine but Firefox chokes.
            if (cm.getScrollSetAt() + 50 > System.currentTimeMillis()) {
                return;
            }
            ScrollInfo si = cm.getScrollInfo();
            if (si.getTop() == 0 && !Gerrit.isHeaderVisible()) {
                Gerrit.setHeaderVisible(true);
                diffTable.updateFileCommentVisibility(false);
                resizeCodeMirror();
            } else if (si.getTop() > 0.5 * si.getClientHeight() && Gerrit.isHeaderVisible()) {
                Gerrit.setHeaderVisible(false);
                diffTable.updateFileCommentVisibility(true);
                resizeCodeMirror();
            }
            /**
             * Since CM doesn't always take the height of line widgets into
             * account when calculating scrollInfo when scrolling too fast
             * (e.g. throw-scrolling), simply setting scrollTop to be the same
             * doesn't guarantee alignment, but should work in most cases. See the
             * hack in fixScroll();
             */
            other.scrollToY(si.getTop());
            other.setScrollSetAt(System.currentTimeMillis());
            (cm == cmA ? scrollTimerA : scrollTimerB).schedule(50);
        }
    };
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            int line = cm.getLineNumber(handle);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                LineHandle activeLine = cm.getActiveLine();
                cm.removeLineClass(activeLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(activeLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                LineHandle otherActiveLine = other.getActiveLine();
                other.removeLineClass(otherActiveLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(otherActiveLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(handle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle));
            int oLine = info.getLine();
            LineHandle oLineHandle = other.getLineHandle(oLine);
            if (info.isAligned()) {
                other.setActiveLine(oLineHandle);
                other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLineHandle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
private Runnable insertNewDraft(final CodeMirror cm) {
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line));
            } else if (box.isDraft()) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).onReply(null);
            }
        }
    };
}
#method_after
private Runnable insertNewDraft(final CodeMirror cm) {
    if (!Gerrit.isSignedIn()) {
        return new Runnable() {

            @Override
            public void run() {
                Gerrit.doSignIn(getToken());
            }
        };
    }
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line));
            } else if (box instanceof DraftBox) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).doReply();
            }
        }
    };
}
#end_block

#method_before
private Runnable toggleReviewed() {
    return new Runnable() {

        public void run() {
            reviewedTop.setReviewed(!reviewedTop.isReviewed());
        }
    };
}
#method_after
private Runnable toggleReviewed() {
    return new Runnable() {

        public void run() {
            reviewed.setReviewed(!reviewed.isReviewed());
        }
    };
}
#end_block

#method_before
private RenderLineHandler resizeEmptyLine(final Side side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, final Element element) {
            if (linePaddingWidgetMap.containsKey(handle)) {
                /**
                 * This needs to be deferred because CM fires "renderLine" **before**
                 * the line is actually added to the DOM.
                 */
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        LinePaddingWidgetWrapper otherWrapper = linePaddingWidgetMap.get(handle);
                        int myLineHeight = element.getOffsetHeight();
                        Element otherPadding = otherWrapper.getElement();
                        if (!otherWrapper.isCommon() && myLineHeight > 0) {
                            setHeightInPx(otherPadding, myLineHeight);
                        } else {
                            /**
                             * We have to pay the cost of keeping track of the actual DOM
                             * elements ourselves, because CM doesn't provide an interface
                             * to query for them, and the only place we can ever have legit
                             * access to the line element is in this event handler.
                             */
                            lineElementMap.put(handle, element);
                            if (myLineHeight == 0) {
                                return;
                            }
                            // The lines are always aligned since they are in a common region.
                            int otherLine = mapper.lineOnOther(side, instance.getLineNumber(handle)).getLine();
                            LineHandle other = otherCm(instance).getLineHandle(otherLine);
                            LinePaddingWidgetWrapper myWrapper = linePaddingWidgetMap.get(other);
                            if (lineElementMap.containsKey(other)) {
                                Element otherElement = lineElementMap.get(other);
                                int otherLineHeight = otherElement.getOffsetHeight();
                                if (otherLineHeight == 0) {
                                    return;
                                }
                                Element myPadding = myWrapper.getElement();
                                int delta = myLineHeight - otherLineHeight;
                                if (delta >= 0) {
                                    setHeightInPx(otherPadding, delta);
                                    setHeightInPx(myPadding, 0);
                                } else {
                                    setHeightInPx(otherPadding, 0);
                                    setHeightInPx(myPadding, -delta);
                                }
                                myWrapper.getWidget().changed();
                                otherWrapper.getWidget().changed();
                            }
                        }
                    }
                });
            }
        }
    };
}
#method_after
private RenderLineHandler resizeEmptyLine(final Side side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, Element element) {
            if (linePaddingOnOtherSideMap.containsKey(handle)) {
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        resizePaddingOnOtherSide(side, instance.getLineNumber(handle));
                    }
                });
            }
        }
    };
}
#end_block

#method_before
void resizePaddingWidget() {
    if (fileComment) {
        cm.refresh();
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        public void execute() {
            if (selfWidget == null || widgetManager == null) {
                throw new IllegalStateException("resizePaddingWidget() called before setting up widgets");
            }
            selfWidget.changed();
            widgetManager.resizePaddingWidget();
        }
    });
}
#method_after
void resizePaddingWidget() {
    if (!getCommentInfo().has_line()) {
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            assert selfWidgetWrapper != null;
            selfWidgetWrapper.getWidget().changed();
            if (diffChunkInfo != null) {
                parent.resizePaddingOnOtherSide(getCommentInfo().side(), diffChunkInfo.getEnd());
            } else {
                assert widgetManager != null;
                widgetManager.resizePaddingWidget();
            }
        }
    });
}
#end_block

#method_before
void setOpen(boolean open) {
    if (open) {
        removeStyleName(res.style().close());
        addStyleName(res.style().open());
    } else {
        removeStyleName(res.style().open());
        addStyleName(res.style().close());
    }
    resizePaddingWidget();
}
#method_after
void setOpen(boolean open) {
    resizePaddingWidget();
}
#end_block

#method_before
private void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
@Override
protected void onUnload() {
    if (availableUpdate != null) {
        availableUpdate.hide(true);
        availableUpdate = null;
    }
    if (poller != null) {
        poller.cancel();
        poller = null;
    }
    for (HandlerRegistration h : keys) {
        h.removeHandler();
    }
    keys.clear();
    super.onUnload();
}
#method_after
@Override
protected void onUnload() {
    if (updateAvailable != null) {
        updateAvailable.hide(true);
        updateAvailable = null;
    }
    if (updateCheck != null) {
        updateCheck.cancel();
        updateCheck = null;
    }
    for (HandlerRegistration h : handlers) {
        h.removeHandler();
    }
    handlers.clear();
    super.onUnload();
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keys.add(GlobalKey.add(this, keysNavigation));
    keys.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#end_block

#method_before
private void loadMergeable(final boolean canSubmit) {
    if (Gerrit.getConfig().testChangeMerge()) {
        ChangeApi.revision(changeId.get(), revision).view("mergeable").get(new AsyncCallback<MergeableInfo>() {

            @Override
            public void onSuccess(MergeableInfo result) {
                if (canSubmit) {
                    actions.setSubmitEnabled(result.mergeable());
                    statusText.setInnerText(result.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
                setVisible(notMergeable, !result.mergeable());
                renderSubmitType(result.submit_type());
            }

            @Override
            public void onFailure(Throwable caught) {
                loadSubmitType(canSubmit);
            }
        });
    } else {
        loadSubmitType(canSubmit);
    }
}
#method_after
private void loadMergeable(final Change.Status status, final boolean canSubmit) {
    if (Gerrit.getConfig().testChangeMerge()) {
        ChangeApi.revision(changeId.get(), revision).view("mergeable").get(new AsyncCallback<MergeableInfo>() {

            @Override
            public void onSuccess(MergeableInfo result) {
                if (canSubmit) {
                    actions.setSubmitEnabled(result.mergeable());
                    if (status == Change.Status.NEW) {
                        statusText.setInnerText(result.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                    }
                }
                setVisible(notMergeable, !result.mergeable());
                renderSubmitType(result.submit_type());
            }

            @Override
            public void onFailure(Throwable caught) {
                loadSubmitType(status, canSubmit);
            }
        });
    } else {
        loadSubmitType(status, canSubmit);
    }
}
#end_block

#method_before
private void loadSubmitType(final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        statusText.setInnerText(Util.C.readyToSubmit());
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(canSubmit);
    }
    reply.setVisible(replyAction != null);
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    reply.setVisible(replyAction != null);
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void showUpdates(ChangeInfo newInfo) {
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (availableUpdate == null) {
        availableUpdate = new UpdatedBar() {

            @Override
            void onShow() {
                // TODO Avoid RPC and use newInfo.
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
        availableUpdate.addCloseHandler(new CloseHandler<PopupPanel>() {

            @Override
            public void onClose(CloseEvent<PopupPanel> event) {
                availableUpdate = null;
            }
        });
    }
    availableUpdate.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!availableUpdate.isShowing()) {
        availableUpdate.popup();
    }
}
#method_after
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
        updateAvailable.addCloseHandler(new CloseHandler<PopupPanel>() {

            @Override
            public void onClose(CloseEvent<PopupPanel> event) {
                updateAvailable = null;
            }
        });
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isShowing()) {
        updateAvailable.popup();
    }
}
#end_block

#method_before
private void startPoller() {
    poller = new Timer() {

        private int delay = REFRESH_POLL_PERIOD;

        @Override
        public void run() {
            if (!isAttached()) {
                // onUnload() should have removed this.
                return;
            } else if (!UserActivityMonitor.isActive()) {
                cancel();
                delay = REFRESH_IDLE_PERIOD;
                scheduleRepeating(delay);
            }
            loadChangeInfo(false, new AsyncCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo info) {
                    if (isAttached() && !info.updated().equals(lastDisplayedUpdate)) {
                        showUpdates(info);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    // but place an upper bound on the delay.
                    if (isAttached()) {
                        cancel();
                        delay = (int) Math.max(delay * (1.5 + Math.random()), REFRESH_MAX_PERIOD);
                        scheduleRepeating(delay);
                    }
                }
            });
        }
    };
    poller.scheduleRepeating(REFRESH_POLL_PERIOD);
}
#method_after
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.getConfig().getChangeUpdateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#end_block

#method_before
public static RootPanel getBottomMenu() {
    return gBottomMenu;
}
#method_after
public static RootPanel getBottomMenu() {
    return bottomMenu;
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            lastViewToken = History.getToken();
            String token = view.getToken();
            if (!token.equals(lastViewToken)) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    saveDefaultTheme();
    loadPlugins(hpd, token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            lastViewToken = History.getToken();
            String token = view.getToken();
            if (!token.equals(lastViewToken)) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(topMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    saveDefaultTheme();
    loadPlugins(hpd, token);
}
#end_block

#method_before
public static boolean isActive() {
    return impl.recent || impl.active;
}
#method_after
public static boolean isActive() {
    return impl.active || impl.recent;
}
#end_block

#method_before
@Override
public void onKeyPress(KeyPressEvent event) {
    active = true;
}
#method_after
@Override
public void onKeyPress(KeyPressEvent event) {
    recent = true;
}
#end_block

#method_before
@Override
public void onValueChange(ValueChangeEvent<String> event) {
    active = true;
}
#method_after
@Override
public void onValueChange(ValueChangeEvent<String> event) {
    recent = true;
}
#end_block

#method_before
@Override
public boolean execute() {
    long now = System.currentTimeMillis();
    if (active) {
        recent = true;
        active = false;
        last = now;
    } else if ((now - last) > TIMEOUT) {
        recent = false;
    }
    return true;
}
#method_after
@Override
public boolean execute() {
    long now = System.currentTimeMillis();
    if (recent) {
        if (!active) {
            ValueChangeEvent.fire(this, active);
        }
        recent = false;
        active = true;
        last = now;
    } else if (active && (now - last) > TIMEOUT) {
        active = false;
        ValueChangeEvent.fire(this, false);
    }
    return true;
}
#end_block

#method_before
private void initChangeActions(ChangeInfo info, boolean hasUser) {
    NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    abandon.setVisible(hasUser && actions.containsKey("abandon"));
    restore.setVisible(hasUser && actions.containsKey("restore"));
    revert.setVisible(hasUser && actions.containsKey("revert"));
    if (hasUser) {
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(changeId, actions.get(id)));
        }
    }
}
#method_after
private void initChangeActions(ChangeInfo info, boolean hasUser) {
    NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    abandon.setVisible(hasUser && actions.containsKey("abandon"));
    restore.setVisible(hasUser && actions.containsKey("restore"));
    revert.setVisible(hasUser && actions.containsKey("revert"));
    if (hasUser) {
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, actions.get(id)));
        }
    }
}
#end_block

#method_before
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    cherrypick.setVisible(hasUser && actions.containsKey("cherrypick"));
    rebase.setVisible(hasUser && actions.containsKey("rebase"));
    canSubmit = hasUser && actions.containsKey("submit");
    if (hasUser) {
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(changeId, revision, actions.get(id)));
        }
    }
}
#method_after
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    cherrypick.setVisible(hasUser && actions.containsKey("cherrypick"));
    rebase.setVisible(hasUser && actions.containsKey("rebase"));
    canSubmit = hasUser && actions.containsKey("submit");
    if (hasUser) {
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#end_block

#method_before
private void loadDiff(final RevisionInfo rev, CallbackGroup group) {
    DiffApi.list(changeId.get(), rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.setRevisions(null, new PatchSet.Id(changeId, rev._number()));
            files.setValue(m);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadDiff(final RevisionInfo rev, CallbackGroup group) {
    DiffApi.list(changeId.get(), rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.setRevisions(null, new PatchSet.Id(changeId, rev._number()));
            files.setValue(m);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void renderReviewers(ChangeInfo info) {
    // TODO Fix approximation of reviewers and CC list(s).
    Map<Integer, AccountInfo> r = new HashMap<Integer, AccountInfo>();
    Map<Integer, AccountInfo> cc = new HashMap<Integer, AccountInfo>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    reviewersText.setInnerSafeHtml(labels.formatUserList(r.values()));
    ccText.setInnerSafeHtml(labels.formatUserList(cc.values()));
}
#method_after
private void renderReviewers(ChangeInfo info) {
    // TODO Fix approximation of reviewers and CC list(s).
    Map<Integer, AccountInfo> r = new HashMap<Integer, AccountInfo>();
    Map<Integer, AccountInfo> cc = new HashMap<Integer, AccountInfo>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    r.remove(info.owner()._account_id());
    cc.remove(info.owner()._account_id());
    reviewersText.setInnerSafeHtml(labels.formatUserList(r.values()));
    ccText.setInnerSafeHtml(labels.formatUserList(cc.values()));
}
#end_block

#method_before
@Override
public void run() {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    PatchList patchList;
    if (// Ignore merges and initial commit.
    commit.getParentCount() == 1 && (patchList = getPatchList(change, ps)) != null) {
        for (PatchListEntry entry : patchList.getPatches()) {
            BlameResult blameResult;
            if ((entry.getChangeType() == ChangeType.MODIFIED || entry.getChangeType() == ChangeType.DELETED) && (blameResult = computeBlame(entry, commit.getParent(0))) != null) {
                List<Edit> edits = entry.getEdits();
                reviewers.putAll(getReviewersForPatch(edits, blameResult));
            }
        }
        Set<Account.Id> topReviewers = findTopReviewers(Collections.unmodifiableSet(reviewers.entrySet()), maxReviewers);
        addReviewers(topReviewers, change);
    }
}
#method_after
@Override
public void run() {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    PatchList patchList;
    try {
        patchList = patchListCache.get(change, ps);
    } catch (PatchListNotAvailableException ex) {
        log.error("Couldn't load patchlist for change {}", change.getKey(), ex);
        return;
    }
    // Ignore merges and initial commit.
    if (commit.getParentCount() != 1) {
        return;
    }
    for (PatchListEntry entry : patchList.getPatches()) {
        BlameResult blameResult;
        if ((entry.getChangeType() == ChangeType.MODIFIED || entry.getChangeType() == ChangeType.DELETED) && (blameResult = computeBlame(entry, commit.getParent(0))) != null) {
            List<Edit> edits = entry.getEdits();
            reviewers.putAll(getReviewersForPatch(edits, blameResult));
        }
    }
    Set<Account.Id> topReviewers = findTopReviewers(reviewers);
    addReviewers(topReviewers, change);
}
#end_block

#method_before
private Set<Account.Id> findTopReviewers(final Set<Entry<Account, Integer>> reviewers, final int max) {
    Set<Account.Id> topReviewers = Sets.newHashSet();
    Queue<Entry<Account, Integer>> pq = new PriorityQueue<Map.Entry<Account, Integer>>(reviewers.size(), new Comparator<Entry<Account, Integer>>() {

        public int compare(Entry<Account, Integer> first, Entry<Account, Integer> second) {
            return second.getValue() - first.getValue();
        }
    });
    pq.addAll(reviewers);
    int curr = 0;
    while (!pq.isEmpty() && curr < max) {
        topReviewers.add(pq.poll().getKey().getId());
        ++curr;
    }
    return topReviewers;
}
#method_after
private Set<Account.Id> findTopReviewers(final Map<Account, Integer> reviewers) {
    Set<Account.Id> topReviewers = Sets.newHashSet();
    List<Entry<Account, Integer>> entries = Ordering.from(new Comparator<Entry<Account, Integer>>() {

        public int compare(Entry<Account, Integer> first, Entry<Account, Integer> second) {
            return first.getValue() - second.getValue();
        }
    }).greatestOf(reviewers.entrySet(), this.maxReviewers);
    for (Entry<Account, Integer> entry : entries) {
        topReviewers.add(entry.getKey().getId());
    }
    return topReviewers;
}
#end_block

#method_before
private Map<Account, Integer> getReviewersForPatch(final List<Edit> edits, final BlameResult blameResult) {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    for (Edit edit : edits) {
        for (int i = edit.getBeginA(); i <= edit.getEndA(); i++) {
            RevCommit commit = blameResult.getSourceCommit(i);
            Set<Account.Id> ids = byEmailCache.get(commit.getAuthorIdent().getEmailAddress());
            for (Account.Id id : ids) {
                Account account = accountCache.get(id).getAccount();
                if (account.isActive() && !change.getOwner().equals(account.getId())) {
                    Integer count = reviewers.get(account);
                    reviewers.put(account, count == null ? 1 : count.intValue() + 1);
                }
            }
        }
    }
    return reviewers;
}
#method_after
private Map<Account, Integer> getReviewersForPatch(final List<Edit> edits, final BlameResult blameResult) {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    for (Edit edit : edits) {
        for (int i = edit.getBeginA(); i < edit.getEndA(); i++) {
            RevCommit commit = blameResult.getSourceCommit(i);
            Set<Account.Id> ids = byEmailCache.get(commit.getAuthorIdent().getEmailAddress());
            for (Account.Id id : ids) {
                Account account = accountCache.get(id).getAccount();
                if (account.isActive() && !change.getOwner().equals(account.getId())) {
                    Integer count = reviewers.get(account);
                    reviewers.put(account, count == null ? 1 : count.intValue() + 1);
                }
            }
        }
    }
    return reviewers;
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(final Event e) {
    Project.NameKey projectName = new Project.NameKey(e.getProjectName());
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    try {
        reviewDb = schemaFactory.open();
        try {
            for (Update u : e.getUpdates()) {
                if (!u.getRefName().startsWith("refs/changes/")) {
                    continue;
                }
                final Change change = reviewDb.changes().get(Change.Id.fromRef(u.getRefName()));
                List<PatchSet> patchSets = reviewDb.patchSets().byChange(change.getId()).toList();
                // only compute for the first patch set
                if (patchSets.size() > 1) {
                    continue;
                }
                final PatchSet ps = patchSets.get(0);
                RevWalk rw = new RevWalk(git);
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
                // FIXME Convert to
                int maxReviewers = 3;
                // project.getMaxReviewersByBlame();
                final Runnable task = reviewersByBlameFactory.create(commit, change, ps, maxReviewers, git);
                workQueue.getDefaultQueue().submit(new Runnable() {

                    public void run() {
                        RequestContext old = tl.setContext(new RequestContext() {

                            @Override
                            public CurrentUser getCurrentUser() {
                                return identifiedUserFactory.create(change.getOwner());
                            }

                            @Override
                            public Provider<ReviewDb> getReviewDbProvider() {
                                return new Provider<ReviewDb>() {

                                    @Override
                                    public ReviewDb get() {
                                        if (db == null) {
                                            try {
                                                db = schemaFactory.open();
                                            } catch (OrmException e) {
                                                throw new ProvisionException("Cannot open ReviewDb", e);
                                            }
                                        }
                                        return db;
                                    }
                                };
                            }
                        });
                        try {
                            task.run();
                        } finally {
                            tl.setContext(old);
                            if (db != null) {
                                db.close();
                                db = null;
                            }
                        }
                    }
                });
            }
        } catch (OrmException x) {
            log.error(x.getMessage(), x);
        } catch (MissingObjectException x) {
            log.error(x.getMessage(), x);
        } catch (IncorrectObjectTypeException x) {
            log.error(x.getMessage(), x);
        } catch (IOException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        git.close();
    }
}
#method_after
@Override
public void onGitReferenceUpdated(final Event e) {
    Project.NameKey projectName = new Project.NameKey(e.getProjectName());
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    final RevWalk rw = new RevWalk(git);
    try {
        reviewDb = schemaFactory.open();
        try {
            for (Update u : e.getUpdates()) {
                if (!u.getRefName().startsWith("refs/changes/")) {
                    continue;
                }
                PatchSet.Id psId = PatchSet.Id.fromRef(u.getRefName());
                PatchSet ps = reviewDb.patchSets().get(psId);
                final Change change = reviewDb.changes().get(psId.getParentKey());
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(u.getNewObjectId()));
                // TODO Move to config
                int maxReviewers = 3;
                final Runnable task = reviewersByBlameFactory.create(commit, change, ps, maxReviewers, git);
                workQueue.getDefaultQueue().submit(new Runnable() {

                    public void run() {
                        RequestContext old = tl.setContext(new RequestContext() {

                            @Override
                            public CurrentUser getCurrentUser() {
                                return identifiedUserFactory.create(change.getOwner());
                            }

                            @Override
                            public Provider<ReviewDb> getReviewDbProvider() {
                                return new Provider<ReviewDb>() {

                                    @Override
                                    public ReviewDb get() {
                                        if (db == null) {
                                            try {
                                                db = schemaFactory.open();
                                            } catch (OrmException e) {
                                                throw new ProvisionException("Cannot open ReviewDb", e);
                                            }
                                        }
                                        return db;
                                    }
                                };
                            }
                        });
                        try {
                            task.run();
                        } finally {
                            tl.setContext(old);
                            if (db != null) {
                                db.close();
                                db = null;
                            }
                        }
                    }
                });
            }
        } catch (OrmException x) {
            log.error(x.getMessage(), x);
        } catch (MissingObjectException x) {
            log.error(x.getMessage(), x);
        } catch (IncorrectObjectTypeException x) {
            log.error(x.getMessage(), x);
        } catch (IOException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        rw.release();
        git.close();
    }
}
#end_block

#method_before
@UiHandler("editArea")
void onEsc(KeyDownEvent e) {
    if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
        if (isNew) {
            removeUI();
        } else {
            onCancel(null);
        }
        e.preventDefault();
    }
}
#method_after
void onEsc(KeyDownEvent e) {
    if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
        if (isNew) {
            removeUI();
        } else {
            onCancel(null);
        }
        e.preventDefault();
    }
}
#end_block

#method_before
private void removeKeyHandlerRegs() {
    if (regNavigation != null) {
        regNavigation.removeHandler();
        regNavigation = null;
    }
    if (regAction != null) {
        regAction.removeHandler();
        regAction = null;
    }
    if (regOpenByEnter != null) {
        regOpenByEnter.removeHandler();
        regOpenByEnter = null;
    }
    if (regComment != null) {
        regComment.removeHandler();
        regComment = null;
    }
}
#method_after
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : keyHandlers) {
        h.removeHandler();
    }
    keyHandlers.clear();
}
#end_block

#method_before
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(otherCM(cm)));
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)));
    cm.addKeyMap(KeyMap.create().on("'k'", moveCursorDown(cm, -1)));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
}
#method_after
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(otherCM(cm)));
    /**
     * TODO: Trying to prevent right click from updating the cursor.
     * Doesn't seem to work for now.
     */
    cm.on("mousedown", ignoreRightClick());
    cm.addKeyMap(KeyMap.create().on("'u'", upToChange()));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
    // TODO: Examine if a better way exists.
    for (String c : new String[] { "A", "C", "D", "I", "O", "P", "R", "S", "U", "X", "Y", "~" }) {
        CodeMirror.disableUnwantedKey("vim", c);
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    regNavigation = GlobalKey.add(this, keysNavigation);
    regAction = GlobalKey.add(this, keysAction);
    regOpenByEnter = GlobalKey.add(this, keysOpenByEnter);
    if (keysComment != null) {
        regComment = GlobalKey.add(this, keysComment);
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new NoOpKeyCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    keyHandlers.add(GlobalKey.add(this, keysNavigation));
    keyHandlers.add(GlobalKey.add(this, keysAction));
    keyHandlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        keyHandlers.add(GlobalKey.add(this, keysComment));
    }
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("styleSelectedText", true).set("showTrailingSpace", true).set("value", contents);
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents);
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffTable.style.diff() : diffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? DiffTable.style.diff() : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, final CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCM(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 21px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, diffTable.style.padding(), line, 21, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, diffTable.style.padding(), lineToPad, 21, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, final CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCM(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 21px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 21, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 21, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    return box;
}
#end_block

#method_before
private void renderSkips() {
    hiddenSkipMap = new HashMap<LineHandle, Integer>();
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < 0 || deltaAfter < 0) {
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                temp.add(before);
                temp.add(skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                temp.add(skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                temp.add(skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < 0 || deltaAfter < 0) {
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                temp.add(before);
                temp.add(skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                temp.add(skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                temp.add(skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() - 1 : skip.getStartB() - 1;
    int markEnd = markStart + size;
    hiddenSkipMap.put(cm.getLineHandle(markEnd), size);
    SkipBar bar = new SkipBar(cm, hiddenSkipMap);
    diffTable.add(bar);
    TextMarker marker = cm.markText(CodeMirror.pos(markStart), CodeMirror.pos(markEnd), Configuration.create().set("collapsed", true));
    /**
     * TODO: Due to CodeMirror limitation, there's no way to make the first
     * line disappear completely. The current approach leaves an empty line
     * with line number "1" still showing, and CodeMirror doesn't like manually
     * setting the display of a line to "none". A workaround may be to use
     * inline widget for the first line and regular line widgets for others.
     */
    boolean isZero = markStart == -1;
    Configuration config = Configuration.create().set("coverGutter", true).set("above", isZero);
    LineWidget widget = cm.addLineWidget(isZero ? markEnd + 1 : markStart, bar.getElement(), config);
    bar.setWidget(widget);
    bar.setMarker(marker, size);
    return bar;
}
#method_after
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() - 1 : skip.getStartB() - 1;
    int markEnd = markStart + size;
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    /**
     * Due to CodeMirror limitation, there's no way to make the first
     * line disappear completely, and CodeMirror doesn't like manually
     * setting the display of a line to "none". The workaround here uses
     * inline widget for the first line and regular line widgets for others.
     */
    Configuration markerConfig;
    if (markStart == -1) {
        markerConfig = Configuration.create().set("inclusiveLeft", true).set("inclusiveRight", true).set("replacedWith", bar.getElement());
        cm.addLineClass(0, LineClassWhere.WRAP, DiffTable.style.hideNumber());
    } else {
        markerConfig = Configuration.create().set("collapsed", true);
        Configuration config = Configuration.create().set("coverGutter", true);
        bar.setWidget(cm.addLineWidget(markStart, bar.getElement(), config));
    }
    bar.setMarker(cm.markText(CodeMirror.pos(markStart), CodeMirror.pos(markEnd), markerConfig), size);
    return bar;
}
#end_block

#method_before
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", diffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.diff());
        }
    }
}
#method_after
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", DiffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", DiffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.diff());
        }
    }
}
#end_block

#method_before
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#method_after
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, DiffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCM(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            int line = getCursorLine(cm);
            LineHandle handle = cm.getLineHandle(line);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, diffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(cm == cmA ? Side.PARENT : Side.REVISION, line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, diffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCM(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            int line = cm.getLineNumber(handle);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(cm == cmA ? Side.PARENT : Side.REVISION, line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
    mapper = null;
    initialBoxes = null;
    publishedMap = null;
    lineBoxMapA = null;
    lineBoxMapB = null;
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    render(diffInfo);
    cmA.on("cursorActivity", updateActiveLine(cmA));
    cmB.on("cursorActivity", updateActiveLine(cmB));
    initialBoxes = new ArrayList<CommentBox>();
    publishedMap = new HashMap<String, PublishedBox>(published.length());
    lineBoxMapA = new HashMap<Integer, CommentBox>();
    lineBoxMapB = new HashMap<Integer, CommentBox>();
    renderPublished();
    renderDrafts();
    published = null;
    drafts = null;
    cmA.addKeyMap(KeyMap.create("'c'", insertNewDraft(cmA)));
    cmB.addKeyMap(KeyMap.create("'c'", insertNewDraft(cmB)));
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    render(diffInfo);
    initialBoxes = new ArrayList<CommentBox>();
    publishedMap = new HashMap<String, PublishedBox>(published.length());
    lineBoxMapA = new HashMap<Integer, CommentBox>();
    lineBoxMapB = new HashMap<Integer, CommentBox>();
    renderPublished();
    renderDrafts();
    published = null;
    drafts = null;
    cmA.on("cursorActivity", updateActiveLine(cmA));
    cmB.on("cursorActivity", updateActiveLine(cmB));
    cmA.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmA)));
    cmB.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmB)));
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#end_block

#method_before
public static KeyMap create(String key, Runnable thunk) {
    KeyMap map = createObject().cast();
    map.setHandler(key, thunk);
    return map;
}
#method_after
public static KeyMap create() {
    return createObject().cast();
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDateText(FormatUtil.shortFormatDayTime(result.updated()));
            setEdit(false);
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            setEdit(false);
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || !(obj instanceof LineOnOtherInfo)) {
        return false;
    }
    LineOnOtherInfo other = (LineOnOtherInfo) obj;
    return (aligned == other.aligned && line == other.line);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj instanceof LineOnOtherInfo) {
        LineOnOtherInfo other = (LineOnOtherInfo) obj;
        return aligned == other.aligned && line == other.line;
    }
    return false;
}
#end_block

#method_before
public final AccountGroup.UUID getGroupUUID() {
    return new AccountGroup.UUID(URL.decodePathSegment(URL.decodeQueryString(id())));
}
#method_after
public final AccountGroup.UUID getGroupUUID() {
    return new AccountGroup.UUID(URL.decodeQueryString(id()));
}
#end_block

#method_before
public final AccountGroup.UUID getOwnerUUID() {
    String owner = owner_id();
    if (owner != null) {
        return new AccountGroup.UUID(URL.decodePathSegment(URL.decodeQueryString(owner)));
    }
    return null;
}
#method_after
public final AccountGroup.UUID getOwnerUUID() {
    String owner = owner_id();
    if (owner != null) {
        return new AccountGroup.UUID(URL.decodeQueryString(owner));
    }
    return null;
}
#end_block

#method_before
public final void setOwnerUUID(AccountGroup.UUID uuid) {
    owner_id(URL.encodePathSegment(URL.encodeQueryString(uuid.get())));
}
#method_after
public final void setOwnerUUID(AccountGroup.UUID uuid) {
    owner_id(URL.encodeQueryString(uuid.get()));
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    GitRepositoryManager mgr = sysInjector.getInstance(GitRepositoryManager.class);
    repo = mgr.openRepository(project);
    try {
        Map<String, Ref> refs = repo.getAllRefs();
        for (Change c : db.changes().byProject(project)) {
            String refName = c.currentPatchSetId().toRefName();
            Ref r = refs.get(refName);
            if (r != null) {
                byId.put(r.getObjectId(), new ChangeData(c));
            } else {
                String error = "Failed to index change " + c.getId() + " (" + refName + " not found)";
                log.warn(error);
                failed.update(1);
                if (verbose) {
                    System.out.println(error);
                }
            }
        }
        walk();
    } finally {
        repo.close();
        // Only used once per Reindex call.
        RepositoryCache.close(repo);
    }
    return null;
}
#method_after
@Override
public Void call() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    GitRepositoryManager mgr = sysInjector.getInstance(GitRepositoryManager.class);
    repo = mgr.openRepository(project);
    try {
        Map<String, Ref> refs = repo.getAllRefs();
        for (Change c : db.changes().byProject(project)) {
            String refName = c.currentPatchSetId().toRefName();
            Ref r = refs.get(refName);
            if (r != null) {
                byId.put(r.getObjectId(), new ChangeData(c));
            } else {
                fail("Failed to index change " + c.getId() + " (" + refName + " not found)", true, null);
            }
        }
        walk();
    } finally {
        repo.close();
        // Only used once per Reindex call.
        RepositoryCache.close(repo);
    }
    return null;
}
#end_block

#method_before
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    try {
                        cd.setCurrentFilePaths(paths);
                        indexer.indexTask(cd).call();
                        done.update(1);
                        if (verbose) {
                            System.out.println("Reindexed change " + cd.getId());
                        }
                    } catch (Exception e) {
                        log.warn("Failed to index change " + cd.getId(), e);
                        if (verbose) {
                            System.out.println("Failed to index change " + cd.getId());
                        }
                        failed.update(1);
                    }
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        log.warn("Failed to index changes for commit " + bCommit.name(), e);
        if (verbose) {
            System.out.println("Failed to index changes for commit " + bCommit.name());
        }
        failed.update(1);
    }
}
#method_after
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    List<ChangeData> cds = byId.get(bCommit);
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                Iterator<ChangeData> cdit = cds.iterator();
                for (ChangeData cd; cdit.hasNext(); cdit.remove()) {
                    cd = cdit.next();
                    try {
                        cd.setCurrentFilePaths(paths);
                        indexer.indexTask(cd).call();
                        done.update(1);
                        if (verbose) {
                            System.out.println("Reindexed change " + cd.getId());
                        }
                    } catch (Exception e) {
                        fail("Failed to index change " + cd.getId(), true, e);
                    }
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        fail("Failed to index commit " + bCommit.name(), false, e);
        for (ChangeData cd : cds) {
            fail("Failed to index change " + cd.getId(), true, null);
        }
    }
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    try {
        return object.commitMessage(repoManager, db).contains(value);
    } catch (IOException e) {
        return false;
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public boolean match(ChangeData object) throws OrmException {
    try {
        for (ChangeData cData : index.getSource(Predicate.and(new LegacyChangeIdPredicate(db, object.getId()), this)).read()) {
            if (cData.getId().equals(object.getId())) {
                return true;
            }
        }
    } catch (QueryParseException e) {
        throw new OrmException(e);
    }
    return false;
}
#end_block

#method_before
@Override
public void start() {
// Do nothing.
}
#method_after
@Override
public void start() {
}
#end_block

#method_before
@Override
public void stop() {
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    List<Future<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    for (Future<?> future : closeFutures) {
        Futures.getUnchecked(future);
    }
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    if (cd.getChange().getStatus().isOpen()) {
        return allOf(closedIndex.delete(id), openIndex.insert(doc));
    } else {
        return allOf(openIndex.delete(id), closedIndex.insert(doc));
    }
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    if (cd.getChange().getStatus().isOpen()) {
        return allOf(closedIndex.delete(id), openIndex.replace(id, doc));
    } else {
        return allOf(openIndex.delete(id), closedIndex.replace(id, doc));
    }
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    return allOf(openIndex.delete(id), closedIndex.delete(id));
}
#end_block

#method_before
private Term idTerm(ChangeData cd) {
    return intTerm(FIELD_CHANGE, cd.getId().get());
}
#method_after
private Term idTerm(ChangeData cd) {
    return intTerm(ID_FIELD, cd.getId().get());
}
#end_block

#method_before
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#method_after
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        if (p.getChild(0) instanceof TimestampRangePredicate) {
            return notTimestampQuery((TimestampRangePredicate<ChangeData>) p.getChild(0));
        }
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#end_block

#method_before
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else if (p.getType() == FieldType.FULL_TEXT) {
        return fullTextQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#method_after
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.TIMESTAMP) {
        return timestampQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else if (p.getType() == FieldType.PREFIX) {
        return prefixQuery(p);
    } else if (p.getType() == FieldType.FULL_TEXT) {
        return fullTextQuery(p);
    } else if (p instanceof SortKeyPredicate) {
        return sortKeyQuery((SortKeyPredicate) p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
private Query intQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    int value;
    try {
        // Can't use IntPredicate because it and IndexPredicate are different
        // subclasses of OperatorPredicate.
        value = Integer.valueOf(p.getValue());
    } catch (IllegalArgumentException e) {
        throw new QueryParseException("not an integer: " + p.getValue());
    }
    return new TermQuery(intTerm(p.getOperator(), value));
}
#method_after
private Query intQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    int value;
    try {
        // Can't use IntPredicate because it and IndexPredicate are different
        // subclasses of OperatorPredicate.
        value = Integer.valueOf(p.getValue());
    } catch (IllegalArgumentException e) {
        throw new QueryParseException("not an integer: " + p.getValue());
    }
    return new TermQuery(intTerm(p.getField().getName(), value));
}
#end_block

#method_before
private Query exactQuery(IndexPredicate<ChangeData> p) {
    return new TermQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query exactQuery(IndexPredicate<ChangeData> p) {
    if (p instanceof RegexPredicate<?>) {
        return regexQuery(p);
    } else {
        return new TermQuery(new Term(p.getField().getName(), p.getValue()));
    }
}
#end_block

#method_before
private Query fullTextQuery(IndexPredicate<ChangeData> p) {
    return new FuzzyQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query fullTextQuery(IndexPredicate<ChangeData> p) {
    return new FuzzyQuery(new Term(p.getField().getName(), p.getValue()));
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = Lists.newArrayListWithExpectedSize(2 * getCardinality());
        for (SubIndex index : indexes) {
            result.addAll(index.search(query, LIMIT));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    Sort sort = new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.INT, true));
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT, sort);
        }
        TopDocs docs = TopDocs.merge(sort, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc, FIELDS);
            Number v = doc.getField(ID_FIELD).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                Object val = f.get(cd, fillArgs);
                if (val != null) {
                    add(result, f, Collections.singleton(val));
                }
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else if (f.getType() == FieldType.FULL_TEXT) {
        for (Object value : values) {
            doc.add(new TextField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    String name = f.getName();
    Store store = store(f);
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (f.getType() == FieldType.LONG) {
        for (Object value : values) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (f.getType() == FieldType.TIMESTAMP) {
        for (Object v : values) {
            doc.add(new IntField(name, toIndexTime((Timestamp) v), store));
        }
    } else if (f.getType() == FieldType.EXACT || f.getType() == FieldType.PREFIX) {
        for (Object value : values) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (f.getType() == FieldType.FULL_TEXT) {
        for (Object value : values) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args.dbProvider, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate(args.dbProvider);
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(args.dbProvider, self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(args.dbProvider, self());
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args.dbProvider, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate(args.dbProvider);
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(args.dbProvider, self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(args.dbProvider, self());
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> branch(String name) {
    if (name.startsWith("^"))
        return new RegexBranchPredicate(args.dbProvider, name);
    return new BranchPredicate(args.dbProvider, name);
}
#method_after
@Operator
public Predicate<ChangeData> branch(String name) {
    if (name.startsWith("^"))
        return ref("^" + branchToRef(name.substring(1)));
    return ref(branchToRef(name));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (!allowsFile) {
        throw error("operator not permitted here: file:" + file);
    }
    if (file.startsWith("^")) {
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (allowFileRegex || args.index != ChangeIndex.DISABLED) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw error("secondary index must be enabled for file:" + file);
        }
    } else {
        if (args.index == ChangeIndex.DISABLED) {
            throw error("secondary index must be enabled for file:" + file);
        }
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    String[] splitReviewer = name.split("~");
    name = splitReviewer[0];
    if (splitReviewer.length > 2) {
        throw new QueryParseException("more than one user specified");
    } else if (splitReviewer.length == 2) {
        accounts = parseAccount(splitReviewer[1]);
    }
    return new LabelPredicate(args.changeControlGenericFactory, args.userFactory, args.dbProvider, args.approvalTypes, name, accounts);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.dbProvider, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id)));
        }
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(args.dbProvider, id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<AccountGroup.UUID>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(args.dbProvider, id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<AccountGroup.UUID>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
public static Timestamp timeFromSortKey(String sortKey) {
    String ts = sortKey.substring(0, 8);
    int i = 0;
    while (i < 8 && ts.charAt(i) == '0') i++;
    long v = Long.parseLong(ts.substring(i), 16) * 60;
    return new Timestamp((v + SORT_KEY_EPOCH) * 1000);
}
#method_after
public static Timestamp timeFromSortKey(String sortKey) {
    if ("z".equals(sortKey)) {
        return new Timestamp(Long.MAX_VALUE);
    }
    String ts = sortKey.substring(0, 8);
    int i = 0;
    while (i < 8 && ts.charAt(i) == '0') i++;
    long v = Long.parseLong(ts.substring(i), 16) * 60;
    return new Timestamp((v + SORT_KEY_EPOCH) * 1000);
}
#end_block

#method_before
@Override
public void start() {
// Do nothing.
}
#method_after
@Override
public void start() {
    refreshThread.start();
}
#end_block

#method_before
@Override
public void stop() {
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    refreshThread.halt();
    List<Future<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    for (Future<?> future : closeFutures) {
        Futures.getUnchecked(future);
    }
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#method_after
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#method_after
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#end_block

#method_before
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#method_after
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        if (p.getChild(0) instanceof TimestampRangePredicate) {
            return notTimestampQuery((TimestampRangePredicate<ChangeData>) p.getChild(0));
        }
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#end_block

#method_before
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p instanceof AgePredicate) {
        int t = ChangeField.toIndexTime(((AgePredicate) p).getCutTimestamp());
        return NumericRangeQuery.newIntRange(p.getField().getName(), 0, t, true, true);
    } else if (p instanceof SortKeyPredicate) {
        int t = ChangeField.toIndexTime(((SortKeyPredicate) p).getCutTimestamp());
        if (p instanceof SortKeyPredicate.Before) {
            return NumericRangeQuery.newIntRange(p.getField().getName(), 0, t, true, true);
        } else {
            return NumericRangeQuery.newIntRange(p.getField().getName(), t, Integer.MAX_VALUE, true, true);
        }
    } else if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#method_after
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.TIMESTAMP) {
        return timestampQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = Lists.newArrayListWithExpectedSize(2 * getCardinality());
        for (SubIndex index : indexes) {
            result.addAll(index.search(query, LIMIT));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT);
        }
        TopDocs docs = TopDocs.merge(null, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc);
            Number v = doc.getField(FIELD_CHANGE).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    String name = f.getName();
    Store store = store(f);
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (f.getType() == FieldType.TIMESTAMP) {
        for (Object v : values) {
            doc.add(new IntField(name, toIndexTime((Timestamp) v), store));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#end_block

#method_before
long getCut() {
    return cut;
}
#method_after
long getCut() {
    return cut + 1;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    Change change = object.change(dbProvider);
    return change != null && change.getLastUpdatedOn().getTime() < cut;
}
#method_after
@Override
public boolean match(final ChangeData object) throws OrmException {
    Change change = object.change(dbProvider);
    return change != null && change.getLastUpdatedOn().getTime() <= cut;
}
#end_block

#method_before
@Override
public void stop() {
    refreshThread.stop = true;
    try {
        refreshThread.join();
    } catch (InterruptedException e) {
        log.warn("error stopping refresh thread", e);
    }
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    refreshThread.halt();
    openIndex.close();
    closedIndex.close();
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = Lists.newArrayListWithExpectedSize(2 * getCardinality());
        for (SubIndex index : indexes) {
            result.addAll(index.search(query, LIMIT));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT);
        }
        TopDocs docs = TopDocs.merge(null, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc);
            Number v = doc.getField(FIELD_CHANGE).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    while (true) {
        if (stop) {
            break;
        }
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            log.warn("error refreshing index searchers", e);
        }
        openIndex.maybeRefresh();
        closedIndex.maybeRefresh();
    }
}
#method_after
@Override
public void run() {
    while (!stop) {
        openIndex.maybeRefresh();
        closedIndex.maybeRefresh();
        synchronized (this) {
            try {
                wait(100);
            } catch (InterruptedException e) {
                log.warn("error refreshing index searchers", e);
            }
        }
    }
}
#end_block

#method_before
protected int getInsertRow(Comparator<RowItem> comparator, RowItem item) {
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        // (left+right)/2
        int middle = (left + right) >>> 1;
        RowItem i = getRowItem(middle);
        int cmp = comparator.compare(i, item);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return -1;
        }
    }
    return left;
}
#method_after
protected int getInsertRow(Comparator<RowItem> comparator, RowItem item) {
    int row = lookupRowItem(comparator, item);
    if (row >= table.getRowCount() || comparator.compare(item, getRowItem(row)) != 0) {
        return row;
    }
    return -1;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new ServletModule() {

                @Override
                protected void configureServlets() {
                    serve("/become").with(BecomeAnyAccountLoginServlet.class);
                }
            });
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    factory(ClearPassword.Factory.class);
    install(new CmdLineParserModule());
    factory(GeneratePassword.Factory.class);
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new BecomeAnyAccountModule());
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig, uiOptions));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    install(new AsyncReceiveCommits.Module());
    install(new CmdLineParserModule());
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#end_block

#method_before
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null);
    saveCookie();
}
#method_after
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null, null);
    saveCookie();
}
#end_block

#method_before
@Override
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, 0, null);
    user = null;
}
#method_after
@Override
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, 0, null, null);
    user = null;
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    try {
        int status = SC_OK;
        checkUserSession(req);
        List<String> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            view = rc.list();
        } else {
            String id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                view = c.list();
                break;
            } else {
                rsrc = c.parse(rsrc, path.remove(0));
                view = view(c, req.getMethod(), path);
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        Multimap<String, String> params = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        Object result;
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            result = m.apply(rsrc, parseRequest(req, m.inputType()));
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, SC_CONFLICT, e.getMessage());
    } catch (ResourceNotFoundException e) {
        replyError(res, SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        handleException(e, req, res);
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            if ("GET".equals(req.getMethod())) {
                view = rc.list();
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                view = ac.post(rsrc);
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req, rsrc);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                if ("GET".equals(req.getMethod())) {
                    view = c.list();
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    view = ac.post(rsrc);
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req, rsrc);
                    view = null;
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        view = ac.create(rsrc, id);
                        status = SC_CREATED;
                    } else {
                        throw e;
                    }
                }
                if (view == null) {
                    view = view(c, req.getMethod(), path);
                }
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, r);
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (PreconditionFailedException e) {
        replyError(res, status = SC_PRECONDITION_FAILED, Objects.firstNonNull(e.getMessage(), "Precondition failed"));
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (UnprocessableEntityException e) {
        replyError(res, status = 422, Objects.firstNonNull(e.getMessage(), "Unprocessable Entity"));
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (MalformedJsonException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new HttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getRequestURI(), auditStartTs, params, req.getMethod(), inputRequestBody, status, result));
    }
}
#end_block

#method_before
private Object parseRequest(HttpServletRequest req, Class<Object> type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (type.getDeclaredFields().length == 0 && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#method_after
private Object parseRequest(HttpServletRequest req, Type type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            json.setLenient(true);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if (("PUT".equals(req.getMethod()) || "POST".equals(req.getMethod())) && acceptsRawInput(type)) {
        return parseRawInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#end_block

#method_before
private Object parseString(String value, Class<Object> type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    Object obj = createInstance(type);
    Field[] fields = type.getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#method_after
private Object parseString(String value, Type type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    if (type == String.class) {
        return value;
    }
    Object obj = createInstance(type);
    Field[] fields = obj.getClass().getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#end_block

#method_before
private static Object createInstance(Class<Object> type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor<Object> c = type.getDeclaredConstructor();
    c.setAccessible(true);
    return c.newInstance();
}
#method_after
private static Object createInstance(Type type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    if (type instanceof Class) {
        @SuppressWarnings("unchecked")
        Class<Object> clazz = (Class<Object>) type;
        Constructor<Object> c = clazz.getDeclaredConstructor();
        c.setAccessible(true);
        return c.newInstance();
    }
    throw new InstantiationException("Cannot make " + type);
}
#end_block

#method_before
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#method_after
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, asBinaryResult(buf).setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#end_block

#method_before
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#method_after
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder();
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#end_block

#method_before
private static void enablePartialGetFields(GsonBuilder gb, Multimap<String, String> config) {
    final Set<String> want = Sets.newHashSet();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, Splitter.on(',').omitEmptyStrings().trimResults().split(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = Maps.newHashMap();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = NAMING.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#method_after
private static void enablePartialGetFields(GsonBuilder gb, Multimap<String, String> config) {
    final Set<String> want = Sets.newHashSet();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, OptionUtil.splitOptionValue(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = Maps.newHashMap();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = // 
                        FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#end_block

#method_before
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                if (buf.length() < len) {
                    res.setContentLength((int) buf.length());
                    res.setHeader("Content-Encoding", "gzip");
                    buf.writeTo(dst, null);
                } else {
                    replyUncompressed(res, dst, bin, len);
                }
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                replyUncompressed(res, dst, bin, len);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#method_after
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    final BinaryResult appResult = bin;
    try {
        if (bin.isBase64()) {
            bin = stackBase64(res, bin);
        }
        if (bin.canGzip() && acceptsGzip(req)) {
            bin = stackGzip(res, bin);
        }
        res.setContentType(bin.getContentType());
        long len = bin.getContentLength();
        if (0 <= len && len < Integer.MAX_VALUE) {
            res.setContentLength((int) len);
        } else if (0 <= len) {
            res.setHeader("Content-Length", Long.toString(len));
        }
        OutputStream dst = res.getOutputStream();
        try {
            bin.writeTo(dst);
        } finally {
            dst.close();
        }
    } finally {
        appResult.close();
    }
}
#end_block

#method_before
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<String> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final String projection = path.isEmpty() ? "/" : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
private static List<String> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<String> out = Lists.newArrayList(Splitter.on('/').split(path));
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#method_after
private static List<IdString> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<IdString> out = Lists.newArrayList();
    for (String p : Splitter.on('/').split(path)) {
        out.add(IdString.fromUrl(p));
    }
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#end_block

#method_before
private static List<String> splitProjection(String projection) {
    return Lists.newArrayList(Splitter.on('~').limit(2).split(projection));
}
#method_after
private static List<String> splitProjection(IdString projection) {
    List<String> p = Lists.newArrayListWithCapacity(2);
    Iterables.addAll(p, Splitter.on('~').limit(2).split(projection.get()));
    return p;
}
#end_block

#method_before
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isStateChange(req)) {
        if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
            throw new AuthException("Invalid authentication method");
        }
    }
    user.setAccessPath(AccessPath.REST_API);
}
#method_after
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isStateChange(req)) {
        if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
            throw new AuthException("Invalid authentication method. In order to authenticate, prefix the REST endpoint URL with /a/ (e.g. http://example.com/a/projects/).");
        }
    }
    user.setAccessPath(AccessPath.REST_API);
}
#end_block

#method_before
static void replyError(HttpServletResponse res, int statusCode, String msg) throws IOException {
    res.setStatus(statusCode);
    replyText(null, res, msg);
}
#method_after
public static void replyError(HttpServletResponse res, int statusCode, String msg) throws IOException {
    res.setStatus(statusCode);
    CacheHeaders.setNotCacheable(res);
    replyText(null, res, msg);
}
#end_block

#method_before
public static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#method_after
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#end_block

#method_before
private static TemporaryBuffer.Heap compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.finish();
    gz.flush();
    return buf;
}
#method_after
private static BinaryResult compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.close();
    return asBinaryResult(buf).setContentType(bin.getContentType());
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        CurrentUser user = session.get().getCurrentUser();
        if (!user.getCapabilities().canAdministrateServer()) {
            error(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            error(req, res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS);
            return;
        }
        if (target == null) {
            error(req, res, SC_FORBIDDEN, "no account matches " + RUN_AS);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        CurrentUser self = session.get().getCurrentUser();
        if (!self.getCapabilities().canRunAs()) {
            RestApiServlet.replyError((HttpServletResponse) res, SC_FORBIDDEN, "not permitted to use " + RUN_AS);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            RestApiServlet.replyError((HttpServletResponse) res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS);
            return;
        }
        if (target == null) {
            RestApiServlet.replyError((HttpServletResponse) res, SC_FORBIDDEN, "no account matches " + RUN_AS);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#end_block

#method_before
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    final String ref = receiveEvent.command.getRefName();
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(ref).matches() || ReceiveCommits.NEW_PATCHSET.matcher(ref).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || ReceiveCommits.NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
public List<CommitValidationMessage> validateForGerritCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForGerritCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || ReceiveCommits.NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, labelTypes, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, labelTypes, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    req.patchSets = db.patchSets().byChange(onto).toList();
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    req.patchSets = db.patchSets().byChange(onto).toList();
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Map<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#end_block

#method_before
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in) {
    return super.rewrite(new IndexRewrite(index).rewrite(in));
}
#method_after
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in) {
    return super.rewrite(indexRewrite.rewrite(in));
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                addRepeatableField(result, f, cd);
            } else {
                addSingleField(result, f, cd);
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    index = new DummyIndex();
    rewrite = new IndexRewrite(index);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    index = new DummyIndex();
    queryBuilder = new ChangeQueryBuilder(new ChangeQueryBuilder.Arguments(null, null, null, null, null, null, null, null, null, null, null, null), null);
    rewrite = new IndexRewriteImpl(index);
}
#end_block

#method_before
public void testIndexPredicate() throws Exception {
    Predicate<ChangeData> in = new FieldPredicate("in");
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#method_after
public void testIndexPredicate() throws Exception {
    Predicate<ChangeData> in = parse("file:a");
    assertEquals(wrap(in), rewrite(in));
}
#end_block

#method_before
public void testIndexPredicates() throws Exception {
    Predicate<ChangeData> f1 = new FieldPredicate("f1");
    Predicate<ChangeData> f2 = new FieldPredicate("f2");
    Predicate<ChangeData> in = Predicate.and(f1, f2);
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#method_after
public void testIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("file:a file:b");
    assertEquals(wrap(in), rewrite(in));
}
#end_block

#method_before
public void testNonIndexPredicates() throws Exception {
    Predicate<ChangeData> o1 = new OpPredicate("o1", "o1");
    Predicate<ChangeData> o2 = new OpPredicate("o2", "o2");
    Predicate<ChangeData> in = Predicate.and(o1, o2);
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(o1, o2), out.getChildren());
}
#method_after
public void testNonIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("branch:a OR branch:b");
    assertSame(in, rewrite(in));
}
#end_block

#method_before
public void testOneIndexPredicate() throws Exception {
    Predicate<ChangeData> o1 = new OpPredicate("o1", "o1");
    Predicate<ChangeData> f2 = new FieldPredicate("f2");
    Predicate<ChangeData> in = Predicate.and(o1, f2);
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(o1, wrap(f2)), out.getChildren());
}
#method_after
public void testOneIndexPredicate() throws Exception {
    Predicate<ChangeData> in = parse("branch:a file:b");
    Predicate<ChangeData> out = rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(in.getChild(0), wrap(in.getChild(1))), out.getChildren());
}
#end_block

#method_before
public void testThreeLevelTreeWithAllIndexPredicates() throws Exception {
    Predicate<ChangeData> f1 = new FieldPredicate("f1");
    Predicate<ChangeData> f21 = new FieldPredicate("f21");
    Predicate<ChangeData> f22 = new FieldPredicate("f22");
    Predicate<ChangeData> n1 = Predicate.not(f1);
    Predicate<ChangeData> o2 = Predicate.or(f21, f22);
    Predicate<ChangeData> in = Predicate.and(n1, o2);
    assertEquals(2, in.getChildCount());
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#method_after
public void testThreeLevelTreeWithAllIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("-status:abandoned (status:open OR status:merged)");
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#end_block

#method_before
public void testThreeLevelTreeWithSomeIndexPredicates() throws Exception {
    Predicate<ChangeData> op1 = new OpPredicate("o1", "o1");
    Predicate<ChangeData> f21 = new FieldPredicate("f21");
    Predicate<ChangeData> f22 = new FieldPredicate("f22");
    Predicate<ChangeData> n1 = Predicate.not(op1);
    Predicate<ChangeData> o2 = Predicate.or(f21, f22);
    Predicate<ChangeData> in = Predicate.and(n1, o2);
    assertEquals(2, in.getChildCount());
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(n1, wrap(o2)), out.getChildren());
}
#method_after
public void testThreeLevelTreeWithSomeIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("-branch:a (file:b OR file:c)");
    Predicate<ChangeData> out = rewrite(in);
    assertEquals(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(in.getChild(0), wrap(in.getChild(1))), out.getChildren());
}
#end_block

#method_before
public void testMultipleIndexPredicates() throws Exception {
    Predicate<ChangeData> f1 = new FieldPredicate("f1");
    Predicate<ChangeData> o2 = new OpPredicate("o2", "o2");
    Predicate<ChangeData> f3 = new FieldPredicate("f3");
    Predicate<ChangeData> o4 = new OpPredicate("o4", "o4");
    Predicate<ChangeData> in = Predicate.and(f1, o2, f3, o4);
    assertEquals(4, in.getChildCount());
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(o2, o4, wrap(Predicate.and(f1, f3))), out.getChildren());
}
#method_after
public void testMultipleIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("file:a OR branch:b OR file:c OR branch:d");
    Predicate<ChangeData> out = rewrite(in);
    assertSame(OrPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(in.getChild(1), in.getChild(3), wrap(Predicate.or(in.getChild(0), in.getChild(2)))), out.getChildren());
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (!file.startsWith("^")) {
            // TODO(dborowitz): Wrap predicates in query rewriter, not here.
            return new PredicateWrapper(args.index, new EqualsFilePredicate(args.dbProvider, args.patchListCache, file));
        } else {
            throw error("regular expression not permitted here: file:" + file);
        }
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (!file.startsWith("^") && args.index != ChangeIndex.DISABLED) {
            // TODO(dborowitz): Wrap predicates in query rewriter, not here.
            return new PredicateWrapper(args.index, new EqualsFilePredicate(args.dbProvider, args.patchListCache, file));
        } else {
            throw error("regular expression not permitted here: file:" + file);
        }
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    sysInjector = createSysInjector();
    manager.add(dbInjector);
    manager.add(sysInjector);
    manager.start();
    SchemaFactory<ReviewDb> schema = dbInjector.getInstance(Key.get(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }));
    ReviewDb db = schema.open();
    Provider<ReviewDb> dbProvider = Providers.of(db);
    PatchListCache plc = sysInjector.getInstance(PatchListCache.class);
    LuceneChangeIndex index = sysInjector.getInstance(LuceneChangeIndex.class);
    index.getWriter().deleteAll();
    int i = 0;
    for (Change change : db.changes().all()) {
        ChangeData cd = new ChangeData(change);
        cd.fillIndexFields(dbProvider, plc);
        index.insert(cd);
        i++;
    }
    index.getWriter().commit();
    System.out.println("Reindexed " + i + " changes");
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!LuceneIndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    sitePaths = dbInjector.getInstance(SitePaths.class);
    deleteAll();
    sysInjector = createSysInjector();
    manager.add(dbInjector);
    manager.add(sysInjector);
    manager.start();
    SchemaFactory<ReviewDb> schema = dbInjector.getInstance(Key.get(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }));
    ReviewDb db = schema.open();
    dbRef.set(db);
    LuceneChangeIndex index = sysInjector.getInstance(LuceneChangeIndex.class);
    Stopwatch sw = new Stopwatch().start();
    int i = 0;
    for (Change change : db.changes().all()) {
        index.insert(new ChangeData(change));
        i++;
    }
    index.getWriter().commit();
    double elapsed = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Reindexed %d changes in %.02fms", i, elapsed);
    manager.stop();
    return 0;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    modules.add(LuceneChangeIndex.module());
    modules.add(new LifecycleModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    modules.add(new LuceneIndexModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            bind(ReviewDb.class).toProvider(new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    return dbRef.get();
                }
            });
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new com.google.gerrit.server.index.Module());
    modules.add(LuceneChangeIndex.module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (LuceneIndexModule.isEnabled(cfgInjector)) {
        modules.add(new LuceneIndexModule());
    } else {
        modules.add(new NoIndexModule());
    }
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(IndexPredicate<ChangeData> p) throws QueryParseException {
    switch(p.getType()) {
        case INTEGER:
            return intQuery(p);
        case EXACT_REPEATABLE:
            return exactQuery(p);
        default:
            throw badFieldType(p.getType());
    }
}
#method_after
@Override
public ChangeDataSource getSource(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    cd.checkIndexFields();
    org.apache.lucene.document.Document result = new Document();
    for (ChangeField f : ChangeField.values()) {
        switch(f.getType()) {
            case INTEGER:
                result.add(new IntField(f.getName(), (Integer) f.get(cd), store(f)));
                break;
            case EXACT_REPEATABLE:
                // Type checked in ChangeField.
                @SuppressWarnings("unchecked")
                Iterable<String> values = (Iterable<String>) f.get(cd);
                for (String value : values) {
                    result.add(new StringField(f.getName(), value, store(f)));
                }
                break;
        }
    }
    return result;
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private Field.Store store(ChangeField f) {
    return f.isStored() ? Field.Store.YES : Field.Store.NO;
}
#method_after
private static Field.Store store(FieldDef<?, ?> f) {
    return f.isStored() ? Field.Store.YES : Field.Store.NO;
}
#end_block

#method_before
private static IllegalArgumentException badFieldType(FieldType t) {
    return new IllegalArgumentException("unknown index field type " + t);
}
#method_after
private static IllegalArgumentException badFieldType(FieldType<?> t) {
    return new IllegalArgumentException("unknown index field type " + t);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new com.google.gerrit.server.index.Module());
    modules.add(LuceneChangeIndex.module());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (LuceneIndexModule.isEnabled(cfgInjector)) {
        modules.add(new LuceneIndexModule());
    } else {
        modules.add(new NoIndexModule());
    }
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
public FieldType getType() {
    return type;
}
#method_after
public FieldType<?> getType() {
    return def.getType();
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        workQueue.getDefaultQueue().submit(indexerFactory.create(change));
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        indexer.index(change);
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(changeIndexerFactory.create(change)));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ins.setReviewers(recipients.getReviewers()).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    ProjectApi.createBranch(getProjectKey(), branchName, rev, new GerritCallback<BranchInfo>() {

        @Override
        public void onSuccess(BranchInfo result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            Util.PROJECT_SVC.listBranches(getProjectKey(), new GerritCallback<ListBranchesResult>() {

                @Override
                public void onSuccess(ListBranchesResult result) {
                    display(result.getBranches());
                }
            });
        }

        @Override
        public void onFailure(Throwable caught) {
            addBranch.setEnabled(true);
            selectAllAndFocus(nameTxtBox);
            new ErrorDialog(caught.getMessage()).center();
        }
    });
}
#method_after
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText().trim();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText().trim();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    ProjectApi.createBranch(getProjectKey(), branchName, rev, new GerritCallback<BranchInfo>() {

        @Override
        public void onSuccess(BranchInfo result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            Util.PROJECT_SVC.listBranches(getProjectKey(), new GerritCallback<ListBranchesResult>() {

                @Override
                public void onSuccess(ListBranchesResult result) {
                    display(result.getBranches());
                }
            });
        }

        @Override
        public void onFailure(Throwable caught) {
            addBranch.setEnabled(true);
            selectAllAndFocus(nameTxtBox);
            new ErrorDialog(caught.getMessage()).center();
        }
    });
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseStartingRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
}
#end_block

#method_before
@Override
public List<BranchInfo> apply(ProjectResource rsrc) throws ResourceNotFoundException, IOException {
    List<BranchInfo> branches = Lists.newArrayList();
    BranchInfo headBranch = null;
    BranchInfo configBranch = null;
    final Set<String> targets = new HashSet<String>();
    final Repository db;
    try {
        db = repoManager.openRepository(rsrc.getNameKey());
    } catch (RepositoryNotFoundException noGitRepository) {
        throw new ResourceNotFoundException();
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = rsrc.getControl().controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                BranchInfo b = new BranchInfo();
                b.ref = ref.getName();
                b.revision = target;
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            final RefControl refControl = rsrc.getControl().controlForRef(ref.getName());
            if (refControl.isVisible()) {
                if (ref.getName().startsWith(Constants.R_HEADS)) {
                    branches.add(createBranchInfo(ref, refControl, targets));
                } else if (GitRepositoryManager.REF_CONFIG.equals(ref.getName())) {
                    configBranch = createBranchInfo(ref, refControl, targets);
                }
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<BranchInfo>() {

        @Override
        public int compare(final BranchInfo a, final BranchInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    if (configBranch != null) {
        branches.add(0, configBranch);
    }
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return branches;
}
#method_after
@Override
public List<BranchInfo> apply(ProjectResource rsrc) throws ResourceNotFoundException, IOException {
    List<BranchInfo> branches = Lists.newArrayList();
    BranchInfo headBranch = null;
    BranchInfo configBranch = null;
    final Set<String> targets = Sets.newHashSet();
    final Repository db;
    try {
        db = repoManager.openRepository(rsrc.getNameKey());
    } catch (RepositoryNotFoundException noGitRepository) {
        throw new ResourceNotFoundException();
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = rsrc.getControl().controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                BranchInfo b = new BranchInfo();
                b.ref = ref.getName();
                b.revision = target;
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            final RefControl refControl = rsrc.getControl().controlForRef(ref.getName());
            if (refControl.isVisible()) {
                if (ref.getName().startsWith(Constants.R_HEADS)) {
                    branches.add(createBranchInfo(ref, refControl, targets));
                } else if (GitRepositoryManager.REF_CONFIG.equals(ref.getName())) {
                    configBranch = createBranchInfo(ref, refControl, targets);
                }
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<BranchInfo>() {

        @Override
        public int compare(final BranchInfo a, final BranchInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    if (configBranch != null) {
        branches.add(0, configBranch);
    }
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return branches;
}
#end_block

#method_before
private BranchInfo createBranchInfo(Ref ref, RefControl refControl, Set<String> targets) {
    BranchInfo b = new BranchInfo();
    b.ref = ref.getName();
    if (ref.getObjectId() != null) {
        b.revision = ref.getObjectId().name();
    }
    b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
    return b;
}
#method_after
private static BranchInfo createBranchInfo(Ref ref, RefControl refControl, Set<String> targets) {
    BranchInfo b = new BranchInfo();
    b.ref = ref.getName();
    if (ref.getObjectId() != null) {
        b.revision = ref.getObjectId().name();
    }
    b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
    return b;
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException, IOException {
    ProjectControl pctl = projectControlFactory.validateFor(projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    try {
        List<Branch> branches = Lists.newArrayList();
        List<BranchInfo> branchInfos = listBranchesProvider.get().apply(new ProjectResource(pctl));
        for (BranchInfo info : branchInfos) {
            Branch b = new Branch(new Branch.NameKey(projectName, info.ref));
            b.setRevision(new RevId(info.revision));
            b.setCanDelete(info.canDelete != null ? true : false);
            branches.add(b);
        }
        return new ListBranchesResult(branches, pctl.canAddRefs(), false);
    } catch (ResourceNotFoundException e) {
        throw new NoSuchProjectException(projectName);
    }
}
#method_after
@Override
public ListBranchesResult call() throws NoSuchProjectException, IOException {
    ProjectControl pctl = projectControlFactory.validateFor(projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    try {
        List<Branch> branches = Lists.newArrayList();
        List<BranchInfo> branchInfos = listBranchesProvider.get().apply(new ProjectResource(pctl));
        for (BranchInfo info : branchInfos) {
            Branch b = new Branch(new Branch.NameKey(projectName, info.ref));
            b.setRevision(new RevId(info.revision));
            b.setCanDelete(Objects.firstNonNull(info.canDelete, false));
            branches.add(b);
        }
        return new ListBranchesResult(branches, pctl.canAddRefs(), false);
    } catch (ResourceNotFoundException e) {
        throw new NoSuchProjectException(projectName);
    }
}
#end_block

#method_before
/**
 * Get specificity of mime types with generic types forced to low values
 *
 * "application/octet-stream" is forced to -1.
 * "text/plain" is forced to 0.
 * All other mime types return the specificity reported by mimeType itself.
 *
 * @param mimeType The mimeType to get the corrected specificity for.
 * @return The corrected specificity.
 */
private int getCorrectedMimeSpecificity(MimeType mimeType) {
    final int ret;
    final String mimeTypeStr = mimeType.toString();
    if (mimeTypeStr.equals("application/octet-stream")) {
        ret = -1;
    } else if (mimeTypeStr.equals("text/plain")) {
        ret = 0;
    } else {
        ret = mimeType.getSpecificity();
    }
    return ret;
}
#method_after
private int getCorrectedMimeSpecificity(MimeType mimeType) {
    // Although the documentation of MimeType's getSpecificity claims that for
    // example "application/octet-stream" always has a specificity of 0, it
    // effectively returns 1 for us. This causes problems when trying to get
    // the correct mime type via sorting. For example in
    // [application/octet-stream, image/x-icon] both mime types come with
    // specificity 1 for us. Hence, getMimeType below may end up using
    // application/octet-stream instead of the more specific image/x-icon.
    // Therefore, we have to force the specificity of generic types below the
    // default of 1.
    // 
    final String mimeTypeStr = mimeType.toString();
    if (mimeTypeStr.equals("application/octet-stream")) {
        return -1;
    }
    if (mimeTypeStr.equals("text/plain")) {
        return 0;
    }
    return mimeType.getSpecificity();
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, footerLines, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(change, ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, footerLines, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void submit(Change change, PatchSet ps) throws OrmException {
    if (!projectControl.controlForRef(MagicBranch.NEW_CHANGE + change.getDest().get()).canSubmit()) {
        addError("Submitting of change " + change.getChangeId() + " not allowed.");
    } else {
        Change c = SubmitChange.submit(db, change, ps, currentUser);
        if (c == null) {
            addError("Submitting change " + change.getChangeId() + " failed.");
        } else {
            addMessage("");
            mergeQueue.merge(c.getDest());
            c = db.changes().get(c.getId());
            switch(c.getStatus()) {
                case SUBMITTED:
                    addMessage("Change " + c.getChangeId() + " submitted.");
                    break;
                case MERGED:
                    addMessage("Change " + c.getChangeId() + " merged.");
                    break;
                case NEW:
                    // If the merge was attempted and it failed the system usually
                    // writes a comment as a ChangeMessage and sets status to NEW.
                    // Find the relevant message and report that as the conflict.
                    final Timestamp before = change.getLastUpdatedOn();
                    ChangeMessage msg = Iterables.getFirst(Iterables.filter(Lists.reverse(db.changeMessages().byChange(c.getId()).toList()), new Predicate<ChangeMessage>() {

                        @Override
                        public boolean apply(ChangeMessage input) {
                            return input.getAuthor() == null && input.getWrittenOn().getTime() >= before.getTime();
                        }
                    }), null);
                    if (msg != null) {
                        addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                        break;
                    }
                default:
                    addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
            }
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(new ChangeResource(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final MailRecipients oldRecipients = getRecipientsFromApprovals(ApprovalsUtil.copyLabels(db, labelTypes, priorPatchSet, newPatchSet.getId()));
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(change, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final MailRecipients oldRecipients = getRecipientsFromApprovals(ApprovalsUtil.copyLabels(db, labelTypes, priorPatchSet, newPatchSet.getId()));
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
protected SparseHtmlFile getSparseHtmlFileB(PatchScript s) {
    AccountDiffPreference dp = new AccountDiffPreference(s.getDiffPrefs());
    PrettyFormatter f = ClientSideFormatter.FACTORY.get();
    f.setDiffPrefs(dp);
    f.setFileName(s.getB().getPath());
    f.setEditFilter(PrettyFormatter.B);
    f.setEditList(s.getEdits());
    if ((dp.isSyntaxHighlighting() || dp.getContext() != AccountDiffPreference.WHOLE_FILE_CONTEXT) && s.getA().isWholeFile() && !s.getB().isWholeFile()) {
        f.format(s.getB().apply(s.getA(), s.getEdits()));
    } else {
        f.format(s.getB());
    }
    return f;
}
#method_after
protected SparseHtmlFile getSparseHtmlFileB(PatchScript s) {
    AccountDiffPreference dp = new AccountDiffPreference(s.getDiffPrefs());
    SparseFileContent b = s.getB();
    PrettyFormatter f = ClientSideFormatter.FACTORY.get();
    f.setDiffPrefs(dp);
    f.setFileName(b.getPath());
    f.setEditFilter(PrettyFormatter.B);
    f.setEditList(s.getEdits());
    if (s.getA().isWholeFile() && !b.isWholeFile()) {
        b = b.apply(s.getA(), s.getEdits());
    }
    f.format(b);
    return f;
}
#end_block

#method_before
private PatchScript build(final PatchListEntry content, final CommentDetail comments, final List<Patch> history) throws IOException {
    boolean intralineDifferenceIsPossible = true;
    boolean intralineFailure = false;
    a.path = oldName(content);
    b.path = newName(content);
    a.resolve(null, aId);
    b.resolve(a, bId);
    edits = new ArrayList<Edit>(content.getEdits());
    if (!isModify(content)) {
        intralineDifferenceIsPossible = false;
    } else if (diffPrefs.isIntralineDifference()) {
        IntraLineDiff d = patchListCache.getIntraLineDiff(new IntraLineDiffKey(a.id, a.src, b.id, b.src, edits, projectKey, bId, b.path, diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE));
        if (d != null) {
            switch(d.getStatus()) {
                case EDIT_LIST:
                    edits = new ArrayList<Edit>(d.getEdits());
                    break;
                case DISABLED:
                    intralineDifferenceIsPossible = false;
                    break;
                case ERROR:
                case TIMEOUT:
                    intralineDifferenceIsPossible = false;
                    intralineFailure = true;
                    break;
            }
        } else {
            intralineDifferenceIsPossible = false;
            intralineFailure = true;
        }
    }
    ensureCommentsVisible(comments);
    boolean hugeFile = false;
    if (a.mode == FileMode.GITLINK || b.mode == FileMode.GITLINK) {
    } else if (a.src == b.src && a.size() <= context && content.getEdits().isEmpty()) {
        // 
        for (int i = 0; i < a.size(); i++) {
            a.addLine(i);
        }
        edits = new ArrayList<Edit>(1);
        edits.add(new Edit(a.size(), a.size()));
    } else {
        if (BIG_FILE < Math.max(a.size(), b.size())) {
            // IF the file is really large, we disable things to avoid choking
            // the browser client.
            // 
            diffPrefs.setContext((short) Math.min(25, context));
            diffPrefs.setSyntaxHighlighting(false);
            context = diffPrefs.getContext();
            hugeFile = true;
        } else if (diffPrefs.isSyntaxHighlighting() || diffPrefs.getContext() != AccountDiffPreference.WHOLE_FILE_CONTEXT) {
            // In order to expand the skipped common lines or syntax highlight the
            // file properly we need to give the client the complete file contents.
            // So force our context temporarily to the complete file size.
            // 
            context = MAX_CONTEXT;
        }
        packContent(diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE);
    }
    return new PatchScript(change.getKey(), content.getChangeType(), content.getOldName(), content.getNewName(), a.fileMode, b.fileMode, content.getHeaderLines(), diffPrefs, a.dst, b.dst, edits, a.displayMethod, b.displayMethod, comments, history, hugeFile, intralineDifferenceIsPossible, intralineFailure);
}
#method_after
private PatchScript build(final PatchListEntry content, final CommentDetail comments, final List<Patch> history) throws IOException {
    boolean intralineDifferenceIsPossible = true;
    boolean intralineFailure = false;
    a.path = oldName(content);
    b.path = newName(content);
    a.resolve(null, aId);
    b.resolve(a, bId);
    edits = new ArrayList<Edit>(content.getEdits());
    if (!isModify(content)) {
        intralineDifferenceIsPossible = false;
    } else if (diffPrefs.isIntralineDifference()) {
        IntraLineDiff d = patchListCache.getIntraLineDiff(new IntraLineDiffKey(a.id, a.src, b.id, b.src, edits, projectKey, bId, b.path, diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE));
        if (d != null) {
            switch(d.getStatus()) {
                case EDIT_LIST:
                    edits = new ArrayList<Edit>(d.getEdits());
                    break;
                case DISABLED:
                    intralineDifferenceIsPossible = false;
                    break;
                case ERROR:
                case TIMEOUT:
                    intralineDifferenceIsPossible = false;
                    intralineFailure = true;
                    break;
            }
        } else {
            intralineDifferenceIsPossible = false;
            intralineFailure = true;
        }
    }
    ensureCommentsVisible(comments);
    boolean hugeFile = false;
    if (a.mode == FileMode.GITLINK || b.mode == FileMode.GITLINK) {
    } else if (a.src == b.src && a.size() <= context && content.getEdits().isEmpty()) {
        // 
        for (int i = 0; i < a.size(); i++) {
            a.addLine(i);
        }
        edits = new ArrayList<Edit>(1);
        edits.add(new Edit(a.size(), a.size()));
    } else {
        if (BIG_FILE < Math.max(a.size(), b.size())) {
            // IF the file is really large, we disable things to avoid choking
            // the browser client.
            // 
            diffPrefs.setContext((short) Math.min(25, context));
            diffPrefs.setSyntaxHighlighting(false);
            context = diffPrefs.getContext();
            hugeFile = true;
        } else {
            // In order to expand the skipped common lines or syntax highlight the
            // file properly we need to give the client the complete file contents.
            // So force our context temporarily to the complete file size.
            // 
            context = MAX_CONTEXT;
        }
        packContent(diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE);
    }
    return new PatchScript(change.getKey(), content.getChangeType(), content.getOldName(), content.getNewName(), a.fileMode, b.fileMode, content.getHeaderLines(), diffPrefs, a.dst, b.dst, edits, a.displayMethod, b.displayMethod, comments, history, hugeFile, intralineDifferenceIsPossible, intralineFailure);
}
#end_block

#method_before
public boolean canStreamEvents() {
    return canPerform(GlobalCapability.STREAM_EVENTS);
}
#method_after
public boolean canStreamEvents() {
    return canPerform(GlobalCapability.STREAM_EVENTS) || canAdministrateServer();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    showUsernameInReviewCategory = new CheckBox(Util.C.showUsernameInReviewCategory());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    defaultCommentVisibilityStrategy = new ListBox();
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    final Grid formGrid = new Grid(9, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showUsernameInReviewCategory);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, Util.C.defaultCommentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, defaultCommentVisibilityStrategy);
    row++;
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(showUsernameInReviewCategory);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(defaultCommentVisibilityStrategy);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    showUsernameInReviewCategory = new CheckBox(Util.C.showUsernameInReviewCategory());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    commentVisibilityStrategy = new ListBox();
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    final Grid formGrid = new Grid(9, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showUsernameInReviewCategory);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, Util.C.commentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, commentVisibilityStrategy);
    row++;
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(showUsernameInReviewCategory);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(commentVisibilityStrategy);
}
#end_block

#method_before
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    showUsernameInReviewCategory.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    defaultCommentVisibilityStrategy.setEnabled(on);
}
#method_after
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    showUsernameInReviewCategory.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    commentVisibilityStrategy.setEnabled(on);
}
#end_block

#method_before
private void display(final AccountGeneralPreferences p) {
    showSiteHeader.setValue(p.isShowSiteHeader());
    useFlashClipboard.setValue(p.isUseFlashClipboard());
    copySelfOnEmails.setValue(p.isCopySelfOnEmails());
    reversePatchSetOrder.setValue(p.isReversePatchSetOrder());
    showUsernameInReviewCategory.setValue(p.isShowUsernameInReviewCategory());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.getMaximumPageSize());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.getDateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.getTimeFormat());
    relativeDateInChangeTable.setValue(p.isRelativeDateInChangeTable());
    setListBox(defaultCommentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT, p.getDefaultCommentVisibilityStrategy());
}
#method_after
private void display(final AccountGeneralPreferences p) {
    showSiteHeader.setValue(p.isShowSiteHeader());
    useFlashClipboard.setValue(p.isUseFlashClipboard());
    copySelfOnEmails.setValue(p.isCopySelfOnEmails());
    reversePatchSetOrder.setValue(p.isReversePatchSetOrder());
    showUsernameInReviewCategory.setValue(p.isShowUsernameInReviewCategory());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.getMaximumPageSize());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.getDateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.getTimeFormat());
    relativeDateInChangeTable.setValue(p.isRelativeDateInChangeTable());
    setListBox(commentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT, p.getCommentVisibilityStrategy());
}
#end_block

#method_before
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setShowUsernameInReviewCategory(showUsernameInReviewCategory.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setDefaultCommentVisibilityStrategy(getListBox(defaultCommentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_MOST_RECENT, CommentVisibilityStrategy.values()));
    enable(false);
    save.setEnabled(false);
    Util.ACCOUNT_SVC.changePreferences(p, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(final VoidResult result) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            enable(true);
        }

        @Override
        public void onFailure(final Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setShowUsernameInReviewCategory(showUsernameInReviewCategory.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setCommentVisibilityStrategy(getListBox(commentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_MOST_RECENT, CommentVisibilityStrategy.values()));
    enable(false);
    save.setEnabled(false);
    Util.ACCOUNT_SVC.changePreferences(p, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(final VoidResult result) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            enable(true);
        }

        @Override
        public void onFailure(final Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void addComments(final ChangeDetail detail) {
    comments.clear();
    final AccountInfoCache accts = detail.getAccounts();
    final List<ChangeMessage> msgList = detail.getMessages();
    HorizontalPanel title = new HorizontalPanel();
    title.setWidth("100%");
    title.add(new Label(Util.C.changeScreenComments()));
    if (msgList.size() > 1) {
        title.add(messagesMenuBar());
    }
    title.setStyleName(Gerrit.RESOURCES.css().blockHeader());
    comments.add(title);
    final long AGE = 7 * 24 * 60 * 60 * 1000L;
    final Timestamp aged = new Timestamp(System.currentTimeMillis() - AGE);
    final CommentVisibilityStrategy commentVisibilityStrategy = Gerrit.getUserAccount().getGeneralPreferences().getDefaultCommentVisibilityStrategy();
    for (int i = 0; i < msgList.size(); i++) {
        final ChangeMessage msg = msgList.get(i);
        AccountInfo author;
        if (msg.getAuthor() != null) {
            author = FormatUtil.asInfo(accts.get(msg.getAuthor()));
        } else {
            author = AccountInfo.create(0, Util.C.messageNoAuthor(), null);
        }
        boolean isRecent;
        if (i == msgList.size() - 1) {
            isRecent = true;
        } else {
            // TODO Instead of opening messages by strict age, do it by "unread"?
            isRecent = msg.getWrittenOn().after(aged);
        }
        final CommentPanel cp = new CommentPanel(author, msg.getWrittenOn(), msg.getMessage());
        cp.setRecent(isRecent);
        cp.addStyleName(Gerrit.RESOURCES.css().commentPanelBorder());
        if (i == msgList.size() - 1) {
            cp.addStyleName(Gerrit.RESOURCES.css().commentPanelLast());
        }
        boolean isOpen = false;
        switch(commentVisibilityStrategy) {
            case COLLAPSE_ALL:
                break;
            case EXPAND_RECENT:
                isOpen = isRecent;
                break;
            case EXPAND_ALL:
                isOpen = true;
                break;
            case EXPAND_MOST_RECENT:
            default:
                isOpen = i == msgList.size() - 1;
                break;
        }
        cp.setOpen(isOpen);
        comments.add(cp);
    }
    final Button b = new Button(Util.C.changeScreenAddComment());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            PatchSet.Id currentPatchSetId = patchSetsBlock.getCurrentPatchSet().getId();
            Gerrit.display(Dispatcher.toPublish(currentPatchSetId));
        }
    });
    comments.add(b);
    comments.setVisible(msgList.size() > 0);
}
#method_after
private void addComments(final ChangeDetail detail) {
    comments.clear();
    final AccountInfoCache accts = detail.getAccounts();
    final List<ChangeMessage> msgList = detail.getMessages();
    HorizontalPanel title = new HorizontalPanel();
    title.setWidth("100%");
    title.add(new Label(Util.C.changeScreenComments()));
    if (msgList.size() > 1) {
        title.add(messagesMenuBar());
    }
    title.setStyleName(Gerrit.RESOURCES.css().blockHeader());
    comments.add(title);
    final long AGE = 7 * 24 * 60 * 60 * 1000L;
    final Timestamp aged = new Timestamp(System.currentTimeMillis() - AGE);
    CommentVisibilityStrategy commentVisibilityStrategy = CommentVisibilityStrategy.EXPAND_MOST_RECENT;
    if (Gerrit.isSignedIn()) {
        commentVisibilityStrategy = Gerrit.getUserAccount().getGeneralPreferences().getCommentVisibilityStrategy();
    }
    for (int i = 0; i < msgList.size(); i++) {
        final ChangeMessage msg = msgList.get(i);
        AccountInfo author;
        if (msg.getAuthor() != null) {
            author = FormatUtil.asInfo(accts.get(msg.getAuthor()));
        } else {
            author = AccountInfo.create(0, Util.C.messageNoAuthor(), null);
        }
        boolean isRecent;
        if (i == msgList.size() - 1) {
            isRecent = true;
        } else {
            // TODO Instead of opening messages by strict age, do it by "unread"?
            isRecent = msg.getWrittenOn().after(aged);
        }
        final CommentPanel cp = new CommentPanel(author, msg.getWrittenOn(), msg.getMessage());
        cp.setRecent(isRecent);
        cp.addStyleName(Gerrit.RESOURCES.css().commentPanelBorder());
        if (i == msgList.size() - 1) {
            cp.addStyleName(Gerrit.RESOURCES.css().commentPanelLast());
        }
        boolean isOpen = false;
        switch(commentVisibilityStrategy) {
            case COLLAPSE_ALL:
                break;
            case EXPAND_RECENT:
                isOpen = isRecent;
                break;
            case EXPAND_ALL:
                isOpen = true;
                break;
            case EXPAND_MOST_RECENT:
            default:
                isOpen = i == msgList.size() - 1;
                break;
        }
        cp.setOpen(isOpen);
        comments.add(cp);
    }
    final Button b = new Button(Util.C.changeScreenAddComment());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            PatchSet.Id currentPatchSetId = patchSetsBlock.getCurrentPatchSet().getId();
            Gerrit.display(Dispatcher.toPublish(currentPatchSetId));
        }
    });
    comments.add(b);
    comments.setVisible(msgList.size() > 0);
}
#end_block

#method_before
@Override
public Object apply(CommentResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    AccountInfo.Loader accountLoader = accountLoaderFactory.create(true);
    CommentInfo ci = new CommentInfo(rsrc.getComment(), accountLoader);
    accountLoader.fill();
    return ci;
}
#method_after
@Override
public Object apply(CommentResource rsrc) throws OrmException {
    AccountInfo.Loader accountLoader = accountLoaderFactory.create(true);
    CommentInfo ci = new CommentInfo(rsrc.getComment(), accountLoader);
    accountLoader.fill();
    return ci;
}
#end_block

#method_before
@Override
public Object apply(RevisionResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    Map<String, List<CommentInfo>> out = Maps.newTreeMap();
    AccountInfo.Loader accountLoader = useAccountLoader() ? accountLoaderFactory.create(true) : null;
    for (PatchLineComment c : listComments(rsrc)) {
        CommentInfo o = new CommentInfo(c, accountLoader);
        List<CommentInfo> list = out.get(o.path);
        if (list == null) {
            list = Lists.newArrayList();
            out.put(o.path, list);
        }
        o.path = null;
        list.add(o);
    }
    for (List<CommentInfo> list : out.values()) {
        Collections.sort(list, new Comparator<CommentInfo>() {

            @Override
            public int compare(CommentInfo a, CommentInfo b) {
                int c = firstNonNull(a.side, Side.REVISION).ordinal() - firstNonNull(b.side, Side.REVISION).ordinal();
                if (c == 0) {
                    c = firstNonNull(a.line, 0) - firstNonNull(b.line, 0);
                }
                if (c == 0) {
                    c = a.id.compareTo(b.id);
                }
                return c;
            }
        });
    }
    if (accountLoader != null) {
        accountLoader.fill();
    }
    return out;
}
#method_after
@Override
public Object apply(RevisionResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    Map<String, List<CommentInfo>> out = Maps.newTreeMap();
    AccountInfo.Loader accountLoader = includeAuthorInfo() ? accountLoaderFactory.create(true) : null;
    for (PatchLineComment c : listComments(rsrc)) {
        CommentInfo o = new CommentInfo(c, accountLoader);
        List<CommentInfo> list = out.get(o.path);
        if (list == null) {
            list = Lists.newArrayList();
            out.put(o.path, list);
        }
        o.path = null;
        list.add(o);
    }
    for (List<CommentInfo> list : out.values()) {
        Collections.sort(list, new Comparator<CommentInfo>() {

            @Override
            public int compare(CommentInfo a, CommentInfo b) {
                int c = firstNonNull(a.side, Side.REVISION).ordinal() - firstNonNull(b.side, Side.REVISION).ordinal();
                if (c == 0) {
                    c = firstNonNull(a.line, 0) - firstNonNull(b.line, 0);
                }
                if (c == 0) {
                    c = a.id.compareTo(b.id);
                }
                return c;
            }
        });
    }
    if (accountLoader != null) {
        accountLoader.fill();
    }
    return out;
}
#end_block

#method_before
public GarbageCollectionResult run(final List<Project.NameKey> projectNames, final GarbageCollectionProgressMonitor pm) {
    final GarbageCollectionResult result = new GarbageCollectionResult();
    if (!currentUser.getCapabilities().canRunGC()) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_PERMITTED, currentUser.getUserName()));
        return result;
    }
    for (final Project.NameKey projectName : projectNames) {
        pm.startGarbageCollection(projectName);
        try {
            final Repository repo = repoManager.openRepository(projectName);
            try {
                if (!(repo instanceof FileRepository)) {
                    result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_SUPPORTED, projectName));
                    continue;
                }
                GC.gc(pm, (FileRepository) repo);
            } catch (IOException e) {
                log.error("garbage collection for project \"" + projectName + "\" failed", e);
                result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, projectName));
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException e) {
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, projectName));
        } finally {
            pm.endGarbageCollection();
        }
    }
    return result;
}
#method_after
public GarbageCollectionResult run(final List<Project.NameKey> projectNames, final PrintWriter writer) {
    final GarbageCollectionResult result = new GarbageCollectionResult();
    if (!currentUser.getCapabilities().canRunGC()) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_PERMITTED, currentUser.getUserName()));
        return result;
    }
    for (final Project.NameKey projectName : projectNames) {
        writer.print("collecting garbage for \"" + projectName + "\":\n");
        try {
            final Repository repo = repoManager.openRepository(projectName);
            try {
                if (!(repo instanceof FileRepository)) {
                    result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_SUPPORTED, projectName));
                    continue;
                }
                GC.gc(new TextProgressMonitor(writer), (FileRepository) repo);
            } catch (IOException e) {
                log.error("garbage collection for project \"" + projectName + "\" failed", e);
                result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, projectName));
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException e) {
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, projectName));
        } finally {
            writer.print("done.\n\n");
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                verifyCommandLine();
                collectGarbage();
            } finally {
                stdout.flush();
            }
        }
    });
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                verifyCommandLine();
                runGC();
            } finally {
                stdout.flush();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    get(PROJECT_KIND, "head").to(GetHead.class);
    put(PROJECT_KIND, "head").to(SetHead.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", input.ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.disableRefLog();
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                case NEW:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException {
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        String headRef = repo.getRef(Constants.HEAD).getTarget().getName();
        if (!rsrc.getControl().controlForRef(headRef).isVisible()) {
            throw new AuthException();
        }
        return headRef;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException {
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        Ref head = repo.getRef(Constants.HEAD);
        if (head == null) {
            throw new ResourceNotFoundException(Constants.HEAD);
        } else if (head.isSymbolic()) {
            String n = head.getTarget().getName();
            if (rsrc.getControl().controlForRef(n).isVisible()) {
                return n;
            }
            throw new AuthException();
        } else if (head.getObjectId() != null) {
            if (rsrc.getControl().isOwner()) {
                return head.getObjectId().name();
            }
            throw new AuthException();
        }
        throw new ResourceNotFoundException(Constants.HEAD);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#end_block

#method_before
public Set<Account.Id> findAll(String nameOrEmail) throws OrmException {
    Matcher m = Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail);
    if (m.matches()) {
        return findById(m.group(1));
    }
    if (nameOrEmail.matches("^[1-9][0-9]*$")) {
        return findById(nameOrEmail);
    }
    if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) {
        AccountState who = byId.getByUsername(nameOrEmail);
        if (who != null) {
            return Collections.singleton(who.getAccount().getId());
        }
    }
    return findAllByNameOrEmail(nameOrEmail);
}
#method_after
public Set<Account.Id> findAll(String nameOrEmail) throws OrmException {
    Matcher m = Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail);
    if (m.matches()) {
        Account.Id id = Account.Id.parse(m.group(1));
        if (exists(id)) {
            return Collections.singleton(id);
        } else {
            return Collections.emptySet();
        }
    }
    if (nameOrEmail.matches("^[1-9][0-9]*$")) {
        Account.Id id = Account.Id.parse(nameOrEmail);
        if (exists(id)) {
            return Collections.singleton(id);
        } else {
            return Collections.emptySet();
        }
    }
    if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) {
        AccountState who = byId.getByUsername(nameOrEmail);
        if (who != null) {
            return Collections.singleton(who.getAccount().getId());
        }
    }
    return findAllByNameOrEmail(nameOrEmail);
}
#end_block

#method_before
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#method_after
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getProject().getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#end_block

#method_before
List<SectionMatcher> getAllSections() {
    if (isAllProjects) {
        return getLocalAccessSections();
    }
    List<SectionMatcher> all = new ArrayList<SectionMatcher>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    ProjectState allProjects = projectCache.getAllProjects();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        all.addAll(s.getLocalAccessSections());
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    if (seen.add(allProjects.getProject().getNameKey())) {
        all.addAll(allProjects.getLocalAccessSections());
    }
    return all;
}
#method_after
List<SectionMatcher> getAllSections() {
    if (isAllProjects) {
        return getLocalAccessSections();
    }
    List<SectionMatcher> all = Lists.newArrayList();
    for (ProjectState s : tree()) {
        all.addAll(s.getLocalAccessSections());
    }
    return all;
}
#end_block

#method_before
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isAllProjects) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#method_after
public Set<AccountGroup.UUID> getOwners() {
    for (ProjectState p : tree()) {
        if (!p.localOwners.isEmpty()) {
            return p.localOwners;
        }
    }
    return Collections.emptySet();
}
#end_block

#method_before
boolean isOwner(GroupMembership groups) {
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        if (groups.containsAnyOf(s.localOwners)) {
            return true;
        }
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    return false;
}
#method_after
boolean isOwner(final GroupMembership groups) {
    return Iterables.any(tree(), new Predicate<ProjectState>() {

        @Override
        public boolean apply(ProjectState in) {
            return groups.containsAnyOf(in.localOwners);
        }
    });
}
#end_block

#method_before
private boolean getInheritableBoolean(Function<Project, InheritableBoolean> func) {
    Set<Project.NameKey> seen = Sets.newHashSet();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        switch(func.apply(s.getProject())) {
            case TRUE:
                return true;
            case FALSE:
                return false;
            case INHERIT:
            default:
                Project.NameKey parent = s.getProject().getParent(allProjectsName);
                if (parent != null && seen.add(parent)) {
                    s = projectCache.get(parent);
                } else {
                    s = null;
                }
        }
    } while (s != null);
    return false;
}
#method_after
private boolean getInheritableBoolean(Function<Project, InheritableBoolean> func) {
    for (ProjectState s : tree()) {
        switch(func.apply(s.getProject())) {
            case TRUE:
                return true;
            case FALSE:
                return false;
            case INHERIT:
            default:
                continue;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public PostResult apply(ChangeResource rsrc, Input input) throws ResourceNotFoundException, AuthException, OrmException, EmailException {
    if (input.reviewer == null) {
        throw new ResourceNotFoundException();
    }
    Account.Id accountId = parser.parse(rsrc, input.reviewer);
    try {
        if (accountId != null) {
            return putAccount(reviewerFactory.create(rsrc, accountId));
        } else {
            return putGroup(rsrc, input);
        }
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchGroupException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#method_after
@Override
public PostResult apply(ChangeResource rsrc, Input input) throws BadRequestException, ResourceNotFoundException, AuthException, OrmException, EmailException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    Account.Id accountId = parser.parse(rsrc, input.reviewer);
    try {
        if (accountId != null) {
            return putAccount(reviewerFactory.create(rsrc, accountId));
        } else {
            return putGroup(rsrc, input);
        }
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchGroupException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
        out.removable_reviewers = removableReviewers(cd);
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION) || cd.getLimitedPatchSets() != null) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
        out.removable_reviewers = removableReviewers(cd, out.labels.values());
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION) || cd.getLimitedPatchSets() != null) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> initLabels(ChangeData cd, boolean standard) throws OrmException {
    // For the following TreeMap, we'd rather use
    // [...] = Maps.newTreeMap(LabelOrdering.create(approvalTypes));
    // but this fails on OpenJDK 6. See:
    // http://bugs.openjdk.java.net/show_bug.cgi?id=100167#c1
    // To still be able to compile on OpenJDK 6, we instantiate the following
    // TreeMap directly.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> initLabels(ChangeData cd, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsForClosedChange(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    // For the following TreeMap, we'd rather use
    // [...] = Maps.newTreeMap(LabelOrdering.create(approvalTypes));
    // but this fails on OpenJDK 6. See:
    // http://bugs.openjdk.java.net/show_bug.cgi?id=100167#c1
    // To still be able to compile on OpenJDK 6, we instantiate the following
    // TreeMap directly.
    // 
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval psa : cd.currentApprovals(db)) {
        ApprovalType type = approvalTypes.byId(psa.getCategoryId());
        if (type == null) {
            continue;
        }
        String label = type.getCategory().getLabelName();
        LabelInfo li = labels.get(label);
        if (li == null) {
            li = new LabelInfo();
            labels.put(label, li);
            if (detailed) {
                setLabelValues(type, li);
            }
        }
        short val = psa.getValue();
        if (detailed) {
            li.addApproval(approvalInfo(psa.getAccountId(), val));
        }
        if (!standard || li.approved != null || li.rejected != null) {
            continue;
        }
        if (val == type.getMax().getValue()) {
            li.approved = accountInfo(psa);
        } else if (val == type.getMin().getValue() && // A merged change can't have been rejected.
        cd.getChange().getStatus() != Status.MERGED) {
            li.rejected = accountInfo(psa);
        } else if (val > 0) {
            li.recommended = accountInfo(psa);
            li.value = val;
        } else if (val < 0) {
            li.disliked = accountInfo(psa);
            li.value = val;
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsForClosedChange(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    // 
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval psa : cd.currentApprovals(db)) {
        ApprovalType type = approvalTypes.byId(psa.getCategoryId());
        if (type == null) {
            continue;
        }
        String label = type.getCategory().getLabelName();
        LabelInfo li = labels.get(label);
        if (li == null) {
            li = new LabelInfo();
            labels.put(label, li);
            if (detailed) {
                setLabelValues(type, li);
            }
        }
        short val = psa.getValue();
        if (detailed) {
            li.addApproval(approvalInfo(psa.getAccountId(), val));
        }
        if (!standard || li.approved != null || li.rejected != null) {
            continue;
        }
        if (val == type.getMax().getValue()) {
            li.approved = accountInfo(psa);
        } else if (val == type.getMin().getValue() && // A merged change can't have been rejected.
        cd.getChange().getStatus() != Status.MERGED) {
            li.rejected = accountInfo(psa);
        } else if (val > 0) {
            li.recommended = accountInfo(psa);
            li.value = val;
        } else if (val < 0) {
            li.disliked = accountInfo(psa);
            li.value = val;
        }
    }
    return labels;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return ImmutableList.of();
    }
    Change change = ctl.getChange();
    if (!change.getStatus().isOpen() || !(ctl.getCurrentUser() instanceof IdentifiedUser)) {
        return ImmutableList.of();
    }
    Set<Account.Id> fixed = Sets.newHashSet();
    Set<Account.Id> removable = Sets.newHashSet();
    for (PatchSetApproval app : cd.currentApprovals(db)) {
        if (ctl.canRemoveReviewer(app)) {
            removable.add(app.getAccountId());
        } else {
            fixed.add(app.getAccountId());
        }
    }
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeData cd, Collection<LabelInfo> labels) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return ImmutableList.of();
    }
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            if (ctl.canRemoveReviewer(ai._id, ai.value)) {
                removable.add(ai._id);
            } else {
                fixed.add(ai._id);
            }
        }
    }
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#end_block

#method_before
public ReviewerInfo format(ReviewerInfo out, ChangeControl ctl, List<PatchSetApproval> approvals) throws OrmException {
    PatchSet.Id psId = ctl.getChange().currentPatchSetId();
    if (approvals == null) {
        approvals = ChangeData.sortApprovals(db.get().patchSetApprovals().byPatchSetUser(psId, out._id));
    }
    FunctionState fs = functionState.create(ctl, psId, approvals);
    for (ApprovalType at : approvalTypes.getApprovalTypes()) {
        CategoryFunction.forCategory(at.getCategory()).run(at, fs);
    }
    // For the following TreeMap, we'd rather use
    // [...] = Maps.newTreeMap(LabelOrdering.create(approvalTypes));
    // but this fails on OpenJDK 6. See:
    // http://bugs.openjdk.java.net/show_bug.cgi?id=100167#c1
    // To still be able to compile on OpenJDK 6, we instantiate the following
    // TreeMap directly.
    out.approvals = new TreeMap<String, String>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : ctl.getLabelRanges()) {
            if (!pr.isEmpty()) {
                // TODO: Support arbitrary labels.
                ApprovalType at = approvalTypes.byId(ca.getCategoryId());
                if (at != null) {
                    out.approvals.put(at.getCategory().getLabelName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    ChangeData cd = new ChangeData(ctl);
    PatchSet ps = cd.currentPatchSet(db);
    if (ps != null) {
        for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                if (!out.approvals.containsKey(name) && !ctl.getRange(Permission.forLabel(name)).isEmpty()) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#method_after
public ReviewerInfo format(ReviewerInfo out, ChangeControl ctl, List<PatchSetApproval> approvals) throws OrmException {
    PatchSet.Id psId = ctl.getChange().currentPatchSetId();
    if (approvals == null) {
        approvals = ChangeData.sortApprovals(db.get().patchSetApprovals().byPatchSetUser(psId, out._id));
    }
    FunctionState fs = functionState.create(ctl, psId, approvals);
    for (ApprovalType at : approvalTypes.getApprovalTypes()) {
        CategoryFunction.forCategory(at.getCategory()).run(at, fs);
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    out.approvals = new TreeMap<String, String>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : ctl.getLabelRanges()) {
            if (!pr.isEmpty()) {
                // TODO: Support arbitrary labels.
                ApprovalType at = approvalTypes.byId(ca.getCategoryId());
                if (at != null) {
                    out.approvals.put(at.getCategory().getLabelName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    ChangeData cd = new ChangeData(ctl);
    PatchSet ps = cd.currentPatchSet(db);
    if (ps != null) {
        for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                if (!out.approvals.containsKey(name) && !ctl.getRange(Permission.forLabel(name)).isEmpty()) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#end_block

#method_before
Map<String, Provider<Command>> getMap() {
    return commands;
}
#method_after
Map<String, CommandProvider> getMap() {
    return commands;
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final Provider<Command> p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final CommandProvider p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.getProvider().get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#end_block

#method_before
@Override
protected String usage() {
    final StringBuilder usage = new StringBuilder();
    usage.append("Available commands");
    if (!getName().isEmpty()) {
        usage.append(" of ");
        usage.append(getName());
    }
    usage.append(" are:\n");
    usage.append("\n");
    int maxLength = -1;
    for (String name : commands.keySet()) {
        maxLength = Math.max(maxLength, name.length());
    }
    String format = "%-" + maxLength + "s   %s";
    for (String name : Sets.newTreeSet(commands.keySet())) {
        final Command cmd = commands.get(name).get();
        usage.append("   ");
        if (cmd instanceof BaseCommand) {
            BaseCommand bc = (BaseCommand) cmd;
            String descr = bc.getDescription();
            if (name.equals("plugin")) {
                descr = "Install, reload, remove and list plugins";
            }
            usage.append(String.format(format, name, descr));
        } else {
            usage.append(name);
        }
        usage.append("\n");
    }
    usage.append("\n");
    usage.append("See '");
    if (getName().indexOf(' ') < 0) {
        usage.append(getName());
        usage.append(' ');
    }
    usage.append("COMMAND --help' for more information.\n");
    usage.append("\n");
    return usage.toString();
}
#method_after
@Override
protected String usage() {
    final StringBuilder usage = new StringBuilder();
    usage.append("Available commands");
    if (!getName().isEmpty()) {
        usage.append(" of ");
        usage.append(getName());
    }
    usage.append(" are:\n");
    usage.append("\n");
    int maxLength = -1;
    for (String name : commands.keySet()) {
        maxLength = Math.max(maxLength, name.length());
    }
    String format = "%-" + maxLength + "s   %s";
    for (String name : Sets.newTreeSet(commands.keySet())) {
        final CommandProvider p = commands.get(name);
        usage.append("   ");
        usage.append(String.format(format, name, Strings.nullToEmpty(p.getDescription())));
        usage.append("\n");
    }
    usage.append("\n");
    usage.append("See '");
    if (getName().indexOf(' ') < 0) {
        usage.append(getName());
        usage.append(' ');
    }
    usage.append("COMMAND --help' for more information.\n");
    usage.append("\n");
    return usage.toString();
}
#end_block

#method_before
public final Set<String> values() {
    return Natives.keys(values0());
}
#method_after
public final Set<String> values() {
    return Natives.keys(_values());
}
#end_block

#method_before
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    if (!accounts.isEmpty()) {
        for (Account account : db.get().accounts().get(accounts.keySet())) {
            AccountAttribute a = accounts.get(account.getId());
            a.name = Strings.emptyToNull(account.getFullName());
        }
    }
    return res;
}
#method_after
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    if (options.contains(LABELS) || options.contains(DETAILED_LABELS)) {
        out.labels = labelsFor(cd, options.contains(DETAILED_LABELS));
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean detailed) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                if (detailed) {
                    ApprovalType at = approvalTypes.byLabel(r.label);
                    if (at != null) {
                        PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
                        n.category = at.getCategory().getName();
                        n.id = at.getCategory().getId().get();
                        n.values = Maps.newLinkedHashMap();
                        for (ApprovalCategoryValue acv : at.getValues()) {
                            if (range.contains(acv.getValue())) {
                                n.values.put(acv.formatValue(), acv.getName());
                            }
                        }
                        if (n.values.size() == 1 && " 0".equals(Iterables.getOnlyElement(n.values.keySet()))) {
                            n.values = ImmutableMap.of();
                        }
                    }
                }
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    initLabels(cd, labels, standard);
    Collection<PatchSetApproval> approvals = null;
    if (detailed) {
        approvals = cd.currentApprovals(db);
        setAllApprovals(labels, approvals);
    }
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null) {
            // TODO: Support arbitrary labels.
            continue;
        }
        if (standard) {
            approvals = setRecommendedAndDisliked(cd, approvals, type, e.getValue());
        }
        if (detailed) {
            setLabelValues(type, e.getValue());
        }
    }
    return labels;
}
#end_block

#method_before
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountInfoCache = new AccountInfo.Cache(db, !options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountInfoCache.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountInfoCache.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = options.contains(LABELS) ? labelsFor(cd) : null;
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = options.contains(LABELS) ? labelsFor(cd) : null;
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = accountInfoCache.get(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = accountInfoCache.get(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = accountLoader.get(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = accountLoader.get(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = accountLoader.get(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = accountLoader.get(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    com.google.gwtjsonrpc.common.AsyncCallback<PatchSetPublishDetail> load = new ScreenLoadCallback<PatchSetPublishDetail>(this) {

        @Override
        protected void preDisplay(final PatchSetPublishDetail result) {
            send.setEnabled(true);
            display(result);
        }

        @Override
        protected void postDisplay() {
            message.setFocus(true);
        }
    };
    CallbackGroup cbs = new CallbackGroup();
    Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.add(load));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.addGwtjsonrpc(new ScreenLoadCallback<PatchSetPublishDetail>(this) {

        @Override
        protected void preDisplay(final PatchSetPublishDetail result) {
            send.setEnabled(true);
            display(result);
        }

        @Override
        protected void postDisplay() {
            message.setFocus(true);
        }
    }));
}
#end_block

#method_before
private void onSuccess() {
    if (results.size() < callbacks.size()) {
        return;
    }
    Throwable caught = null;
    for (Object o : callbacks) {
        try {
            Object result = results.get(o);
            if (o instanceof AsyncCallback) {
                @SuppressWarnings("unchecked")
                AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
                cb.onSuccess(result);
            } else {
                @SuppressWarnings("unchecked")
                com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
                cb.onSuccess(result);
            }
        } catch (Throwable t) {
            if (caught != null) {
                caught = t;
            }
        }
    }
    if (caught != null) {
        if (caught instanceof RuntimeException) {
            throw (RuntimeException) caught;
        } else if (caught instanceof Error) {
            throw (Error) caught;
        } else {
            throw new RuntimeException(caught);
        }
    }
}
#method_after
private void onSuccess() {
    if (results.size() < callbacks.size()) {
        return;
    }
    for (Object o : callbacks) {
        Object result = results.get(o);
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onSuccess(result);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onSuccess(result);
        }
    }
}
#end_block

#method_before
private void onFailure(Throwable caught) {
    for (Object o : callbacks) {
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onFailure(caught);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onFailure(caught);
        }
    }
}
#method_after
private void onFailure(Throwable caught) {
    if (failed) {
        return;
    }
    failed = true;
    for (Object o : callbacks) {
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onFailure(caught);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onFailure(caught);
        }
    }
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(uuid.toString());
    sb.append("|");
    sb.append(sessionId);
    sb.append('|');
    sb.append(who);
    sb.append('|');
    sb.append(when);
    sb.append('|');
    sb.append(what);
    sb.append('|');
    sb.append(elapsed);
    sb.append('|');
    if (params != null) {
        sb.append('[');
        for (int i = 0; i < params.size(); i++) {
            if (i > 0)
                sb.append(',');
            if (params != null) {
                Set<String> paramNames = params.keySet();
                for (String paramName : paramNames) {
                    sb.append("name=");
                    sb.append(paramName);
                    int numValues = 0;
                    Collection<?> paramValues = params.get(paramName);
                    for (Object paramValue : paramValues) {
                        sb.append(Objects.firstNonNull(paramValue, "null"));
                        if (numValues++ > 0) {
                            sb.append(",");
                        }
                    }
                }
            }
        }
        sb.append(']');
    }
    sb.append('|');
    if (result != null) {
        sb.append(result);
    }
    return sb.toString();
}
#method_after
@Override
public String toString() {
    return String.format("AuditEvent UUID:%s, SID:%s, TS:%d, who:%s, what:%s", uuid.get(), sessionId, when, who, what);
}
#end_block

#method_before
private Multimap<String, ?> extractParameters(DispatchCommand dcmd) {
    String[] cmdArgs = dcmd.getArguments();
    String paramName = null;
    int argPos = 0;
    Multimap<String, String> parms = ArrayListMultimap.create();
    for (int i = 2; i < cmdArgs.length; i++) {
        String arg = cmdArgs[i];
        if (arg.startsWith("-")) {
            if (paramName != null) {
                parms.put(paramName, null);
            }
            paramName = arg;
        } else {
            if (paramName == null) {
                parms.put("$" + argPos++, arg);
            } else {
                parms.put(paramName, arg);
                paramName = null;
            }
        }
    }
    if (paramName != null) {
        parms.put(paramName, null);
    }
    return parms;
}
#method_after
private Multimap<String, ?> extractParameters(DispatchCommand dcmd) {
    String[] cmdArgs = dcmd.getArguments();
    String paramName = null;
    int argPos = 0;
    Multimap<String, String> parms = ArrayListMultimap.create();
    for (int i = 2; i < cmdArgs.length; i++) {
        String arg = cmdArgs[i];
        // -- stop parameters parsing
        if (arg.equals("--")) {
            for (i++; i < cmdArgs.length; i++) {
                parms.put("$" + argPos++, cmdArgs[i]);
            }
            break;
        }
        // --param=value
        int eqPos = arg.indexOf('=');
        if (arg.startsWith("--") && eqPos > 0) {
            parms.put(arg.substring(0, eqPos), arg.substring(eqPos + 1));
            continue;
        }
        // -p value or --param value
        if (arg.startsWith("-")) {
            if (paramName != null) {
                parms.put(paramName, null);
            }
            paramName = arg;
            continue;
        }
        // value
        if (paramName == null) {
            parms.put("$" + argPos++, arg);
        } else {
            parms.put(paramName, arg);
            paramName = null;
        }
    }
    if (paramName != null) {
        parms.put(paramName, null);
    }
    return parms;
}
#end_block

#method_before
void audit(Context ctx, Object result, String cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + cmd, created, null, result));
}
#method_after
void audit(Context ctx, Object result, String cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new SshAuditEvent(sid, extractCurrentUser(ctx), cmd, created, null, result));
}
#end_block

#method_before
void audit(Context ctx, Object result, DispatchCommand cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + extractWhat(cmd), created, extractParameters(cmd), result));
}
#method_after
void audit(Context ctx, Object result, DispatchCommand cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new SshAuditEvent(sid, extractCurrentUser(ctx), extractWhat(cmd), created, extractParameters(cmd), result));
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    int status = SC_OK;
    Object result = "";
    Multimap<String, String> params = LinkedHashMultimap.create();
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    try {
        checkUserSession(req);
        List<String> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            view = rc.list();
        } else {
            String id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                view = c.list();
                break;
            } else {
                rsrc = c.parse(rsrc, path.remove(0));
                view = view(c, req.getMethod(), path);
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            result = m.apply(rsrc, parseRequest(req, m.inputType()));
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        res.setStatus(status);
        if (result instanceof BinaryResult) {
            replyBinaryResult(req, res, (BinaryResult) result);
        } else {
            replyJson(req, res, config, result);
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (InvalidMethodException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new AuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getMethod() + " " + req.getRequestURI(), auditStartTs, params, status + " " + result));
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    CacheHeaders.setNotCacheable(res);
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            if ("GET".equals(req.getMethod())) {
                view = rc.list();
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                view = ac.post(rsrc);
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                checkPreconditions(req, rsrc);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                if ("GET".equals(req.getMethod())) {
                    view = c.list();
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    view = ac.post(rsrc);
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req, rsrc);
                    view = null;
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        view = ac.create(rsrc, id);
                        status = SC_CREATED;
                    } else {
                        throw e;
                    }
                }
                if (view == null) {
                    view = view(c, req.getMethod(), path);
                }
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
        } else if (result instanceof Response.Redirect) {
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (PreconditionFailedException e) {
        replyError(res, status = SC_PRECONDITION_FAILED, Objects.firstNonNull(e.getMessage(), "Precondition failed"));
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new HttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getRequestURI(), auditStartTs, params, req.getMethod(), inputRequestBody, status, result));
    }
}
#end_block

#method_before
private Object parseRequest(HttpServletRequest req, Class<Object> type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, InvalidMethodException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (type.getDeclaredFields().length == 0 && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#method_after
private Object parseRequest(HttpServletRequest req, Type type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (isEmptyType(type) && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#end_block

#method_before
private static boolean hasNoBody(HttpServletRequest req) {
    int len = req.getContentLength();
    String type = req.getContentType();
    return (len <= 0 && type == null) || (len == 0 && isType("application/x-www-form-urlencoded", type));
}
#method_after
private static boolean hasNoBody(HttpServletRequest req) {
    int len = req.getContentLength();
    String type = req.getContentType();
    return (len <= 0 && type == null) || (len == 0 && isType(FORM_TYPE, type));
}
#end_block

#method_before
private static boolean acceptsPutInput(Class<Object> type) {
    for (Field f : type.getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            return true;
        }
    }
    return false;
}
#method_after
@SuppressWarnings("rawtypes")
private static boolean acceptsPutInput(Type type) {
    if (type instanceof Class) {
        for (Field f : ((Class) type).getDeclaredFields()) {
            if (f.getType() == PutInput.class) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private Object parsePutInput(final HttpServletRequest req, Class<Object> type) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException, InvalidMethodException {
    Object obj = createInstance(type);
    for (Field f : type.getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            f.setAccessible(true);
            f.set(obj, new PutInput() {

                @Override
                public String getContentType() {
                    return req.getContentType();
                }

                @Override
                public long getContentLength() {
                    return req.getContentLength();
                }

                @Override
                public InputStream getInputStream() throws IOException {
                    return req.getInputStream();
                }
            });
            return obj;
        }
    }
    throw new InvalidMethodException();
}
#method_after
private Object parsePutInput(final HttpServletRequest req, Type type) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException, MethodNotAllowedException {
    Object obj = createInstance(type);
    for (Field f : obj.getClass().getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            f.setAccessible(true);
            f.set(obj, new PutInput() {

                @Override
                public String getContentType() {
                    return req.getContentType();
                }

                @Override
                public long getContentLength() {
                    return req.getContentLength();
                }

                @Override
                public InputStream getInputStream() throws IOException {
                    return req.getInputStream();
                }
            });
            return obj;
        }
    }
    throw new MethodNotAllowedException();
}
#end_block

#method_before
private Object parseString(String value, Class<Object> type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    Object obj = createInstance(type);
    Field[] fields = type.getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#method_after
private Object parseString(String value, Type type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    if (type == String.class) {
        return value;
    }
    Object obj = createInstance(type);
    Field[] fields = obj.getClass().getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#end_block

#method_before
private static Object createInstance(Class<Object> type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor<Object> c = type.getDeclaredConstructor();
    c.setAccessible(true);
    return c.newInstance();
}
#method_after
private static Object createInstance(Type type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    if (type instanceof Class) {
        @SuppressWarnings("unchecked")
        Class<Object> clazz = (Class<Object>) type;
        Constructor<Object> c = clazz.getDeclaredConstructor();
        c.setAccessible(true);
        return c.newInstance();
    }
    throw new InstantiationException("Cannot make " + type);
}
#end_block

#method_before
private static void replyJson(HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8));
}
#method_after
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#end_block

#method_before
private static Gson newGson(Multimap<String, String> config, HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#method_after
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#end_block

#method_before
private static void enablePrettyPrint(GsonBuilder gb, Multimap<String, String> config, HttpServletRequest req) {
    String pp = Iterables.getFirst(config.get("pp"), null);
    if (pp == null) {
        pp = Iterables.getFirst(config.get("prettyPrint"), null);
        if (pp == null) {
            pp = acceptsJson(req) ? "0" : "1";
        }
    }
    if ("1".equals(pp) || "true".equals(pp)) {
        gb.setPrettyPrinting();
    }
}
#method_after
private static void enablePrettyPrint(GsonBuilder gb, Multimap<String, String> config, @Nullable HttpServletRequest req) {
    String pp = Iterables.getFirst(config.get("pp"), null);
    if (pp == null) {
        pp = Iterables.getFirst(config.get("prettyPrint"), null);
        if (pp == null && req != null) {
            pp = acceptsJson(req) ? "0" : "1";
        }
    }
    if ("1".equals(pp) || "true".equals(pp)) {
        gb.setPrettyPrinting();
    }
}
#end_block

#method_before
private static void replyBinaryResult(HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                res.setContentLength((int) buf.length());
                res.setHeader("Content-Encoding", "gzip");
                buf.writeTo(dst, null);
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                if (0 <= len && len < Integer.MAX_VALUE) {
                    res.setContentLength((int) len);
                } else if (0 <= len) {
                    res.setHeader("Content-Length", Long.toString(len));
                }
                bin.writeTo(dst);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#method_after
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                if (buf.length() < len) {
                    res.setContentLength((int) buf.length());
                    res.setHeader("Content-Encoding", "gzip");
                    buf.writeTo(dst, null);
                } else {
                    replyUncompressed(res, dst, bin, len);
                }
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                replyUncompressed(res, dst, bin, len);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#end_block

#method_before
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<String> path) throws ResourceNotFoundException, InvalidMethodException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final String projection = path.isEmpty() ? "/" : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
private static List<String> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<String> out = Lists.newArrayList(Splitter.on('/').split(path));
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#method_after
private static List<IdString> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<IdString> out = Lists.newArrayList();
    for (String p : Splitter.on('/').split(path)) {
        out.add(IdString.fromUrl(p));
    }
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#end_block

#method_before
private static List<String> splitProjection(String projection) {
    return Lists.newArrayList(Splitter.on('~').limit(2).split(projection));
}
#method_after
private static List<String> splitProjection(IdString projection) {
    List<String> p = Lists.newArrayListWithCapacity(2);
    Iterables.addAll(p, Splitter.on('~').limit(2).split(projection.get()));
    return p;
}
#end_block

#method_before
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if (!text.endsWith("\n")) {
        text += "\n";
    }
    replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
}
#method_after
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#end_block

#method_before
private static boolean acceptsJson(HttpServletRequest req) {
    return req != null && isType(JSON_TYPE, req.getHeader("Accept"));
}
#method_after
private static boolean acceptsJson(HttpServletRequest req) {
    return req != null && isType(JSON_TYPE, req.getHeader(HttpHeaders.ACCEPT));
}
#end_block

#method_before
private static boolean acceptsGzip(HttpServletRequest req) {
    return req != null && RPCServletUtils.acceptsGzipEncoding(req);
}
#method_after
private static boolean acceptsGzip(HttpServletRequest req) {
    if (req != null) {
        String accepts = req.getHeader(HttpHeaders.ACCEPT_ENCODING);
        return accepts != null && accepts.indexOf("gzip") != -1;
    }
    return false;
}
#end_block

#method_before
@Override
protected GerritCall createActiveCall(final HttpServletRequest req, final HttpServletResponse rsp) {
    final GerritCall call = new GerritCall(session.get(), req, rsp);
    currentCall.set(call);
    return call;
}
#method_after
@Override
protected GerritCall createActiveCall(final HttpServletRequest req, final HttpServletResponse rsp) {
    final GerritCall call = new GerritCall(session.get(), req, new AuditedHttpServletResponse(rsp));
    currentCall.set(call);
    return call;
}
#end_block

#method_before
private void audit() {
    try {
        GerritCall call = currentCall.get();
        MethodHandle method = call.getMethod();
        if (method == null) {
            return;
        }
        Audit note = (Audit) method.getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getSessionId();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final Multimap<String, ?> args = extractParams(note, call);
            final String what = extractWhat(note, method.getName());
            final Object result = call.getResult();
            audit.dispatch(new AuditEvent(sid, username, what, call.getWhen(), args, result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#method_after
private void audit() {
    try {
        GerritCall call = currentCall.get();
        MethodHandle method = call.getMethod();
        if (method == null) {
            return;
        }
        Audit note = (Audit) method.getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getSessionId();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final Multimap<String, ?> args = extractParams(note, call);
            final String what = extractWhat(note, call);
            final Object result = call.getResult();
            audit.dispatch(new RpcAuditEvent(sid, username, what, call.getWhen(), args, call.getHttpServletRequest().getMethod(), call.getHttpServletRequest().getMethod(), ((AuditedHttpServletResponse) (call.getHttpServletResponse())).getStatus(), result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#end_block

#method_before
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (ccase && !Character.isLowerCase(c)) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#method_after
private String extractWhat(final Audit note, final GerritCall call) {
    String methodClass = call.getMethodClass().getName();
    methodClass = methodClass.substring(methodClass.lastIndexOf(".") + 1);
    String what = note.action();
    if (what.length() == 0) {
        what = call.getMethod().getName();
    }
    return methodClass + "." + what;
}
#end_block

#method_before
@Override
public boolean xsrfValidate() {
    final String keyIn = getXsrfKeyIn();
    if (keyIn == null || "".equals(keyIn)) {
        // 
        return !session.isSignedIn();
    } else {
        // 
        return session.isSignedIn() && session.isValidAuthorization(keyIn);
    }
}
#method_after
@Override
public boolean xsrfValidate() {
    final String keyIn = getXsrfKeyIn();
    if (keyIn == null || "".equals(keyIn)) {
        // 
        return !session.isSignedIn();
    } else if (session.isSignedIn() && session.isValidAuthorization(keyIn)) {
        // The session must exist, and must be using this token.
        // 
        session.getCurrentUser().setAccessPath(AccessPath.JSON_RPC);
        return true;
    }
    return false;
}
#end_block

#method_before
public void setReviewedByCurrentUser(boolean reviewed) {
    if (fileList != null) {
        fileList.updateReviewedStatus(patchKey, reviewed);
    }
    MarkReviewedInput in = MarkReviewedInput.create();
    in.reviewed(reviewed);
    PatchSet.Id ps = patchKey.getParentKey();
    new RestApi("/changes/").id(ps.getParentKey().get()).view("revisions").id(ps.get()).view("files").id(patchKey.getFileName()).view("reviewed").post(in, new AsyncCallback<VoidResult>() {

        @Override
        public void onFailure(Throwable arg0) {
        // nop
        }

        @Override
        public void onSuccess(VoidResult result) {
        // nop
        }
    });
}
#method_after
public void setReviewedByCurrentUser(boolean reviewed) {
    if (fileList != null) {
        fileList.updateReviewedStatus(patchKey, reviewed);
    }
    PatchSet.Id ps = patchKey.getParentKey();
    RestApi api = new RestApi("/changes/").id(ps.getParentKey().get()).view("revisions").id(ps.get()).view("files").id(patchKey.getFileName()).view("reviewed");
    AsyncCallback<VoidResult> cb = new AsyncCallback<VoidResult>() {

        @Override
        public void onFailure(Throwable arg0) {
        // nop
        }

        @Override
        public void onSuccess(VoidResult result) {
        // nop
        }
    };
    if (reviewed) {
        api.put(cb);
    } else {
        api.delete(cb);
    }
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), PATCH_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "files").to(Patches.class);
    post(PATCH_KIND, "reviewed").to(MarkReviewed.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Patches.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), PATCH_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "files").to(Patches.class);
    put(PATCH_KIND, "reviewed").to(PutReviewed.class);
    delete(PATCH_KIND, "reviewed").to(DeleteReviewed.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#end_block

#method_before
private static void whoAmI(boolean canLogOut) {
    Account account = getUserAccount();
    final CurrentUserPopupPanel userPopup = new CurrentUserPopupPanel(account, canLogOut);
    final String name = FormatUtil.name(account);
    String[] names = name.split("\\s+", 2);
    final InlineLabel l = new InlineLabel(names[0] + " ▾");
    l.setStyleName(RESOURCES.css().menuBarUserName());
    l.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (userPopup.isShowing()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(l);
            }
        }
    });
    userPopup.addAutoHidePartner(l.getElement());
    menuRight.add(l);
}
#method_after
private static void whoAmI(boolean canLogOut) {
    Account account = getUserAccount();
    final CurrentUserPopupPanel userPopup = new CurrentUserPopupPanel(account, canLogOut);
    final InlineLabel l = new InlineLabel(FormatUtil.name(account) + " ▾");
    l.setStyleName(RESOURCES.css().menuBarUserName());
    l.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (userPopup.isShowing()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(l);
            }
        }
    });
    userPopup.addAutoHidePartner(l.getElement());
    FocusPanel fp = new FocusPanel(l);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(new KeyDownHandler() {

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                if (userPopup.isShowing()) {
                    userPopup.hide();
                } else {
                    userPopup.showRelativeTo(l);
                }
                event.preventDefault();
            }
        }
    });
    menuRight.add(fp);
}
#end_block

#method_before
public DynamicItem<T> get() {
    return new DynamicItem<T>(find(injector, type));
}
#method_after
public DynamicItem<T> get() {
    return new DynamicItem<T>(key, find(injector, type), "gerrit");
}
#end_block

#method_before
private static <T> AtomicReference<Provider<T>> find(Injector src, TypeLiteral<T> type) {
    List<Binding<T>> bindings = src.findBindingsByType(type);
    if (bindings != null) {
        for (Binding<T> b : bindings) {
            if (b.getKey().getAnnotation() != null) {
                // TODO: throw exception if > 1 match?
                return new AtomicReference<Provider<T>>(b.getProvider());
            }
        }
    }
    return new AtomicReference<Provider<T>>();
}
#method_after
private static <T> Provider<T> find(Injector src, TypeLiteral<T> type) {
    List<Binding<T>> bindings = src.findBindingsByType(type);
    if (bindings != null && bindings.size() == 1) {
        return bindings.get(0).getProvider();
    } else if (bindings != null && bindings.size() > 1) {
        throw new ProvisionException(String.format("Multiple providers bound for DynamicItem<%s>\n" + "This is not allowed; check the server configuration.", type));
    } else {
        return null;
    }
}
#end_block

#method_before
public static List<RegistrationHandle> attachItems(Injector src, Map<TypeLiteral<?>, DynamicItem<?>> items) {
    if (src == null || items == null || items.isEmpty()) {
        return Collections.emptyList();
    }
    List<RegistrationHandle> handles = new ArrayList<RegistrationHandle>(4);
    try {
        for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
            @SuppressWarnings("unchecked")
            TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
            @SuppressWarnings("unchecked")
            DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
            for (Binding<Object> b : bindings(src, type)) {
                if (b.getKey().getAnnotation() != null) {
                    handles.add(item.set(b.getKey(), b.getProvider()));
                }
            }
        }
    } catch (RuntimeException e) {
        remove(handles);
        throw e;
    } catch (Error e) {
        remove(handles);
        throw e;
    }
    return handles;
}
#method_after
public static List<RegistrationHandle> attachItems(Injector src, Map<TypeLiteral<?>, DynamicItem<?>> items, String pluginName) {
    if (src == null || items == null || items.isEmpty()) {
        return Collections.emptyList();
    }
    List<RegistrationHandle> handles = new ArrayList<RegistrationHandle>(4);
    try {
        for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
            @SuppressWarnings("unchecked")
            TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
            @SuppressWarnings("unchecked")
            DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
            for (Binding<Object> b : bindings(src, type)) {
                if (b.getKey().getAnnotation() != null) {
                    handles.add(item.set(b.getKey(), b.getProvider(), pluginName));
                }
            }
        }
    } catch (RuntimeException e) {
        remove(handles);
        throw e;
    } catch (Error e) {
        remove(handles);
        throw e;
    }
    return handles;
}
#end_block

#method_before
public static <T> void itemOf(Binder binder, TypeLiteral<T> member) {
    @SuppressWarnings("unchecked")
    Key<DynamicItem<T>> key = (Key<DynamicItem<T>>) Key.get(Types.newParameterizedType(DynamicItem.class, member.getType()));
    binder.bind(key).toProvider(new DynamicItemProvider<T>(member)).in(Scopes.SINGLETON);
}
#method_after
public static <T> void itemOf(Binder binder, TypeLiteral<T> member) {
    @SuppressWarnings("unchecked")
    Key<DynamicItem<T>> key = (Key<DynamicItem<T>>) Key.get(Types.newParameterizedType(DynamicItem.class, member.getType()));
    binder.bind(key).toProvider(new DynamicItemProvider<T>(member, key)).in(Scopes.SINGLETON);
}
#end_block

#method_before
public static <T> LinkedBindingBuilder<T> bind(Binder binder, TypeLiteral<T> type) {
    return binder.bind(type).annotatedWith(UniqueAnnotations.create());
}
#method_after
public static <T> LinkedBindingBuilder<T> bind(Binder binder, TypeLiteral<T> type) {
    return binder.bind(type);
}
#end_block

#method_before
public T get() {
    Provider<T> p = item.get();
    T t = null;
    if (p != null) {
        t = p.get();
    }
    return t;
}
#method_after
public T get() {
    NamedProvider<T> item = ref.get();
    return item != null ? item.impl.get() : null;
}
#end_block

#method_before
public ReloadableRegistrationHandle<T> set(Key<T> key, Provider<T> item) {
    if (!this.item.compareAndSet(null, item)) {
        // We already have an item bound.
        throw new RuntimeException("Type already provided by " + this.item.get());
    }
    return new ReloadableHandle(key, item);
}
#method_after
public RegistrationHandle set(T item, String pluginName) {
    return set(Providers.of(item), pluginName);
}
#end_block

#method_before
@Override
public void remove() {
    DynamicItem.this.item.compareAndSet(item, null);
}
#method_after
@Override
public void remove() {
    ref.compareAndSet(item, null);
}
#end_block

#method_before
@Override
public ReloadableHandle replace(Key<T> newKey, Provider<T> newItem) {
    if (DynamicItem.this.item.compareAndSet(item, newItem)) {
        return new ReloadableHandle(newKey, newItem);
    }
    return null;
}
#method_after
@Override
public ReloadableHandle replace(Key<T> newKey, Provider<T> newItem) {
    NamedProvider<T> n = new NamedProvider<T>(newItem, item.pluginName);
    if (ref.compareAndSet(item, n)) {
        return new ReloadableHandle(newKey, n);
    }
    return null;
}
#end_block

#method_before
private void attachItem(Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin plugin) {
    for (RegistrationHandle h : PrivateInternals_DynamicTypes.attachItems(src, items)) {
        plugin.add(h);
    }
}
#method_after
private void attachItem(Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin plugin) {
    for (RegistrationHandle h : PrivateInternals_DynamicTypes.attachItems(src, items, plugin.getName())) {
        plugin.add(h);
    }
}
#end_block

#method_before
private void reattachItem(ListMultimap<TypeLiteral<?>, ReloadableRegistrationHandle<?>> oldHandles, Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin newPlugin) {
    if (src == null || items == null || items.isEmpty()) {
        return;
    }
    for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
        @SuppressWarnings("unchecked")
        TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
        @SuppressWarnings("unchecked")
        DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
        // Index all old handles that match this DynamicItem<T> keyed by
        // annotations. Ignore the unique annotations, thereby favoring
        // the @Named annotations or some other non-unique naming.
        Map<Annotation, ReloadableRegistrationHandle<?>> am = Maps.newHashMap();
        List<ReloadableRegistrationHandle<?>> old = oldHandles.get(type);
        Iterator<ReloadableRegistrationHandle<?>> oi = old.iterator();
        while (oi.hasNext()) {
            ReloadableRegistrationHandle<?> h = oi.next();
            Annotation a = h.getKey().getAnnotation();
            if (a != null && !UNIQUE_ANNOTATION.isInstance(a)) {
                am.put(a, h);
                oi.remove();
            }
        }
        // Replace old handles with new bindings, favoring cases where there
        // is an exact match on an @Named annotation. If there is no match
        // pick any handle and replace it. We generally expect only one
        // handle of each DynamicItem type when using unique annotations, but
        // possibly multiple ones if @Named was used. Plugin authors that want
        // atomic replacement across reloads should use @Named annotations with
        // stable names that do not change across plugin versions to ensure the
        // handles are swapped correctly.
        oi = old.iterator();
        for (Binding<?> binding : bindings(src, type)) {
            @SuppressWarnings("unchecked")
            Binding<Object> b = (Binding<Object>) binding;
            Key<Object> key = b.getKey();
            if (key.getAnnotation() == null) {
                continue;
            }
            @SuppressWarnings("unchecked")
            ReloadableRegistrationHandle<Object> h1 = (ReloadableRegistrationHandle<Object>) am.remove(key.getAnnotation());
            if (h1 != null) {
                replace(newPlugin, h1, b);
            } else if (oi.hasNext()) {
                @SuppressWarnings("unchecked")
                ReloadableRegistrationHandle<Object> h2 = (ReloadableRegistrationHandle<Object>) oi.next();
                oi.remove();
                replace(newPlugin, h2, b);
            } else {
                newPlugin.add(item.set(b.getKey(), b.getProvider()));
            }
        }
    }
}
#method_after
private void reattachItem(ListMultimap<TypeLiteral<?>, ReloadableRegistrationHandle<?>> oldHandles, Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin newPlugin) {
    if (src == null || items == null || items.isEmpty()) {
        return;
    }
    for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
        @SuppressWarnings("unchecked")
        TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
        @SuppressWarnings("unchecked")
        DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
        Iterator<ReloadableRegistrationHandle<?>> oi = oldHandles.get(type).iterator();
        for (Binding<?> binding : bindings(src, type)) {
            @SuppressWarnings("unchecked")
            Binding<Object> b = (Binding<Object>) binding;
            if (oi.hasNext()) {
                @SuppressWarnings("unchecked")
                ReloadableRegistrationHandle<Object> h = (ReloadableRegistrationHandle<Object>) oi.next();
                oi.remove();
                replace(newPlugin, h, b);
            } else {
                newPlugin.add(item.set(b.getKey(), b.getProvider(), newPlugin.getName()));
            }
        }
    }
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() == null) {
                continue;
            } else if (ref.getName().startsWith("refs/changes/")) {
                existing.add(ref.getObjectId());
            } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
                try {
                    walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
                } catch (IOException e) {
                    log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                    continue;
                }
            }
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            boolean validCommit = CommitUtil.validateCommit(destBranchCtl, newChange, c, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

                public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                    reject(newChange, rejectReason);
                }

                @Override
                public void onAccepted(List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                }
            });
            if (!validCommit) {
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(newChange, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(newChange, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(newChange, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(newChange, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(newChange, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() == null) {
                continue;
            } else if (ref.getName().startsWith("refs/changes/")) {
                existing.add(ref.getObjectId());
            } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
                try {
                    walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
                } catch (IOException e) {
                    log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                    continue;
                }
            }
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(newChange, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(newChange, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(newChange, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(newChange, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(newChange, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    boolean validCommit = CommitUtil.validateCommit(changeCtl.getRefControl(), inputCommand, newCommit, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

        public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
            getMessages().addAll(messages);
            reject(newChange, rejectReason);
        }

        @Override
        public void onAccepted(List<CommitValidationMessage> messages) {
            getMessages().addAll(messages);
        }
    });
    if (!validCommit) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            boolean validCommit = CommitUtil.validateCommit(ctl, cmd, c, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

                public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                    reject(newChange, rejectReason);
                }

                @Override
                public void onAccepted(List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                }
            });
            if (!validCommit) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    bind(AnonymousUser.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapRealmModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    install(new LdapModule());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(LdapGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (req.getUsername() == null) {
        throw new MissingCredentialsException();
    }
    final String username;
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        username = req.getUsername().toLowerCase(Locale.US);
    } else {
        username = req.getUsername();
    }
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, req.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), req.getPassword());
            }
            return new AuthUser(new AuthUser.UUID(username), username);
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (AccountException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new InvalidCredentialsException("Cannot query LDAP for account", e);
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AuthException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (req.getUsername() == null) {
        throw new MissingCredentialsException();
    }
    final String username;
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        username = req.getUsername().toLowerCase(Locale.US);
    } else {
        username = req.getUsername();
    }
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, req.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), req.getPassword());
            }
            return new AuthUser(new AuthUser.UUID(username), username);
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (AccountException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new InvalidCredentialsException("Cannot query LDAP for account", e);
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final String newMessage = message + '\n';
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            Date now = myIdent.getWhen();
            Change change = db.changes().get(changeId);
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            if (commit.getFullMessage().equals(newMessage)) {
                throw new InvalidChangeOperationException("The commit message is unchanged");
            }
            PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(commit.getAuthorIdent());
            commitBuilder.setCommitter(authorIdent);
            commitBuilder.setMessage(newMessage);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
            newPatchSet.setUploader(user.getAccountId());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            if (commit.getFullMessage().equals(message)) {
                throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
            }
            Date now = myIdent.getWhen();
            Change change = db.changes().get(changeId);
            PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(commit.getAuthorIdent());
            commitBuilder.setCommitter(authorIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
            newPatchSet.setUploader(user.getAccountId());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setHTML(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#method_after
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        ValueRadioButton b = new ValueRadioButton(ct.getCategory(), buttonValue);
        SafeHtml buf = new SafeHtmlBuilder().append(buttonValue.format());
        buf = CommentLinkProcessor.apply(buf);
        SafeHtml.set(b, buf);
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
        approvals.setAccountInfoCache(r.getAccounts());
        approvals.display(r);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, false, r.getPatchSetInfo(), r.getAccounts(), r.getSubmitTypeRecord());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
        approvals.setAccountInfoCache(r.getAccounts());
        approvals.display(r);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    revision = r.getPatchSetInfo().getRevId();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    enableForm(false);
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#method_after
private void onSend2(final boolean submit) {
    ReviewInput data = ReviewInput.create();
    data.message(ChangeApi.emptyToNull(message.getText().trim()));
    data.init();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            data.label(b.category.getLabelName(), b.value.getValue());
        }
    }
    enableForm(false);
    new RestApi("/changes/" + patchSetId.getParentKey().get() + "/revisions/" + revision + "/review").data(data).post(new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable caught) {
            goChange();
            super.onFailure(caught);
        }
    });
}
#method_after
private void submit() {
    ChangeApi.submit(patchSetId.getParentKey().get(), revision, new GerritCallback<SubmitInfo>() {

        public void onSuccess(SubmitInfo result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
            } else {
                super.onFailure(err);
            }
            goChange();
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (RepositoryNotFoundException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#method_after
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(openRepository(change), patchsetCreatedHook, args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        addArg(args, "--" + approval.getKey().get(), Short.toString(approval.getValue().get()));
    }
    runHook(openRepository(change), commentAddedHook, args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        addArg(args, "--" + approval.getKey().get(), Short.toString(approval.getValue().get()));
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(openRepository(change), changeMergedHook, args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(openRepository(change), changeAbandonedHook, args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(openRepository(refName.getParentKey()), refUpdatedHook, args);
}
#method_after
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<String>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-id", cla.getId().toString());
        runHook(claSignedHook, args);
    }
}
#method_after
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<String>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new HookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, File hook, List<String> args) {
    if (project != null && hook.exists()) {
        hookQueue.execute(new AsyncHookTask(project, hook, args));
    }
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new HookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Repository repo, File hook, List<String> args) throws TimeoutException {
    if (hook.exists()) {
        SyncHookTask syncHook = new SyncHookTask(repo, hook, args);
        FutureTask<HookResult> task = new FutureTask<HookResult>(syncHook);
        syncHookThreadPool.execute(task);
        try {
            return task.get(syncHookTimeout, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Error running hook " + hook.getAbsolutePath(), e);
        } catch (ExecutionException e) {
            log.error("Error running hook " + hook.getAbsolutePath(), e);
        } catch (TimeoutException e) {
            log.error("Synchronous hook timed out " + hook.getAbsolutePath());
            throw e;
        }
    }
    return null;
}
#method_after
private HookResult runSyncHook(Project.NameKey project, File hook, List<String> args) throws TimeoutException {
    if (!hook.exists()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<HookResult>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.getAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.getAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
@Override
public HookResult call() throws Exception {
    HookResult result = null;
    StringBuilder output = new StringBuilder();
    try {
        final List<String> argv = new ArrayList<String>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (repo != null) {
            pb.directory(repo.getDirectory());
            final Map<String, String> env = pb.environment();
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        Process ps = pb.start();
        ps.getOutputStream().close();
        BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream()));
        try {
            String line = br.readLine();
            while (line != null) {
                output.append(line);
                line = br.readLine();
                if (line != null) {
                    output.append(System.getProperty("line.separator"));
                }
            }
        } finally {
            try {
                br.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output.toString());
        }
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return result;
}
#method_after
@Override
public HookResult call() throws Exception {
    return super.runHook();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        // Run the update hook, if it returns output then reject the push
        // passing the output back to the user
        String output = hooks.doUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (output != null) {
            reject(cmd, output);
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private Collection<ObjectId> existingObjects() {
    if (existingObjects == null) {
        Map<String, Ref> refs = repo.getAllRefs();
        existingObjects = new ArrayList<ObjectId>(refs.size());
        for (Ref r : refs.values()) {
            existingObjects.add(r.getObjectId());
        }
    }
    return existingObjects;
}
#method_after
private Collection<ObjectId> existingObjects() {
    if (existingObjects == null) {
        existingObjects = new ArrayList<ObjectId>(allRefs.size());
        for (Ref r : allRefs.values()) {
            existingObjects.add(r.getObjectId());
        }
    }
    return existingObjects;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidationListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
        final String message = validationResult.getValidationReason();
        if (!validationResult.isValidated()) {
            reject(cmd, message);
            return false;
        } else if (!Strings.isNullOrEmpty(message)) {
            addMessage(String.format("(W) %s", message));
        }
    }
    return true;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    addMessage(sb.toString());
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(result.change);
                cm.setFrom(currentUser.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void insertAncestors(PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#method_after
private void insertAncestors(ReviewDb db, PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
@Override
public DashboardResource parse(ProjectResource parent, String id) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    ProjectControl myCtl = parent.getControl();
    if ("default".equals(id)) {
        return DashboardResource.projectDefault(myCtl);
    }
    List<String> parts = Lists.newArrayList(Splitter.on(':').limit(2).split(id));
    if (parts.size() != 2) {
        throw new ResourceNotFoundException(id);
    }
    String ref = URLDecoder.decode(parts.get(0), "UTF-8");
    String path = URLDecoder.decode(parts.get(1), "UTF-8");
    Set<Project.NameKey> seen = Sets.newHashSet();
    Project.NameKey name = myCtl.getProject().getNameKey();
    ProjectControl ctl = myCtl;
    seen.add(name);
    do {
        try {
            return parse(ctl, ref, path, myCtl);
        } catch (Exception e) {
            try {
                ProjectState ps = ctl.getProjectState().getParentState();
                if (ps == null) {
                    break;
                }
                name = ps.getProject().getNameKey();
                if (!seen.add(name)) {
                    break;
                }
                ctl = projectFactory.controlFor(name, ctl.getCurrentUser());
            } catch (NoSuchProjectException pnf) {
                throw new ResourceNotFoundException(id);
            }
        }
    } while (ctl != null);
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public DashboardResource parse(ProjectResource parent, String id) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    ProjectControl myCtl = parent.getControl();
    if ("default".equals(id)) {
        return DashboardResource.projectDefault(myCtl);
    }
    List<String> parts = Lists.newArrayList(Splitter.on(':').limit(2).split(id));
    if (parts.size() != 2) {
        throw new ResourceNotFoundException(id);
    }
    String ref = URLDecoder.decode(parts.get(0), "UTF-8");
    String path = URLDecoder.decode(parts.get(1), "UTF-8");
    ProjectControl ctl = myCtl;
    Set<Project.NameKey> seen = Sets.newHashSet(ctl.getProject().getNameKey());
    for (; ; ) {
        try {
            return parse(ctl, ref, path, myCtl);
        } catch (AmbiguousObjectException e) {
            throw new ResourceNotFoundException(id);
        } catch (IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        } catch (ResourceNotFoundException e) {
            ProjectState ps = ctl.getProjectState().getParentState();
            if (ps != null && seen.add(ps.getProject().getNameKey())) {
                ctl = ps.controlFor(ctl.getCurrentUser());
                continue;
            }
            throw new ResourceNotFoundException(id);
        }
    }
}
#end_block

#method_before
private DashboardResource parse(ProjectControl ctl, String ref, String path, ProjectControl myCtl) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    String id = ref + ":" + path;
    if (!ref.startsWith(REFS_DASHBOARDS)) {
        ref = REFS_DASHBOARDS + ref;
    }
    if (!Repository.isValidRefName(ref) || !ctl.controlForRef(ref).canRead()) {
        throw new ResourceNotFoundException(id);
    }
    Repository git;
    try {
        git = gitManager.openRepository(ctl.getProject().getNameKey());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(id);
    }
    try {
        ObjectId objId;
        try {
            objId = git.resolve(id);
        } catch (AmbiguousObjectException e) {
            throw new ResourceNotFoundException(id);
        } catch (IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        }
        if (objId == null) {
            throw new ResourceNotFoundException(id);
        }
        BlobBasedConfig cfg = new BlobBasedConfig(null, git, objId);
        return new DashboardResource(myCtl, ref, path, cfg, false);
    } finally {
        git.close();
    }
}
#method_after
private DashboardResource parse(ProjectControl ctl, String ref, String path, ProjectControl myCtl) throws ResourceNotFoundException, IOException, AmbiguousObjectException, IncorrectObjectTypeException, ConfigInvalidException {
    String id = ref + ":" + path;
    if (!ref.startsWith(REFS_DASHBOARDS)) {
        ref = REFS_DASHBOARDS + ref;
    }
    if (!Repository.isValidRefName(ref) || !ctl.controlForRef(ref).canRead()) {
        throw new ResourceNotFoundException(id);
    }
    Repository git;
    try {
        git = gitManager.openRepository(ctl.getProject().getNameKey());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(id);
    }
    try {
        ObjectId objId = git.resolve(ref + ":" + path);
        if (objId == null) {
            throw new ResourceNotFoundException(id);
        }
        BlobBasedConfig cfg = new BlobBasedConfig(null, git, objId);
        return new DashboardResource(myCtl, ref, path, cfg, false);
    } finally {
        git.close();
    }
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.nextPatchSetId();
        change.setTopic(changeToRevert.getTopic());
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        Change change = db.changes().get(changeId);
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        CommitBuilder commitBuilder = new CommitBuilder();
        commitBuilder.addParentId(commit);
        commitBuilder.setTreeId(commit.getTree());
        commitBuilder.setAuthor(authorIdent);
        commitBuilder.setCommitter(myIdent);
        commitBuilder.setMessage(message);
        RevCommit newCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(commitBuilder);
            oi.flush();
            newCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        change.nextPatchSetId();
        final PatchSet originalPS = db.patchSets().get(patchSetId);
        final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
        newPatchSet.setCreatedOn(change.getCreatedOn());
        newPatchSet.setUploader(change.getOwner());
        newPatchSet.setRevision(new RevId(newCommit.name()));
        newPatchSet.setDraft(originalPS.isDraft());
        final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
        final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(newCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            Change updatedChange;
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
            }
            ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
            db.patchSets().insert(Collections.singleton(newPatchSet));
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(patchSetId)) {
                        return null;
                    }
                    if (change.getStatus() != Change.Status.DRAFT) {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
            final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            cmsg.setMessage(msg);
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        hooks.doPatchsetCreatedHook(change, newPatchSet, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            Change change = db.changes().get(changeId);
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.addParentId(commit);
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setAuthor(authorIdent);
            commitBuilder.setCommitter(myIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(change.getCreatedOn());
            newPatchSet.setUploader(change.getOwner());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    detail.setCanEditCommitMessage(change.getStatus() == Change.Status.NEW && control.canAddPatchSet());
    detail.setCanEditTopicName(control.canEditTopicName());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    detail.setCanEditCommitMessage(change.getStatus().isOpen() && control.canAddPatchSet());
    detail.setCanEditTopicName(control.canEditTopicName());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AbandonChangeHandler.Factory.class);
            factory(EditCommitMessageHandler.Factory.class);
            factory(AlterTopicHandler.Factory.class);
            factory(RestoreChangeHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EditCommitMessageHandler.Factory.class);
            factory(RestoreChangeHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#end_block

#method_before
public void display(final String commitMessage) {
    display(null, null, null, commitMessage);
}
#method_after
public void display(final String commitMessage) {
    display(null, null, false, commitMessage);
}
#end_block

#method_before
public void display(Change.Id changeId, final PatchSet.Id patchSetId, Boolean starred, final String commitMessage) {
    starPanel.clear();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (changeId != null && patchSetId != null) {
        ChangeDetailCache detailCache = ChangeCache.get(patchSetId.getParentKey()).getChangeDetailCache();
        ChangeDetail changeDetail = detailCache.get();
        if (changeDetail.canEditCommitMessage()) {
            permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
            permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new EditCommitMessageActionDialog() {

                        {
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.editCommitMessage(patchSetId, getMessageText(), createCallback());
                        }
                    }.center();
                }
            });
            edit.addStyleName(Gerrit.RESOURCES.css().changeInfoBlockEdit());
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#method_after
public void display(final PatchSet.Id patchSetId, Boolean starred, Boolean canEditCommitMessage, final String commitMessage) {
    starPanel.clear();
    Change.Id changeId = patchSetId.getParentKey();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (changeId != null) {
        permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
        permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
        if (canEditCommitMessage) {
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new CommentedActionDialog<ChangeDetail>(Util.C.titleEditCommitMessage(), Util.C.headingEditCommitMessage(), new ChangeDetailCache.IgnoreErrorCallback() {
                    }) {

                        {
                            message.setCharacterWidth(80);
                            message.setVisibleLines(20);
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.createNewPatchSet(patchSetId, getMessageText(), createCallback());
                        }
                    }.center();
                }
            });
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.editCommitMessage(patchSetId, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new InvalidChangeOperationException("Not allowed to add new Patch Sets to: " + changeId.toString());
    }
    ChangeUtil.editCommitMessage(patchSetId, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
public void display(Change chg, Boolean starred, PatchSetInfo info, final AccountInfoCache acc, SubmitTypeRecord submitTypeRecord) {
    infoBlock.display(chg, acc, submitTypeRecord);
    messageBlock.display(chg.getId(), chg.currentPatchSetId(), starred, info.getMessage());
}
#method_after
public void display(Change chg, Boolean starred, Boolean canEditCommitMessage, PatchSetInfo info, final AccountInfoCache acc, SubmitTypeRecord submitTypeRecord) {
    infoBlock.display(chg, acc, submitTypeRecord);
    messageBlock.display(chg.currentPatchSetId(), starred, canEditCommitMessage, info.getMessage());
}
#end_block

#method_before
@Override
protected void onCellDoubleClick(final int row, final int column) {
    if (getRowItem(row) instanceof PatchLine) {
        final PatchLine pl = (PatchLine) getRowItem(row);
        switch(pl.getType()) {
            case DELETE:
            case CONTEXT:
                createCommentEditor(row + 1, PC, pl.getLineA(), (short) 0);
                break;
            case INSERT:
                createCommentEditor(row + 1, PC, pl.getLineB(), (short) 1);
                break;
        }
    }
}
#method_after
@Override
protected void onCellDoubleClick(final int row, final int column) {
    if (column > C_ARROW && getRowItem(row) instanceof PatchLine) {
        final PatchLine pl = (PatchLine) getRowItem(row);
        switch(pl.getType()) {
            case DELETE:
            case CONTEXT:
                createCommentEditor(row + 1, PC, pl.getLineA(), (short) 0);
                break;
            case INSERT:
                createCommentEditor(row + 1, PC, pl.getLineB(), (short) 1);
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
@Override
protected void render(final PatchScript script) {
    final SparseHtmlFile a = getSparseHtmlFileA(script);
    final SparseHtmlFile b = getSparseHtmlFileB(script);
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            } else {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final boolean syntaxHighlighting = script.getDiffPrefs().isSyntaxHighlighting();
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final EditList.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, false, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, syntaxHighlighting, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && script.getA().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, syntaxHighlighting, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && script.getB().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            }
        }
    }
    resetHtml(nc);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n;
        switch(l.getType()) {
            case CONTEXT:
                n = Gerrit.RESOURCES.css().diffTextCONTEXT();
                break;
            case DELETE:
                n = Gerrit.RESOURCES.css().diffTextDELETE();
                break;
            case INSERT:
                n = Gerrit.RESOURCES.css().diffTextINSERT();
                break;
            default:
                continue;
        }
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#method_after
@Override
protected void render(final PatchScript script, final PatchSetDetail detail) {
    final SparseHtmlFile a = getSparseHtmlFileA(script);
    final SparseHtmlFile b = getSparseHtmlFileB(script);
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    allocateTableHeader(nc);
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            } else {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final boolean syntaxHighlighting = script.getDiffPrefs().isSyntaxHighlighting();
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final EditList.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumberForSideA(nc, hunk.getCurA());
                appendLineNumberForSideB(nc, hunk.getCurB());
                appendLineText(nc, false, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumberForSideA(nc, hunk.getCurA());
                padLineNumberForSideB(nc);
                appendLineText(nc, syntaxHighlighting, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), -1));
                if (a.size() == hunk.getCurA() && script.getA().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumberForSideA(nc);
                appendLineNumberForSideB(nc, hunk.getCurB());
                appendLineText(nc, syntaxHighlighting, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, -1, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && script.getB().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            }
        }
    }
    resetHtml(nc);
    populateTableHeader(script, detail);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n;
        switch(l.getType()) {
            case CONTEXT:
                n = Gerrit.RESOURCES.css().diffTextCONTEXT();
                break;
            case DELETE:
                n = Gerrit.RESOURCES.css().diffTextDELETE();
                break;
            case INSERT:
                n = Gerrit.RESOURCES.css().diffTextINSERT();
                break;
            default:
                continue;
        }
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#end_block

#method_before
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    final ArrayList<PatchLineComment> all = new ArrayList<PatchLineComment>();
    for (int row = 0; row < table.getRowCount(); ) {
        final List<PatchLineComment> fora;
        final List<PatchLineComment> forb;
        if (row == 0) {
            fora = cd.getForA(0);
            forb = cd.getForB(0);
        } else if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            fora = cd.getForA(pLine.getLineA());
            forb = cd.getForB(pLine.getLineB());
        } else {
            row++;
            continue;
        }
        row++;
        if (!fora.isEmpty() && !forb.isEmpty()) {
            all.clear();
            all.addAll(fora);
            all.addAll(forb);
            Collections.sort(all, BY_DATE);
            row = insert(all, row, expandComments);
        } else if (!fora.isEmpty()) {
            row = insert(fora, row, expandComments);
        } else if (!forb.isEmpty()) {
            row = insert(forb, row, expandComments);
        }
    }
}
#method_after
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    final ArrayList<PatchLineComment> all = new ArrayList<PatchLineComment>();
    for (int row = 0; row < table.getRowCount(); ) {
        final List<PatchLineComment> fora;
        final List<PatchLineComment> forb;
        if (row == R_HEAD) {
            fora = cd.getForA(R_HEAD);
            forb = cd.getForB(R_HEAD);
            row++;
            if (!fora.isEmpty()) {
                row = insert(fora, row, expandComments);
            }
            rowOfTableHeaderB = row;
            borderRowOfFileComment = row + 1;
            if (!forb.isEmpty()) {
                // Skip the Header of sideB.
                row++;
                row = insert(forb, row, expandComments);
                borderRowOfFileComment = row;
                createFileCommentBorderRow();
            }
        } else if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            fora = cd.getForA(pLine.getLineA());
            forb = cd.getForB(pLine.getLineB());
            row++;
            if (!fora.isEmpty() && !forb.isEmpty()) {
                all.clear();
                all.addAll(fora);
                all.addAll(forb);
                Collections.sort(all, BY_DATE);
                row = insert(all, row, expandComments);
            } else if (!fora.isEmpty()) {
                row = insert(fora, row, expandComments);
            } else if (!forb.isEmpty()) {
                row = insert(forb, row, expandComments);
            }
        } else {
            row++;
            continue;
        }
    }
}
#end_block

#method_before
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, PC - 2, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, PC - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, PC, Gerrit.RESOURCES.css().diffText());
}
#method_after
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    defaultStyle(row, fmt);
}
#end_block

#method_before
private int insert(final List<PatchLineComment> in, int row, boolean expandComment) {
    for (Iterator<PatchLineComment> ci = in.iterator(); ci.hasNext(); ) {
        final PatchLineComment c = ci.next();
        insertRow(row);
        bindComment(row, PC, c, !ci.hasNext(), expandComment);
        row++;
    }
    return row;
}
#method_after
private int insert(final List<PatchLineComment> in, int row, boolean expandComment) {
    for (Iterator<PatchLineComment> ci = in.iterator(); ci.hasNext(); ) {
        final PatchLineComment c = ci.next();
        if (c.getLine() == R_HEAD) {
            insertFileCommentRow(row);
        } else {
            insertRow(row);
        }
        bindComment(row, PC, c, !ci.hasNext(), expandComment);
        row++;
    }
    return row;
}
#end_block

#method_before
private void appendFileHeader(final SafeHtmlBuilder m, final String line) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextFileHeader());
    m.append(line);
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendFileHeader(final SafeHtmlBuilder m, final String line) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextFileHeader());
    m.append(line);
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void appendHunkHeader(final SafeHtmlBuilder m, final Hunk hunk) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextHunkHeader());
    m.append("@@ -");
    appendRange(m, hunk.getCurA() + 1, hunk.getEndA() - hunk.getCurA());
    m.append(" +");
    appendRange(m, hunk.getCurB() + 1, hunk.getEndB() - hunk.getCurB());
    m.append(" @@");
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendHunkHeader(final SafeHtmlBuilder m, final Hunk hunk) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextHunkHeader());
    m.append("@@ -");
    appendRange(m, hunk.getCurA() + 1, hunk.getEndA() - hunk.getCurA());
    m.append(" +");
    appendRange(m, hunk.getCurB() + 1, hunk.getEndB() - hunk.getCurB());
    m.append(" @@");
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, boolean syntaxHighlighting, final PatchLine.Type type, final SparseHtmlFile src, final int i) {
    final SafeHtml text = src.getSafeHtmlLine(i);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextCONTEXT());
            m.nbsp();
            m.append(text);
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextDELETE());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            }
            m.append("-");
            m.append(text);
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextINSERT());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            }
            m.append("+");
            m.append(text);
            break;
    }
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, boolean syntaxHighlighting, final PatchLine.Type type, final SparseHtmlFile src, final int i) {
    final SafeHtml text = src.getSafeHtmlLine(i);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextCONTEXT());
            m.nbsp();
            m.append(text);
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextDELETE());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            }
            m.append("-");
            m.append(text);
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextINSERT());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            }
            m.append("+");
            m.append(text);
            break;
    }
    m.closeTd();
}
#end_block

#method_before
private void appendNoLF(final SafeHtmlBuilder m) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextNoLF());
    m.append("\\ No newline at end of file");
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendNoLF(final SafeHtmlBuilder m) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextNoLF());
    m.append("\\ No newline at end of file");
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void destroyEditor(final int row, final int col) {
    table.clearCell(row, col);
    final int span = table.getFlexCellFormatter().getRowSpan(row, col);
    boolean removeRow = true;
    final int nCells = table.getCellCount(row);
    for (int cell = 0; cell < nCells; cell++) {
        if (table.getWidget(row, cell) != null) {
            removeRow = false;
            break;
        }
    }
    if (removeRow) {
        for (int r = row - 1; 0 <= r; r--) {
            boolean data = false;
            for (int c = 0; c < table.getCellCount(r); c++) {
                data |= table.getWidget(r, c) != null;
                final int s = table.getFlexCellFormatter().getRowSpan(r, c) - 1;
                if (r + s == row) {
                    table.getFlexCellFormatter().setRowSpan(r, c, s);
                }
            }
            if (!data) {
                break;
            }
        }
        table.removeRow(row);
        removeFileCommentBorderRow(row, col);
    } else {
        // 
        table.getFlexCellFormatter().setStyleName(row, col, Gerrit.RESOURCES.css().diffText());
        if (span != 1) {
            table.getFlexCellFormatter().setRowSpan(row, col, 1);
            for (int r = row + 1; r < row + span; r++) {
                table.insertCell(r, col);
                // 
                table.getFlexCellFormatter().setStyleName(r, col, Gerrit.RESOURCES.css().diffText());
            }
        }
    }
}
#method_after
private void destroyEditor(final int row, final int col) {
    table.clearCell(row, col);
    final int span = table.getFlexCellFormatter().getRowSpan(row, col);
    boolean removeRow = true;
    final int nCells = table.getCellCount(row);
    for (int cell = 0; cell < nCells; cell++) {
        if (table.getWidget(row, cell) != null) {
            removeRow = false;
            break;
        }
    }
    if (removeRow) {
        destroyCommentRow(row);
    } else {
        destroyComment(row, col, span);
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, A, psListOfHeaderA);
    table.setWidget(R_HEAD, B, psListOfHeaderB);
    // Populate icons to lineNumber column header.
    if (psListOfHeaderA.isFile) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (psListOfHeaderB.isFile) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
    // Populate icons to lineNumber column header.
    if (headerSideA.isFile()) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (headerSideB.isFile()) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#end_block

#method_before
private void createFileCommentBorderRow(final int row) {
    if (row == 1 && !isFileCommentBorderRowExist) {
        isFileCommentBorderRowExist = true;
        table.insertRow(R_HEAD + 2);
        final CellFormatter fmt = table.getCellFormatter();
        // 
        fmt.addStyleName(// 
        R_HEAD + 2, // 
        C_ARROW, Gerrit.RESOURCES.css().iconCellOfFileCommentRow());
        defaultStyle(R_HEAD + 2, fmt);
        final Element iconCell = fmt.getElement(R_HEAD + 2, C_ARROW);
        UIObject.setStyleName(DOM.getParent(iconCell), Gerrit.RESOURCES.css().borderRowOfFileComment(), true);
    }
}
#method_after
private void createFileCommentBorderRow(final int row) {
    if (row == 1 && !isFileCommentBorderRowExist) {
        isFileCommentBorderRowExist = true;
        table.insertRow(R_HEAD + 2);
        final CellFormatter fmt = table.getCellFormatter();
        // 
        fmt.addStyleName(// 
        R_HEAD + 2, // 
        C_ARROW, Gerrit.RESOURCES.css().iconCellOfFileCommentRow());
        defaultStyle(R_HEAD + 2, fmt);
        final Element iconCell = fmt.getElement(R_HEAD + 2, C_ARROW);
        UIObject.setStyleName(DOM.getParent(iconCell), Gerrit.RESOURCES.css().fileCommentBorder(), true);
    }
}
#end_block

#method_before
public void notifyDraftDelta(final int delta) {
    if (fileList != null) {
        fileList.notifyDraftDelta(patchKey, delta);
    }
    Widget p = getParent();
    while (p != null) {
        if (p instanceof CommentEditorContainer) {
            ((CommentEditorContainer) p).notifyDraftDelta(delta);
            break;
        }
        p = p.getParent();
    }
}
#method_after
@Override
public void notifyDraftDelta(final int delta) {
    if (fileList != null) {
        fileList.notifyDraftDelta(patchKey, delta);
    }
    Widget p = getParent();
    while (p != null) {
        if (p instanceof CommentEditorContainer) {
            ((CommentEditorContainer) p).notifyDraftDelta(delta);
            break;
        }
        p = p.getParent();
    }
}
#end_block

#method_before
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) {
    if (Gerrit.isSignedIn()) {
        if (R_HEAD <= line) {
            final Patch.Key parentKey;
            final short side;
            switch(file) {
                case 0:
                    if (idSideA == null) {
                        parentKey = new Patch.Key(idSideB, patchKey.get());
                        side = (short) 0;
                    } else {
                        parentKey = new Patch.Key(idSideA, patchKey.get());
                        side = (short) 1;
                    }
                    break;
                case 1:
                    parentKey = new Patch.Key(idSideB, patchKey.get());
                    side = (short) 1;
                    break;
                default:
                    throw new RuntimeException("unexpected file id " + file);
            }
            final PatchLineComment newComment = new PatchLineComment(new PatchLineComment.Key(parentKey, null), line, Gerrit.getUserAccount().getId(), null);
            newComment.setSide(side);
            newComment.setMessage("");
            createCommentEditor(suggestRow, column, newComment).setFocus(true);
        }
    } else {
        Gerrit.doSignIn(History.getToken());
    }
}
#method_after
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) {
    if (Gerrit.isSignedIn()) {
        if (R_HEAD <= line) {
            final Patch.Key parentKey;
            final short side;
            switch(file) {
                case 0:
                    if (idSideA == null) {
                        parentKey = new Patch.Key(idSideB, patchKey.get());
                        side = (short) 0;
                    } else {
                        parentKey = new Patch.Key(idSideA, patchKey.get());
                        side = (short) 1;
                    }
                    break;
                case 1:
                    parentKey = new Patch.Key(idSideB, patchKey.get());
                    side = (short) 1;
                    break;
                default:
                    throw new RuntimeException("unexpected file id " + file);
            }
            final PatchLineComment newComment = new PatchLineComment(new PatchLineComment.Key(parentKey, null), line, Gerrit.getUserAccount().getId(), null);
            newComment.setSide(side);
            newComment.setMessage("");
            findOrCreateCommentEditor(suggestRow, column, newComment, true).setFocus(true);
        }
    } else {
        Gerrit.doSignIn(History.getToken());
    }
}
#end_block

#method_before
private void createReplyEditor() {
    final PatchLineComment newComment = newComment();
    newComment.setMessage("");
    createEditor(newComment).setFocus(true);
}
#method_after
private void createReplyEditor() {
    final PatchLineComment newComment = newComment();
    newComment.setMessage("");
    findOrCreateEditor(newComment, true).setFocus(true);
}
#end_block

#method_before
private void cannedReply(String message) {
    final PatchLineComment newComment = newComment();
    newComment.setMessage(message);
    CommentEditorPanel p = createEditor(newComment);
    if (p == null) {
        enableButtons(false);
        PatchUtil.DETAIL_SVC.saveDraft(newComment, new GerritCallback<PatchLineComment>() {

            public void onSuccess(final PatchLineComment result) {
                enableButtons(true);
                notifyDraftDelta(1);
                createEditor(result).setOpen(false);
            }

            @Override
            public void onFailure(Throwable caught) {
                enableButtons(true);
                super.onFailure(caught);
            }
        });
    } else {
        if (!p.isOpen()) {
            p.setOpen(true);
        }
        p.setFocus(true);
    }
}
#method_after
private void cannedReply(String message) {
    final PatchLineComment newComment = newComment();
    newComment.setMessage(message);
    CommentEditorPanel p = findOrCreateEditor(newComment, false);
    if (p == null) {
        enableButtons(false);
        PatchUtil.DETAIL_SVC.saveDraft(newComment, new GerritCallback<PatchLineComment>() {

            @Override
            public void onSuccess(final PatchLineComment result) {
                enableButtons(true);
                notifyDraftDelta(1);
                findOrCreateEditor(result, true).setOpen(false);
            }

            @Override
            public void onFailure(Throwable caught) {
                enableButtons(true);
                super.onFailure(caught);
            }
        });
    } else {
        if (!p.isOpen()) {
            p.setOpen(true);
        }
        p.setFocus(true);
    }
}
#end_block

#method_before
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB, DoubleClickHandler handler) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    isFile = isFile();
    linkPanel.clear();
    doubleClickPanel.addDoubleClickHandler(handler);
    if (isFile) {
        doubleClickPanel.setTitle(PatchUtil.C.addFileCommentByDoubleClick());
    }
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    patchSet.addDoubleClickHandler(handler);
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    linkPanel.clear();
    if (isFile()) {
        linkPanel.setTitle(PatchUtil.C.addFileCommentByDoubleClick());
    }
    patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private boolean isFile() {
    boolean isCommitMessage = Patch.COMMIT_MSG.equals(script.getNewName());
    return !(// 
    isCommitMessage || // 
    (side == Side.A && 0 >= script.getA().size()) || (side == Side.B && 0 >= script.getB().size()));
}
#method_after
public boolean isFile() {
    boolean isCommitMessage = Patch.COMMIT_MSG.equals(script.getNewName());
    return !(// 
    isCommitMessage || // 
    (side == Side.A && 0 >= script.getA().size()) || (side == Side.B && 0 >= script.getB().size()));
}
#end_block

#method_before
private Anchor createDownloadLink() {
    if (!isFile) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#method_after
private Anchor createDownloadLink() {
    if (!isFile()) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, A, psListOfHeaderA);
    table.setWidget(R_HEAD, B, psListOfHeaderB);
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
}
#end_block

#method_before
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    isFile = isFile();
    linkPanel.clear();
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    linkPanel.clear();
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private Anchor createDownloadLink() {
    if (!isFile) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#method_after
private Anchor createDownloadLink() {
    if (!isFile()) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, PC, psListOfHeaderA);
    table.setWidget(rowOfTableHeaderB, PC, psListOfHeaderB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, PC, headerSideA);
    table.setWidget(rowOfTableHeaderB, PC, headerSideB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(MaterializedGroupMembership.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    bind(GitReferenceUpdated.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), CommitValidatorListener.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    newProgress.end();
    doReplaces();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
                commandProgress.update(1);
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                addMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                addMessage("  " + url + c.getChangeId());
            }
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        if (cmd.getResult().equals(ReceiveCommand.Result.NOT_ATTEMPTED)) {
            cmd.execute(rp);
        }
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "can not delete references");
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        cmd.execute(rp);
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "can not upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidatorListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.validate(cmd, project, ctl.getRefName(), c, currentUser);
        if (!validationResult.validated) {
            reject(cmd, validationResult.why);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidationListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
        String pluginName = pluginLoader.getPluginName(validator);
        if (!validationResult.validated) {
            reject(cmd, String.format("%s (rejected by plugin %s)", validationResult.message, pluginName));
            return false;
        } else if (!Strings.isNullOrEmpty(validationResult.message)) {
            addMessage(String.format("%s (from plugin %s)", pluginName));
        }
    }
    return true;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req, true);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (Exception e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(result.change);
                cm.setFrom(currentUser.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void insertAncestors(PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#method_after
private void insertAncestors(ReviewDb db, PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
public static CommitValidationResult newFailure(String why) {
    return new CommitValidationResult(false, why);
}
#method_after
public static CommitValidationResult newFailure(String message) {
    return new CommitValidationResult(false, message);
}
#end_block

#method_before
private InitStep loadInitStep(File jar) {
    try {
        ClassLoader pluginLoader = new URLClassLoader(new URL[] { jar.toURI().toURL() }, InitPluginStepsLoader.class.getClassLoader());
        JarFile jarFile = new JarFile(jar);
        Attributes jarFileAttributes = jarFile.getManifest().getMainAttributes();
        String initClassName = jarFileAttributes.getValue("Gerrit-InitStep");
        if (initClassName == null) {
            return null;
        }
        @SuppressWarnings("unchecked")
        Class<? extends InitStep> initStepClass = (Class<? extends InitStep>) pluginLoader.loadClass(initClassName);
        return initInjector.getInstance(initStepClass);
    } catch (ClassCastException e) {
        log.warn("InitStep from plugin " + jar.getName() + " does not implement " + InitStep.class.getName(), e);
        return null;
    } catch (Exception e) {
        log.error("Cannot load and get plugin init step for " + jar, e);
        return null;
    }
}
#method_after
private InitStep loadInitStep(File jar) {
    try {
        ClassLoader pluginLoader = new URLClassLoader(new URL[] { jar.toURI().toURL() }, InitPluginStepsLoader.class.getClassLoader());
        JarFile jarFile = new JarFile(jar);
        Attributes jarFileAttributes = jarFile.getManifest().getMainAttributes();
        String initClassName = jarFileAttributes.getValue("Gerrit-InitStep");
        if (initClassName == null) {
            return null;
        }
        @SuppressWarnings("unchecked")
        Class<? extends InitStep> initStepClass = (Class<? extends InitStep>) pluginLoader.loadClass(initClassName);
        return getPluginInjector(jar).getInstance(initStepClass);
    } catch (ClassCastException e) {
        ui.message("WARN: InitStep from plugin %s does not implement %s (Exception: %s)", jar.getName(), InitStep.class.getName(), e.getMessage());
        return null;
    } catch (Exception e) {
        ui.message("WARN: Cannot load and get plugin init step for %s (Exception: %s)", jar, e.getMessage());
        return null;
    }
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") && pathname.isFile());
        }
    });
    if (matches == null) {
        ui.message("WARN: Cannot list %s", pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    Arrays.sort(matches, new Comparator<File>() {

        @Override
        public int compare(File o1, File o2) {
            return o1.getName().compareTo(o2.getName());
        }
    });
    return Arrays.asList(matches);
}
#end_block

#method_before
private void initPlugins() throws Exception {
    Collection<? extends InitStep> pluginsInitSteps = pluginLoader.getInitSteps();
    for (InitStep initStep : pluginsInitSteps) {
        initStep.run();
    }
}
#method_after
private void initPlugins() throws Exception {
    for (InitStep initStep : pluginLoader.getInitSteps()) {
        initStep.run();
    }
}
#end_block

#method_before
@Override
public String getUrl() {
    // not used
    return null;
}
#method_after
@Override
public String getUrl() {
    // not used
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public String getUrl() {
    String database = optional(cfg, "database");
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    File db = site.resolve(database);
    try {
        db = db.getCanonicalFile();
    } catch (IOException e) {
        db = db.getAbsoluteFile();
    }
    return "jdbc:h2:" + db.toURI().toString();
}
#method_after
@Override
public String getUrl() {
    String database = cfg.getString("database", null, "database");
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    File db = site.resolve(database);
    try {
        db = db.getCanonicalFile();
    } catch (IOException e) {
        db = db.getAbsoluteFile();
    }
    return "jdbc:h2:" + db.toURI().toString();
}
#end_block

#method_before
@Override
public String getUrl() {
    return required(cfg, "url");
}
#method_after
@Override
public String getUrl() {
    return ConfigUtil.getRequired(cfg, "database", "url");
}
#end_block

#method_before
private DataSource open(final SitePaths site, final Config cfg, final Context context, final DataSourceType dst) {
    String driver = optional(cfg, "driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = optional(cfg, "url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = optional(cfg, "username");
    String password = optional(cfg, "password");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(cfg.getInt("database", "poollimit", 8));
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        return ds;
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return new SimpleDataSource(p);
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#method_after
private DataSource open(final SitePaths site, final Config cfg, final Context context, final DataSourceType dst) {
    ConfigSection dbs = new ConfigSection(cfg, "database");
    String driver = dbs.optional("driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = dbs.optional("url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = dbs.optional("username");
    String password = dbs.optional("password");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(cfg.getInt("database", "poollimit", 8));
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        return ds;
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return new SimpleDataSource(p);
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#end_block

#method_before
@Override
public final NamedInputStream getIndexScript() {
    return getScriptAsStream(indexScript);
}
#method_after
@Override
public ScriptRunner getIndexScript() throws IOException {
    return getScriptRunner("index_generic.sql");
}
#end_block

#method_before
@Override
public final NamedInputStream getNextValScript() {
    return getScriptAsStream(nextValScript);
}
#method_after
@Override
public ScriptRunner getNextValScript() throws IOException {
    return ScriptRunner.NOOP;
}
#end_block

#method_before
public void create(final ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    final JdbcExecutor e = new JdbcExecutor(jdbc);
    try {
        jdbc.updateSchema(e);
    } finally {
        e.close();
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = versionNbr;
    db.schemaVersion().insert(Collections.singleton(sVer));
    final SystemConfig sConfig = initSystemConfig(db);
    initVerifiedCategory(db);
    initCodeReviewCategory(db, sConfig);
    if (mgr != null) {
        // TODO This should never be null when initializing a site.
        initWildCardProject();
    }
    runScript(dataSourceType.getIndexScript(), db);
    runScript(dataSourceType.getNextValScript(), db);
}
#method_after
public void create(final ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    final JdbcExecutor e = new JdbcExecutor(jdbc);
    try {
        jdbc.updateSchema(e);
    } finally {
        e.close();
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = versionNbr;
    db.schemaVersion().insert(Collections.singleton(sVer));
    final SystemConfig sConfig = initSystemConfig(db);
    initVerifiedCategory(db);
    initCodeReviewCategory(db, sConfig);
    if (mgr != null) {
        // TODO This should never be null when initializing a site.
        initWildCardProject();
    }
    dataSourceType.getIndexScript().run(db);
    dataSourceType.getNextValScript().run(db);
}
#end_block

#method_before
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    b.append("jdbc:postgresql://");
    b.append(hostname(optional(cfg, "hostname")));
    b.append(port(optional(cfg, "port")));
    b.append("/");
    b.append(required(cfg, "database"));
    return b.toString();
}
#method_after
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbc = new ConfigSection(cfg, "database");
    b.append("jdbc:postgresql://");
    b.append(hostname(dbc.optional("hostname")));
    b.append(port(dbc.optional("port")));
    b.append("/");
    b.append(dbc.required("database"));
    return b.toString();
}
#end_block

#method_before
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    b.append("jdbc:mysql://");
    b.append(hostname(optional(cfg, "hostname")));
    b.append(port(optional(cfg, "port")));
    b.append("/");
    b.append(required(cfg, "database"));
    return b.toString();
}
#method_after
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbs = new ConfigSection(cfg, "database");
    b.append("jdbc:mysql://");
    b.append(hostname(dbs.optional("hostname")));
    b.append(port(dbs.optional("port")));
    b.append("/");
    b.append(dbs.required("database"));
    return b.toString();
}
#end_block

#method_before
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(getProjectKey(), branchName, rev, new GerritCallback<ListBranchesResult>() {

        public void onSuccess(final ListBranchesResult result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            display(result.getBranches());
        }

        @Override
        public void onFailure(final Throwable caught) {
            addBranch.setEnabled(true);
            if (caught instanceof RemoteJsonException) {
                final String msg = caught.getMessage();
                String userMsg = null;
                if (InvalidNameException.MESSAGE.equals(msg)) {
                    selectAllAndFocus(nameTxtBox);
                    userMsg = Gerrit.M.invalidBranchName(branchName);
                } else if (InvalidRevisionException.MESSAGE.equals(msg)) {
                    selectAllAndFocus(irevTxtBox);
                    userMsg = Gerrit.M.invalidRevision(rev);
                } else if (msg.startsWith(BranchCreationNotAllowedUnderRefnamePrefixException.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String refnamePrefix = caught.getMessage().substring(BranchCreationNotAllowedUnderRefnamePrefixException.MESSAGE.length());
                    userMsg = Gerrit.M.branchCreationNotAllowedUnderRefnamePrefix(refnamePrefix);
                } else if (msg.startsWith(BranchAlreadyExistsException.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String existingBranchName = caught.getMessage().substring(BranchAlreadyExistsException.MESSAGE.length());
                    userMsg = Gerrit.M.branchAlreadyExists(existingBranchName);
                } else if (msg.startsWith(BranchCreationNotAllowedUnderExistingBranch.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String existingBranchName = caught.getMessage().substring(BranchCreationNotAllowedUnderExistingBranch.MESSAGE.length());
                    userMsg = Gerrit.M.branchCreationNotAllowedUnderExistingBranch(branchName, existingBranchName);
                }
                if (userMsg != null) {
                    new ErrorDialog(userMsg).center();
                    return;
                }
            }
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(getProjectKey(), branchName, rev, new GerritCallback<AddBranchResult>() {

        public void onSuccess(final AddBranchResult result) {
            addBranch.setEnabled(true);
            if (!result.hasError()) {
                nameTxtBox.setText("");
                irevTxtBox.setText("");
                display(result.getListBranchesResult().getBranches());
            } else {
                final AddBranchResult.Error error = result.getError();
                final String msg;
                switch(error.getType()) {
                    case INVALID_NAME:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.invalidBranchName(branchName);
                        break;
                    case INVALID_REVISION:
                        selectAllAndFocus(irevTxtBox);
                        msg = Gerrit.M.invalidRevision(rev);
                        break;
                    case BRANCH_CREATION_NOT_ALLOWED_UNDER_REFNAME_PREFIX:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchCreationNotAllowedUnderRefnamePrefix(error.getRefname());
                        break;
                    case BRANCH_ALREADY_EXISTS:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchAlreadyExists(error.getRefname());
                        break;
                    case BRANCH_CREATION_CONFLICT:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchCreationConflict(branchName, error.getRefname());
                        break;
                    default:
                        msg = Gerrit.M.branchCreationFailed(branchName, error.toString());
                }
                new ErrorDialog(msg).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            addBranch.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
void deleteChecked() {
    final StringBuilder message = new StringBuilder();
    message.append("<b>").append(Gerrit.C.branchDeletionConfirmationMessage()).append("</b>");
    message.append("<p>");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                message.append(", <br>");
            }
            message.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    message.append("</p>");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

        @Override
        public void onOk() {
            Util.PROJECT_SVC.deleteBranch(getProjectKey(), ids, new GerritCallback<Set<Branch.NameKey>>() {

                public void onSuccess(final Set<Branch.NameKey> deleted) {
                    for (int row = 1; row < table.getRowCount(); ) {
                        final Branch k = getRowItem(row);
                        if (k != null && deleted.contains(k.getNameKey())) {
                            table.removeRow(row);
                        } else {
                            row++;
                        }
                    }
                }
            });
        }
    });
    confirmationDialog.center();
}
#method_after
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchDeletionConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids);
        }
    });
    confirmationDialog.center();
}
#end_block

#method_before
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor(c.getLinkName(), false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if ("refs/meta/config".equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    if (c != null) {
        fmt.addStyleName(row, 4, dataCellStyle);
    }
    setRowItem(row, k);
}
#method_after
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor(c.getLinkName(), false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if ("refs/meta/config".equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    if (c != null) {
        fmt.addStyleName(row, 4, dataCellStyle);
    }
    setRowItem(row, k);
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException, InvalidNameException, InvalidRevisionException, IOException, BranchCreationNotAllowedUnderRefnamePrefixException, BranchAlreadyExistsException, BranchCreationNotAllowedUnderExistingBranch {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        throw new InvalidNameException();
    }
    if (MagicBranch.isMagicBranch(refname)) {
        throw new BranchCreationNotAllowedUnderRefnamePrefixException(MagicBranch.getMagicRefNamePrefix(refname));
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName);
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    replication.scheduleUpdate(name.getParentKey(), refname);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(refname) != null) {
                        throw new BranchAlreadyExistsException(refname);
                    }
                    String refPrefix = getRefPrefix(refname);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new BranchCreationNotAllowedUnderExistingBranch(refPrefix);
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } finally {
        repo.close();
    }
    return listBranchesFactory.create(projectName).call();
}
#method_after
@Override
public AddBranchResult call() throws NoSuchProjectException, IOException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.INVALID_NAME, refname));
    }
    if (MagicBranch.isMagicBranch(refname)) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_CREATION_NOT_ALLOWED_UNDER_REFNAME_PREFIX, MagicBranch.getMagicRefNamePrefix(refname)));
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName);
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), refname);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(refname) != null) {
                        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_ALREADY_EXISTS, refname));
                    }
                    String refPrefix = getRefPrefix(refname);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_CREATION_CONFLICT, refPrefix));
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.INVALID_REVISION));
    } finally {
        repo.close();
    }
    return new AddBranchResult(listBranchesFactory.create(projectName).call());
}
#end_block

#method_before
private String getRefPrefix(final String refName) {
    int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#method_after
private static String getRefPrefix(final String refName) {
    final int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append("      $ scp -p -P 29418 review.example.com:hooks/commit-msg .git/hooks/");
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#method_after
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#end_block

#method_before
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#method_after
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#end_block

#method_before
private void updateSuperProjects(final Branch.NameKey updatedBranch, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            String msgbuf = msg;
            if (msgbuf == null) {
                // Initialize the message buffer
                msgbuf = "";
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.statusCode == CommitMergeStatus.CLEAN_MERGE || c.statusCode == CommitMergeStatus.CLEAN_PICK || c.statusCode == CommitMergeStatus.CLEAN_REBASE)) {
                        msgbuf += "\n";
                        msgbuf += c.getFullMessage();
                    }
                }
            }
            // update subscribers of this module
            for (final SubmoduleSubscription s : subscribers) {
                if (!updatedSubscribers.add(s.getSuperProject())) {
                    log.error("Possible circular subscription involving " + s.toString());
                } else {
                    Map<Branch.NameKey, ObjectId> modules = new HashMap<Branch.NameKey, ObjectId>(1);
                    modules.put(updatedBranch, mergedCommit);
                    Map<Branch.NameKey, String> paths = new HashMap<Branch.NameKey, String>(1);
                    paths.put(updatedBranch, s.getPath());
                    try {
                        updateGitlinks(s.getSuperProject(), modules, paths, msgbuf);
                    } catch (SubmoduleException e) {
                        throw e;
                    }
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            String msgbuf = msg;
            if (msgbuf == null) {
                // Initialize the message buffer
                msgbuf = "";
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.statusCode == CommitMergeStatus.CLEAN_MERGE || c.statusCode == CommitMergeStatus.CLEAN_PICK || c.statusCode == CommitMergeStatus.CLEAN_REBASE)) {
                        msgbuf += "\n";
                        msgbuf += c.getFullMessage();
                    }
                }
            }
            // update subscribers of this module
            for (final SubmoduleSubscription s : subscribers) {
                if (!updatedSubscribers.add(s.getSuperProject())) {
                    log.error("Possible circular subscription involving " + s.toString());
                } else {
                    Map<Branch.NameKey, ObjectId> modules = new HashMap<Branch.NameKey, ObjectId>(1);
                    modules.put(updatedBranch, mergedCommit);
                    Map<Branch.NameKey, String> paths = new HashMap<Branch.NameKey, String>(1);
                    paths.put(updatedBranch, s.getPath());
                    try {
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, msgbuf);
                    } catch (SubmoduleException e) {
                        throw e;
                    }
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#end_block

#method_before
private void updateGitlinks(final Branch.NameKey subscriber, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = rw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (pdb != null) {
            pdb.close();
        }
    }
}
#method_after
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.release();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final RevWalk rw = new RevWalk(pdb);
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#method_after
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final RevWalk rw = new RevWalk(pdb);
    try {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    } finally {
        rw.release();
    }
}
#end_block

#method_before
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            final boolean isMergeable = !toMerge.isEmpty() ? createStrategy().dryRun(branchTip, toMerge.remove(0)) : false;
            // update sha1 tested merge.
            if (destBranchRef != null) {
                change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
            } else {
                change.setLastSha1MergeTested(new RevId(""));
            }
            change.setMergeable(isMergeable);
            db.changes().update(Collections.singleton(change));
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            if (!toMerge.isEmpty()) {
                final Entry<SubmitType, CodeReviewCommit> e = toMerge.entries().iterator().next();
                final boolean isMergeable = createStrategy(e.getKey()).dryRun(branchTip, e.getValue());
                // update sha1 tested merge.
                if (destBranchRef != null) {
                    change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
                } else {
                    change.setLastSha1MergeTested(new RevId(""));
                }
                change.setMergeable(isMergeable);
                db.changes().update(Collections.singleton(change));
            } else {
                log.error("Test merge attempt for change: " + change.getId() + " failed");
            }
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        final List<Change> submitted = db.changes().submitted(destBranch).toList();
        final RefUpdate branchUpdate = openBranch();
        validateChangeList(submitted);
        preMerge();
        updateBranch(branchUpdate);
        updateChangeStatus(submitted);
        updateSubscriptions(submitted);
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        openBranch();
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<SubmitType> submitTypes = new HashSet<Project.SubmitType>(toMerge.keySet());
            for (final SubmitType submitType : submitTypes) {
                final RefUpdate branchUpdate = openBranch();
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.change, message(commit.change, capable.getMessage()), false);
            }
        }
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private void preMerge() throws MergeException {
    final SubmitStrategy strategy = createStrategy();
    mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    commits.putAll(strategy.getNewCommits());
}
#method_after
private void preMerge(final SubmitStrategy strategy, final List<CodeReviewCommit> toMerge) throws MergeException {
    mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    commits.putAll(strategy.getNewCommits());
}
#end_block

#method_before
private SubmitStrategy createStrategy() throws MergeException {
    return submitStrategyFactory.create(destProject.getSubmitType(), db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, destProject.isUseContentMerge());
}
#method_after
private SubmitStrategy createStrategy(final SubmitType submitType) throws MergeException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, destProject.isUseContentMerge());
}
#end_block

#method_before
private void validateChangeList(final List<Change> submitted) throws MergeException {
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        commit.add(canMergeFlag);
        toMerge.add(commit);
    }
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void updateBranch(final RefUpdate branchUpdate) throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    String msg;
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                        msg = "will retry";
                    } else {
                        msg = "will not retry";
                    }
                    throw new IOException(branchUpdate.getResult().name() + ", " + msg);
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_REBASE:
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db, repo);
    try {
        codeReviewNotes.create(merged, computeMergeCommitAuthor(db, identifiedUserFactory, myIdent, rw, merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.fire(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_REBASE:
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    potentiallyStillSubmittable.add(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db, repo);
    try {
        codeReviewNotes.create(merged, computeMergeCommitAuthor(db, identifiedUserFactory, myIdent, rw, merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.fire(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        capable = new Capable(txt);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#method_after
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.change;
    final boolean submitStillPossible = isSubmitForMissingCommitsStillPossible(commit);
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        capable = new Capable(txt);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final MergedSender cm = mergedSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final MergedSender cm = mergedSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            PatchSetApproval submitter;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                    submitter = getSubmitter(reviewDb, c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (submitter != null) {
                    cm.setFrom(submitter.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m = newThreeWayMerger(args.repo, args.inserter, args.useContentMerge);
        try {
            if (newMergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(newMergeTip, n)) {
                    newMergeTip = writeCherryPickCommit(m, newMergeTip, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (!hasMissingDependencies(args.mergeSorter, n)) {
                    if (args.rw.isMergedInto(newMergeTip, n)) {
                        newMergeTip = n;
                    } else {
                        newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.useContentMerge, args.destBranch, newMergeTip, n);
                    }
                    final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                    setRefLogIdent(submitApproval);
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        } catch (OrmException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return newMergeTip;
}
#method_after
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m = newThreeWayMerger(args.repo, args.inserter, args.useContentMerge);
        try {
            if (newMergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(newMergeTip, n)) {
                    newMergeTip = writeCherryPickCommit(m, newMergeTip, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (!hasMissingDependencies(args.mergeSorter, n)) {
                    if (args.rw.isMergedInto(newMergeTip, n)) {
                        newMergeTip = n;
                    } else {
                        newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                    }
                    final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                    setRefLogIdent(submitApproval);
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        } catch (OrmException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return newMergeTip;
}
#end_block

#method_before
private CodeReviewCommit writeCherryPickCommit(final Merger m, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = args.db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = args.identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(args.inserter, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.rw.parseCommit(id);
    n.change.nextPatchSetId();
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            args.db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#method_after
private CodeReviewCommit writeCherryPickCommit(final Merger m, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = args.db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            @Override
            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = args.identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(args.inserter, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.rw.parseCommit(id);
    n.change.nextPatchSetId();
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            args.db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#end_block

#method_before
public static void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
public static void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#end_block

#method_before
public static ObjectInserter createDryRunInserter() {
    return new ObjectInserter() {

        @Override
        public ObjectId insert(int objectType, long length, InputStream in) throws IOException {
            return createRandomObjectId();
        }

        @Override
        public PackParser newPackParser(InputStream in) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public void flush() throws IOException {
        // Do nothing.
        }

        @Override
        public void release() {
        // Do nothing.
        }
    };
}
#method_after
public static ObjectInserter createDryRunInserter() {
    return new ObjectInserter() {

        private final MutableObjectId buf = new MutableObjectId();

        private final static int LAST_BYTE = Constants.OBJECT_ID_LENGTH - 1;

        @Override
        public ObjectId insert(int objectType, long length, InputStream in) throws IOException {
            // create non-existing dummy ID
            buf.setByte(LAST_BYTE, buf.getByte(LAST_BYTE) + 1);
            return buf.copy();
        }

        @Override
        public PackParser newPackParser(InputStream in) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public void flush() throws IOException {
        // Do nothing.
        }

        @Override
        public void release() {
        // Do nothing.
        }
    };
}
#end_block

#method_before
public static CodeReviewCommit mergeOneCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final boolean useContentMerge, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter, useContentMerge);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(reviewDb, identifiedUserFactory, myIdent, rw, inserter, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(rw, mergeTip, n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return mergeTip;
}
#method_after
public static CodeReviewCommit mergeOneCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final boolean useContentMerge, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter, useContentMerge);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(reviewDb, identifiedUserFactory, myIdent, rw, inserter, canMergeFlag, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return mergeTip;
}
#end_block

#method_before
private static CodeReviewCommit failed(final RevWalk rw, final CodeReviewCommit mergeTip, final CodeReviewCommit n, final CommitMergeStatus failure) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit failed;
    while ((failed = (CodeReviewCommit) rw.next()) != null) {
        failed.statusCode = failure;
    }
    return failed;
}
#method_after
private static CodeReviewCommit failed(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final CodeReviewCommit n, final CommitMergeStatus failure) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit failed;
    while ((failed = (CodeReviewCommit) rw.next()) != null) {
        failed.statusCode = failure;
    }
    return failed;
}
#end_block

#method_before
public static CodeReviewCommit writeMergeCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final RevWalk rw, final ObjectInserter inserter, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final ObjectId treeId, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeMergeCommitAuthor(reviewDb, identifiedUserFactory, myIdent, rw, merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    return (CodeReviewCommit) rw.parseCommit(commit(inserter, mergeCommit));
}
#method_after
public static CodeReviewCommit writeMergeCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final ObjectId treeId, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeMergeCommitAuthor(reviewDb, identifiedUserFactory, myIdent, rw, merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    return (CodeReviewCommit) rw.parseCommit(commit(inserter, mergeCommit));
}
#end_block

#method_before
public boolean canAbandon() {
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getCurrentUser().getCapabilities().canAdministrateServer();
}
#method_after
public boolean canAbandon() {
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getCurrentUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon();
}
#end_block

#method_before
public boolean canRestore() {
    // Anyone who can abandon the change can restore it back
    return canAbandon();
}
#method_after
public boolean canRestore() {
    return // Anyone who can abandon the change can restore it back
    canAbandon() && // as long as you can upload too
    getRefControl().canUpload();
}
#end_block

#method_before
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // 
        if (// branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    return evaluatePrologRules(db, patchSet, cd, fastEvalLabels, "submit_rule", "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results");
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, change, cd, fastEvalLabels, "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results");
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        return logRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    return resultsToSubmitRecord(evaluator.getSubmitRule(), results);
}
#end_block

#method_before
private void appliedBy(SubmitRecord.Label label, Term status) throws UserTermExpected {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        } else {
            throw new UserTermExpected(label);
        }
    }
}
#method_after
private void appliedBy(SubmitRecord.Label label, Term status) {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        }
    }
}
#end_block

#method_before
private static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#method_after
public static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#end_block

#method_before
private void reduceToMinimalMerge() throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = new MergeSorter(rw, alreadyAccepted, CAN_MERGE).sort(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toMerge.clear();
    toMerge.addAll(heads);
    Collections.sort(toMerge, new Comparator<CodeReviewCommit>() {

        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
private void reduceToMinimalMerge() throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = new MergeSorter(rw, alreadyAccepted, CAN_MERGE).sort(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toMerge.clear();
    toMerge.addAll(heads);
    Collections.sort(toMerge, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    final Change oldChange = n.change;
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    db.patchSets().insert(Collections.singleton(ps));
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    this.submitted.remove(oldChange);
    this.submitted.add(n.change);
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            @Override
            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    final Change oldChange = n.change;
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    db.patchSets().insert(Collections.singleton(ps));
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    this.submitted.remove(oldChange);
    this.submitted.add(n.change);
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    switch(destProject.getSubmitType()) {
                        case FAST_FORWARD_ONLY:
                            break;
                        case CHERRY_PICK:
                        case MERGE_ALWAYS:
                        case MERGE_IF_NECESSARY:
                        default:
                            mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                            break;
                    }
                    break;
            }
            throw new IOException(branchUpdate.getResult().name());
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    switch(destProject.getSubmitType()) {
                        case CHERRY_PICK:
                        case MERGE_ALWAYS:
                        case MERGE_IF_NECESSARY:
                            mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                            break;
                        case FAST_FORWARD_ONLY:
                            // Not mergeable, no need to recheck.
                            break;
                        default:
                            log.warn("Lock failure in project with unknown merge type " + destProject.getSubmitType());
                            break;
                    }
                    break;
            }
            throw new IOException(branchUpdate.getResult().name());
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeSubmitRecords) {
                    try {
                        PatchSet.Id psId = d.getChange().currentPatchSetId();
                        Change.Id changeId = psId.getParentKey();
                        ChangeControl control = changeControlFactory.validateFor(changeId);
                        List<SubmitRecord> submitResult = control.canSubmit(db.get(), psId);
                        eventFactory.addSubmitRecords(c, submitResult);
                    } catch (OrmException e) {
                    // Squash DB exceptions and leave submit records partially filled
                    } catch (NoSuchChangeException e) {
                    // Squash DB exceptions and leave submit records partially filled
                    }
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.currentApprovals(db));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeSubmitRecords) {
                    PatchSet.Id psId = d.getChange().currentPatchSetId();
                    PatchSet patchSet = db.get().patchSets().get(psId);
                    Change.Id changeId = psId.getParentKey();
                    List<SubmitRecord> submitResult = // 
                    d.changeControl().canSubmit(db.get(), patchSet, null, false, true);
                    eventFactory.addSubmitRecords(c, submitResult);
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.currentApprovals(db));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
public void addSubmitRecords(ChangeAttribute ca, List<SubmitRecord> submitRecords) {
    ca.submitRecords = new ArrayList<SubmitRecordAttribute>();
    for (SubmitRecord submitRecord : submitRecords) {
        SubmitRecordAttribute sa = new SubmitRecordAttribute();
        switch(submitRecord.status) {
            case OK:
                sa.status = "OK";
                break;
            case NOT_READY:
                sa.status = "NOT_READY";
                if (!submitRecord.labels.isEmpty()) {
                    sa.labels = new ArrayList<SubmitLabelAttribute>();
                    for (SubmitRecord.Label lbl : submitRecord.labels) {
                        SubmitLabelAttribute la = new SubmitLabelAttribute();
                        la.label = lbl.label;
                        switch(lbl.status) {
                            case OK:
                                la.status = "OK";
                                break;
                            case REJECT:
                                la.status = "REJECT";
                                break;
                            case NEED:
                                la.status = "NEED";
                                break;
                            case IMPOSSIBLE:
                                la.status = "IMPOSSIBLE";
                                break;
                            default:
                                throw new IllegalArgumentException("Unsupported SubmitRecord.Label.status (" + lbl.status + ")");
                        }
                        sa.labels.add(la);
                    }
                }
                break;
            case CLOSED:
                sa.status = "CLOSED";
                break;
            case RULE_ERROR:
                sa.status = "RULE_ERROR";
                break;
            default:
                throw new IllegalStateException("Unsupported SubmitRecord.status + (" + submitRecord.status + ")");
        }
        ca.submitRecords.add(sa);
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.submitRecords.isEmpty()) {
        ca.submitRecords = null;
    }
}
#method_after
public void addSubmitRecords(ChangeAttribute ca, List<SubmitRecord> submitRecords) {
    ca.submitRecords = new ArrayList<SubmitRecordAttribute>();
    for (SubmitRecord submitRecord : submitRecords) {
        SubmitRecordAttribute sa = new SubmitRecordAttribute();
        sa.status = submitRecord.status.name();
        if (submitRecord.status != SubmitRecord.Status.RULE_ERROR) {
            addSubmitRecordLabels(submitRecord, sa);
        }
        ca.submitRecords.add(sa);
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.submitRecords.isEmpty()) {
        ca.submitRecords = null;
    }
}
#end_block

#method_before
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final Set<Account> members = groupMembersFactory.create().listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    // reviewer see a draft.
                    if (control.forUser(user).isRefVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        // reviewer see a draft.
        if (!control.forUser(user).isRefVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final Change change = control.getChange();
    final PatchSet.Id psid = change.currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Execute hook for added reviewers
    // 
    final PatchSet patchSet = db.patchSets().get(psid);
    for (final Account.Id reviewer : added) {
        final Account account = db.accounts().get(reviewer);
        hooks.doReviewerAddedHook(change, account, patchSet, db);
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#method_after
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final Set<Account> members = groupMembersFactory.create().listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    // reviewer see a draft.
                    if (control.forUser(user).isRefVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        // reviewer see a draft.
        if (!control.forUser(user).isRefVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final Change change = control.getChange();
    final PatchSet.Id psid = change.currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Execute hook for added reviewers
    // 
    final PatchSet patchSet = db.patchSets().get(psid);
    for (final Account.Id id : added) {
        final Account account = accountCache.get(id).getAccount();
        hooks.doReviewerAddedHook(change, account, patchSet, db);
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            final Image readOnlyIcon = new Image(Gerrit.RESOURCES.readonly());
            readOnlyIcon.setTitle(Gerrit.C.userCannotVoteToolTip());
            table.setWidget(row, col, readOnlyIcon);
        } else if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().notVotable());
            fmt.getElement(row, col).setTitle(Gerrit.C.userCannotVoteToolTip());
        } else if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            d.votable(pr.getLabel());
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
private void loadApprovals(final PatchSetPublishDetail detail, final ChangeControl control) throws OrmException, NoSuchChangeException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final Change.Id changeId = patchSetId.getParentKey();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            d.votable(pr.getLabel());
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void loadApprovals(final PatchSetPublishDetail detail, final ChangeControl control) throws OrmException, NoSuchChangeException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final Change.Id changeId = patchSetId.getParentKey();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    String token = "token=" + verifier.encode(currentUser.get().getUserName(), getReqUrl(req));
    sendText(req, res, token);
}
#method_after
@Override
protected final void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    CurrentUser user = userProvider.get();
    if (!(user instanceof IdentifiedUser)) {
        sendError(res, SC_UNAUTHORIZED, "API requires authentication");
        return;
    }
    TokenInfo info = new TokenInfo();
    info._authkey = verifier.sign(((IdentifiedUser) user).getAccountId(), computeUrl(req));
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    String type;
    buf.write(JSON_MAGIC);
    if (acceptsJson(req)) {
        type = JSON_TYPE;
        buf.write(gson.toJson(info).getBytes(UTF_8));
    } else {
        type = FORM_ENCODED;
        buf.write(String.format("%s=%s", AUTHKEY_NAME, URLEncoder.encode(info._authkey, UTF_8)).getBytes(UTF_8));
    }
    res.setContentType(type);
    res.setCharacterEncoding(UTF_8);
    res.setHeader("Content-Disposition", "attachment");
    send(req, res, buf.toByteArray());
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    noCache(res);
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        res.setStatus(HttpServletResponse.SC_FORBIDDEN);
        noCache(res);
        sendText(req, res, err.getMessage());
    } catch (Error err) {
        handleError(err, req, res);
    } catch (RuntimeException err) {
        handleError(err, req, res);
    }
}
#method_after
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        sendError(res, SC_FORBIDDEN, err.getMessage());
    } catch (Error err) {
        handleException(err, req, res);
    } catch (RuntimeException err) {
        handleException(err, req, res);
    }
}
#end_block

#method_before
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", Objects.firstNonNull(user.getUserName(), ((IdentifiedUser) user).getNameEmail()), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#method_after
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", Objects.firstNonNull(user.getUserName(), user instanceof IdentifiedUser ? ((IdentifiedUser) user).getNameEmail() : user.toString()), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#end_block

#method_before
protected static void sendText(HttpServletRequest req, HttpServletResponse res, String data) throws IOException {
    res.setContentType("text/plain");
    res.setCharacterEncoding("UTF-8");
    send(req, res, data.getBytes("UTF-8"));
}
#method_after
protected static void sendText(@Nullable HttpServletRequest req, HttpServletResponse res, String data) throws IOException {
    res.setContentType("text/plain");
    res.setCharacterEncoding("UTF-8");
    send(req, res, data.getBytes("UTF-8"));
}
#end_block

#method_before
protected static void send(HttpServletRequest req, HttpServletResponse res, byte[] data) throws IOException {
    if (data.length > 256 && RPCServletUtils.acceptsGzipEncoding(req)) {
        res.setHeader("Content-Encoding", "gzip");
        data = HtmlDomUtil.compress(data);
    }
    res.setContentLength(data.length);
    OutputStream out = res.getOutputStream();
    try {
        out.write(data);
    } finally {
        out.close();
    }
}
#method_after
protected static void send(@Nullable HttpServletRequest req, HttpServletResponse res, byte[] data) throws IOException {
    if (data.length > 256 && req != null && RPCServletUtils.acceptsGzipEncoding(req)) {
        res.setHeader("Content-Encoding", "gzip");
        data = HtmlDomUtil.compress(data);
    }
    res.setContentLength(data.length);
    OutputStream out = res.getOutputStream();
    try {
        out.write(data);
    } finally {
        out.close();
    }
}
#end_block

#method_before
@Override
public void onResponseReceived(Request req, Response res) {
    String text = res.getText();
    if (text.startsWith("token=")) {
        RestApi.this.sendPost(cb, text);
        return;
    }
    RpcStatus.INSTANCE.onRpcComplete();
    int status = res.getStatusCode();
    if (status != 200) {
        if ((400 <= status && status < 500) && isTextBody(res)) {
            cb.onFailure(new RemoteJsonException(res.getText(), status, null));
        } else {
            cb.onFailure(new StatusCodeException(status, res.getStatusText()));
        }
        return;
    }
    if (!isJsonBody(res)) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    String json = res.getText();
    if (!json.startsWith(JSON_MAGIC)) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    T data;
    try {
        // javac generics bug
        data = Natives.<T>parseJSON(json.substring(JSON_MAGIC.length()));
    } catch (RuntimeException e) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    cb.onSuccess(data);
}
#method_after
@Override
public void onResponseReceived(Request req, Response res) {
    int status = res.getStatusCode();
    if (status != 200) {
        RpcStatus.INSTANCE.onRpcComplete();
        if ((400 <= status && status < 600) && isTextBody(res)) {
            cb.onFailure(new RemoteJsonException(res.getText(), status, null));
        } else {
            cb.onFailure(new StatusCodeException(status, res.getStatusText()));
        }
        return;
    }
    if (!isJsonBody(res)) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    String json = res.getText();
    if (!json.startsWith(JSON_MAGIC)) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    json = json.substring(JSON_MAGIC.length());
    if (wasGet && json.startsWith("{\"_authkey\":")) {
        RestApi.this.resendPost(cb, json);
        return;
    }
    T data;
    try {
        // javac generics bug
        data = Natives.<T>parseJSON(json);
    } catch (RuntimeException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    cb.onSuccess(data);
    RpcStatus.INSTANCE.onRpcComplete();
}
#end_block

#method_before
public RestApi addParameter(String name, int value) {
    return addParameterRaw(name, String.valueOf(value));
}
#method_after
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#end_block

#method_before
public <T extends JavaScriptObject> void send(final AsyncCallback<T> cb) {
    RequestBuilder req = new RequestBuilder(RequestBuilder.GET, url.toString());
    req.setHeader("Accept", JsonConstants.JSON_TYPE);
    req.setCallback(new MyRequestCallback<T>(cb));
    try {
        RpcStatus.INSTANCE.onRpcStart();
        req.send();
    } catch (RequestException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(e);
    }
}
#method_after
public <T extends JavaScriptObject> void send(final AsyncCallback<T> cb) {
    RequestBuilder req = new RequestBuilder(RequestBuilder.GET, url.toString());
    req.setHeader("Accept", JsonConstants.JSON_TYPE);
    req.setCallback(new MyRequestCallback<T>(true, cb));
    try {
        RpcStatus.INSTANCE.onRpcStart();
        req.send();
    } catch (RequestException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(e);
    }
}
#end_block

#method_before
@Deprecated
public Change.Id getId() {
    return changeId;
}
#method_after
public Change.Id getId() {
    return changeId;
}
#end_block

#method_before
@Deprecated
public int getChangeId() {
    return changeId.get();
}
#method_after
public int getChangeId() {
    return changeId.get();
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : merged) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : merged) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(merged.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#method_after
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeAuthor(merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.getApprovalType(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(db, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    this.testMergeabilityOfChangesbyBranch();
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    this.testMergeabilityOfChangesbyBranch();
                    break;
                }
            case ALREADY_MERGED:
                {
                    setMerged(c, null);
                    break;
                }
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    String str = dependencyError(commit);
                    if (submitStillPossible) {
                        if (str != null) {
                            sendMergeFail(c, message(c, str), false, false);
                        }
                    } else {
                        setNew(c, message(c, str));
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unused")
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#method_after
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#end_block

#method_before
public static void testMerge(MergeOp.Factory opFactory, Change change) {
    opFactory.create(change.getDest()).runTestMerge(change);
}
#method_after
public static void testMerge(MergeOp.Factory opFactory, Change change) {
    opFactory.create(change.getDest()).verifyMergeability(change);
}
#end_block

#method_before
public static void submit(MergeOp.Factory opFactory, PatchSet.Id patchSetId, IdentifiedUser user, ReviewDb db, MergeQueue merger) throws OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSetApproval approval = createSubmitApproval(patchSetId, user, db);
    db.patchSetApprovals().upsert(Collections.singleton(approval));
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.NEW) {
                change.setStatus(Change.Status.SUBMITTED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (change.getStatus() == Change.Status.SUBMITTED) {
        merger.merge(opFactory, change.getDest());
    }
}
#method_after
public static void submit(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db, final MergeOp.Factory opFactory, final MergeQueue merger) throws OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSetApproval approval = createSubmitApproval(patchSetId, user, db);
    db.patchSetApprovals().upsert(Collections.singleton(approval));
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.NEW) {
                change.setStatus(Change.Status.SUBMITTED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
        merger.merge(opFactory, updatedChange.getDest());
    }
}
#end_block

#method_before
public static PatchSetApproval createSubmitApproval(PatchSet.Id patchSetId, IdentifiedUser user, ReviewDb db) throws OrmException {
    final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
    final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, user.getAccountId(), SUBMIT);
    for (final PatchSetApproval approval : allApprovals) {
        if (akey.equals(approval.getKey())) {
            approval.setValue((short) 1);
            approval.setGranted();
            return approval;
        }
    }
    return new PatchSetApproval(akey, (short) 1);
}
#method_after
public static PatchSetApproval createSubmitApproval(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db) throws OrmException {
    final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
    final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, user.getAccountId(), SUBMIT);
    for (final PatchSetApproval approval : allApprovals) {
        if (akey.equals(approval.getKey())) {
            approval.setValue((short) 1);
            approval.setGranted();
            return approval;
        }
    }
    return new PatchSetApproval(akey, (short) 1);
}
#end_block

#method_before
public Capable canUpload() {
    if (!projectControl.canPushToAtLeastOneRef()) {
        String reqName = project.getName();
        return new Capable("Upload denied for project '" + reqName + "'");
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    if (project.isUseContributorAgreements()) {
        try {
            return verifyActiveContributorAgreement();
        } catch (OrmException e) {
            log.error("Cannot query database for agreements", e);
            return new Capable("Cannot verify contribution agreement");
        }
    } else {
        return Capable.OK;
    }
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    return Capable.OK;
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        boolean haveHeads = false;
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            if (isHead(r) || isTag(r)) {
                try {
                    final RevCommit h = walk.parseCommit(r.getObjectId());
                    h.add(SIDE_HAVE);
                    walk.markStart(h);
                    haveHeads = true;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
    ChangeUtil.testMerge(opFactory, change);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    ChangeUtil.testMerge(opFactory, change);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                change.setLastSha1MergeTested(null);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        ChangeUtil.mergeTestChangesByBranch(opFactory, destBranch);
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    if (!isMergeable) {
        final Label lbl = new Label();
        lbl.setText(Util.C.messageMergeFail());
        actionsPanel.add(lbl);
    }
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && allowedSchemes.contains(DownloadScheme.ANON_GIT)) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.setEnabled(isMergeable);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new RestoreChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateReviewAction() {
    final Button b = new Button(Util.C.buttonReview());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            Gerrit.display("change,publish," + patchSet.getId().toString(), new PublishCommentScreen(patchSet.getId()));
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateReviewAction() {
    final Button b = new Button(Util.C.buttonReview());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            Gerrit.display(Dispatcher.toPublish(patchSet.getId()));
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen());
    approvalButtons = new ArrayList<ValueRadioButton>();
    descBlock = new ChangeDescriptionBlock();
    add(descBlock);
    final FormPanel form = new FormPanel();
    final FlowPanel body = new FlowPanel();
    form.setWidget(body);
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
        }
    });
    add(form);
    approvalPanel = new FlowPanel();
    body.add(approvalPanel);
    initMessage(body);
    draftsPanel = new FlowPanel();
    body.add(draftsPanel);
    final FlowPanel buttonRow = new FlowPanel();
    buttonRow.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(buttonRow);
    send = new Button(Util.C.buttonPublishCommentsSend());
    send.addClickHandler(this);
    buttonRow.add(send);
    submit = new Button(Util.C.buttonPublishSubmitSend());
    submit.addClickHandler(this);
    buttonRow.add(submit);
    cancel = new Button(Util.C.buttonPublishCommentsCancel());
    cancel.addClickHandler(this);
    buttonRow.add(cancel);
    errorlabel.setText(Util.C.messageMergeFail());
    body.add(errorlabel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen());
    approvalButtons = new ArrayList<ValueRadioButton>();
    descBlock = new ChangeDescriptionBlock();
    add(descBlock);
    final FormPanel form = new FormPanel();
    final FlowPanel body = new FlowPanel();
    form.setWidget(body);
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
        }
    });
    add(form);
    approvalPanel = new FlowPanel();
    body.add(approvalPanel);
    initMessage(body);
    draftsPanel = new FlowPanel();
    body.add(draftsPanel);
    final FlowPanel buttonRow = new FlowPanel();
    buttonRow.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(buttonRow);
    send = new Button(Util.C.buttonPublishCommentsSend());
    send.addClickHandler(this);
    buttonRow.add(send);
    submit = new Button(Util.C.buttonPublishSubmitSend());
    submit.addClickHandler(this);
    buttonRow.add(submit);
    cancel = new Button(Util.C.buttonPublishCommentsCancel());
    cancel.addClickHandler(this);
    buttonRow.add(cancel);
}
#end_block

#method_before
private void initApprovals(final PatchSetPublishDetail r, final Panel body) {
    for (final ApprovalType ct : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        if (r.isAllowed(ct.getCategory().getId())) {
            initApprovalType(r, body, ct);
        }
    }
}
#method_after
private void initApprovals(final PatchSetPublishDetail r, final Panel body) {
    ApprovalTypes types = Gerrit.getConfig().getApprovalTypes();
    for (PermissionRange range : r.getLabels()) {
        ApprovalType type = types.byLabel(range.getLabel());
        if (type != null) {
            // Legacy type, use radio buttons.
            initApprovalType(r, body, type, range);
        } else {
        // TODO Newer style label.
        }
    }
}
#end_block

#method_before
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final Set<ApprovalCategoryValue.Id> allowed = r.getAllowed(catId);
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!allowed.contains(buttonValue.getId())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#method_after
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.isSubmitAllowed());
    submit.setEnabled(r.getChange().isMergeable());
    errorlabel.setVisible(!r.getChange().isMergeable());
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }
    });
}
#method_after
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    enableForm(false);
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }
    });
}
#method_after
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable caught) {
            goChange();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private String toHTML(SparseFileContent src) {
    SafeHtml html;
    if (diffPrefs.isIntralineDifference()) {
        html = colorLineEdits(src);
    } else {
        SafeHtmlBuilder b = new SafeHtmlBuilder();
        for (int index = src.first(); index < src.size(); index = src.next(index)) {
            b.append(src.get(index));
            b.append('\n');
        }
        html = b;
        final String r = // 
        "<span class=\"wse\"" + " title=\"" + PrettifyConstants.C.wseBareCR() + // 
        "\"" + ">&nbsp;</span>$1";
        html = html.replaceAll("\r([^\n])", r);
    }
    if (diffPrefs.isShowWhitespaceErrors()) {
        // We need to do whitespace errors before showing tabs, because
        // these patterns rely on \t as a literal, before it expands.
        // 
        html = showTabAfterSpace(html);
        html = showTrailingWhitespace(html);
    }
    if (diffPrefs.isShowCrLf()) {
        html = showCrLf(html);
    }
    if (diffPrefs.isShowTabs()) {
        String t = 1 < diffPrefs.getTabSize() ? "\t" : "";
        html = html.replaceAll("\t", "<span class=\"vt\">\u00BB</span>" + t);
    }
    return html.asString();
}
#method_after
private String toHTML(SparseFileContent src) {
    SafeHtml html;
    if (diffPrefs.isIntralineDifference()) {
        html = colorLineEdits(src);
    } else {
        SafeHtmlBuilder b = new SafeHtmlBuilder();
        for (int index = src.first(); index < src.size(); index = src.next(index)) {
            b.append(src.get(index));
            b.append('\n');
        }
        html = b;
        final String r = // 
        "<span class=\"wse\"" + " title=\"" + PrettifyConstants.C.wseBareCR() + // 
        "\"" + ">&nbsp;</span>$1";
        html = html.replaceAll("\r([^\n])", r);
    }
    if (diffPrefs.isShowWhitespaceErrors()) {
        // We need to do whitespace errors before showing tabs, because
        // these patterns rely on \t as a literal, before it expands.
        // 
        html = showTabAfterSpace(html);
        html = showTrailingWhitespace(html);
    }
    if (diffPrefs.isShowLineEndings()) {
        html = showLineEndings(html);
    }
    if (diffPrefs.isShowTabs()) {
        String t = 1 < diffPrefs.getTabSize() ? "\t" : "";
        html = html.replaceAll("\t", "<span class=\"vt\">\u00BB</span>" + t);
    }
    return html.asString();
}
#end_block

#method_before
private void appendShowBareCR(SafeHtmlBuilder buf, String src, boolean end) {
    while (!src.isEmpty()) {
        int cr = src.indexOf('\r');
        if (cr < 0) {
            buf.append(src);
            return;
        } else if (end) {
            if (cr == src.length() - 1) {
                buf.append(src.substring(0, cr + 1));
                return;
            }
        } else if (cr == src.length() - 2 && src.charAt(cr + 1) == '\n') {
            buf.append(src.substring(0, cr + 1));
            buf.append('\n');
            return;
        }
        buf.append(src.substring(0, cr));
        buf.openSpan();
        buf.setStyleName("wse");
        buf.setAttribute("title", PrettifyConstants.C.wseBareCR());
        buf.nbsp();
        buf.closeSpan();
        src = src.substring(cr + 1);
    }
}
#method_after
private void appendShowBareCR(SafeHtmlBuilder buf, String src, boolean end) {
    while (!src.isEmpty()) {
        int cr = src.indexOf('\r');
        if (cr < 0) {
            buf.append(src);
            return;
        } else if (end) {
            if (cr == src.length() - 1) {
                buf.append(src.substring(0, cr + 1));
                return;
            }
        } else if (cr == src.length() - 2 && src.charAt(cr + 1) == '\n') {
            buf.append(src);
            return;
        }
        buf.append(src.substring(0, cr));
        buf.openSpan();
        buf.setStyleName("wse");
        buf.setAttribute("title", PrettifyConstants.C.wseBareCR());
        buf.nbsp();
        buf.closeSpan();
        src = src.substring(cr + 1);
    }
}
#end_block

#method_before
protected void display() {
    final AccountDiffPreference dp = getValue();
    setIgnoreWhitespace(dp.getIgnoreWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(dp.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(dp.getContext());
    tabWidth.setIntValue(dp.getTabSize());
    colWidth.setIntValue(dp.getLineLength());
    intralineDifference.setValue(dp.isIntralineDifference());
    whitespaceErrors.setValue(dp.isShowWhitespaceErrors());
    crlfErrors.setValue(dp.isShowCrLf());
    showTabs.setValue(dp.isShowTabs());
    skipDeleted.setValue(dp.isSkipDeleted());
    skipUncommented.setValue(dp.isSkipUncommented());
    expandAllComments.setValue(dp.isExpandAllComments());
    retainHeader.setValue(dp.isRetainHeader());
    manualReview.setValue(dp.isManualReview());
}
#method_after
protected void display() {
    final AccountDiffPreference dp = getValue();
    setIgnoreWhitespace(dp.getIgnoreWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(dp.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(dp.getContext());
    tabWidth.setIntValue(dp.getTabSize());
    colWidth.setIntValue(dp.getLineLength());
    intralineDifference.setValue(dp.isIntralineDifference());
    whitespaceErrors.setValue(dp.isShowWhitespaceErrors());
    showLineEndings.setValue(dp.isShowLineEndings());
    showTabs.setValue(dp.isShowTabs());
    skipDeleted.setValue(dp.isSkipDeleted());
    skipUncommented.setValue(dp.isSkipUncommented());
    expandAllComments.setValue(dp.isExpandAllComments());
    retainHeader.setValue(dp.isRetainHeader());
    manualReview.setValue(dp.isManualReview());
}
#end_block

#method_before
private void update() {
    if (colWidth.getIntValue() <= 0) {
        new ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowCrLf(crlfErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    dp.setExpandAllComments(expandAllComments.getValue());
    dp.setRetainHeader(retainHeader.getValue());
    dp.setManualReview(manualReview.getValue());
    listenablePrefs.set(dp);
}
#method_after
private void update() {
    if (colWidth.getIntValue() <= 0) {
        new ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowLineEndings(showLineEndings.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    dp.setExpandAllComments(expandAllComments.getValue());
    dp.setRetainHeader(retainHeader.getValue());
    dp.setManualReview(manualReview.getValue());
    listenablePrefs.set(dp);
}
#end_block

#method_before
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowCrLf(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    return p;
}
#method_after
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowLineEndings(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    return p;
}
#end_block

#method_before
@Override
protected void onRequestSuggestions(Request request, Callback done) {
    final String query = request.getQuery();
    int lastSpace = query.lastIndexOf(' ');
    final String lastWord;
    if (query.length() == 0) {
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == query.length() - 1) {
        // Starting a new word - don't show suggestions yet.
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == -1) {
        lastWord = query;
    } else {
        lastWord = query.substring(lastSpace + 1);
    }
    final ArrayList<SearchSuggestion> r = new ArrayList<SearchSuggestOracle.SearchSuggestion>();
    for (String suggestion : suggestions) {
        if ((lastWord.length() < suggestion.length()) && suggestion.startsWith(lastWord)) {
            r.add(new SearchSuggestion(suggestion, query + suggestion.substring(lastWord.length())));
        }
    }
    done.onSuggestionsReady(request, new Response(r));
}
#method_after
@Override
protected void onRequestSuggestions(Request request, Callback done) {
    final String query = request.getQuery();
    int lastSpace = query.lastIndexOf(' ');
    final String lastWord;
    // NOTE: this method is not called if the query is empty.
    if (lastSpace == query.length() - 1) {
        // Starting a new word - don't show suggestions yet.
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == -1) {
        lastWord = query;
    } else {
        lastWord = query.substring(lastSpace + 1);
    }
    final ArrayList<SearchSuggestion> r = new ArrayList<SearchSuggestOracle.SearchSuggestion>();
    for (String suggestion : suggestions.tailSet(lastWord)) {
        if ((lastWord.length() < suggestion.length()) && suggestion.startsWith(lastWord)) {
            if (suggestion.contains("self") && !Gerrit.isSignedIn()) {
                continue;
            }
            r.add(new SearchSuggestion(suggestion, query + suggestion.substring(lastWord.length())));
        }
    }
    done.onSuggestionsReady(request, new Response(r));
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (names != null && !names.isEmpty()) {
        try {
            loader.enablePlugins(Sets.newHashSet(names));
        } catch (PluginInstallException e) {
            e.printStackTrace(stderr);
            throw die("plugin failed to install");
        }
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (names != null && !names.isEmpty()) {
        try {
            loader.enablePlugins(Sets.newHashSet(names));
        } catch (PluginInstallException e) {
            e.printStackTrace(stderr);
            throw die("plugin failed to enable");
        }
    }
}
#end_block

#method_before
public synchronized void rescan() {
    List<File> jars = scanJarsInPluginsDirectory();
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
    for (File jar : jars) {
        String name = nameOf(jar);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            runPlugin(name, jar, active);
            if (active == null) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    List<File> jars = scanJarsInPluginsDirectory();
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
    for (File jar : jars) {
        String name = nameOf(jar);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private void runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        unload.remove(nameOf(jar));
    }
    for (String name : unload) {
        log.info(String.format("Unloading plugin %s", name));
        running.remove(name).stop();
    }
}
#method_after
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        if (!jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        log.info(String.format("Unloading plugin %s", name));
        running.remove(name).stop();
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        unload.remove(nameOf(jar));
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
private void createReviewedPanel() {
    reviewedPanel = new FlowPanel();
    reviewedCheckBox = new CheckBox();
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    Anchor reviewedAnchor = new Anchor(PatchUtil.C.reviewed());
    reviewedAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setReviewedByCurrentUser(true);
        }
    });
    final PatchValidator unreviewedValidator = new PatchValidator() {

        public boolean isValid(Patch patch) {
            return !patch.isReviewedByCurrentUser();
        }
    };
    int nextUnreviewedPatchIndex = patchSetDetail.getNextPatch(patchIndex, true, unreviewedValidator, fileList.PREFERENCE_VALIDATOR);
    if (nextUnreviewedPatchIndex > -1) {
        // Create invisible patch link to change page
        final PatchLink reviewedLink = fileList.createLink(nextUnreviewedPatchIndex, getPatchScreenType(), null, null);
        reviewedLink.setText("");
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                reviewedLink.go();
            }
        });
    } else {
        final ChangeLink upLink = new ChangeLink("", patchKey.getParentKey());
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                upLink.go();
            }
        });
    }
    reviewedPanel.add(reviewedCheckBox);
    reviewedPanel.add(reviewedAnchor);
}
#method_after
private void createReviewedPanel() {
    reviewedPanel = new FlowPanel();
    reviewedCheckBox = new CheckBox(PatchUtil.C.reviewedAnd() + " ");
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    reviewedPanel.add(reviewedCheckBox);
    reviewedPanel.add(getReviewedAnchor());
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS, sugestParent);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectName);
            }
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectListPopup.setCoordinates(top, left);
            projectListPopup.display();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.suggestParentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.parentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                continue;
            }
            if (!isVisible && !(showTree && pctl.isOwner())) {
                // 
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && format.isJson() || (type == FilterType.SUGGEST_PARENT_CANDIDATES)) {
                ProjectState parent = e.getParentState();
                if (parent != null) {
                    ProjectControl parentCtrl = parent.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        if (type == FilterType.SUGGEST_PARENT_CANDIDATES) {
                            info.name = parent.getProject().getName();
                            info.description = parent.getProject().getDescription();
                            if (format.isJson()) {
                                output.put(info.name, info);
                            }
                            continue;
                        }
                        info.parent = parent.getProject().getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getProject().getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getProject().getName(), info.parent);
                        }
                    }
                } else {
                    if (type == FilterType.SUGGEST_PARENT_CANDIDATES) {
                        continue;
                    }
                }
            }
            info.name = projectName.get();
            if (showDescription && !e.getProject().getDescription().isEmpty()) {
                info.description = e.getProject().getDescription();
            }
            try {
                if (showBranch != null) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                        List<Ref> refs = getBranchRefs(projectName, pctl);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = Maps.newLinkedHashMap();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    } finally {
                        git.close();
                    }
                } else if (!showTree && type != FilterType.ALL) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                    } finally {
                        git.close();
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + info.description.replace("\n", "\\n"));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = e.getParentState();
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = parentState.getProject().getDescription();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final ProjectControl pctl = e.controlFor(currentUser);
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = e.getParentState();
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription && !e.getProject().getDescription().isEmpty()) {
                    info.description = e.getProject().getDescription();
                }
                try {
                    if (showBranch != null) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS, nameTxt, this);
    projectListPopup.addProjectListPopupOnOpenRowHandler(new ProjectListPopup.ProjectListPopupOnOpenRowHandler() {

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            doAddNew();
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(nameBox.getText())) {
                nameBox.setText(projectName);
            }
        }

        @Override
        protected void openRow(String projectName) {
            nameBox.setText(projectName);
            doAddNew();
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS);
}
#end_block

#method_before
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            calculatePopupCoordinates();
            projectListPopup.display();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#method_after
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
protected void initPopup() {
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            if (preferredPopupWidth == -1) {
                preferredPopupWidth = offsetWidth;
            }
            if (top + offsetHeight > Window.getClientWidth()) {
                top = Window.getClientWidth() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#method_after
public void initPopup(final String popupText, final String currentPageLink) {
    createWidgets(popupText, currentPageLink);
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    sp.setSize("100%", "100%");
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popup.setHeight("100%");
    popupPosition = getPositionCallback();
}
#end_block

#method_before
protected void createWidgets(final String popupText, final String currentPageLink) {
    projectsTab = new ProjectsTable() {

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            handlerManager.fireEvent(new ProjectListPopupOnMovePointerEvent(popingUp, getRowItem(row).getName()));
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            handlerManager.fireEvent(new ProjectListPopupOnOpenRowEvent(getRowItem(row).getName()));
        }
    };
    projectsTab.setSavePointerId(currentPageLink);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
            handlerManager.fireEvent(new ProjectListPopupOnCloseEvent());
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(popupText);
}
#method_after
private void createWidgets(final String popupText, final String currentPageLink) {
    projectsTab = new ProjectsTable() {

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            onMovePointerTo(getRowItem(row).name());
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            openRow(getRowItem(row).name());
        }
    };
    projectsTab.setSavePointerId(currentPageLink);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(popupText);
}
#end_block

#method_before
public void closePopup() {
    popup.hide();
    resetHandlerRegistration();
}
#method_after
public void closePopup() {
    popup.hide();
}
#end_block

#method_before
protected void populateProjects() {
    Util.PROJECT_SVC.visibleProjects(new GerritCallback<ProjectList>() {

        @Override
        public void onSuccess(final ProjectList result) {
            projectsTab.display(result.getProjects());
            if (firstPopupLoad) {
                // Display was delayed until table was loaded
                firstPopupLoad = false;
                display();
            }
        }
    });
}
#method_after
protected void populateProjects() {
    ProjectMap.all(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(final ProjectMap result) {
            projectsTab.display(result);
            if (firstPopupLoad) {
                // Display was delayed until table was loaded
                firstPopupLoad = false;
                displayPopup();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewed);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewed);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader(getPatchScreenType());
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    header.display(script, patchKey, idSideA, idSideB, getPatchScreenType());
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    header.display(patchSetDetail, script, patchKey, idSideA, idSideB);
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
public void display(final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB, final PatchScreen.Type type) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.screenType = type;
    this.links = new LinkedList<Anchor>();
    linkPanel.add(new Label(PatchUtil.C.patchSet() + " "));
    if (side == Side.A) {
        addLink("Base", null);
    } else {
        links.add(null);
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        addLink(Integer.toString(psId.get()), psId);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    downloadLink();
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new LinkedList<Anchor>();
    if (screenType == PatchScreen.Type.UNIFIED) {
        sideMarker.setInnerText((side == Side.A) ? "(-)" : "(+)");
    }
    if (detail.getInfo().getParents().size() > 1) {
        addLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        addLink(PatchUtil.C.patchBase(), null);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        addLink(Integer.toString(psId.get()), psId);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = getDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(new Label(" - "));
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private void addLink(String label, final PatchSet.Id id) {
    final Anchor anchor = new Anchor(label);
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (side == Side.A) {
                idSideA = id;
            } else {
                idSideB = id;
            }
            Patch.Key k = new Patch.Key(idSideB, patchKey.get());
            switch(screenType) {
                case SIDE_BY_SIDE:
                    Gerrit.display(Dispatcher.toPatchSideBySide(idSideA, k));
                    break;
                case UNIFIED:
                    Gerrit.display(Dispatcher.toPatchUnified(idSideA, k));
                    break;
            }
        }
    });
    links.add(anchor);
    linkPanel.add(anchor);
}
#method_after
private void addLink(String label, final PatchSet.Id id) {
    final Anchor anchor = new Anchor(label);
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (side == Side.A) {
                idSideA = id;
            } else {
                idSideB = id;
            }
            Patch.Key keySideB = new Patch.Key(idSideB, patchKey.get());
            switch(screenType) {
                case SIDE_BY_SIDE:
                    Gerrit.display(Dispatcher.toPatchSideBySide(idSideA, keySideB));
                    break;
                case UNIFIED:
                    Gerrit.display(Dispatcher.toPatchUnified(idSideA, keySideB));
                    break;
            }
        }
    });
    links.add(anchor);
    linkPanel.add(anchor);
}
#end_block

#method_before
public void display(PatchScript script, final Patch.Key patchKey, final PatchSet.Id idSideA, final PatchSet.Id idSideB, PatchScreen.Type type) {
    listA.display(script, patchKey, idSideA, idSideB, type);
    listB.display(script, patchKey, idSideA, idSideB, type);
    if (type == PatchScreen.Type.UNIFIED) {
        aligner.getStyle().setDisplay(Display.NONE);
    }
}
#method_after
public void display(final PatchSetDetail detail, PatchScript script, final Patch.Key patchKey, final PatchSet.Id idSideA, final PatchSet.Id idSideB) {
    listA.display(detail, script, patchKey, idSideA, idSideB);
    listB.display(detail, script, patchKey, idSideA, idSideB);
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String[] auths = new String(decoded, encoding(req)).split(":");
    if (auths.length < 2) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = auths[0];
    String password = auths[1];
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = getAuthRequest(who, password);
    if (whoAuth == null) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        session.get().setUserAccountId(whoAuthResult.getAccountId(), AuthMethod.PASSWORD);
        return true;
    } catch (AccountException e) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null) {
        // 
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        session.get().setUserAccountId(whoAuthResult.getAccountId(), AuthMethod.PASSWORD);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private String encoding(HttpServletRequest req) {
    String encoding = req.getCharacterEncoding();
    if (encoding == null)
        encoding = "UTF-8";
    return encoding;
}
#method_after
private String encoding(HttpServletRequest req) {
    return Objects.firstNonNull(req.getCharacterEncoding(), "UTF-8");
}
#end_block

#method_before
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append("Basic");
        v.append(" realm=\"" + REALM_NAME + "\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#method_after
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append(LIT_BASIC);
        v.append("realm=\"" + REALM_NAME + "\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, InvalidChangeOperationException, PatchSetInfoNotAvailableException, RepositoryNotFoundException, IOException {
    final AbandonChange abandonChange = abandonChangeFactory.get();
    abandonChange.setChangeId(patchSetId.getParentKey());
    abandonChange.setMessage(message);
    final ReviewResult result = abandonChange.call();
    if (result.getErrors().size() > 0) {
        throw new NoSuchChangeException(result.getChangeId());
    }
    return changeDetailFactory.create(result.getChangeId()).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, InvalidChangeOperationException, PatchSetInfoNotAvailableException, RepositoryNotFoundException, IOException {
    final AbandonChange abandonChange = abandonChangeProvider.get();
    abandonChange.setChangeId(patchSetId.getParentKey());
    abandonChange.setMessage(message);
    final ReviewResult result = abandonChange.call();
    if (result.getErrors().size() > 0) {
        throw new NoSuchChangeException(result.getChangeId());
    }
    return changeDetailFactory.create(result.getChangeId()).call();
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure, RepositoryNotFoundException, IOException {
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final AbandonChange abandonChange = abandonChangeFactory.get();
            abandonChange.setChangeId(patchSetId.getParentKey());
            abandonChange.setMessage(changeComment);
            final ReviewResult result = abandonChange.call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId.getParentKey(), changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure, RepositoryNotFoundException, IOException {
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final AbandonChange abandonChange = abandonChangeProvider.get();
            abandonChange.setChangeId(patchSetId.getParentKey());
            abandonChange.setMessage(changeComment);
            final ReviewResult result = abandonChange.call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId.getParentKey(), changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case DELETE_NOT_PERMITTED:
                errMsg += "not permitted to delete change/patch set";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            case NOT_A_DRAFT:
                errMsg += "change is not a draft";
                break;
            case GIT_ERROR:
                errMsg += "error writing change to git repository";
                break;
            case DEST_BRANCH_NOT_FOUND:
                errMsg += "destination branch not found";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case CHANGE_NOT_ABANDONED:
                errMsg += "change is not abandoned";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case DELETE_NOT_PERMITTED:
                errMsg += "not permitted to delete change/patch set";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            case NOT_A_DRAFT:
                errMsg += "change is not a draft";
                break;
            case GIT_ERROR:
                errMsg += "error writing change to git repository";
                break;
            case DEST_BRANCH_NOT_FOUND:
                errMsg += "destination branch not found";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final Change change = db.changes().get(changeId);
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canAbandon()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.ABANDON_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a message to accompany the abandoned change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
        if (message != null && message.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(message);
        }
        cmsg.setMessage(msgBuf.toString());
        // Abandon the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, abandonedSenderFactory, "Change is no longer open or patchset is not latest");
        hooks.doChangeAbandonedHook(updatedChange, currentUser.getAccount(), message, db);
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    if (changeId == null) {
        throw new InvalidChangeOperationException("changeId is required");
    }
    final ReviewResult result = new ReviewResult();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final Change change = db.changes().get(changeId);
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canAbandon()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.ABANDON_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a message to accompany the abandoned change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
        if (message != null && message.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(message);
        }
        cmsg.setMessage(msgBuf.toString());
        // Abandon the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (updatedChange == null) {
            result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
            return result;
        }
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, abandonedSenderFactory);
        hooks.doChangeAbandonedHook(updatedChange, currentUser.getAccount(), message, db);
    }
    return result;
}
#end_block

#method_before
private List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                for (final String permissionName : Permission.getPermissionNames()) {
                    if (!Permission.canBeOnWildProject(permissionName)) {
                        section.removePermission(permissionName);
                    }
                }
            }
            SectionMatcher matcher = SectionMatcher.wrap(section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#method_after
private List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#end_block

#method_before
boolean isOwner(Set<AccountGroup.UUID> groups) {
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        if (CollectionsUtil.isAnyIncludedIn(s.localOwners, groups)) {
            return true;
        }
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    return false;
}
#method_after
boolean isOwner(GroupMembership groups) {
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        if (groups.containsAnyOf(s.localOwners)) {
            return true;
        }
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    return false;
}
#end_block

#method_before
public ProjectState getParentState() {
    if (isAllProjects) {
        return null;
    }
    Project.NameKey parentName = getProject().getParent();
    if (parentName == null) {
        parentName = allProjectsName;
    }
    return projectCache.get(parentName);
}
#method_after
public ProjectState getParentState() {
    if (isAllProjects) {
        return null;
    }
    return projectCache.get(getProject().getParent(allProjectsName));
}
#end_block

#method_before
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && AccessSection.isAccessSection(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#method_after
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && RefConfigSection.isValid(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#end_block

#method_before
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (AccessSection.isAccessSection(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#method_after
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (RefConfigSection.isValid(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            addPermission(varName, perms);
        }
    } else if (AccessSection.isAccessSection(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            addPermission(varName, perms);
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            addPermission(varName, perms);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            addPermission(varName, perms);
        }
    } else if (RefConfigSection.isValid(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            addPermission(varName, perms);
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            addPermission(varName, perms);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
private void addPermission(final String permissionName, final List<String> permissionList) {
    if (value.getPermission(permissionName) != null) {
        return;
    }
    if (Gerrit.getConfig().getWildProject().equals(projectAccess.getProjectName()) && !Permission.canBeOnWildProject(permissionName)) {
        return;
    }
    permissionList.add(permissionName);
}
#method_after
private void addPermission(final String permissionName, final List<String> permissionList) {
    if (value.getPermission(permissionName) != null) {
        return;
    }
    if (Gerrit.getConfig().getWildProject().equals(projectAccess.getProjectName()) && !Permission.canBeOnAllProjects(value.getName(), permissionName)) {
        return;
    }
    permissionList.add(permissionName);
}
#end_block

#method_before
@Override
public PermissionEditor create(int index) {
    PermissionEditor subEditor = new PermissionEditor(readOnly, value);
    permissionContainer.insert(subEditor, index);
    return subEditor;
}
#method_after
@Override
public PermissionEditor create(int index) {
    PermissionEditor subEditor = new PermissionEditor(projectAccess.getProjectName(), readOnly, value);
    permissionContainer.insert(subEditor, index);
    return subEditor;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable2();
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable2.Section();
    incoming = new ChangeTable2.Section();
    closed = new ChangeTable2.Section();
    outgoing.setTitleText(Util.C.outgoingReviews());
    incoming.setTitleText(Util.C.incomingReviews());
    incoming.initHighlightUnreviewed(true, ownerId);
    closed.setTitleText(Util.C.recentlyClosed());
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable2();
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable2.Section();
    incoming = new ChangeTable2.Section();
    closed = new ChangeTable2.Section();
    outgoing.setTitleText(Util.C.outgoingReviews());
    incoming.setTitleText(Util.C.incomingReviews());
    incoming.setHighlightUnreviewed(true);
    closed.setTitleText(Util.C.recentlyClosed());
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#end_block

#method_before
private void display(NativeList<ChangeList> result) {
    if (!mine && !hasChanges(result)) {
        // When no results are returned and the data is not for the
        // current user, the target user is presumed to not exist.
        Gerrit.display(getToken(), new NotFoundScreen());
        return;
    }
    ChangeList out = result.get(0);
    ChangeList in = result.get(1);
    ChangeList done = result.get(2);
    if (mine) {
        setWindowTitle(Util.C.myDashboardTitle());
        setPageTitle(Util.C.myDashboardTitle());
    } else {
        // The server doesn't tell us who the dashboard is for. Try to guess
        // by looking at a change started by the owner and extract the name.
        String name = guessName(out);
        if (name == null) {
            name = guessName(done);
        }
        if (name != null) {
            setWindowTitle(name);
            setPageTitle(Util.M.accountDashboardTitle(name));
        } else {
            setWindowTitle(Util.C.unknownDashboardTitle());
            setWindowTitle(Util.C.unknownDashboardTitle());
        }
    }
    Collections.sort(out.asList(), compare());
    Collections.sort(in.asList(), compare());
    table.updateColumnsForLabels(out, in, done);
    outgoing.display(out);
    incoming.display(in);
    closed.display(done);
    table.finishDisplay();
}
#method_after
private void display(NativeList<ChangeList> result) {
    if (!mine && !hasChanges(result)) {
        // When no results are returned and the data is not for the
        // current user, the target user is presumed to not exist.
        Gerrit.display(getToken(), new NotFoundScreen());
        return;
    }
    ChangeList out = result.get(0);
    ChangeList in = result.get(1);
    ChangeList done = result.get(2);
    if (mine) {
        setWindowTitle(Util.C.myDashboardTitle());
        setPageTitle(Util.C.myDashboardTitle());
    } else {
        // The server doesn't tell us who the dashboard is for. Try to guess
        // by looking at a change started by the owner and extract the name.
        String name = guessName(out);
        if (name == null) {
            name = guessName(done);
        }
        if (name != null) {
            setWindowTitle(name);
            setPageTitle(Util.M.accountDashboardTitle(name));
        } else {
            setWindowTitle(Util.C.unknownDashboardTitle());
            setWindowTitle(Util.C.unknownDashboardTitle());
        }
    }
    Collections.sort(out.asList(), outComparator());
    table.updateColumnsForLabels(out, in, done);
    outgoing.display(out);
    incoming.display(in);
    closed.display(done);
    table.finishDisplay();
}
#end_block

#method_before
public final SubmitRecord.Label.Status status() {
    if (approved() != null) {
        return SubmitRecord.Label.Status.OK;
    } else if (rejected() != null) {
        return SubmitRecord.Label.Status.REJECT;
    } else {
        return SubmitRecord.Label.Status.NEED;
    }
}
#method_after
public final SubmitRecord.Label.Status status() {
    if (approved() != null) {
        return SubmitRecord.Label.Status.OK;
    } else if (rejected() != null) {
        return SubmitRecord.Label.Status.REJECT;
    } else if (optional()) {
        return SubmitRecord.Label.Status.MAY;
    } else {
        return SubmitRecord.Label.Status.NEED;
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed, Account.Id accountId) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(c.id_abbreviated(), c));
    String subject = c.subject();
    if (subject.length() > 80) {
        subject = subject.substring(0, 80);
    }
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        subject += " (" + Util.toLongString(status) + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    String owner = "";
    if (c.owner() != null && c.owner().name() != null) {
        owner = c.owner().name();
    }
    table.setWidget(row, C_OWNER, new InlineHyperlink(owner, PageLinks.toAccountQuery(owner)));
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    boolean reviewScored = false;
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            table.clearCell(row, col);
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
        reviewScored = true;
    }
    boolean needHighlight = false;
    // patch set, we also don't highlight it.
    if (highlightUnreviewed && !reviewScored && accountId != null) {
        needHighlight = true;
        for (int i = 0; i < c.messageAuthorIds().length(); i++) {
            if (accountId.get() == c.messageAuthorIds().get(i)) {
                needHighlight = false;
                break;
            }
        }
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(c.id_abbreviated(), c));
    String subject = c.subject();
    if (subject.length() > 80) {
        subject = subject.substring(0, 80);
    }
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        subject += " (" + Util.toLongString(status) + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    String owner = "";
    if (c.owner() != null && c.owner().name() != null) {
        owner = c.owner().name();
    }
    table.setWidget(row, C_OWNER, new InlineHyperlink(owner, PageLinks.toAccountQuery(owner)));
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            table.clearCell(row, col);
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
public void display(ChangeList changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    } else {
        parent.removeRow(dataBegin);
    }
    if (sz == 0) {
        parent.insertNoneRow(dataBegin);
        return;
    }
    while (rows < sz) {
        parent.insertChangeRow(dataBegin + rows);
        rows++;
    }
    for (int i = 0; i < sz; i++) {
        parent.populateChangeRow(dataBegin + i, changeList.get(i), highlightUnreviewed, ownerId);
    }
}
#method_after
public void display(ChangeList changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    } else {
        parent.removeRow(dataBegin);
    }
    if (sz == 0) {
        parent.insertNoneRow(dataBegin);
        return;
    }
    while (rows < sz) {
        parent.insertChangeRow(dataBegin + rows);
        rows++;
    }
    for (int i = 0; i < sz; i++) {
        parent.populateChangeRow(dataBegin + i, changeList.get(i), highlightUnreviewed);
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.id = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.labels = labelsFor(cd);
    out.messageauthors = recentMessageAuthorIds(cd);
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.id = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd);
    return out;
}
#end_block

#method_before
private AccountAttribute asAccountAttribute(Account.Id user) {
    AccountAttribute a = accounts.get(user);
    if (a == null) {
        a = new AccountAttribute();
        accounts.put(user, a);
    }
    return a;
}
#method_after
private AccountAttribute asAccountAttribute(Account.Id user) {
    if (user == null) {
        return null;
    }
    AccountAttribute a = accounts.get(user);
    if (a == null) {
        a = new AccountAttribute();
        accounts.put(user, a);
    }
    return a;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    Change in = cd.change(db);
    ChangeControl ctl = cd.changeControl();
    if (ctl == null || ctl.getCurrentUser() != user) {
        try {
            ctl = changeControlFactory.controlFor(in);
        } catch (NoSuchChangeException e) {
            return null;
        }
    }
    PatchSet ps = cd.currentPatchSet(db);
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                }
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    Change in = cd.change(db);
    ChangeControl ctl = cd.changeControl();
    if (ctl == null || ctl.getCurrentUser() != user) {
        try {
            ctl = changeControlFactory.controlFor(in);
        } catch (NoSuchChangeException e) {
            return null;
        }
    }
    PatchSet ps = cd.currentPatchSet(db);
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS, nameTxt, null);
    projectListPopup.addOpenRowHandler(new ProjectListPopup.ProjectListPopupOnOpenRowHandler() {

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            doAddNew();
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    sp.setSize("100%", "100%");
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popup.setHeight("100%");
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            if (top + offsetHeight > Window.getClientHeight()) {
                top = Window.getClientHeight() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#end_block

#method_before
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            calculatePopupCoordinates();
            projectListPopup.display();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#method_after
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    projectsTab = new ProjectsTable() {

        {
            keysNavigation.add(new OpenKeyCommand(0, 'o', Util.C.projectListOpen()));
            keysNavigation.add(new OpenKeyCommand(0, KeyCodes.KEY_ENTER, Util.C.projectListOpen()));
        }

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            // prevent user input from being overwritten by simply poping up
            if (!popingUp || "".equals(nameBox.getText())) {
                nameBox.setText(getRowItem(row).name());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            nameBox.setText(getRowItem(row).name());
            doAddNew();
        }
    };
    projectsTab.setSavePointerId(PageLinks.SETTINGS_PROJECTS);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(Util.C.projects());
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    closePopup();
}
#end_block

#method_before
public void display(final String commitMessage) {
    String commitSummary = "";
    String commitBody = "";
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    commitSummary = splitCommitMessage[0];
    commitBody = SafeHtmlUtils.htmlEscape(splitCommitMessage[1]);
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.setAttribute("style", "display: none;");
    }
    commitSummaryPre.setInnerText(commitSummary);
    // Linkify commit body for Change-Id etc.
    SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
    commitBodyLinkified = commitBodyLinkified.linkify();
    commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
    commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
}
#method_after
public void display(final String commitMessage) {
    String commitSummary = "";
    String commitBody = "";
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    commitSummary = splitCommitMessage[0];
    commitBody = splitCommitMessage[1];
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.setAttribute("style", "display: none;");
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    // Linkify commit body
    SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
    commitBodyLinkified = commitBodyLinkified.linkify();
    commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        final Provider<Command> p = commands.get(commandName);
        if (p == null) {
            String msg = (prefix.isEmpty() ? "Gerrit Code Review" : prefix) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (prefix.isEmpty())
                bc.setName(commandName);
            else
                bc.setName(prefix + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        final Provider<Command> p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#end_block

#method_before
@Override
protected String usage() {
    final StringBuilder usage = new StringBuilder();
    usage.append("Available commands");
    if (!prefix.isEmpty()) {
        usage.append(" of ");
        usage.append(prefix);
    }
    usage.append(" are:\n");
    usage.append("\n");
    for (Map.Entry<String, Provider<Command>> e : commands.entrySet()) {
        usage.append("   ");
        usage.append(e.getKey());
        usage.append("\n");
    }
    usage.append("\n");
    usage.append("See '");
    if (prefix.indexOf(' ') < 0) {
        usage.append(prefix);
        usage.append(' ');
    }
    usage.append("COMMAND --help' for more information.\n");
    usage.append("\n");
    return usage.toString();
}
#method_after
@Override
protected String usage() {
    final StringBuilder usage = new StringBuilder();
    usage.append("Available commands");
    if (!getName().isEmpty()) {
        usage.append(" of ");
        usage.append(getName());
    }
    usage.append(" are:\n");
    usage.append("\n");
    for (String name : Sets.newTreeSet(commands.keySet())) {
        usage.append("   ");
        usage.append(name);
        usage.append("\n");
    }
    usage.append("\n");
    usage.append("See '");
    if (getName().indexOf(' ') < 0) {
        usage.append(getName());
        usage.append(' ');
    }
    usage.append("COMMAND --help' for more information.\n");
    usage.append("\n");
    return usage.toString();
}
#end_block

#method_before
@Override
protected void run() {
    loader.rescan(true);
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (names == null || names.isEmpty()) {
        loader.rescan();
    } else {
        try {
            loader.reload(names);
        } catch (InvalidPluginException e) {
            throw die(e.getMessage());
        } catch (PluginInstallException e) {
            throw die(e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    noCache(res);
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (Error err) {
        handleError(err, req, res);
    } catch (RuntimeException err) {
        handleError(err, req, res);
    }
}
#method_after
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    noCache(res);
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        res.setStatus(HttpServletResponse.SC_FORBIDDEN);
        noCache(res);
        sendText(req, res, err.getMessage());
    } catch (Error err) {
        handleError(err, req, res);
    } catch (RuntimeException err) {
        handleError(err, req, res);
    }
}
#end_block

#method_before
private void checkRequiresCapability() throws RuntimeException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), rc.value());
            throw new RuntimeException(msg);
        }
    }
}
#method_after
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#end_block

#method_before
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        final PatchList patchList = repo != null ? getPatchList() : null;
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            final int lineNbr = c.getLine();
            final short side = c.getSide();
            if (!pk.equals(currentFileKey)) {
                cmts.append("....................................................\n");
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message\n");
                } else {
                    cmts.append("File ");
                    cmts.append(pk.get());
                    cmts.append("\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.getFileName());
                    } catch (IOException e) {
                    // Don't quote the line if we can't load it.
                    }
                } else {
                    currentFileData = null;
                }
            }
            for (int line = lineNbr - lines + 1; line <= lineNbr; ++line) {
                appendFileLine(cmts, currentFileData, side, line);
            }
            cmts.append(c.getMessage().trim());
            cmts.append("\n");
            for (int line = lineNbr + 1; line < lineNbr + lines; ++line) {
                appendFileLine(cmts, currentFileData, side, line);
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#method_after
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        final PatchList patchList = repo != null ? getPatchList() : null;
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            final int lineNbr = c.getLine();
            final short side = c.getSide();
            if (!pk.equals(currentFileKey)) {
                cmts.append("....................................................\n");
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message\n");
                } else {
                    cmts.append("File ");
                    cmts.append(pk.get());
                    cmts.append("\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.getFileName());
                    } catch (IOException e) {
                    // Don't quote the line if we can't load it.
                    }
                } else {
                    currentFileData = null;
                }
            }
            if (currentFileData != null) {
                int maxLines;
                try {
                    maxLines = currentFileData.getLineCount(side);
                } catch (Throwable e) {
                    maxLines = lineNbr;
                }
                final int startLine = Math.max(1, lineNbr - lines + 1);
                final int stopLine = Math.min(maxLines, lineNbr + lines);
                for (int line = startLine; line <= lineNbr; ++line) {
                    appendFileLine(cmts, currentFileData, side, line);
                }
                cmts.append(c.getMessage().trim());
                cmts.append("\n");
                for (int line = lineNbr + 1; line < stopLine; ++line) {
                    appendFileLine(cmts, currentFileData, side, line);
                }
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#end_block

#method_before
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    cmts.append("Line " + line);
    if (fileData != null) {
        try {
            final String lineStr = fileData.getLine(side, line);
            cmts.append(": ");
            cmts.append(lineStr);
        } catch (Throwable cce) {
        // Don't quote the line if we can't safely convert it.
        }
    }
    cmts.append("\n");
}
#method_after
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    cmts.append("Line " + line);
    try {
        final String lineStr = fileData.getLine(side, line);
        cmts.append(": ");
        cmts.append(lineStr);
    } catch (Throwable e) {
    // Don't quote the line if we can't safely convert it.
    }
    cmts.append("\n");
}
#end_block

#method_before
private List<GroupReference> suggestAccountGroup(@Nullable final ProjectControl projectControl, final String query, final int limit) {
    final int n = limit <= 0 ? 10 : Math.min(limit, 10);
    List<GroupReference> out = Lists.newArrayListWithCapacity(n);
    for (GroupReference g : groupBackend.suggest(query)) {
        try {
            if (groupControlFactory.controlFor(g.getUUID()).isVisible() || (GroupBackends.isExactSuggestion(g, query) && (projectControl != null) && projectControl.isOwnerAnyRef())) {
                out.add(g);
                if (out.size() == n) {
                    break;
                }
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return out;
}
#method_after
private List<GroupReference> suggestAccountGroup(@Nullable final ProjectControl projectControl, final String query, final int limit) {
    final int n = limit <= 0 ? 10 : Math.min(limit, 10);
    List<GroupReference> out = Lists.newArrayListWithCapacity(n);
    for (GroupReference g : groupBackend.suggest(query)) {
        try {
            if (groupControlFactory.controlFor(g.getUUID()).isVisible() || (GroupBackends.isExactSuggestion(g, query) && projectControl != null && projectControl.isOwnerAnyRef())) {
                out.add(g);
                if (out.size() == n) {
                    break;
                }
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return out;
}
#end_block

#method_before
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<Change.Id> descendants = new HashSet<Change.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                final Change.Id ck = a.getPatchSet().getParentKey();
                if (descendants.add(ck)) {
                    changesToGet.add(a.getPatchSet().getParentKey());
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final Change.Id a : descendants) {
        final Change ac = m.get(a);
        if (ac != null) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#method_after
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<Change.Id> descendants = new HashSet<Change.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                final Change.Id ck = a.getPatchSet().getParentKey();
                if (descendants.add(ck)) {
                    changesToGet.add(ck);
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final Change.Id a : descendants) {
        final Change ac = m.get(a);
        if (ac != null) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#end_block

#method_before
@Override
protected void migrateData(final ReviewDb db, final UpdateUI ui) throws SQLException {
    final Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        stmt.execute("CREATE INDEX submodule_subscription_access_bySubscription" + " ON submodule_subscriptions (submodule_project_name, submodule_branch_name)");
    } catch (SQLException e) {
    // ignore, assume that the index exists already
    } finally {
        stmt.close();
    }
}
#method_after
@Override
protected void migrateData(final ReviewDb db, final UpdateUI ui) throws SQLException {
    final Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        stmt.execute("CREATE INDEX submodule_subscription_access_bySubscription" + " ON submodule_subscriptions (submodule_project_name, submodule_branch_name)");
    } catch (SQLException e) {
        // the index creation might have failed because the index exists already,
        // in this case the exception can be safely ignored,
        // but there are also other possible reasons for an exception here that
        // should not be ignored,
        // -> ask the user whether to ignore this exception or not
        ui.message("warning: Cannot create index for submodule subscriptions");
        ui.message(e.getMessage());
        if (ui.isBatch()) {
            ui.message("you may ignore this warning when running in interactive mode");
            throw e;
        } else {
            final boolean answer = ui.yesno(false, "Ignore warning and proceed with schema upgrade");
            if (!answer) {
                throw e;
            }
        }
    } finally {
        stmt.close();
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore(repoManager));
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, repoManager, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch);
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#end_block

#method_before
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canRestore(repoManager)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a message to accompany the restored change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
        if (changeComment != null && changeComment.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(changeComment);
        }
        cmsg.setMessage(msgBuf.toString());
        // Restore the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
        hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException, RepositoryNotFoundException, IOException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canRestore()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
        return result;
    }
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Branch.NameKey destBranch = control.getChange().getDest();
    if (!ProjectUtil.branchExists(repoManager, destBranch)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.DEST_BRANCH_NOT_FOUND, destBranch.get()));
        return result;
    }
    // Create a message to accompany the restored change
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
    if (changeComment != null && changeComment.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(changeComment);
    }
    cmsg.setMessage(msgBuf.toString());
    // Restore the change
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.NEW);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
    hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    return result;
}
#end_block

#method_before
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canAdministrateServer()) {
                String msg = String.format("fatal: %s does not have \"Administrator\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(1, msg);
            }
            parseCommandLine();
            if (active && inactive) {
                throw new UnloggedFailure(1, "You can't use both --active and --inactive");
            }
            setAccount();
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canAdministrateServer()) {
                String msg = String.format("fatal: %s does not have \"Administrator\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(1, msg);
            }
            parseCommandLine();
            validate();
            setAccount();
        }
    });
}
#end_block

#method_before
private void setAccount() throws OrmException, IOException, InvalidSshKeyException, UnloggedFailure {
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw die("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    final Account account;
    AccountExternalId.Key key = new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username);
    AccountExternalId accExtId = db.accountExternalIds().get(key);
    if (accExtId != null) {
        account = db.accounts().get(accExtId.getAccountId());
    } else {
        throw die("Could not find user : " + username);
    }
    Account.Id id = account.getId();
    if (newEmail != null) {
        link(id, newEmail);
    }
    if (oldEmail != null) {
        deleteMail(id, oldEmail);
    }
    if (fullName != null && realm.allowsEdit(FieldName.FULL_NAME)) {
        account.setFullName(fullName);
    }
    if (active) {
        account.setActive(true);
    } else if (inactive) {
        account.setActive(false);
    }
    final String readAddKey = readSshKey(addSshKey);
    if (readAddKey != null) {
        addSshKey(readAddKey, account);
    }
    final String readDeleteKey = readSshKey(deleteSshKey);
    if (readDeleteKey != null) {
        deleteSshKeys(readDeleteKey, account);
    }
    db.accounts().update(Collections.singleton(account));
    byIdCache.evict(id);
    db.close();
}
#method_after
private void setAccount() throws OrmException, IOException, UnloggedFailure {
    final Account account = db.accounts().get(id);
    boolean accountUpdated = false;
    boolean sshKeysUpdated = false;
    for (String email : addEmails) {
        link(id, email);
    }
    for (String email : deleteEmails) {
        deleteMail(id, email);
    }
    if (fullName != null) {
        if (realm.allowsEdit(FieldName.FULL_NAME)) {
            account.setFullName(fullName);
        } else {
            throw new UnloggedFailure(1, "The realm doesn't allow editing names");
        }
    }
    if (active) {
        accountUpdated = true;
        account.setActive(true);
    } else if (inactive) {
        accountUpdated = true;
        account.setActive(false);
    }
    addSshKeys = readSshKey(addSshKeys);
    if (!addSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        addSshKeys(addSshKeys, account);
    }
    deleteSshKeys = readSshKey(deleteSshKeys);
    if (!deleteSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        deleteSshKeys(deleteSshKeys, account);
    }
    if (accountUpdated) {
        db.accounts().update(Collections.singleton(account));
        byIdCache.evict(id);
    }
    if (sshKeysUpdated) {
        sshKeyCache.evict(account.getUserName());
    }
    db.close();
}
#end_block

#method_before
private void deleteSshKeys(final String readDeleteKey, final Account account) throws OrmException {
    ResultSet<AccountSshKey> keys = db.accountSshKeys().byAccount(account.getId());
    if (readDeleteKey.equals("ALL")) {
        db.accountSshKeys().delete(keys);
    } else {
        for (AccountSshKey accountSshKey : keys) {
            if (accountSshKey.getSshPublicKey().equals(readDeleteKey)) {
                db.accountSshKeys().delete(Collections.singleton(accountSshKey));
            }
        }
    }
    sshKeyCache.evict(account.getUserName());
}
#method_after
private void deleteSshKeys(final List<String> keys, final Account account) throws OrmException {
    ResultSet<AccountSshKey> allKeys = db.accountSshKeys().byAccount(account.getId());
    if (keys.contains("ALL")) {
        db.accountSshKeys().delete(allKeys);
    } else {
        List<AccountSshKey> accountKeys = new ArrayList<AccountSshKey>();
        for (String key : keys) {
            for (AccountSshKey accountSshKey : allKeys) {
                if (key.trim().equals(accountSshKey.getSshPublicKey()) || accountSshKey.getComment().trim().equals(key)) {
                    accountKeys.add(accountSshKey);
                }
            }
        }
        db.accountSshKeys().delete(accountKeys);
    }
}
#end_block

#method_before
private void deleteMail(Account.Id id, final String mailAddress) throws UnloggedFailure {
    if (mailAddress.equals("ALL")) {
        ResultSet<AccountExternalId> ids;
        try {
            ids = db.accountExternalIds().byAccount(id);
        } catch (OrmException e) {
            throw die("Could not query database: " + e.getMessage());
        }
        for (AccountExternalId extId : ids) {
            unlink(id, extId.getEmailAddress());
        }
    } else {
        unlink(id, mailAddress);
    }
}
#method_after
private void deleteMail(Account.Id id, final String mailAddress) throws UnloggedFailure, OrmException {
    if (mailAddress.equals("ALL")) {
        ResultSet<AccountExternalId> ids = db.accountExternalIds().byAccount(id);
        for (AccountExternalId extId : ids) {
            if (extId.isScheme(AccountExternalId.SCHEME_MAILTO)) {
                unlink(id, extId.getEmailAddress());
            }
        }
    } else {
        AccountExternalId.Key key = new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, mailAddress);
        AccountExternalId extId = db.accountExternalIds().get(key);
        if (extId != null) {
            unlink(id, mailAddress);
        }
    }
}
#end_block

#method_before
private String readSshKey(String sshKey) throws UnsupportedEncodingException, IOException, InvalidSshKeyException {
    if (sshKey == null) {
        return null;
    }
    if ("-".equals(sshKey)) {
        sshKey = "";
        BufferedReader br = new BufferedReader(new InputStreamReader(in, "UTF-8"));
        String line;
        while ((line = br.readLine()) != null) {
            sshKey += line + "\n";
        }
    }
    return sshKey.trim();
}
#method_after
private List<String> readSshKey(final List<String> sshKeys) throws UnsupportedEncodingException, IOException {
    if (!sshKeys.isEmpty()) {
        String sshKey = "";
        int idx = sshKeys.indexOf("-");
        if (idx >= 0) {
            sshKey = "";
            BufferedReader br = new BufferedReader(new InputStreamReader(in, "UTF-8"));
            String line;
            while ((line = br.readLine()) != null) {
                sshKey += line + "\n";
            }
            sshKeys.set(idx, sshKey);
        }
    }
    return sshKeys;
}
#end_block

#method_before
@Override
protected void onCellDoubleClick(final int row, int column) {
    if (column > 0 && getRowItem(row) instanceof PatchLine) {
        final PatchLine line = (PatchLine) getRowItem(row);
        final short file = (short) ((column - 1) / 2);
        if (column < (1 + file * 2 + 1)) {
            column++;
        }
        switch(file) {
            case 0:
                createCommentEditor(row + 1, column, line.getLineA(), file);
                break;
            case 1:
                createCommentEditor(row + 1, column, line.getLineB(), file);
                break;
        }
    }
}
#method_after
@Override
protected void onCellDoubleClick(final int row, int column) {
    if (column > 0 && getRowItem(row) instanceof PatchLine) {
        final PatchLine line = (PatchLine) getRowItem(row);
        if (column == 1 || column == A) {
            createCommentEditor(row + 1, A, line.getLineA(), (short) 0);
        } else if (column == B || column == 4) {
            createCommentEditor(row + 1, B, line.getLineB(), (short) 1);
        }
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
@Override
protected void onInsertComment(final PatchLine line) {
    final int row = getCurrentRow();
    createCommentEditor(row + 1, 4, line.getLineB(), (short) 1);
}
#method_after
@Override
protected void onInsertComment(final PatchLine line) {
    final int row = getCurrentRow();
    createCommentEditor(row + 1, B, line.getLineB(), (short) 1);
}
#end_block

#method_before
@Override
protected void render(final PatchScript script) {
    a = getSparseHtmlFileA(script);
    b = getSparseHtmlFileB(script);
    final ArrayList<Object> lines = new ArrayList<Object>();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    final boolean intraline = script.getDiffPrefs().isIntralineDifference() && script.hasIntralineDifference();
    appendHeader(script, nc);
    lines.add(null);
    if (script.getFileModeA() != FileMode.FILE || script.getFileModeB() != FileMode.FILE) {
        openLine(nc);
        appendModeLine(nc, script.getFileModeA());
        appendModeLine(nc, script.getFileModeB());
        closeLine(nc);
        lines.add(null);
    }
    int lastA = 0;
    int lastB = 0;
    final boolean ignoreWS = script.isIgnoreWhitespace();
    for (final EditList.Hunk hunk : script.getHunks()) {
        if (!hunk.isStartOfFile()) {
            appendSkipLine(nc, hunk.getCurB() - lastB);
            lines.add(new SkippedLine(lastA, lastB, hunk.getCurB() - lastB));
        }
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                final SafeHtml ctx = a.getSafeHtmlLine(hunk.getCurA());
                appendLineText(nc, hunk.getCurA(), CONTEXT, ctx, false, false);
                if (ignoreWS && b.contains(hunk.getCurB())) {
                    appendLineText(nc, hunk.getCurB(), CONTEXT, b, hunk.getCurB(), false);
                } else {
                    appendLineText(nc, hunk.getCurB(), CONTEXT, ctx, false, false);
                }
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isModifiedLine()) {
                final boolean del = hunk.isDeletedA();
                final boolean ins = hunk.isInsertedB();
                final boolean full = intraline && hunk.getCurEdit().getType() != Edit.Type.REPLACE;
                openLine(nc);
                if (del) {
                    appendLineText(nc, hunk.getCurA(), DELETE, a, hunk.getCurA(), full);
                    hunk.incA();
                } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                    appendLineNone(nc, DELETE);
                } else {
                    appendLineNone(nc, CONTEXT);
                }
                if (ins) {
                    appendLineText(nc, hunk.getCurB(), INSERT, b, hunk.getCurB(), full);
                    hunk.incB();
                } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                    appendLineNone(nc, INSERT);
                } else {
                    appendLineNone(nc, CONTEXT);
                }
                closeLine(nc);
                if (del && ins) {
                    lines.add(new PatchLine(REPLACE, hunk.getCurA(), hunk.getCurB()));
                } else if (del) {
                    lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                } else if (ins) {
                    lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                }
            }
        }
        lastA = hunk.getCurA();
        lastB = hunk.getCurB();
    }
    if (lastB != b.size()) {
        appendSkipLine(nc, b.size() - lastB);
        lines.add(new SkippedLine(lastA, lastB, b.size() - lastB));
    }
    resetHtml(nc);
    initScript(script);
    for (int row = 0; row < lines.size(); row++) {
        setRowItem(row, lines.get(row));
        if (lines.get(row) instanceof SkippedLine) {
            createSkipLine(row, (SkippedLine) lines.get(row));
        }
    }
}
#method_after
@Override
protected void render(final PatchScript script) {
    a = getSparseHtmlFileA(script);
    b = getSparseHtmlFileB(script);
    final ArrayList<Object> lines = new ArrayList<Object>();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    final boolean intraline = script.getDiffPrefs().isIntralineDifference() && script.hasIntralineDifference();
    appendHeader(script, nc);
    lines.add(null);
    if (script.getFileModeA() != FileMode.FILE || script.getFileModeB() != FileMode.FILE) {
        openLine(nc);
        appendModeLine(nc, script.getFileModeA());
        appendModeLine(nc, script.getFileModeB());
        closeLine(nc);
        lines.add(null);
    }
    int lastA = 0;
    int lastB = 0;
    final boolean ignoreWS = script.isIgnoreWhitespace();
    for (final EditList.Hunk hunk : script.getHunks()) {
        if (!hunk.isStartOfFile()) {
            appendSkipLine(nc, hunk.getCurB() - lastB);
            lines.add(new SkippedLine(lastA, lastB, hunk.getCurB() - lastB));
        }
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                final SafeHtml ctx = a.getSafeHtmlLine(hunk.getCurA());
                appendLineNumber(nc, hunk.getCurA(), false);
                appendLineText(nc, CONTEXT, ctx, false, false);
                if (ignoreWS && b.contains(hunk.getCurB())) {
                    appendLineText(nc, CONTEXT, b, hunk.getCurB(), false);
                } else {
                    appendLineText(nc, CONTEXT, ctx, false, false);
                }
                appendLineNumber(nc, hunk.getCurB(), true);
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isModifiedLine()) {
                final boolean del = hunk.isDeletedA();
                final boolean ins = hunk.isInsertedB();
                final boolean full = intraline && hunk.getCurEdit().getType() != Edit.Type.REPLACE;
                openLine(nc);
                if (del) {
                    appendLineNumber(nc, hunk.getCurA(), false);
                    appendLineText(nc, DELETE, a, hunk.getCurA(), full);
                    hunk.incA();
                } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                    appendLineNumber(nc, false);
                    appendLineNone(nc, DELETE);
                } else {
                    appendLineNumber(nc, false);
                    appendLineNone(nc, CONTEXT);
                }
                if (ins) {
                    appendLineText(nc, INSERT, b, hunk.getCurB(), full);
                    appendLineNumber(nc, hunk.getCurB(), true);
                    hunk.incB();
                } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                    appendLineNone(nc, INSERT);
                    appendLineNumber(nc, true);
                } else {
                    appendLineNone(nc, CONTEXT);
                    appendLineNumber(nc, true);
                }
                closeLine(nc);
                if (del && ins) {
                    lines.add(new PatchLine(REPLACE, hunk.getCurA(), hunk.getCurB()));
                } else if (del) {
                    lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                } else if (ins) {
                    lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                }
            }
        }
        lastA = hunk.getCurA();
        lastB = hunk.getCurB();
    }
    if (lastB != b.size()) {
        appendSkipLine(nc, b.size() - lastB);
        lines.add(new SkippedLine(lastA, lastB, b.size() - lastB));
    }
    resetHtml(nc);
    initScript(script);
    for (int row = 0; row < lines.size(); row++) {
        setRowItem(row, lines.get(row));
        if (lines.get(row) instanceof SkippedLine) {
            createSkipLine(row, (SkippedLine) lines.get(row));
        }
    }
}
#end_block

#method_before
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    for (int row = 0; row < table.getRowCount(); ) {
        if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            final List<PatchLineComment> fora = cd.getForA(pLine.getLineA());
            final List<PatchLineComment> forb = cd.getForB(pLine.getLineB());
            row++;
            final Iterator<PatchLineComment> ai = fora.iterator();
            final Iterator<PatchLineComment> bi = forb.iterator();
            while (ai.hasNext() && bi.hasNext()) {
                final PatchLineComment ac = ai.next();
                final PatchLineComment bc = bi.next();
                insertRow(row);
                bindComment(row, COL_A, ac, !ai.hasNext(), expandComments);
                bindComment(row, COL_B, bc, !bi.hasNext(), expandComments);
                row++;
            }
            row = finish(ai, row, COL_A, expandComments);
            row = finish(bi, row, COL_B, expandComments);
        } else {
            row++;
        }
    }
}
#method_after
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    for (int row = 0; row < table.getRowCount(); ) {
        if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            final List<PatchLineComment> fora = cd.getForA(pLine.getLineA());
            final List<PatchLineComment> forb = cd.getForB(pLine.getLineB());
            row++;
            final Iterator<PatchLineComment> ai = fora.iterator();
            final Iterator<PatchLineComment> bi = forb.iterator();
            while (ai.hasNext() && bi.hasNext()) {
                final PatchLineComment ac = ai.next();
                final PatchLineComment bc = bi.next();
                insertRow(row);
                bindComment(row, A, ac, !ai.hasNext(), expandComments);
                bindComment(row, B, bc, !bi.hasNext(), expandComments);
                row++;
            }
            row = finish(ai, row, A, expandComments);
            row = finish(bi, row, B, expandComments);
        } else {
            row++;
        }
    }
}
#end_block

#method_before
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, COL_A - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, COL_A, Gerrit.RESOURCES.css().diffText());
    fmt.addStyleName(row, COL_B - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, COL_B, Gerrit.RESOURCES.css().diffText());
}
#method_after
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, A - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, A, Gerrit.RESOURCES.css().diffText());
    fmt.addStyleName(row, B, Gerrit.RESOURCES.css().diffText());
    fmt.addStyleName(row, B + 1, Gerrit.RESOURCES.css().lineNumber());
}
#end_block

#method_before
private void appendHeader(PatchScript script, final SafeHtmlBuilder m) {
    m.openTr();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconCell());
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.addStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.setAttribute("width", "50%");
    if (script.getChangeType() == ChangeType.RENAMED || script.getChangeType() == ChangeType.COPIED) {
        m.append(script.getOldName());
    } else {
        m.append(PatchUtil.C.patchHeaderOld());
    }
    m.br();
    if (0 < script.getA().size()) {
        if (idSideA == null) {
            downloadLink(m, patchKey, "1");
        } else {
            downloadLink(m, new Patch.Key(idSideA, patchKey.get()), "0");
        }
    }
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.addStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.setAttribute("width", "50%");
    m.append(PatchUtil.C.patchHeaderNew());
    m.br();
    if (0 < script.getB().size()) {
        downloadLink(m, new Patch.Key(idSideB, patchKey.get()), "0");
    }
    m.closeTd();
    m.closeTr();
}
#method_after
private void appendHeader(PatchScript script, final SafeHtmlBuilder m) {
    boolean isCommitMessage = Patch.COMMIT_MSG.equals(script.getNewName());
    m.openTr();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconCell());
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.addStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.setAttribute("width", "50%");
    if (script.getChangeType() == ChangeType.RENAMED || script.getChangeType() == ChangeType.COPIED) {
        m.append(script.getOldName());
    } else {
        m.append(PatchUtil.C.patchHeaderOld());
    }
    if (!isCommitMessage) {
        m.br();
        if (0 < script.getA().size()) {
            if (idSideA == null) {
                downloadLink(m, patchKey, "1");
            } else {
                downloadLink(m, new Patch.Key(idSideA, patchKey.get()), "0");
            }
        }
    }
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.setAttribute("width", "50%");
    m.append(PatchUtil.C.patchHeaderNew());
    if (!isCommitMessage) {
        m.br();
        if (0 < script.getB().size()) {
            downloadLink(m, new Patch.Key(idSideB, patchKey.get()), "0");
        }
    }
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.addStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.closeTd();
    m.closeTr();
}
#end_block

#method_before
private void expand(ClickEvent event, final int numRows) {
    Cell cell = table.getCellForEvent(event);
    int row = cell.getRowIndex();
    if (!(getRowItem(row) instanceof SkippedLine)) {
        return;
    }
    SkippedLine line = (SkippedLine) getRowItem(row);
    int loopTo = numRows;
    if (numRows == 0) {
        loopTo = line.getSize();
    } else if (numRows < 0) {
        loopTo = -numRows;
    }
    int offset = 0;
    if (numRows < 0) {
        offset = 1;
    }
    for (int i = 0 + offset; i < loopTo + offset; i++) {
        // The overridden version of insertRow adds some css classes we don't
        // want.
        super.insertRow(row + i);
        table.getRowFormatter().setVerticalAlign(row + i, HasVerticalAlignment.ALIGN_TOP);
        int lineA = line.getStartA() + i;
        int lineB = line.getStartB() + i;
        if (numRows < 0) {
            lineA = line.getStartA() + line.getSize() + numRows + i - offset;
            lineB = line.getStartB() + line.getSize() + numRows + i - offset;
        }
        setHtml(row + i, 1, "<a href=\"javascript:void(0)\">" + (lineA + 1) + "</a>");
        addStyle(row + i, 1, Gerrit.RESOURCES.css().lineNumber());
        setHtml(row + i, 2, a.getSafeHtmlLine(lineA).asString());
        addStyle(row + i, 2, Gerrit.RESOURCES.css().fileLine());
        addStyle(row + i, 2, Gerrit.RESOURCES.css().fileLineCONTEXT());
        setHtml(row + i, 3, "<a href=\"javascript:void(0)\">" + (lineB + 1) + "</a>");
        addStyle(row + i, 3, Gerrit.RESOURCES.css().lineNumber());
        setHtml(row + i, 4, b.getSafeHtmlLine(lineB).asString());
        addStyle(row + i, 4, Gerrit.RESOURCES.css().fileLine());
        addStyle(row + i, 4, Gerrit.RESOURCES.css().fileLineCONTEXT());
        setRowItem(row + i, new PatchLine(CONTEXT, lineA, lineB));
    }
    if (numRows > 0) {
        line.incrementStart(numRows);
        createSkipLine(row + loopTo, line);
    } else if (numRows < 0) {
        line.reduceSize(-numRows);
        createSkipLine(row, line);
    } else {
        removeRow(row + loopTo);
    }
}
#method_after
private void expand(ClickEvent event, final int numRows) {
    int row = table.getCellForEvent(event).getRowIndex();
    if (!(getRowItem(row) instanceof SkippedLine)) {
        return;
    }
    SkippedLine line = (SkippedLine) getRowItem(row);
    int loopTo = numRows;
    if (numRows == 0) {
        loopTo = line.getSize();
    } else if (numRows < 0) {
        loopTo = -numRows;
    }
    int offset = 0;
    if (numRows < 0) {
        offset = 1;
    }
    CellFormatter fmt = table.getCellFormatter();
    for (int i = 0 + offset; i < loopTo + offset; i++) {
        // The overridden version of insertRow adds some css classes we don't
        // want.
        super.insertRow(row + i);
        table.getRowFormatter().setVerticalAlign(row + i, HasVerticalAlignment.ALIGN_TOP);
        int lineA = line.getStartA() + i;
        int lineB = line.getStartB() + i;
        if (numRows < 0) {
            lineA = line.getStartA() + line.getSize() + numRows + i - offset;
            lineB = line.getStartB() + line.getSize() + numRows + i - offset;
        }
        table.setHTML(row + i, A - 1, "<a href=\"javascript:;\">" + (lineA + 1) + "</a>");
        fmt.addStyleName(row + i, A - 1, Gerrit.RESOURCES.css().lineNumber());
        table.setHTML(row + i, A, a.getSafeHtmlLine(lineA).asString());
        fmt.addStyleName(row + i, A, Gerrit.RESOURCES.css().fileLine());
        fmt.addStyleName(row + i, A, Gerrit.RESOURCES.css().fileLineCONTEXT());
        table.setHTML(row + i, B, b.getSafeHtmlLine(lineB).asString());
        fmt.addStyleName(row + i, B, Gerrit.RESOURCES.css().fileLine());
        fmt.addStyleName(row + i, B, Gerrit.RESOURCES.css().fileLineCONTEXT());
        table.setHTML(row + i, B + 1, "<a href=\"javascript:;\">" + (lineB + 1) + "</a>");
        fmt.addStyleName(row + i, B + 1, Gerrit.RESOURCES.css().lineNumber());
        setRowItem(row + i, new PatchLine(CONTEXT, lineA, lineB));
    }
    if (numRows > 0) {
        line.incrementStart(numRows);
        createSkipLine(row + loopTo, line);
    } else if (numRows < 0) {
        line.reduceSize(-numRows);
        createSkipLine(row, line);
    } else {
        table.removeRow(row + loopTo);
    }
}
#end_block

#method_before
private void createSkipLine(int row, SkippedLine line) {
    FlowPanel p = new FlowPanel();
    Label l1 = new Label(" " + PatchUtil.C.patchSkipRegionStart() + " ");
    Anchor all = new Anchor(String.valueOf(line.getSize()));
    Label l2 = new Label(" " + PatchUtil.C.patchSkipRegionEnd() + " ");
    all.addClickHandler(expandAllListener);
    if (line.getSize() > 30) {
        // We only show the expand before & after links if we skip more than
        // 30 lines.
        Anchor before = new Anchor(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
        before.addClickHandler(expandBeforeListener);
        Anchor after = new Anchor(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
        after.addClickHandler(expandAfterListener);
        p.add(before);
        p.add(l1);
        p.add(all);
        p.add(l2);
        p.add(after);
    } else {
        p.add(l1);
        p.add(all);
        p.add(l2);
    }
    setWidget(row, 1, p);
}
#method_after
private void createSkipLine(int row, SkippedLine line) {
    FlowPanel p = new FlowPanel();
    InlineLabel l1 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionStart() + " ");
    InlineLabel l2 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionEnd() + " ");
    Anchor all = new Anchor(String.valueOf(line.getSize()));
    all.addClickHandler(expandAllListener);
    all.setStyleName(Gerrit.RESOURCES.css().skipLine());
    if (line.getSize() > 30) {
        // Only show the expand before/after if skipped more than 30 lines.
        Anchor b = new Anchor(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND), true);
        Anchor a = new Anchor(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND), true);
        b.addClickHandler(expandBeforeListener);
        a.addClickHandler(expandAfterListener);
        b.setStyleName(Gerrit.RESOURCES.css().skipLine());
        a.setStyleName(Gerrit.RESOURCES.css().skipLine());
        p.add(b);
        p.add(l1);
        p.add(all);
        p.add(l2);
        p.add(a);
    } else {
        p.add(l1);
        p.add(all);
        p.add(l2);
    }
    table.setWidget(row, 1, p);
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(SafeHtml.asis("<a href=\"javascript:void(0)\">" + (lineNumberMinusOne + 1) + "</a>"));
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, final PatchLine.Type type, final SparseHtmlFile src, final int i, final boolean fullBlock) {
    appendLineText(m, type, src.getSafeHtmlLine(i), src.hasTrailingEdit(i), fullBlock);
}
#end_block

#method_before
private void appendLineNone(final SafeHtmlBuilder m, final PatchLine.Type type) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type != null ? type : PatchLine.Type.CONTEXT) {
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            break;
        default:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineNone());
            break;
    }
    m.closeTd();
}
#method_after
private void appendLineNone(final SafeHtmlBuilder m, final PatchLine.Type type) {
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type != null ? type : PatchLine.Type.CONTEXT) {
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            break;
        default:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineNone());
            break;
    }
    m.closeTd();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            rp.sendMessage("You are not allowed to perform this operation.\n" + "Configuration changes can only be pushed by project owners\n" + "who also have 'Push' rights");
        } else {
            rp.sendMessage("You are not allowed to perform this operation.\n" + "To push into this reference you need 'Push' rights." + MESSAGE_FOOTER);
        }
        reject(cmd, "Current user '" + ctl.getCurrentUser().getUserName() + "' can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "Deleting the project configuration is not allowed");
        } else {
            rp.sendMessage("You need 'Push' rights with the 'Force Push' flag set to delete references." + MESSAGE_FOOTER);
            reject(cmd, "Current user '" + ctl.getCurrentUser().getUserName() + "' can not delete references");
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "can not delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        cmd.execute(rp);
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        rp.sendMessage("You need 'Push' rights to upload code review requests.\n" + "Verify that you are pushing to the right branch." + MESSAGE_FOOTER);
        reject(cmd, "Current user '" + destBranchCtl.getCurrentUser().getUserName() + "' can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "can not upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
        newProgress.update(1);
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(change, ps, info, reviewers);
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private void doReplaces() {
    for (final ReplaceRequest request : replaceByChange.values()) {
        try {
            doReplace(request);
        } catch (IOException err) {
            log.error("Error computing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "diff error");
        } catch (OrmException err) {
            log.error("Error storing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "database error");
        }
        if (request.cmd.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
            log.error("Replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name() + " wasn't attempted." + "  This is a bug in the receive process implementation.");
            reject(request.cmd, "internal error");
        }
    }
}
#method_after
private void doReplaces() {
    for (final ReplaceRequest request : replaceByChange.values()) {
        try {
            doReplace(request, false);
            replaceProgress.update(1);
        } catch (IOException err) {
            log.error("Error computing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "diff error");
        } catch (OrmException err) {
            log.error("Error storing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "database error");
        }
        if (request.cmd.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
            log.error("Replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name() + " wasn't attempted." + "  This is a bug in the receive process implementation.");
            reject(request.cmd, "internal error");
        }
    }
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request, boolean ignoreNoChanges) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq && !ignoreNoChanges) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet)) {
                    if (type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                        // If there was a negative vote on the prior patch set, carry it
                        // into this patch set.
                        // 
                        db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                    }
                }
            }
        }
        approvalsUtil.addReviewers(change, ps, info, reviewers, haveApprovals);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    addMessage(sb.toString());
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req, true);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    ApprovalsUtil.syncChangeStatus(db, change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (Exception e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
@Override
public DeleteBranchesResult call() throws NoSuchProjectException, RepositoryNotFoundException, EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final DeleteBranchesResult result = new DeleteBranchesResult();
    final Iterator<Branch.NameKey> branchIt = toRemove.iterator();
    while (branchIt.hasNext()) {
        final Branch.NameKey k = branchIt.next();
        if (!projectName.equals(k.getParentKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!projectControl.controlForRef(k).canDelete()) {
            throw new IllegalStateException("Cannot delete " + k.getShortName());
        }
        final List<Change> openChanges = db.changes().byBranchOpenAll(k).toList();
        if (!openChanges.isEmpty()) {
            if (!abandonOpenChanges) {
                result.addError(new DeleteBranchesResult.Error(DeleteBranchesResult.Error.Type.OPEN_CHANGES, k));
                branchIt.remove();
            } else {
                final boolean allAbandoned = abandon(openChanges, "Branch " + k.get() + " gets deleted.");
                if (!allAbandoned) {
                    result.addError(new DeleteBranchesResult.Error(DeleteBranchesResult.Error.Type.ABANDON_FAILED, k));
                    branchIt.remove();
                }
            }
        }
    }
    final Set<Branch.NameKey> deleted = new HashSet<Branch.NameKey>();
    final Repository r = repoManager.openRepository(projectName);
    try {
        for (final Branch.NameKey branchKey : toRemove) {
            final String refname = branchKey.get();
            final RefUpdate.Result refUpdateResult;
            final RefUpdate u;
            try {
                u = r.updateRef(refname);
                u.setForceUpdate(true);
                refUpdateResult = u.delete();
            } catch (IOException e) {
                log.error("Cannot delete " + branchKey, e);
                continue;
            }
            switch(refUpdateResult) {
                case NEW:
                case NO_CHANGE:
                case FAST_FORWARD:
                case FORCED:
                    deleted.add(branchKey);
                    replication.scheduleUpdate(projectName, refname);
                    hooks.doRefUpdatedHook(branchKey, u, identifiedUser.getAccount());
                    break;
                case REJECTED_CURRENT_BRANCH:
                    log.warn("Cannot delete " + branchKey + ": " + refUpdateResult.name());
                    break;
                default:
                    log.error("Cannot delete " + branchKey + ": " + refUpdateResult.name());
                    break;
            }
        }
    } finally {
        r.close();
    }
    result.setDeletedBranches(deleted);
    return result;
}
#method_after
@Override
public Set<Branch.NameKey> call() throws NoSuchProjectException, RepositoryNotFoundException, OrmException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final Iterator<Branch.NameKey> branchIt = toRemove.iterator();
    while (branchIt.hasNext()) {
        final Branch.NameKey k = branchIt.next();
        if (!projectName.equals(k.getParentKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!projectControl.controlForRef(k).canDelete()) {
            throw new IllegalStateException("Cannot delete " + k.getShortName());
        }
        if (db.changes().byBranchOpenAll(k).iterator().hasNext()) {
            branchIt.remove();
        }
    }
    final Set<Branch.NameKey> deleted = new HashSet<Branch.NameKey>();
    final Repository r = repoManager.openRepository(projectName);
    try {
        for (final Branch.NameKey branchKey : toRemove) {
            final String refname = branchKey.get();
            final RefUpdate.Result result;
            final RefUpdate u;
            try {
                u = r.updateRef(refname);
                u.setForceUpdate(true);
                result = u.delete();
            } catch (IOException e) {
                log.error("Cannot delete " + branchKey, e);
                continue;
            }
            switch(result) {
                case NEW:
                case NO_CHANGE:
                case FAST_FORWARD:
                case FORCED:
                    deleted.add(branchKey);
                    replication.scheduleUpdate(projectName, refname);
                    hooks.doRefUpdatedHook(branchKey, u, identifiedUser.getAccount());
                    break;
                case REJECTED_CURRENT_BRANCH:
                    log.warn("Cannot delete " + branchKey + ": " + result.name());
                    break;
                default:
                    log.error("Cannot delete " + branchKey + ": " + result.name());
                    break;
            }
        }
    } finally {
        r.close();
    }
    return deleted;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.listBranches(getProjectKey(), new ScreenLoadCallback<ListBranchesResult>(this) {

        @Override
        public void preDisplay(final ListBranchesResult result) {
            if (result.getNoRepository()) {
                branches.setVisible(false);
                addPanel.setVisible(false);
                abandonOpenChanges.setVisible(false);
                delBranch.setVisible(false);
                Label no = new Label(Util.C.errorNoGitRepository());
                no.setStyleName(Gerrit.RESOURCES.css().smallHeading());
                add(no);
            } else {
                enableForm(true);
                display(result.getBranches());
                addPanel.setVisible(result.getCanAdd());
            }
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.listBranches(getProjectKey(), new ScreenLoadCallback<ListBranchesResult>(this) {

        @Override
        public void preDisplay(final ListBranchesResult result) {
            if (result.getNoRepository()) {
                branches.setVisible(false);
                addPanel.setVisible(false);
                delBranch.setVisible(false);
                Label no = new Label(Util.C.errorNoGitRepository());
                no.setStyleName(Gerrit.RESOURCES.css().smallHeading());
                add(no);
            } else {
                enableForm(true);
                display(result.getBranches());
                addPanel.setVisible(result.getCanAdd());
            }
        }
    });
}
#end_block

#method_before
private void display(final List<Branch> listBranches) {
    branches.display(listBranches);
    abandonOpenChanges.setVisible(branches.hasBranchCanDelete());
    delBranch.setVisible(branches.hasBranchCanDelete());
}
#method_after
private void display(final List<Branch> listBranches) {
    branches.display(listBranches);
    delBranch.setVisible(branches.hasBranchCanDelete());
}
#end_block

#method_before
private void enableForm(final boolean on) {
    abandonOpenChanges.setEnabled(on);
    delBranch.setEnabled(on);
    addBranch.setEnabled(on);
    nameTxtBox.setEnabled(on);
    irevTxtBox.setEnabled(on);
}
#method_after
private void enableForm(final boolean on) {
    delBranch.setEnabled(on);
    addBranch.setEnabled(on);
    nameTxtBox.setEnabled(on);
    irevTxtBox.setEnabled(on);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(2, 2);
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(50);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    abandonOpenChanges = new CheckBox(Util.C.checkboxAbandonOpenChanges());
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    final VerticalPanel v = new VerticalPanel();
    v.add(abandonOpenChanges);
    v.add(delBranch);
    add(v);
    add(addPanel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(2, 2);
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(50);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    add(delBranch);
    add(addPanel);
}
#end_block

#method_before
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    if (abandonOpenChanges.getValue()) {
        b.append(Gerrit.C.branchDeletionAndAbandonOpenChangesConfirmationMessage());
    } else {
        b.append(Gerrit.C.branchDeletionConfirmationMessage());
    }
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids, abandonOpenChanges.getValue());
        }
    });
    confirmationDialog.center();
}
#method_after
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchDeletionConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids);
        }
    });
    confirmationDialog.center();
}
#end_block

#method_before
private void deleteBranches(final Set<Branch.NameKey> branchIds, final boolean abandonOpenChanges) {
    Util.PROJECT_SVC.deleteBranch(getProjectKey(), branchIds, abandonOpenChanges, new GerritCallback<DeleteBranchesResult>() {

        public void onSuccess(final DeleteBranchesResult result) {
            final Set<NameKey> deletedBranches = result.getDeletedBranches();
            if (!deletedBranches.isEmpty()) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final Branch k = getRowItem(row);
                    if (k != null && deletedBranches.contains(k.getNameKey())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
            }
            if (result.hasErrors()) {
                final SafeHtmlBuilder b = new SafeHtmlBuilder();
                final Set<Branch.NameKey> branchesWithOpenChanges = new HashSet<Branch.NameKey>();
                final Set<Branch.NameKey> branchesWithOpenChangesThatCannotBeAbandoned = new HashSet<Branch.NameKey>();
                for (final DeleteBranchesResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case OPEN_CHANGES:
                            branchesWithOpenChanges.add(e.getBranchKey());
                            break;
                        case ABANDON_FAILED:
                            branchesWithOpenChangesThatCannotBeAbandoned.add(e.getBranchKey());
                            break;
                        default:
                            b.append(Gerrit.M.branchDeletionFailed(e.getBranchKey().get(), e.toString()));
                            b.br();
                    }
                }
                if (!branchesWithOpenChanges.isEmpty()) {
                    b.append(Util.C.branchDeletionOpenChanges());
                    b.br();
                    appendBranchOpenChangesLinks(b, branchesWithOpenChanges);
                }
                if (!branchesWithOpenChangesThatCannotBeAbandoned.isEmpty()) {
                    b.append(Util.C.branchDeletionAbandonFailed());
                    b.br();
                    appendBranchOpenChangesLinks(b, branchesWithOpenChangesThatCannotBeAbandoned);
                }
                new ErrorDialog(b.toSafeHtml()).center();
            }
        }

        private void appendBranchOpenChangesLinks(final SafeHtmlBuilder b, final Set<Branch.NameKey> branches) {
            b.openElement("p");
            for (final Branch.NameKey branch : branches) {
                b.openAnchor();
                final BranchLink link = new BranchLink(branch.getParentKey(), Change.Status.NEW, branch.get(), null);
                b.setAttribute("href", "/#" + link.getTargetHistoryToken());
                b.setAttribute("target", "_blank");
                b.append(branch.get());
                b.closeAnchor();
                b.br();
            }
            b.closeElement("p");
        }
    });
}
#method_after
private void deleteBranches(final Set<Branch.NameKey> branchIds) {
    Util.PROJECT_SVC.deleteBranch(getProjectKey(), branchIds, new GerritCallback<Set<Branch.NameKey>>() {

        public void onSuccess(final Set<Branch.NameKey> deleted) {
            if (!deleted.isEmpty()) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final Branch k = getRowItem(row);
                    if (k != null && deleted.contains(k.getNameKey())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
            }
            branchIds.removeAll(deleted);
            if (!branchIds.isEmpty()) {
                final VerticalPanel p = new VerticalPanel();
                final ErrorDialog errorDialog = new ErrorDialog(p);
                final Label l = new Label(Util.C.branchDeletionOpenChanges());
                l.setStyleName(Gerrit.RESOURCES.css().errorDialogText());
                p.add(l);
                for (final Branch.NameKey branch : branchIds) {
                    final BranchLink link = new BranchLink(branch.getParentKey(), Change.Status.NEW, branch.get(), null) {

                        @Override
                        public void go() {
                            errorDialog.hide();
                            super.go();
                        }
                    };
                    p.add(link);
                }
                errorDialog.center();
            }
        }
    });
}
#end_block

#method_before
public Image createStar() {
    final Image star = new Image(getResource());
    star.setVisible(Gerrit.isSignedIn());
    star.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            StarCache.this.toggleStar();
        }
    });
    cache.getChangeDetailCache().addValueChangeHandler(createStarUpdater(star, ChangeDetail.class));
    cache.getChangeInfoCache().addValueChangeHandler(createStarUpdater(star, ChangeInfo.class));
    this.addValueChangeHandler(createStarUpdater(star, Boolean.class));
    return star;
}
#method_after
@SuppressWarnings("unchecked")
public Image createStar() {
    final Image star = new Image(getResource());
    star.setVisible(Gerrit.isSignedIn());
    star.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            StarCache.this.toggleStar();
        }
    });
    @SuppressWarnings("rawtypes")
    ValueChangeHandler starUpdater = new ValueChangeHandler() {

        @Override
        public void onValueChange(ValueChangeEvent event) {
            star.setResource(StarCache.this.getResource());
        }
    };
    cache.getChangeDetailCache().addValueChangeHandler(starUpdater);
    cache.getChangeInfoCache().addValueChangeHandler(starUpdater);
    this.addValueChangeHandler(starUpdater);
    return star;
}
#end_block

#method_before
@Rewrite("status:open P=(project:*) B=(branch:*) S=(sortkey_before:*) L=(limit:*)")
public Predicate<ChangeData> r05_byBranchOpenNext(@Named("P") final ProjectPredicate p, @Named("B") final BranchPredicate b, @Named("S") final SortKeyPredicate.Before s, @Named("L") final IntPredicate<ChangeData> l) {
    return new PaginatedSource(500, s.getValue(), l.intValue()) {

        @Override
        ResultSet<Change> scan(ChangeAccess a, String key, int limit) throws OrmException {
            return a.byBranchOpenNext(new Branch.NameKey(p.getValueKey(), b.getValue()), key, limit);
        }

        @Override
        public boolean match(ChangeData cd) throws OrmException {
            return // 
            cd.change(dbProvider).getStatus().isOpen() && // 
            p.match(cd) && // 
            b.match(cd) && s.match(cd);
        }
    };
}
#method_after
@Rewrite("status:open P=(project:*) B=(branch:*) S=(sortkey_before:*) L=(limit:*)")
public Predicate<ChangeData> r05_byBranchOpenNext(@Named("P") final ProjectPredicate p, @Named("B") final BranchPredicate b, @Named("S") final SortKeyPredicate.Before s, @Named("L") final IntPredicate<ChangeData> l) {
    return new PaginatedSource(500, s.getValue(), l.intValue()) {

        @Override
        ResultSet<Change> scan(ChangeAccess a, String key, int limit) throws OrmException {
            return a.byBranchOpenAll(new Branch.NameKey(p.getValueKey(), b.getValue()));
        }

        @Override
        public boolean match(ChangeData cd) throws OrmException {
            return // 
            cd.change(dbProvider).getStatus().isOpen() && // 
            p.match(cd) && // 
            b.match(cd) && s.match(cd);
        }
    };
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
private DependencyAttribute newDependsOn(Change c, PatchSet ps) {
    DependencyAttribute d = newDependencyAttribute(c, ps);
    if (c.currPatchSetId().equals(ps.getId())) {
        d.isCurrentPatchSet = "true";
    } else {
        d.isCurrentPatchSet = "false";
    }
    return d;
}
#method_after
private DependencyAttribute newDependsOn(Change c, PatchSet ps) {
    DependencyAttribute d = newDependencyAttribute(c, ps);
    d.isCurrentPatchSet = c.currPatchSetId().equals(ps.getId());
    return d;
}
#end_block

#method_before
private void processCommands(final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        messageSender.sendMessage("");
        messageSender.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                messageSender.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                messageSender.sendMessage("  " + url + c.getChangeId());
            }
        }
        messageSender.sendMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        messageSender.sendMessage("");
        messageSender.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                messageSender.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                messageSender.sendMessage("  " + url + c.getChangeId());
            }
        }
        messageSender.sendMessage("");
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    messageSender.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    messageSender.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (EmailException e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#end_block

#method_before
@Override
public void advertiseRefs(ReceiveSession rs) throws ServiceMayNotContinueException {
    base.advertiseRefs(rs);
    HashMap<String, Ref> r = new HashMap<String, Ref>();
    for (Map.Entry<String, Ref> e : rs.getAdvertisedRefs().entrySet()) {
        if (!e.getKey().startsWith("refs/changes/")) {
            r.put(e.getKey(), e.getValue());
        }
    }
    rs.setAdvertisedRefs(r, rs.getAdvertisedObjects());
}
#method_after
@Override
public void advertiseRefs(UploadPack us) {
    throw new UnsupportedOperationException("ReceiveCommitsAdvertiseRefsHook cannot be used for UploadPack");
}
#end_block

#method_before
@Override
public void onPreReceive(final ReceiveSession rs, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#method_after
@Override
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceiveSession rs, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceiveSession().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#end_block

#method_before
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotAuthorizedException {
    final ProjectControl pc = (ProjectControl) req.getAttribute(ATT_CONTROL);
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        // Anonymous users are not permitted to push.
        throw new ServiceNotAuthorizedException();
    }
    final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
    final ReceiveCommits rc = factory.create(pc, db);
    final ReceivePack rp = (ReceivePack) rc.getReceiveSession();
    rp.setRefLogIdent(user.newRefLogIdent());
    req.setAttribute(ATT_RC, rc);
    session.get().setAccessPath(AccessPath.GIT);
    return rp;
}
#method_after
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotAuthorizedException {
    final ProjectControl pc = (ProjectControl) req.getAttribute(ATT_CONTROL);
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        // Anonymous users are not permitted to push.
        throw new ServiceNotAuthorizedException();
    }
    final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
    final ReceiveCommits rc = factory.create(pc, db);
    rc.getReceivePack().setRefLogIdent(user.newRefLogIdent());
    req.setAttribute(ATT_RC, rc);
    session.get().setAccessPath(AccessPath.GIT);
    return rc.getReceivePack();
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = (ReceivePack) rc.getReceiveSession();
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        if (isGet) {
            rc.advertiseHistory();
        }
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        rc.advertiseHistory();
        cache.remove(cacheKey);
    } else {
        Set<ObjectId> ids = cache.get(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.remove(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        if (isGet) {
            rc.advertiseHistory();
        }
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        rc.advertiseHistory();
        cache.remove(cacheKey);
    } else {
        Set<ObjectId> ids = cache.get(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.remove(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunReceivePack()) {
        throw new Failure(1, "fatal: receive-pack not permitted on this server");
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    Capable r = receive.canUpload();
    if (r != Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = (ReceivePack) receive.getReceiveSession();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    rp.setMaxObjectSizeLimit(config.getMaxObjectSizeLimit());
    try {
        receive.advertiseHistory();
        rp.receive(in, out, err);
    } catch (UnpackException badStream) {
        // This may have been triggered by branch level access controls.
        // Log what the heck is going on, as detailed as we can.
        // 
        StringBuilder msg = new StringBuilder();
        msg.append("Unpack error on project \"" + projectControl.getProject().getName() + "\":\n");
        msg.append("  AdvertiseRefsHook: " + rp.getAdvertiseRefsHook());
        if (rp.getAdvertiseRefsHook() == AdvertiseRefsHook.DEFAULT) {
            msg.append("DEFAULT");
        } else if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            msg.append("VisibleRefFilter");
        } else {
            msg.append(rp.getAdvertiseRefsHook().getClass());
        }
        msg.append("\n");
        if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            Map<String, Ref> adv = rp.getAdvertisedRefs();
            msg.append("  Visible references (" + adv.size() + "):\n");
            for (Ref ref : adv.values()) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
            List<Ref> hidden = new ArrayList<Ref>();
            for (Ref ref : rp.getRepository().getAllRefs().values()) {
                if (!adv.containsKey(ref.getName())) {
                    hidden.add(ref);
                }
            }
            msg.append("  Hidden references (" + hidden.size() + "):\n");
            for (Ref ref : hidden) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
        }
        IOException detail = new IOException(msg.toString(), badStream);
        throw new Failure(128, "fatal: Unpack error, check server log", detail);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunReceivePack()) {
        throw new Failure(1, "fatal: receive-pack not permitted on this server");
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    Capable r = receive.canUpload();
    if (r != Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = receive.getReceivePack();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    rp.setMaxObjectSizeLimit(config.getMaxObjectSizeLimit());
    try {
        receive.advertiseHistory();
        rp.receive(in, out, err);
    } catch (UnpackException badStream) {
        // This may have been triggered by branch level access controls.
        // Log what the heck is going on, as detailed as we can.
        // 
        StringBuilder msg = new StringBuilder();
        msg.append("Unpack error on project \"" + projectControl.getProject().getName() + "\":\n");
        msg.append("  AdvertiseRefsHook: " + rp.getAdvertiseRefsHook());
        if (rp.getAdvertiseRefsHook() == AdvertiseRefsHook.DEFAULT) {
            msg.append("DEFAULT");
        } else if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            msg.append("VisibleRefFilter");
        } else {
            msg.append(rp.getAdvertiseRefsHook().getClass());
        }
        msg.append("\n");
        if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            Map<String, Ref> adv = rp.getAdvertisedRefs();
            msg.append("  Visible references (" + adv.size() + "):\n");
            for (Ref ref : adv.values()) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
            List<Ref> hidden = new ArrayList<Ref>();
            for (Ref ref : rp.getRepository().getAllRefs().values()) {
                if (!adv.containsKey(ref.getName())) {
                    hidden.add(ref);
                }
            }
            msg.append("  Hidden references (" + hidden.size() + "):\n");
            for (Ref ref : hidden) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
        }
        IOException detail = new IOException(msg.toString(), badStream);
        throw new Failure(128, "fatal: Unpack error, check server log", detail);
    }
}
#end_block

#method_before
@Override
public final com.google.gwtorm.client.ResultSet<T> get(final Iterable<K> keys) throws OrmException {
    final Collection<K> keySet;
    if (keys instanceof Collection) {
        keySet = (Collection<K>) keys;
    } else {
        keySet = new ArrayList<K>();
        for (final K k : keys) {
            keySet.add(k);
        }
    }
    switch(keySet.size()) {
        case 0:
            // 
            return new ListResultSet<T>(Collections.<T>emptyList());
        case 1:
            {
                // Only one key requested, use a faster equality lookup.
                // 
                final T entity = get(keySet.iterator().next());
                if (entity != null) {
                    return new ListResultSet<T>(Collections.singletonList(entity));
                }
                return new ListResultSet<T>(Collections.<T>emptyList());
            }
        default:
            return getBySqlIn(keySet);
    }
}
#method_after
@Override
public final com.google.gwtorm.server.ResultSet<T> get(final Iterable<K> keys) throws OrmException {
    final Collection<K> keySet;
    if (keys instanceof Collection) {
        keySet = (Collection<K>) keys;
    } else {
        keySet = new ArrayList<K>();
        for (final K k : keys) {
            keySet.add(k);
        }
    }
    switch(keySet.size()) {
        case 0:
            // 
            return new ListResultSet<T>(Collections.<T>emptyList());
        case 1:
            {
                // Only one key requested, use a faster equality lookup.
                // 
                final T entity = get(keySet.iterator().next());
                if (entity != null) {
                    return new ListResultSet<T>(Collections.singletonList(entity));
                }
                return new ListResultSet<T>(Collections.<T>emptyList());
            }
        default:
            return getBySqlIn(keySet);
    }
}
#end_block

#method_before
protected com.google.gwtorm.client.ResultSet<T> getBySqlIn(final Collection<K> keys) throws OrmException {
    return super.get(keys);
}
#method_after
protected com.google.gwtorm.server.ResultSet<T> getBySqlIn(final Collection<K> keys) throws OrmException {
    return super.get(keys);
}
#end_block

#method_before
protected ListResultSet<T> queryList(final PreparedStatement ps) throws OrmException {
    try {
        try {
            final ResultSet rs = ps.executeQuery();
            try {
                final ArrayList<T> r = new ArrayList<T>();
                while (rs.next()) {
                    final T o = newEntityInstance();
                    bindOneFetch(rs, o);
                    r.add(o);
                }
                return new ListResultSet<T>(r);
            } finally {
                rs.close();
            }
        } finally {
            ps.close();
        }
    } catch (SQLException e) {
        throw convertError("fetch", e);
    }
}
#method_after
protected com.google.gwtorm.server.ResultSet<T> queryList(final PreparedStatement ps) throws OrmException {
    final ResultSet rs;
    try {
        rs = ps.executeQuery();
        if (!rs.next()) {
            rs.close();
            ps.close();
            return new ListResultSet<T>(Collections.<T>emptyList());
        }
    } catch (SQLException err) {
        try {
            ps.close();
        } catch (SQLException e) {
        // Ignored.
        }
        throw convertError("fetch", err);
    }
    return new JdbcResultSet<T, K>(this, rs, ps);
}
#end_block

#method_before
private void insertIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getInsertOneSql());
            }
            bindOneInsert(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                throw new OrmConcurrencyException();
            }
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#method_after
private void insertIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        boolean concurrencyViolationDetected = false;
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getInsertOneSql());
            }
            bindOneInsert(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                concurrencyViolationDetected = true;
            }
        }
        if (concurrencyViolationDetected) {
            throw new OrmConcurrencyException();
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#end_block

#method_before
private void updateIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getUpdateOneSql());
            }
            bindOneUpdate(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                throw new OrmConcurrencyException();
            }
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#method_after
private void updateIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        boolean concurrencyViolationDetected = false;
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getUpdateOneSql());
            }
            bindOneUpdate(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                concurrencyViolationDetected = true;
            }
        }
        if (concurrencyViolationDetected) {
            throw new OrmConcurrencyException();
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#end_block

#method_before
private Collection<T> attemptUpdateAsBatch(final Iterable<T> instances) throws OrmException {
    Collection<T> inserts = null;
    try {
        PreparedStatement ps = null;
        try {
            int cnt = 0;
            List<T> allInstances = new ArrayList<T>();
            for (final T o : instances) {
                if (ps == null) {
                    ps = schema.getConnection().prepareStatement(getUpdateOneSql());
                }
                bindOneUpdate(ps, o);
                ps.addBatch();
                allInstances.add(o);
                cnt++;
            }
            if (0 < cnt) {
                final int[] states = ps.executeBatch();
                if (states == null) {
                    inserts = new ArrayList<T>(cnt);
                    for (T o : allInstances) {
                        inserts.add(o);
                    }
                } else {
                    int i = 0;
                    for (T o : allInstances) {
                        if (states.length <= i || states[i] != 1) {
                            if (inserts == null) {
                                inserts = new ArrayList<T>(cnt - i);
                            }
                            inserts.add(o);
                        }
                        i++;
                    }
                }
            }
        } finally {
            if (ps != null) {
                ps.close();
            }
        }
    } catch (SQLException e) {
        throw convertError("update", e);
    }
    return inserts;
}
#method_after
private Collection<T> attemptUpdateAsBatch(final Iterable<T> instances) throws OrmException {
    Collection<T> inserts = null;
    try {
        PreparedStatement ps = null;
        try {
            int cnt = 0;
            List<T> allInstances = new ArrayList<T>();
            for (final T o : instances) {
                if (ps == null) {
                    ps = schema.getConnection().prepareStatement(getUpdateOneSql());
                }
                bindOneUpdate(ps, o);
                ps.addBatch();
                allInstances.add(o);
                cnt++;
            }
            if (0 < cnt) {
                final int[] states = ps.executeBatch();
                if (states == null) {
                    inserts = allInstances;
                } else {
                    int i = 0;
                    for (T o : allInstances) {
                        if (states.length <= i || states[i] != 1) {
                            if (inserts == null) {
                                inserts = new ArrayList<T>(cnt - i);
                            }
                            inserts.add(o);
                        }
                        i++;
                    }
                }
            }
        } finally {
            if (ps != null) {
                ps.close();
            }
        }
    } catch (SQLException e) {
        throw convertError("update", e);
    }
    return inserts;
}
#end_block

#method_before
private void deleteIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getDeleteOneSql());
            }
            bindOneDelete(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                throw new OrmConcurrencyException();
            }
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#method_after
private void deleteIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        boolean concurrencyViolationDetected = false;
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getDeleteOneSql());
            }
            bindOneDelete(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                concurrencyViolationDetected = true;
            }
        }
        if (concurrencyViolationDetected) {
            throw new OrmConcurrencyException();
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#end_block

#method_before
private OrmException convertError(final String op, final SQLException err) {
    if (err.getCause() == null && err.getNextException() != null) {
        err.initCause(err.getNextException());
    }
    return schema.getDialect().convertError(op, getRelationName(), err);
}
#method_after
protected OrmException convertError(final String op, final SQLException err) {
    if (err.getCause() == null && err.getNextException() != null) {
        err.initCause(err.getNextException());
    }
    return schema.getDialect().convertError(op, getRelationName(), err);
}
#end_block

#method_before
public long nextLong(final Connection conn, final String query) throws OrmException {
    try {
        final Statement st = conn.createStatement();
        try {
            final ResultSet rs = st.executeQuery(query);
            try {
                if (!rs.next()) {
                    throw new SQLException("No result row for sequence query");
                }
                final long r = rs.getLong(1);
                if (rs.next()) {
                    throw new SQLException("Too many results from sequence query");
                }
                return r;
            } finally {
                rs.close();
            }
        } finally {
            st.close();
        }
    } catch (SQLException e) {
        throw convertError("sequence", query, e);
    }
}
#method_after
public long nextLong(final Connection conn, final String poolName) throws OrmException {
    final String query = getNextSequenceValueSql(poolName);
    try {
        final Statement st = conn.createStatement();
        try {
            final ResultSet rs = st.executeQuery(query);
            try {
                if (!rs.next()) {
                    throw new SQLException("No result row for sequence query");
                }
                final long r = rs.getLong(1);
                if (rs.next()) {
                    throw new SQLException("Too many results from sequence query");
                }
                return r;
            } finally {
                rs.close();
            }
        } finally {
            st.close();
        }
    } catch (SQLException e) {
        throw convertError("sequence", query, e);
    }
}
#end_block

#method_before
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", id);
}
#method_after
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", null, id);
}
#end_block

#method_before
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", id);
}
#method_after
public static String toPatchSideBySide(PatchSet.Id diffBase, Patch.Key id) {
    return toPatch("", diffBase, id);
}
#end_block

#method_before
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", id);
}
#method_after
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", null, id);
}
#end_block

#method_before
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", id);
}
#method_after
public static String toPatchUnified(PatchSet.Id diffBase, Patch.Key id) {
    return toPatch("unified", diffBase, id);
}
#end_block

#method_before
public static String toPatch(final PatchScreen.Type type, final Patch.Key id) {
    if (type == PatchScreen.Type.SIDE_BY_SIDE) {
        return toPatchSideBySide(id);
    } else {
        return toPatchUnified(id);
    }
}
#method_after
private static String toPatch(String type, PatchSet.Id diffBase, Patch.Key id) {
    PatchSet.Id ps = id.getParentKey();
    Change.Id c = ps.getParentKey();
    StringBuilder p = new StringBuilder();
    p.append("/c/").append(c).append("/");
    if (diffBase != null) {
        p.append(diffBase.get()).append("..");
    }
    p.append(ps.get()).append("/").append(KeyUtil.encode(id.get()));
    if (type != null && !type.isEmpty()) {
        p.append(",").append(type);
    }
    return p.toString();
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, // 
        panel == null ? // 
        new ChangeScreen(id) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, rest);
        patch(token, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(ps));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, // 
        panel == null ? // 
        new ChangeScreen(id) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, rest);
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(ps));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
public static void patch(String token, final Patch.Key id, final int patchIndex, final PatchSetDetail patchSetDetail, final PatchTable patchTable, final PatchScreen.TopView topView, final String panelType) {
    final String parametersUrl;
    if (token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) != -1) {
        parametersUrl = token.substring(token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) + 1);
        token = token.substring(0, token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START));
    } else {
        parametersUrl = null;
    }
    final PatchScreen.TopView top = topView == null ? Gerrit.getPatchScreenTopView() : topView;
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (id != null) {
                String panel = panelType;
                if (panel == null) {
                    int c = token.lastIndexOf(',');
                    panel = 0 <= c ? token.substring(c + 1) : "";
                }
                if ("".equals(panel)) {
                    return new // 
                    PatchScreen.SideBySide(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    parametersUrl);
                } else if ("unified".equals(panel)) {
                    return new // 
                    PatchScreen.Unified(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    parametersUrl);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
public static void patch(String token, PatchSet.Id base, Patch.Key id, int patchIndex, PatchSetDetail patchSetDetail, PatchTable patchTable, PatchScreen.TopView topView) {
    patch(token, base, id, patchIndex, patchSetDetail, patchTable, topView, null);
}
#end_block

#method_before
private static String skip(String token) {
    if (token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) != -1) {
        return token.substring(0, token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START)).substring(prefixlen);
    } else {
        return token.substring(prefixlen);
    }
}
#method_after
private static String skip(String token) {
    return token.substring(prefixlen);
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    // Did the user just turn on auto-review?
    if (!reviewed.getValue() && prefs.getOld().isManualReview() && !dp.isManualReview()) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(idSideA, result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(idSideA, result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.display(diffBaseId, detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateDiffAllActions(final PatchSetDetail detail) {
    diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    addHandlerForDiffButton(detail);
    actionsPanel.add(diffAllSideBySide);
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchSideBySide(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchUnified(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
private void populateDeleteDraftPatchSetAction() {
    final Button b = new Button(Util.C.buttonDeleteDraftPatchSet());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            b.setEnabled(false);
            PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new GerritCallback<VoidResult>() {

                public void onSuccess(VoidResult result) {
                    Gerrit.display(PageLinks.MINE);
                }

                @Override
                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateDeleteDraftPatchSetAction() {
    final Button b = new Button(Util.C.buttonDeleteDraftPatchSet());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            b.setEnabled(false);
            PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                public void onSuccess(final ChangeDetail result) {
                    if (result != null) {
                        changeScreen.update(result);
                    } else {
                        Gerrit.display(PageLinks.MINE);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
            hOfdiffAllSideBySide.removeHandler();
            hOfdiffAllUnified.removeHandler();
            addHandlerForDiffButton(result);
        }
    });
}
#method_after
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.display(diffBaseId, result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void go() {
    // 
    Dispatcher.patch(// 
    getTargetHistoryToken(), // 
    patchKey, // 
    patchIndex, // 
    patchSetDetail, parentPatchTable, // 
    topView);
}
#method_after
@Override
public void go() {
    // 
    Dispatcher.patch(// 
    getTargetHistoryToken(), // 
    base, // 
    patchKey, // 
    patchIndex, // 
    patchSetDetail, parentPatchTable, // 
    topView);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
            factory(RetrieveParentCandidatesHandler.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(VisibleProjectDetails.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
            factory(SuggestParentCandidatesHandler.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    vp = new VerticalPanel();
    addCreateProjectPanel();
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects());
    projectListPopup.addProjectListPopupHandler(new ProjectListPopupHandler() {

        @Override
        public void onClose(ProjectListPopupOnCloseEvent projectListPopupEvent) {
            resetHandlerRegistration();
        }

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            sugestParent.setText(projectListPopupEvent.getProjectName());
        }

        @Override
        public void onMovePointer(ProjectListPopupOnMovePointerEvent projectListPopupEvent) {
            // prevent user input from being overwritten by simply poping up
            if (!projectListPopupEvent.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectListPopupEvent.getProjectName());
            }
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
}
#end_block

#method_before
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    final HorizontalPanel bp = new HorizontalPanel();
    bp.add(create);
    bp.add(browse);
    fp.add(bp);
    vp.add(fp);
    initSuggestedParents();
    add(vp);
}
#method_after
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    fp.add(create);
    VerticalPanel vp = new VerticalPanel();
    vp.add(fp);
    initSuggestedParents();
    vp.add(suggestedParentsTab);
    add(vp);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    vp.add(suggestedParentsTab);
    Util.PROJECT_SVC.suggestParentCandidates(new AsyncCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    Util.PROJECT_SVC.suggestParentCandidates(new GerritCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
private void addGrid(final VerticalPanel fp) {
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, sugestParent);
    fp.add(grid);
}
#method_after
private void addGrid(final VerticalPanel fp) {
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, sugestParent);
    fp.add(grid);
}
#end_block

#method_before
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()) {

                @Override
                public void setText(final String t) {
                }
            }.center();
            enableForm(true);
        }
    });
}
#method_after
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#end_block

#method_before
@Override
public void suggestParentCandidates(AsyncCallback<List<Project>> callback) {
    RetrieveParentCandidatesHandlerFactory.create().to(callback);
}
#method_after
@Override
public void suggestParentCandidates(AsyncCallback<List<Project>> callback) {
    suggestParentCandidatesHandlerFactory.create().to(callback);
}
#end_block

#method_before
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, AsyncCallback<ProjectAccess> cb) {
    ObjectId base = ObjectId.fromString(baseRevision);
    changeProjectAccessFactory.create(projectName, base, sections, msg).to(cb);
}
#method_after
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, AsyncCallback<ProjectAccess> cb) {
    ObjectId base;
    if (baseRevision != null && !baseRevision.isEmpty()) {
        base = ObjectId.fromString(baseRevision);
    } else {
        base = null;
    }
    changeProjectAccessFactory.create(projectName, base, sections, msg).to(cb);
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case CHANGE_NOT_VISIBLE:
                errMsg += "not permitted to review change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    if (!control.isVisible(db) && !control.isOwner()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_NOT_VISIBLE));
    } else {
        db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                }
                return null;
            }
        });
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
        }
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    if (!control.canPublish(db)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.PUBLISH_NOT_PERMITTED));
    } else {
        db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                }
                return null;
            }
        });
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
        }
    }
    return result;
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
        updateSubscriptions();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void openRepository() throws MergeException {
    final String name = destBranch.getParentKey().get();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#method_after
private void openRepository() throws MergeException {
    final Project.NameKey name = destBranch.getParentKey();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name.get() + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#end_block

#method_before
private void openBranch() throws MergeException {
    alreadyAccepted = new HashSet<RevCommit>();
    try {
        branchUpdate = db.updateRef(destBranch.get());
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = (CodeReviewCommit) rw.parseCommit(branchUpdate.getOldObjectId());
            alreadyAccepted.add(branchTip);
        } else {
            branchTip = null;
        }
        for (final Ref r : rw.getRepository().getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot open branch", e);
    }
}
#method_after
private void openBranch() throws MergeException {
    alreadyAccepted = new HashSet<RevCommit>();
    try {
        branchUpdate = db.updateRef(destBranch.get());
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = (CodeReviewCommit) rw.parseCommit(branchUpdate.getOldObjectId());
            alreadyAccepted.add(branchTip);
        } else {
            branchTip = null;
        }
        for (final Ref r : db.getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot open branch", e);
    }
}
#end_block

#method_before
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final Merger m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m;
    if (destProject.isUseContentMerge()) {
        // Settings for this project allow us to try and
        // automatically resolve conflicts within files if needed.
        // Use ResolveMerge and instruct to operate in core.
        m = MergeStrategy.RESOLVE.newMerger(db, true);
    } else {
        // No auto conflict resolving allowed. If any of the
        // affected files was modified, merge will fail.
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    }
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : merged) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : merged) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(merged.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    final Commit mergeCommit = new Commit(db);
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(new ObjectId[] { mergeTip, n });
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = m.getObjectWriter().writeCommit(mergeCommit);
    mergeTip = (CodeReviewCommit) rw.parseCommit(id);
}
#method_after
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeAuthor(merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#end_block

#method_before
private void cherryPickChanges() throws MergeException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void cherryPickChanges() throws MergeException, OrmException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.getApprovalType(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final Commit mergeCommit = new Commit(db);
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(new ObjectId[] { mergeTip });
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = m.getObjectWriter().writeCommit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    for (PatchSetApproval a : schema.patchSetApprovals().byChange(n.change.getId())) {
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (branchTip == null || branchTip != mergeTip) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(db, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void updateSubscriptions() {
    // Note: The merge is already performed so we shall not throw an exception
    // on failure.
    Transaction txn = null;
    final String gitmodulesFile = ".gitmodules";
    File tmpGitmodulesFile = null;
    try {
        final TreeWalk tw = TreeWalk.forPath(db, gitmodulesFile, mergeTip.getTree());
        if ((tw != null) && (tw.getFileMode(0).getObjectType() == Constants.OBJ_BLOB)) {
            tmpGitmodulesFile = File.createTempFile(gitmodulesFile, ".tmp");
            final byte[] blobData = db.openBlob(tw.getObjectId(0)).getCachedBytes();
            FileOutputStream fos = new FileOutputStream(tmpGitmodulesFile.getCanonicalPath());
            fos.write(blobData);
            fos.close();
            final FileBasedConfig cfg = new FileBasedConfig(tmpGitmodulesFile);
            final String thisServer = getSrvName(urlProvider.get());
            if (thisServer == null) {
                throw new DataFormatException("At parse of " + gitmodulesFile + ": problem retrieving name of this server.");
            }
            txn = schema.beginTransaction();
            schema.subscriptions().delete(schema.subscriptions().getSubscription(destBranch), txn);
            cfg.load();
            for (String id : cfg.getSubsections("submodule")) {
                final String url = cfg.getString("submodule", id, "url");
                final String path = cfg.getString("submodule", id, "path");
                String revision = cfg.getString("submodule", id, "revision");
                if (url != null && url.length() > 0 && path != null && path.length() > 0 && revision != null && revision.length() > 0) {
                    boolean pathIsRelative = url.startsWith("/");
                    String server = null;
                    if (!pathIsRelative)
                        server = getSrvName(url);
                    if ((pathIsRelative) || (server != null && server.equalsIgnoreCase(thisServer))) {
                        if (revision.equals(".")) {
                            revision = destBranch.get();
                        }
                        schema.subscriptions().insert(Collections.singleton(new Subscription(new Subscription.Id(schema.nextSubscriptionId()), new Branch.NameKey(new Project.NameKey(destProject.getName()), destBranch.get()), new Branch.NameKey(new Project.NameKey(path), revision))), txn);
                    }
                }
            }
            txn.commit();
        }
    } catch (OrmException e) {
        log.error("Database problem at update of subscriptions table from " + gitmodulesFile + " file.", e);
    } catch (ConfigInvalidException e) {
        log.error("Problem at update of subscriptions table: " + gitmodulesFile + " config file is invalid.", e);
    } catch (IOException e) {
        log.error("Problem at update of subscriptions table from " + gitmodulesFile + ".", e);
    } catch (DataFormatException e) {
        log.error(e.getMessage(), e);
    } finally {
        if (txn != null) {
            try {
                txn.rollback();
            } catch (OrmException e) {
            }
        }
        if (tmpGitmodulesFile != null) {
            tmpGitmodulesFile.delete();
        }
    }
}
#method_after
private void updateSubscriptions() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        SubmoduleOp subOp = subOpFactory.create(destBranch, mergeTip, rw, db, destProject, submitted, commits);
        try {
            subOp.update();
        } catch (SubmoduleException e) {
            log.error("The gitLinks were not updated according to the subscriptions " + e.getMessage());
        }
    }
}
#end_block

#method_before
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null);
    m.setMessage(body);
    return m;
}
#method_after
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null, c.currentPatchSetId());
    m.setMessage(body);
    return m;
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(schema, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()), schema);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
public Capable canUpload() {
    if (!projectControl.canUploadToAtLeastOneRef()) {
        String reqName = project.getName();
        return new Capable("Upload denied for project '" + reqName + "'");
    }
    if (project.isUseContributorAgreements()) {
        try {
            return verifyActiveContributorAgreement();
        } catch (OrmException e) {
            log.error("Cannot query database for agreements", e);
            return new Capable("Cannot verify contribution agreement");
        }
    } else {
        return Capable.OK;
    }
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#method_after
@Override
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#end_block

#method_before
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (isHead(c) || isTag(c)) {
                // We only schedule heads and tags for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private Account.Id toAccountId(final String nameOrEmail) throws OrmException, NoSuchAccountException {
    final Account a = accountResolver.find(nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#method_after
private Account.Id toAccountId(final String nameOrEmail) throws OrmException, NoSuchAccountException {
    final Account a = accountResolver.findByNameOrEmail(nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    final RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    final RevObject oldObject, newObject;
    try {
        oldObject = rp.getRevWalk().parseAny(cmd.getOldId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getOldId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    try {
        newObject = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (oldObject instanceof RevCommit && newObject instanceof RevCommit && ctl.canForceUpdate()) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    if (rp.getAdvertisedRefs().containsKey(destBranchName)) {
        // We advertised the branch to the client so we know
        // the branch exists. Target this branch for the upload.
        // 
        destBranch = new Branch.NameKey(project.getNameKey(), destBranchName);
    } else {
        // We didn't advertise the branch, because it doesn't exist yet.
        // Allow it anyway if HEAD is a symbolic reference to the name.
        // 
        final String head;
        try {
            head = repo.getFullBranch();
        } catch (IOException e) {
            log.error("Cannot read HEAD symref", e);
            reject(cmd, "internal error");
            return;
        }
        if (head.equals(destBranchName)) {
            destBranch = new Branch.NameKey(project.getNameKey(), destBranchName);
        }
    }
    if (destBranch == null) {
        String n = destBranchName;
        if (n.startsWith(Constants.R_HEADS))
            n = n.substring(Constants.R_HEADS.length());
        reject(cmd, "branch " + n + " not found");
        return;
    }
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        boolean haveHeads = false;
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            if (isHead(r) || isTag(r)) {
                try {
                    final RevCommit h = walk.parseCommit(r.getObjectId());
                    h.add(SIDE_HAVE);
                    walk.markStart(h);
                    haveHeads = true;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private void requestReplace(final ReceiveCommand cmd, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            try {
                walk.markUninteresting(walk.parseCommit(r.getObjectId()));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // Schedule as a replacement to this one matching change.
                    // 
                    requestReplace(newChange, changes.get(0), c);
                    continue;
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                if (messageEq && parentsEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    rp.sendMessage(// 
                    "(W) " + c.abbreviate(repo, 6).name() + ":" + // 
                    " no files changed, but" + // 
                    (!messageEq ? " message updated" : "") + // 
                    (!messageEq && !parentsEq ? " and" : "") + // 
                    (!parentsEq ? " was rebased" : ""));
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            try {
                walk.markUninteresting(walk.parseCommit(r.getObjectId()));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    if (65 < c.getShortMessage().length()) {
        rp.sendMessage("(W) " + c.abbreviate(repo, 6).name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        rp.sendMessage("(W) " + c.abbreviate(repo, 6).name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            } else {
                log.warn("Replacement of Change-Id " + req.ontoChange + " with commit " + req.newCommit.name() + " did not import the new patch set.");
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private Map<ObjectId, Ref> changeRefsById() {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (final Ref r : repo.getAllRefs().values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private Map<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db);
    }
}
#method_after
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db, toTargetVersion);
    }
}
#end_block

#method_before
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        final List<String> pruneList = new ArrayList<String>();
        s.pruneSchema(new StatementExecutor() {

            public void execute(String sql) {
                pruneList.add(sql);
            }
        });
        if (!pruneList.isEmpty()) {
            ui.pruneSchema(e, pruneList);
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#method_after
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db, false);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        if (toTargetVersion) {
            final List<String> pruneList = new ArrayList<String>();
            s.pruneSchema(new StatementExecutor() {

                public void execute(String sql) {
                    pruneList.add(sql);
                }
            });
            if (!pruneList.isEmpty()) {
                ui.pruneSchema(e, pruneList);
            }
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#end_block

#method_before
@SuppressWarnings("unused")
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#method_after
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateProjectImpl.Factory.class);
    bind(RetrieveParentCandidates.class).to(RetrieveParentCandidatesImpl.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
}
#end_block

#method_before
public boolean isDraft() {
    return isDraft;
}
#method_after
public boolean isDraft() {
    return draft;
}
#end_block

#method_before
public void setDraft(boolean draftStatus) {
    isDraft = draftStatus;
}
#method_after
public void setDraft(boolean draftStatus) {
    draft = draftStatus;
}
#end_block

#method_before
public static void revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps);
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
private static void updatedChange(final ReviewDb db, final IdentifiedUser user, final Change change, final ChangeMessage cmsg, ReplyToChangeSender.Factory senderFactory, final String err) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    if (change == null) {
        throw new InvalidChangeOperationException(err);
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final ReplyToChangeSender cm = senderFactory.create(change);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
}
#method_after
private static <T extends ReplyToChangeSender> void updatedChange(final ReviewDb db, final IdentifiedUser user, final Change change, final ChangeMessage cmsg, ReplyToChangeSender.Factory<T> senderFactory, final String err) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    if (change == null) {
        throw new InvalidChangeOperationException(err);
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final ReplyToChangeSender cm = senderFactory.create(change);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    publishDrafts();
    final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
    if (isCurrent && change.getStatus().isOpen()) {
        publishApprovals(ctl);
    } else if (!approvals.isEmpty()) {
        throw new InvalidChangeOperationException("Change is closed");
    } else {
        publishMessageOnly();
    }
    touchChange();
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    db.changes().beginTransaction(changeId);
    try {
        publishDrafts();
        final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
        if (isCurrent && change.getStatus().isOpen()) {
            publishApprovals(ctl);
        } else if (approvals.isEmpty() || forceMessage) {
            publishMessageOnly();
        } else {
            throw new InvalidChangeOperationException("Change is closed");
        }
        touchChange();
        db.commit();
    } finally {
        db.rollback();
    }
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#end_block

#method_before
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draft(patchSetId, user.getAccountId()).toList();
}
#method_after
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draftByPatchSetAuthor(patchSetId, user.getAccountId()).toList();
}
#end_block

#method_before
private void email() {
    try {
        final CommentSender cm = commentSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setPatchSet(patchSet, patchSetInfoFactory.get(patchSetId));
        cm.setChangeMessage(message);
        cm.setPatchLineComments(drafts);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#method_after
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(db, patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void cherryPickChanges() throws MergeException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void cherryPickChanges() throws MergeException, OrmException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    for (PatchSetApproval a : schema.patchSetApprovals().byChange(n.change.getId())) {
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null, null);
    m.setMessage(body);
    return m;
}
#method_after
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null, c.currentPatchSetId());
    m.setMessage(body);
    return m;
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(schema, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        change.setStatus(Change.Status.NEW);
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (!ps.isDraft() || control.isDraftVisible(db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#end_block

#method_before
private void loadMessages() throws OrmException {
    ResultSet<ChangeMessage> source = db.changeMessages().byChange(changeId);
    List<ChangeMessage> msgList = new ArrayList<ChangeMessage>();
    for (ChangeMessage msg : source) {
        PatchSet.Id id = msg.getPatchSetId();
        if (id != null) {
            PatchSet ps = patchsetsById.get(msg.getPatchSetId());
            if (!ps.isDraft() || control.isDraftVisible(db)) {
                msgList.add(msg);
            }
        } else {
            // Not guaranteed to have a non-null patchset id, so just display it.
            msgList.add(msg);
        }
    }
    detail.setMessages(msgList);
    for (final ChangeMessage m : detail.getMessages()) {
        aic.want(m.getAuthor());
    }
}
#method_after
private void loadMessages() throws OrmException {
    ResultSet<ChangeMessage> source = db.changeMessages().byChange(changeId);
    List<ChangeMessage> msgList = new ArrayList<ChangeMessage>();
    for (ChangeMessage msg : source) {
        PatchSet.Id id = msg.getPatchSetId();
        if (id != null) {
            PatchSet ps = patchsetsById.get(msg.getPatchSetId());
            if (control.isPatchVisible(ps, db)) {
                msgList.add(msg);
            }
        } else {
            // Not guaranteed to have a non-null patchset id, so just display it.
            msgList.add(msg);
        }
    }
    detail.setMessages(msgList);
    for (final ChangeMessage m : detail.getMessages()) {
        aic.want(m.getAuthor());
    }
}
#end_block

#method_before
private void load() throws OrmException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    if (detail.getChange().getStatus().equals(Change.Status.NEW) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException {
    return validate(controlFor(id));
}
#method_after
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException, OrmException {
    return validate(controlFor(id), db.get());
}
#end_block

#method_before
public ChangeControl validateFor(final Change change) throws NoSuchChangeException {
    return validate(controlFor(change));
}
#method_after
public ChangeControl validateFor(final Change change) throws NoSuchChangeException, OrmException {
    return validate(controlFor(change), db.get());
}
#end_block

#method_before
private static ChangeControl validate(final ChangeControl c) throws NoSuchChangeException {
    if (!c.isVisible()) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
private static ChangeControl validate(final ChangeControl c, final ReviewDb db) throws NoSuchChangeException, OrmException {
    if (!c.isVisible(db)) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isVisible();
}
#method_after
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    @SuppressWarnings("unchecked")
                    final List<? extends Term> termList = ((ListTerm) template[2]).toJava();
                    results.addAll(termList);
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
public boolean isDraftVisible(ReviewDb db) throws OrmException {
    return isOwner() || isReviewer(db);
}
#method_after
private boolean isDraftVisible(ReviewDb db) throws OrmException {
    return isOwner() || isReviewer(db);
}
#end_block

#method_before
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a (magic branch)/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    result = checkMagicBranchRef(NEW_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_DRAFT_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_PUBLISH_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    return Capable.OK;
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!isMagicBranch(c)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (isMagicBranch(cmd)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = getDestBranchName(cmd);
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    if (isDraft(newChange)) {
        change.setStatus(Change.Status.DRAFT);
        ps.setDraft(true);
    }
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    if (isDraft(request.cmd)) {
        ps.setDraft(true);
    }
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    msg.setPatchSetId(ps.getId());
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        change.setStatus(Change.Status.DRAFT);
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (isMagicBranch(cmd) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    msg.setPatchSetId(result.info.getKey());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException {
    return validate(controlFor(id));
}
#method_after
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException, OrmException {
    return validate(controlFor(id), db.get());
}
#end_block

#method_before
public ChangeControl validateFor(final Change change) throws NoSuchChangeException {
    return validate(controlFor(change));
}
#method_after
public ChangeControl validateFor(final Change change) throws NoSuchChangeException, OrmException {
    return validate(controlFor(change), db.get());
}
#end_block

#method_before
private static ChangeControl validate(final ChangeControl c) throws NoSuchChangeException {
    if (!c.isVisible()) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
private static ChangeControl validate(final ChangeControl c, final ReviewDb db) throws NoSuchChangeException, OrmException {
    if (!c.isVisible(db)) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isOwner() && !isReviewer(db)) {
        return false;
    }
    return isVisible();
}
#method_after
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    if (change.getStatus() == Change.Status.DRAFT) {
        return ruleError("Cannot submit draft changes");
    }
    try {
        if (isDraftPatchSet(patchSetId, db)) {
            return ruleError("Cannot submit draft patch sets");
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSetId, err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isVisible(db)) {
                return ruleError("Patch set " + patchSetId + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (isDraftPatchSet(patchSetId, db)) {
            if (!isVisible(db)) {
                return ruleError("Patch set " + patchSetId + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSetId, err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    @SuppressWarnings("unchecked")
                    final List<? extends Term> termList = ((ListTerm) template[2]).toJava();
                    results.addAll(termList);
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private boolean isDraftPatchSet(PatchSet.Id id, ReviewDb db) throws OrmException {
    PatchSet ps = db.patchSets().get(id);
    if (ps == null) {
        return false;
    }
    return ps.isDraft();
}
#method_after
private boolean isDraftPatchSet(PatchSet.Id id, ReviewDb db) throws OrmException {
    PatchSet ps = db.patchSets().get(id);
    if (ps == null) {
        throw new OrmException("Patch set " + id + " not found");
    }
    return ps.isDraft();
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
        reject(cmd, "For non-fast forward updates, 'Force Push' privilege is needed");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, groupUUID, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            groupId = result.group.getId();
            groupUUID = result.group.getGroupUUID();
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, groupUUID, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            groupId = result.group.getId();
            groupUUID = result.group.getGroupUUID();
            display(result);
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            saveType.setVisible(result.canModify);
            delInclude.setVisible(result.canModify);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initMemberList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initIncludeList();
    initExternal();
}
#end_block

#method_before
private void initMemberList() {
    addMemberBox = new AddMemberBox();
    addMemberBox.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    members = new MemberTable();
    delMember = new Button(Util.C.buttonDeleteGroupMembers());
    delMember.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            members.deleteChecked();
        }
    });
    memberPanel = new FlowPanel();
    memberPanel.add(new SmallHeading(Util.C.headingMembers()));
    memberPanel.add(addMemberBox);
    memberPanel.add(members);
    memberPanel.add(delMember);
    add(memberPanel);
}
#method_after
private void initMemberList() {
    addMemberBox = new AddMemberBox();
    addMemberBox.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewMember();
        }
    });
    members = new MemberTable();
    delMember = new Button(Util.C.buttonDeleteGroupMembers());
    delMember.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            members.deleteChecked();
        }
    });
    memberPanel = new FlowPanel();
    memberPanel.add(new SmallHeading(Util.C.headingMembers()));
    memberPanel.add(addMemberBox);
    memberPanel.add(members);
    memberPanel.add(delMember);
    add(memberPanel);
}
#end_block

#method_before
private void initExternal() {
    externalName = new Label();
    externalNameFilter = new NpTextBox();
    externalNameFilter.setVisibleLength(30);
    externalNameFilter.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doExternalSearch();
            }
        }
    });
    externalNameSearch = new Button(Gerrit.C.searchButton());
    externalNameSearch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doExternalSearch();
        }
    });
    externalMatches = new Grid();
    externalMatches.setStyleName(Gerrit.RESOURCES.css().infoTable());
    externalMatches.setVisible(false);
    final FlowPanel searchLine = new FlowPanel();
    searchLine.add(externalNameFilter);
    searchLine.add(externalNameSearch);
    externalPanel = new VerticalPanel();
    externalPanel.add(new SmallHeading(Util.C.headingExternalGroup()));
    externalPanel.add(externalName);
    externalPanel.add(searchLine);
    externalPanel.add(externalMatches);
    add(externalPanel);
}
#method_after
private void initExternal() {
    externalName = new Label();
    externalNameFilter = new NpTextBox();
    externalNameFilter.setVisibleLength(30);
    externalNameFilter.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doExternalSearch();
            }
        }
    });
    externalNameSearch = new Button(Gerrit.C.searchButton());
    externalNameSearch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doExternalSearch();
        }
    });
    externalMatches = new Grid();
    externalMatches.setStyleName(Gerrit.RESOURCES.css().infoTable());
    externalMatches.setVisible(false);
    final FlowPanel searchLine = new FlowPanel();
    searchLine.add(externalNameFilter);
    searchLine.add(externalNameSearch);
    externalPanel = new VerticalPanel();
    externalPanel.add(new SmallHeading(Util.C.headingExternalGroup()));
    externalPanel.add(externalName);
    externalPanel.add(searchLine);
    externalPanel.add(externalMatches);
    add(externalPanel);
}
#end_block

#method_before
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#method_after
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includePanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
    emailOnlyAuthors.setValue(group.isEmailOnlyAuthors());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includes.display(result.includes);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
private void addGroup(GroupReference ref) {
    if (ref.getUUID() != null) {
        if (value.getRule(ref) == null) {
            PermissionRule newRule = value.getRule(ref, true);
            if (value.isLabel()) {
                newRule.setRange(0, 1);
            }
            rules.getList().add(newRule);
        }
        groupToAdd.setValue(null);
        groupToAdd.setFocus(true);
    } else {
        // If the oracle didn't get to complete a UUID, resolve it now.
        // 
        addRule.setEnabled(false);
        SuggestUtil.SVC.suggestAccountGroup(ref.getName(), 1, new GerritCallback<List<GroupReference>>() {

            @Override
            public void onSuccess(List<GroupReference> result) {
                addRule.setEnabled(true);
                if (result.size() == 1) {
                    addGroup(result.get(0));
                } else {
                    groupToAdd.setFocus(true);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                addRule.setEnabled(true);
                super.onFailure(caught);
            }
        });
    }
}
#method_after
private void addGroup(GroupReference ref) {
    if (ref.getUUID() != null) {
        if (value.getRule(ref) == null) {
            PermissionRule newRule = value.getRule(ref, true);
            if (rangeType != null) {
                int min = rangeType.getMin().getValue();
                int max = rangeType.getMax().getValue();
                newRule.setRange(min, max);
            }
            rules.getList().add(newRule);
        }
        groupToAdd.setValue(null);
        groupToAdd.setFocus(true);
    } else {
        // If the oracle didn't get to complete a UUID, resolve it now.
        // 
        addRule.setEnabled(false);
        SuggestUtil.SVC.suggestAccountGroup(ref.getName(), 1, new GerritCallback<List<GroupReference>>() {

            @Override
            public void onSuccess(List<GroupReference> result) {
                addRule.setEnabled(true);
                if (result.size() == 1) {
                    addGroup(result.get(0));
                } else {
                    groupToAdd.setFocus(true);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                addRule.setEnabled(true);
                super.onFailure(caught);
            }
        });
    }
}
#end_block

#method_before
@Override
public void setValue(Permission value) {
    this.value = value;
    if (value != null && Permission.OWNER.equals(value.getName())) {
        inherit.setEnabled(false);
    } else {
        inherit.setEnabled(!readOnly);
    }
}
#method_after
@Override
public void setValue(Permission value) {
    this.value = value;
    if (value.isLabel()) {
        rangeType = Gerrit.getConfig().getApprovalTypes().byLabel(value.getLabel());
    } else {
        rangeType = null;
    }
    if (value != null && Permission.OWNER.equals(value.getName())) {
        exclusiveGroup.setEnabled(false);
    } else {
        exclusiveGroup.setEnabled(!readOnly);
    }
}
#end_block

#method_before
@Override
public PermissionRuleEditor create(int index) {
    PermissionRuleEditor subEditor = new PermissionRuleEditor(readOnly, section, value);
    ruleContainer.insert(subEditor, index);
    return subEditor;
}
#method_after
@Override
public PermissionRuleEditor create(int index) {
    PermissionRuleEditor subEditor = new PermissionRuleEditor(readOnly, section, value, rangeType);
    ruleContainer.insert(subEditor, index);
    return subEditor;
}
#end_block

#method_before
@UiHandler("addSection")
void onAddSection(ClickEvent event) {
    int index = local.getList().size();
    local.getList().add(new AccessSection("refs/heads/*"));
    local.getEditors().get(index).editRefPattern();
}
#method_after
@UiHandler("addSection")
void onAddSection(ClickEvent event) {
    int index = local.getList().size();
    local.getList().add(new AccessSection("refs/heads/*"));
    AccessSectionEditor editor = local.getEditors().get(index);
    editor.enableEditing();
    editor.editRefPattern();
}
#end_block

#method_before
@Override
public void render(Action object, Appendable appendable) throws IOException {
    appendable.append(render(object));
}
#method_after
@Override
public String render(PermissionRule.Action object) {
    return object != null ? object.toString() : "";
}
#end_block

#method_before
public void suggestAccount(final String query, final Boolean active, final int limit, final AsyncCallback<List<AccountInfo>> callback) {
    run(callback, new Action<List<AccountInfo>>() {

        public List<AccountInfo> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            final LinkedHashMap<Account.Id, AccountInfo> r = new LinkedHashMap<Account.Id, AccountInfo>();
            for (final Account p : db.accounts().suggestByFullName(a, b, n)) {
                addSuggestion(r, p, new AccountInfo(p), active);
            }
            if (r.size() < n) {
                for (final Account p : db.accounts().suggestByPreferredEmail(a, b, n - r.size())) {
                    addSuggestion(r, p, new AccountInfo(p), active);
                }
            }
            if (r.size() < n) {
                for (final AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, n - r.size())) {
                    if (!r.containsKey(e.getAccountId())) {
                        final Account p = accountCache.get(e.getAccountId()).getAccount();
                        final AccountInfo info = new AccountInfo(p);
                        info.setPreferredEmail(e.getEmailAddress());
                        addSuggestion(r, p, info, active);
                    }
                }
            }
            return new ArrayList<AccountInfo>(r.values());
        }
    });
}
#method_after
public void suggestAccount(final String query, final Boolean active, final int limit, final AsyncCallback<List<AccountInfo>> callback) {
    if (suggestAccounts == SuggestAccountsEnum.OFF) {
        callback.onSuccess(Collections.<AccountInfo>emptyList());
        return;
    }
    run(callback, new Action<List<AccountInfo>>() {

        public List<AccountInfo> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            final LinkedHashMap<Account.Id, AccountInfo> r = new LinkedHashMap<Account.Id, AccountInfo>();
            for (final Account p : db.accounts().suggestByFullName(a, b, n)) {
                addSuggestion(r, p, new AccountInfo(p), active);
            }
            if (r.size() < n) {
                for (final Account p : db.accounts().suggestByPreferredEmail(a, b, n - r.size())) {
                    addSuggestion(r, p, new AccountInfo(p), active);
                }
            }
            if (r.size() < n) {
                for (final AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, n - r.size())) {
                    if (!r.containsKey(e.getAccountId())) {
                        final Account p = accountCache.get(e.getAccountId()).getAccount();
                        final AccountInfo info = new AccountInfo(p);
                        info.setPreferredEmail(e.getEmailAddress());
                        addSuggestion(r, p, info, active);
                    }
                }
            }
            return new ArrayList<AccountInfo>(r.values());
        }
    });
}
#end_block

#method_before
private void addSuggestion(Map map, Account account, AccountInfo info, Boolean active) {
    if (active == null || active == account.isActive()) {
        map.put(account.getId(), info);
    }
}
#method_after
private void addSuggestion(Map<Account.Id, AccountInfo> map, Account account, AccountInfo info, Boolean active) {
    if (map.containsKey(account.getId())) {
        return;
    }
    if (active != null && active != account.isActive()) {
        return;
    }
    switch(suggestAccounts) {
        case ALL:
            map.put(account.getId(), info);
            break;
        case SAME_GROUP:
            {
                Set<AccountGroup.UUID> usersGroups = groupsOf(account);
                usersGroups.remove(AccountGroup.ANONYMOUS_USERS);
                usersGroups.remove(AccountGroup.REGISTERED_USERS);
                usersGroups.remove(authConfig.getBatchUsersGroup());
                for (AccountGroup.UUID myGroup : currentUser.get().getEffectiveGroups()) {
                    if (usersGroups.contains(myGroup)) {
                        map.put(account.getId(), info);
                        break;
                    }
                }
                break;
            }
        case OFF:
            break;
        default:
            throw new IllegalStateException("Bad SuggestAccounts " + suggestAccounts);
    }
}
#end_block

#method_before
public void suggestAccountGroup(final String query, final int limit, final AsyncCallback<List<GroupReference>> callback) {
    run(callback, new Action<List<GroupReference>>() {

        public List<GroupReference> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            List<GroupReference> r = new ArrayList<GroupReference>(n);
            for (AccountGroupName c : db.accountGroupNames().suggestByName(a, b, n)) {
                AccountGroup g = groupCache.get(c.getId());
                if (g != null && g.getGroupUUID() != null) {
                    r.add(GroupReference.forGroup(g));
                }
            }
            return r;
        }
    });
}
#method_after
public void suggestAccountGroup(final String query, final int limit, final AsyncCallback<List<GroupReference>> callback) {
    run(callback, new Action<List<GroupReference>>() {

        public List<GroupReference> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            Set<AccountGroup.UUID> memberOf = currentUser.get().getEffectiveGroups();
            List<GroupReference> r = new ArrayList<GroupReference>(n);
            for (AccountGroupName group : db.accountGroupNames().suggestByName(a, b, n)) {
                try {
                    if (memberOf.contains(group.getId()) || groupControlFactory.controlFor(group.getId()).isVisible()) {
                        AccountGroup g = groupCache.get(group.getId());
                        if (g != null && g.getGroupUUID() != null) {
                            r.add(GroupReference.forGroup(g));
                        }
                    }
                } catch (NoSuchGroupException e) {
                    continue;
                }
            }
            return r;
        }
    });
}
#end_block

#method_before
private static Screen core(final String token) {
    String p;
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    p = "q,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final int c = s.indexOf(',');
        return new QueryScreen(s.substring(0, c), s.substring(c + 1));
    }
    return new NotFoundScreen();
}
#method_after
private static Screen core(final String token) {
    String p;
    p = "change,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final String q = "patchset=";
        final String[] t = s.split(",", 2);
        if (t.length > 1 && t[1].startsWith(q)) {
            return new ChangeScreen(PatchSet.Id.parse(t[0] + "," + skip(q, t[1])));
        }
        return new ChangeScreen(Change.Id.parse(t[0]));
    }
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    p = "q,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final int c = s.indexOf(',');
        return new QueryScreen(s.substring(0, c), s.substring(c + 1));
    }
    return new NotFoundScreen();
}
#end_block

#method_before
public void addGroupMember(final AccountGroup.Id groupId, final String nameOrEmail, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final Account a = findAccount(nameOrEmail);
            if (!a.isActive()) {
                throw new Failure(new InactiveAccountException(a.getFullName()));
            }
            if (!control.canAdd(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), groupId);
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, getAccountId())));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#method_after
public void addGroupMember(final AccountGroup.Id groupId, final String nameOrEmail, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final Account a = findAccount(nameOrEmail);
            if (!a.isActive()) {
                throw new Failure(new InactiveAccountException(a.getFullName()));
            }
            if (!control.canAddMember(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), groupId);
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, getAccountId())));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#end_block

#method_before
public void deleteGroupMembers(final AccountGroup.Id groupId, final Set<AccountGroupMember.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupMember.Key k : keys) {
                if (!groupId.equals(k.getAccountGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            for (final AccountGroupMember.Key k : keys) {
                final AccountGroupMember m = db.accountGroupMembers().get(k);
                if (m != null) {
                    if (!control.canRemove(m.getAccountId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupMemberAudit audit = null;
                    for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupMembersAudit().update(Collections.singleton(audit));
                    } else {
                        audit = new AccountGroupMemberAudit(m, me);
                        audit.removedLegacy();
                        db.accountGroupMembersAudit().insert(Collections.singleton(audit));
                    }
                    db.accountGroupMembers().delete(Collections.singleton(m));
                    accountCache.evict(m.getAccountId());
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteGroupMembers(final AccountGroup.Id groupId, final Set<AccountGroupMember.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupMember.Key k : keys) {
                if (!groupId.equals(k.getAccountGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            for (final AccountGroupMember.Key k : keys) {
                final AccountGroupMember m = db.accountGroupMembers().get(k);
                if (m != null) {
                    if (!control.canRemoveMember(m.getAccountId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupMemberAudit audit = null;
                    for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupMembersAudit().update(Collections.singleton(audit));
                    } else {
                        audit = new AccountGroupMemberAudit(m, me);
                        audit.removedLegacy();
                        db.accountGroupMembersAudit().insert(Collections.singleton(audit));
                    }
                    db.accountGroupMembers().delete(Collections.singleton(m));
                    accountCache.evict(m.getAccountId());
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public void setAction(Action action) {
    switch(action) {
        case ALLOW:
            setDeny(false);
            break;
        case DENY:
            setDeny(true);
            break;
        default:
            throw new IllegalArgumentException();
    }
}
#method_after
public void setAction(Action action) {
    if (action == null) {
        throw new NullPointerException("action");
    }
    setDeny(action == Action.DENY);
}
#end_block

#method_before
public int getMin() {
    return min;
}
#method_after
public Integer getMin() {
    return min;
}
#end_block

#method_before
public int getMax() {
    return max;
}
#method_after
public Integer getMax() {
    return max;
}
#end_block

#method_before
@Override
public int compareTo(PermissionRule o) {
    int cmp = deny(this) - deny(o);
    if (cmp == 0)
        cmp = group(this).compareTo(group(o));
    return cmp;
}
#method_after
@Override
public int compareTo(PermissionRule o) {
    int cmp = deny(this) - deny(o);
    if (cmp == 0)
        cmp = range(o) - range(this);
    if (cmp == 0)
        cmp = group(this).compareTo(group(o));
    return cmp;
}
#end_block

#method_before
public String asString(boolean useRange) {
    StringBuilder r = new StringBuilder();
    if (getDeny()) {
        r.append("deny ");
    }
    if (getForce()) {
        r.append("+force ");
    }
    if (useRange) {
        if (getMin() == 0 && getMax() == 1) {
        } else if (getMin() == 1 && getMax() == 1) {
        } else if (getMin() < 0 && getMax() == 0) {
            r.append(getMin());
            r.append(' ');
        } else {
            if (getMin() != getMax()) {
                if (0 <= getMin())
                    r.append('+');
                r.append(getMin());
                r.append("..");
            }
            if (0 <= getMax())
                r.append('+');
            r.append(getMax());
            r.append(' ');
        }
    }
    r.append("group ");
    r.append(getGroup().getName());
    return r.toString();
}
#method_after
public String asString(boolean canUseRange) {
    StringBuilder r = new StringBuilder();
    if (getDeny()) {
        r.append("deny ");
    }
    if (getForce()) {
        r.append("+force ");
    }
    if (canUseRange && (getMin() != 0 || getMax() != 0)) {
        if (0 <= getMin())
            r.append('+');
        r.append(getMin());
        r.append("..");
        if (0 <= getMax())
            r.append('+');
        r.append(getMax());
        r.append(' ');
    }
    r.append("group ");
    r.append(getGroup().getName());
    return r.toString();
}
#end_block

#method_before
public static PermissionRule fromString(String src, boolean useRange) {
    final String orig = src;
    final PermissionRule rule = new PermissionRule();
    src = src.trim();
    if (src.startsWith("deny ")) {
        rule.setDeny(true);
        src = src.substring(5).trim();
    }
    if (src.startsWith("+force ")) {
        rule.setForce(true);
        src = src.substring("+force ".length()).trim();
    }
    if (useRange) {
        if (src.startsWith("group ")) {
            rule.setRange(0, 1);
        } else {
            int sp = src.indexOf(' ');
            String range = src.substring(0, sp);
            if (range.matches("^([+-]\\d+)\\.\\.([+-]\\d)$")) {
                int dotdot = range.indexOf("..");
                int min = parseInt(range.substring(0, dotdot));
                int max = parseInt(range.substring(dotdot + 2));
                rule.setRange(min, max);
            } else if (range.matches("^([+-]\\d)$")) {
                int v = parseInt(range);
                rule.setRange(v, v);
            } else {
                throw new IllegalArgumentException("Invalid range in rule: " + orig);
            }
            src = src.substring(sp + 1).trim();
        }
    }
    if (src.startsWith("group ")) {
        src = src.substring(6).trim();
        GroupReference group = new GroupReference();
        group.setName(src);
        rule.setGroup(group);
    } else {
        throw new IllegalArgumentException("Rule must include group: " + orig);
    }
    return rule;
}
#method_after
public static PermissionRule fromString(String src, boolean mightUseRange) {
    final String orig = src;
    final PermissionRule rule = new PermissionRule();
    src = src.trim();
    if (src.startsWith("deny ")) {
        rule.setDeny(true);
        src = src.substring(5).trim();
    }
    if (src.startsWith("+force ")) {
        rule.setForce(true);
        src = src.substring("+force ".length()).trim();
    }
    if (mightUseRange && !src.startsWith("group ")) {
        int sp = src.indexOf(' ');
        String range = src.substring(0, sp);
        if (range.matches("^([+-]\\d+)\\.\\.([+-]\\d)$")) {
            int dotdot = range.indexOf("..");
            int min = parseInt(range.substring(0, dotdot));
            int max = parseInt(range.substring(dotdot + 2));
            rule.setRange(min, max);
        } else {
            throw new IllegalArgumentException("Invalid range in rule: " + orig);
        }
        src = src.substring(sp + 1).trim();
    }
    if (src.startsWith("group ")) {
        src = src.substring(6).trim();
        GroupReference group = new GroupReference();
        group.setName(src);
        rule.setGroup(group);
    } else {
        throw new IllegalArgumentException("Rule must include group: " + orig);
    }
    return rule;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_DO_NOT_INHERIT)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setInherit(false);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    boolean useRange = perm.isLabel();
                    for (String ruleString : rc.getStringList(ACCESS, refName, varName)) {
                        PermissionRule rule;
                        try {
                            rule = PermissionRule.fromString(ruleString, useRange);
                        } catch (IllegalArgumentException notRule) {
                            throw new ConfigInvalidException("Invalid rule in " + ACCESS + "." + refName + "." + varName + ": " + notRule.getMessage(), notRule);
                        }
                        GroupReference ref = groupsByName.get(rule.getGroup().getName());
                        if (ref == null) {
                            // The group wasn't mentioned in the groups table, so there is
                            // no valid UUID for it. Pool the reference anyway so at least
                            // all rules in the same file share the same GroupReference.
                            // 
                            ref = rule.getGroup();
                            groupsByName.put(ref.getName(), ref);
                        }
                        rule.setGroup(ref);
                        perm.add(rule);
                    }
                }
            }
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    boolean useRange = perm.isLabel();
                    for (String ruleString : rc.getStringList(ACCESS, refName, varName)) {
                        PermissionRule rule;
                        try {
                            rule = PermissionRule.fromString(ruleString, useRange);
                        } catch (IllegalArgumentException notRule) {
                            throw new ConfigInvalidException("Invalid rule in " + ACCESS + "." + refName + "." + varName + ": " + notRule.getMessage(), notRule);
                        }
                        GroupReference ref = groupsByName.get(rule.getGroup().getName());
                        if (ref == null) {
                            // The group wasn't mentioned in the groups table, so there is
                            // no valid UUID for it. Pool the reference anyway so at least
                            // all rules in the same file share the same GroupReference.
                            // 
                            ref = rule.getGroup();
                            groupsByName.put(ref.getName(), ref);
                        }
                        rule.setGroup(ref);
                        perm.add(rule);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (!perm.getInherit()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_DO_NOT_INHERIT, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_DO_NOT_INHERIT);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
@Override
public void setValue(AccessSection value) {
    this.value = value;
    this.readOnly = !projectAccess.isOwnerOf(value);
    refPattern.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        rebuildPermissionSelector();
    }
}
#method_after
@Override
public void setValue(AccessSection value) {
    this.value = value;
    this.readOnly = !projectAccess.isOwnerOf(value);
    refPattern.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        String varName = Permission.LABEL + t.getCategory().getLabelName();
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    for (String varName : Util.C.permissionNames().keySet()) {
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addDotDotDot());
        permissionSelector.setValue(Util.C.addDotDotDot());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        String varName = Permission.LABEL + t.getCategory().getLabelName();
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    for (String varName : Util.C.permissionNames().keySet()) {
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
public String commitMessage(GitRepositoryManager repoManager, Provider<ReviewDb> db) {
    if (commitMessage == null) {
        try {
            PatchSet.Id psId = change.currentPatchSetId();
            String sha1 = db.get().patchSets().get(psId).getRevision().get();
            Project.NameKey name = change.getProject();
            Repository repo = repoManager.openRepository(name);
            RevWalk walk = new RevWalk(repo);
            RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
            commitMessage = c.getFullMessage();
            walk.release();
        } catch (RepositoryNotFoundException e) {
        } catch (IOException e) {
        } catch (OrmException e) {
        }
    }
    return commitMessage;
}
#method_after
public String commitMessage(GitRepositoryManager repoManager, Provider<ReviewDb> db) throws IOException, OrmException {
    if (commitMessage == null) {
        PatchSet.Id psId = change(db).currentPatchSetId();
        String sha1 = db.get().patchSets().get(psId).getRevision().get();
        Project.NameKey name = change.getProject();
        Repository repo = repoManager.openRepository(name);
        try {
            RevWalk walk = new RevWalk(repo);
            try {
                RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
                commitMessage = c.getFullMessage();
            } finally {
                walk.release();
            }
        } finally {
            repo.close();
        }
    }
    return commitMessage;
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute a, Collection<PatchSet> ps) {
    addPatchSets(a, ps, null);
}
#method_after
public void addPatchSets(ChangeAttribute a, Collection<PatchSet> ps) {
    addPatchSets(a, ps, null, false, null);
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
        }
    }
}
#method_after
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    addPatchSets(ca, ps, approvals, false, null);
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
        }
    }
}
#method_after
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals, boolean includeFiles, Change change) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
            if (includeFiles && change != null) {
                addPatchSetFileNames(psa, change, p);
            }
        }
    }
}
#end_block

#method_before
public boolean isVisible() {
    if (isOwner()) {
        return true;
    } else {
        return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && !isHidden();
    }
}
#method_after
public boolean isVisible() {
    return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && canRead();
}
#end_block

#method_before
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && isActive();
}
#method_after
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && isActive();
}
#method_after
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#end_block

#method_before
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && isActive();
}
#method_after
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && canWrite();
}
#end_block

#method_before
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && isActive();
}
#method_after
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && isActive();
}
#method_after
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && canWrite();
}
#end_block

#method_before
private boolean canPushWithForce() {
    if (!isActive() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#method_after
private boolean canPushWithForce() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!isActive()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (!isActive() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().isOwner() || control.getRefControl().isActive());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void load() throws OrmException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    if (detail.getChange().getStatus().equals(Change.Status.NEW) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
public boolean isVisible() {
    return visibleForReplication() || canPerformOnAnyRef(Permission.READ) && !isHidden();
}
#method_after
public boolean isVisible() {
    return (visibleForReplication() || canPerformOnAnyRef(Permission.READ)) && !isHidden();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, STATE, null, KEY_VALUE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, STATE, null, KEY_VALUE, p.getState(), defaultStateValue);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (isEditable()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            r.append(GWT.getHostPageBaseURL());
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        final StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null && changeDetail.isAllowsAnonymous()) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            String base = GWT.getHostPageBaseURL();
            int p = base.indexOf("://");
            int s = base.indexOf('/', p + 3);
            if (s < 0) {
                s = base.length();
            }
            String host = base.substring(p + 3, s);
            if (host.contains("@")) {
                host = host.substring(host.indexOf('@') + 1);
            }
            r.append(base.substring(0, p + 3));
            r.append(Gerrit.getUserAccount().getUserName());
            r.append('@');
            r.append(host);
            r.append(base.substring(s));
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            changeScreen.update(result);
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#method_after
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b, final boolean redirect) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            if (redirect) {
                Gerrit.display(PageLinks.toChange(result.getChange().getId()));
            } else {
                changeScreen.update(result);
            }
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#end_block

#method_before
public void setParentName(String n) {
    parent = n != null ? new NameKey(n) : null;
}
#method_after
public void setParentName(NameKey n) {
    parent = n;
}
#end_block

#method_before
private void setState(final Project.State newState) {
    int index = -1;
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                index = i;
                break;
            }
        }
        state.setSelectedIndex(index);
    }
}
#method_after
private void setState(final Project.State newState) {
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                state.setSelectedIndex(i);
                break;
            }
        }
    }
}
#end_block

#method_before
public void setCanModifyState(final boolean cmmt) {
    canModifyState = cmmt;
}
#method_after
public void setCanModifyState(final boolean cms) {
    canModifyState = cms;
}
#end_block

#method_before
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            parseCommandLine();
            updateParents();
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                updateParents();
            } finally {
                stdout.flush();
            }
        }
    });
}
#end_block

#method_before
private void updateParents() throws Failure {
    if (oldParent == null && children.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: child projects have to be specified as arguments or the --old-parent option has to be set");
    }
    if (oldParent == null && !excludedChildren.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: --exclude can only be used together with --old-parent");
    }
    final StringBuilder err = new StringBuilder();
    final Set<Project.NameKey> grandParents = new HashSet<Project.NameKey>();
    Project.NameKey newParentKey;
    grandParents.add(allProjectsName);
    if (newParent != null) {
        newParentKey = newParent.getProject().getNameKey();
        // Catalog all grandparents of the "parent", we want to
        // catch a cycle in the parent pointers before it occurs.
        // 
        Project.NameKey gp = newParent.getProject().getParent();
        while (gp != null && grandParents.add(gp)) {
            final ProjectState s = projectCache.get(gp);
            if (s != null) {
                gp = s.getProject().getParent();
            } else {
                break;
            }
        }
    } else {
        // If no parent was selected, set to NULL to use the default.
        // 
        newParentKey = null;
    }
    final List<Project> childProjects = new ArrayList<Project>();
    for (final ProjectControl pc : children) {
        childProjects.add(pc.getProject());
    }
    if (oldParent != null) {
        final List<Project.NameKey> excluded = new ArrayList<Project.NameKey>(excludedChildren.size() + 1);
        if (newParentKey != null) {
            excluded.add(newParentKey);
        }
        for (final ProjectControl excludedChild : excludedChildren) {
            excluded.add(excludedChild.getProject().getNameKey());
        }
        final ProjectNode oldParentProject = createProjectHierarchyFactory.create().getProjectHierarchy(oldParent.getProject().getNameKey());
        for (final ProjectNode childProject : oldParentProject.getChildren()) {
            if (!excluded.contains(childProject.getProject().getNameKey())) {
                childProjects.add(childProject.getProject());
            }
        }
    }
    for (final Project project : childProjects) {
        final String name = project.getName();
        final Project.NameKey nameKey = project.getNameKey();
        if (allProjectsName.equals(nameKey)) {
            // Don't allow the wild card project to have a parent.
            // 
            err.append("error: Cannot set parent of '" + name + "'\n");
            continue;
        }
        if (grandParents.contains(nameKey) || nameKey.equals(newParentKey)) {
            // Try to avoid creating a cycle in the parent pointers.
            // 
            err.append("error: Cycle exists between '" + name + "' and '" + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "'\n");
            continue;
        }
        try {
            MetaDataUpdate md = metaDataUpdateFactory.create(nameKey);
            try {
                ProjectConfig config = ProjectConfig.read(md);
                config.getProject().setParentName(newParentKey);
                md.setMessage("Inherit access from " + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "\n");
                if (!config.commit(md)) {
                    err.append("error: Could not update project " + name + "\n");
                }
            } finally {
                md.close();
            }
        } catch (RepositoryNotFoundException notFound) {
            err.append("error: Project " + name + " not found\n");
        } catch (IOException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        } catch (ConfigInvalidException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        }
        projectCache.evict(project);
    }
    if (err.length() > 0) {
        while (err.charAt(err.length() - 1) == '\n') {
            err.setLength(err.length() - 1);
        }
        throw new UnloggedFailure(1, err.toString());
    }
}
#method_after
private void updateParents() throws Failure {
    if (oldParent == null && children.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: child projects have to be specified as " + "arguments or the --children-of option has to be set");
    }
    if (oldParent == null && !excludedChildren.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: --exclude can only be used together " + "with --children-of");
    }
    final StringBuilder err = new StringBuilder();
    final Set<Project.NameKey> grandParents = new HashSet<Project.NameKey>();
    grandParents.add(allProjectsName);
    if (newParent != null) {
        newParentKey = newParent.getProject().getNameKey();
        // Catalog all grandparents of the "parent", we want to
        // catch a cycle in the parent pointers before it occurs.
        // 
        Project.NameKey gp = newParent.getProject().getParent();
        while (gp != null && grandParents.add(gp)) {
            final ProjectState s = projectCache.get(gp);
            if (s != null) {
                gp = s.getProject().getParent();
            } else {
                break;
            }
        }
    }
    final List<Project> childProjects = new ArrayList<Project>();
    for (final ProjectControl pc : children) {
        childProjects.add(pc.getProject());
    }
    if (oldParent != null) {
        childProjects.addAll(getChildrenForReparenting(oldParent));
    }
    for (final Project project : childProjects) {
        final String name = project.getName();
        final Project.NameKey nameKey = project.getNameKey();
        if (allProjectsName.equals(nameKey)) {
            // Don't allow the wild card project to have a parent.
            // 
            err.append("error: Cannot set parent of '" + name + "'\n");
            continue;
        }
        if (grandParents.contains(nameKey) || nameKey.equals(newParentKey)) {
            // Try to avoid creating a cycle in the parent pointers.
            // 
            err.append("error: Cycle exists between '" + name + "' and '" + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "'\n");
            continue;
        }
        try {
            MetaDataUpdate md = metaDataUpdateFactory.create(nameKey);
            try {
                ProjectConfig config = ProjectConfig.read(md);
                config.getProject().setParentName(newParentKey);
                md.setMessage("Inherit access from " + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "\n");
                if (!config.commit(md)) {
                    err.append("error: Could not update project " + name + "\n");
                }
            } finally {
                md.close();
            }
        } catch (RepositoryNotFoundException notFound) {
            err.append("error: Project " + name + " not found\n");
        } catch (IOException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        } catch (ConfigInvalidException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        }
        projectCache.evict(project);
    }
    if (err.length() > 0) {
        while (err.charAt(err.length() - 1) == '\n') {
            err.setLength(err.length() - 1);
        }
        throw new UnloggedFailure(1, err.toString());
    }
}
#end_block

#method_before
private boolean suggestGroupAsReviewer(final Project.NameKey project, final GroupReference group) throws OrmException {
    if (!AddReviewer.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        final PerformGroupMembers groupMembers = groupMembersFactory.create();
        groupMembers.setProject(project);
        final Set<Account> members = groupMembers.listAccounts(group.getUUID());
        if (members.isEmpty()) {
            return false;
        }
        final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", AddReviewer.DEFAULT_MAX_REVIEWERS);
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return true;
}
#method_after
private boolean suggestGroupAsReviewer(final Project.NameKey project, final GroupReference group) throws OrmException {
    if (!AddReviewer.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        final Set<Account> members = groupMembersFactory.create().listAccounts(group.getUUID(), project);
        if (members.isEmpty()) {
            return false;
        }
        final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", AddReviewer.DEFAULT_MAX_REVIEWERS);
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final PerformGroupMembers groupMembers = groupMembersFactory.create();
            groupMembers.setProject(control.getProject().getNameKey());
            final Set<Account> members = groupMembers.listAccounts(group.getGroupUUID());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    if (control.forUser(user).isVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        if (!control.forUser(user).isVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final PatchSet.Id psid = control.getChange().currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#method_after
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final Set<Account> members = groupMembersFactory.create().listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    if (control.forUser(user).isVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        if (!control.forUser(user).isVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final PatchSet.Id psid = control.getChange().currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(PerformGroupMembers.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformVisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembersFactory.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembersFactory.Factory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(FlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "ls-groups").to(ListGroups.class);
    command(gerrit, "query").to(Query.class);
    command(gerrit, "show-caches").to(ShowCaches.class);
    command(gerrit, "show-connections").to(ShowConnections.class);
    command(gerrit, "show-queue").to(ShowQueue.class);
    command(gerrit, "stream-events").to(StreamEvents.class);
    command(gerrit, "version").to(VersionCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(FlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "ls-groups").to(ListGroupsCommand.class);
    command(gerrit, "query").to(Query.class);
    command(gerrit, "show-caches").to(ShowCaches.class);
    command(gerrit, "show-connections").to(ShowConnections.class);
    command(gerrit, "show-queue").to(ShowQueue.class);
    command(gerrit, "stream-events").to(StreamEvents.class);
    command(gerrit, "version").to(VersionCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException {
    final Project.NameKey projectName = update.getNameKey();
    projectControlFactory.ownerFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        // TODO We really should take advantage of the Git commit DAG and
        // ensure the current version matches the old version the caller read.
        // 
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().copySettingsFrom(update);
        md.setMessage("Modified project settings\n");
        if (config.commit(md)) {
            mgr.setProjectDescription(projectName, update.getDescription());
            projectCache.evict(config.getProject());
            userCache.get().evict(projectName);
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } catch (ConfigInvalidException err) {
        throw new OrmException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new OrmException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException {
    final Project.NameKey projectName = update.getNameKey();
    projectControlFactory.ownerFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        // TODO We really should take advantage of the Git commit DAG and
        // ensure the current version matches the old version the caller read.
        // 
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().copySettingsFrom(update);
        md.setMessage("Modified project settings\n");
        if (config.commit(md)) {
            mgr.setProjectDescription(projectName, update.getDescription());
            userCache.get().evict(config.getProject());
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } catch (ConfigInvalidException err) {
        throw new OrmException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new OrmException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public void evict(Project.NameKey nameKey) {
    controls.remove(nameKey);
}
#method_after
public void evict(Project project) {
    projectCache.evict(project);
    controls.remove(project.getNameKey());
}
#end_block

#method_before
private void expand(ClickEvent event, final int numRows) {
    Cell cell = table.getCellForEvent(event);
    int row = cell.getRowIndex();
    if (!(getRowItem(row) instanceof SkippedLine)) {
        return;
    }
    SkippedLine line = (SkippedLine) getRowItem(row);
    int loopTo = numRows;
    if (numRows == 0) {
        loopTo = line.getSize();
    } else if (numRows < 0) {
        loopTo = -numRows;
    }
    int offset = 0;
    if (numRows < 0) {
        offset = 1;
    }
    for (int i = 0 + offset; i < loopTo + offset; i++) {
        insertRow(row + i);
        int lineA = line.getStartA() + i;
        int lineB = line.getStartB() + i;
        if (numRows < 0) {
            lineA = line.getStartA() + line.getSize() + numRows + i - offset;
            lineB = line.getStartB() + line.getSize() + numRows + i - offset;
        }
        setHtml(row + i, 1, "<a href=\"javascript:void(0)\">" + (lineA + 1) + "</a>");
        setHtml(row + i, 2, a.getSafeHtmlLine(lineA).asString());
        setHtml(row + i, 3, "<a href=\"javascript:void(0)\">" + (lineB + 1) + "</a>");
        setHtml(row + i, 4, b.getSafeHtmlLine(lineB).asString());
        setRowItem(row + i, new PatchLine(CONTEXT, lineA, lineB));
    }
    if (numRows > 0) {
        line.incrementStart(numRows);
        createSkipLine(row + loopTo, line);
    } else if (numRows < 0) {
        line.reduceSize(-numRows);
        createSkipLine(row, line);
    } else {
        removeRow(row + loopTo);
    }
}
#method_after
private void expand(ClickEvent event, final int numRows) {
    Cell cell = table.getCellForEvent(event);
    int row = cell.getRowIndex();
    if (!(getRowItem(row) instanceof SkippedLine)) {
        return;
    }
    SkippedLine line = (SkippedLine) getRowItem(row);
    int loopTo = numRows;
    if (numRows == 0) {
        loopTo = line.getSize();
    } else if (numRows < 0) {
        loopTo = -numRows;
    }
    int offset = 0;
    if (numRows < 0) {
        offset = 1;
    }
    for (int i = 0 + offset; i < loopTo + offset; i++) {
        insertRow(row + i);
        int lineA = line.getStartA() + i;
        int lineB = line.getStartB() + i;
        if (numRows < 0) {
            lineA = line.getStartA() + line.getSize() + numRows + i - offset;
            lineB = line.getStartB() + line.getSize() + numRows + i - offset;
        }
        setHtml(row + i, 1, "<a href=\"javascript:void(0)\">" + (lineA + 1) + "</a>");
        addStyle(row + i, 1, Gerrit.RESOURCES.css().lineNumber());
        setHtml(row + i, 2, a.getSafeHtmlLine(lineA).asString());
        addStyle(row + i, 2, Gerrit.RESOURCES.css().fileLine());
        addStyle(row + i, 2, Gerrit.RESOURCES.css().fileLineCONTEXT());
        setHtml(row + i, 3, "<a href=\"javascript:void(0)\">" + (lineB + 1) + "</a>");
        addStyle(row + i, 3, Gerrit.RESOURCES.css().lineNumber());
        setHtml(row + i, 4, b.getSafeHtmlLine(lineB).asString());
        addStyle(row + i, 4, Gerrit.RESOURCES.css().fileLine());
        addStyle(row + i, 4, Gerrit.RESOURCES.css().fileLineCONTEXT());
        setRowItem(row + i, new PatchLine(CONTEXT, lineA, lineB));
    }
    if (numRows > 0) {
        line.incrementStart(numRows);
        createSkipLine(row + loopTo, line);
    } else if (numRows < 0) {
        line.reduceSize(-numRows);
        createSkipLine(row, line);
    } else {
        removeRow(row + loopTo);
    }
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    Pattern regex = (Pattern) ((JavaObjectTerm) a1).object();
    Iterator<PatchListEntry> iter = (Iterator<PatchListEntry>) ((JavaObjectTerm) a5).object();
    if (iter.hasNext()) {
        PatchListEntry patch = iter.next();
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if (!newName.equals("/COMMIT_MSG") && regex.matcher(newName).matches() || (oldName != null && regex.matcher(oldName).matches())) {
            SymbolTerm changeSym = getTypeSymbol(changeType);
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(changeSym, engine.trail)) {
                return engine.fail();
            }
            if (!a3.unify(newSym, engine.trail)) {
                return engine.fail();
            }
            if (!a4.unify(oldSym, engine.trail)) {
                return engine.fail();
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    Pattern regex = (Pattern) ((JavaObjectTerm) a1).object();
    Iterator<PatchListEntry> iter = (Iterator<PatchListEntry>) ((JavaObjectTerm) a5).object();
    while (iter.hasNext()) {
        PatchListEntry patch = iter.next();
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if (newName.equals("/COMMIT_MSG")) {
            continue;
        }
        if (regex.matcher(newName).matches() || (oldName != null && regex.matcher(oldName).matches())) {
            SymbolTerm changeSym = getTypeSymbol(changeType);
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(changeSym, engine.trail)) {
                continue;
            }
            if (!a3.unify(newSym, engine.trail)) {
                continue;
            }
            if (!a4.unify(oldSym, engine.trail)) {
                continue;
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#end_block

#method_before
private void postLoad() {
    if (haveAccount && haveEmails) {
        if (currentEmail != null) {
            boolean found = false;
            for (int i = 0; i < emailPick.getItemCount(); i++) {
                if (currentEmail.equals(emailPick.getValue(i))) {
                    emailPick.setSelectedIndex(i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                emailPick.addItem(currentEmail);
                emailPick.setSelectedIndex(emailPick.getItemCount() - 1);
            }
        }
        if (emailPick.getItemCount() > 0) {
            emailPick.setVisible(true);
            emailPick.setEnabled(true);
            if (canRegisterNewEmail()) {
                final String t = Util.C.buttonOpenRegisterNewEmail();
                emailPick.addItem("... " + t + "  ", t);
            }
        } else {
            emailPick.setVisible(false);
        }
        registerNewEmail.setEnabled(true);
    }
    display();
}
#method_after
private void postLoad() {
    if (haveAccount && haveEmails) {
        updateEmailList();
        registerNewEmail.setEnabled(true);
    }
    display();
}
#end_block

#method_before
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            Util.ACCOUNT_SEC.registerEmail(addr, new GerritCallback<VoidResult>() {

                public void onSuccess(VoidResult result) {
                    box.hide();
                    switch(Gerrit.getConfig().getAuthType()) {
                        case HTTP:
                        case HTTP_LDAP:
                        case CLIENT_SSL_CERT_LDAP:
                        case OPENID:
                        case LDAP:
                        case LDAP_BIND:
                            break;
                        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                            Gerrit.upgradeUI(PageLinks.SETTINGS_CONTACT);
                            break;
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    body.add(new HTML(Util.C.descRegisterNewEmail()));
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#method_after
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                new ErrorDialog(Util.C.invalidUserEmail()).center();
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            Util.ACCOUNT_SEC.registerEmail(addr, new GerritCallback<Account>() {

                public void onSuccess(Account currentUser) {
                    box.hide();
                    if (Gerrit.getConfig().getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
                        currentEmail = addr;
                        if (emailPick.getItemCount() == 0) {
                            onSaveSuccess(currentUser);
                        } else {
                            save.setEnabled(true);
                        }
                        updateEmailList();
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    if (Gerrit.getConfig().getAuthType() != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        body.add(new HTML(Util.C.descRegisterNewEmail()));
    }
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#end_block

#method_before
public void registerEmail(final String address, final AsyncCallback<VoidResult> cb) {
    try {
        switch(authConfig.getAuthType()) {
            case OPENID:
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
            case LDAP:
            case LDAP_BIND:
                final RegisterNewEmailSender sender;
                sender = registerNewEmailFactory.create(address);
                sender.send();
                cb.onSuccess(VoidResult.INSTANCE);
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                registerMail(address, cb);
                break;
            default:
                log.error("Unsupported loginType: " + authConfig.getAuthType(), new ProvisionException("Unsupported loginType: " + authConfig.getAuthType()));
                throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
        }
    } catch (EmailException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    } catch (RuntimeException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    }
}
#method_after
public void registerEmail(final String address, final AsyncCallback<Account> cb) {
    if (authConfig.getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        try {
            accountManager.link(user.get().getAccountId(), AuthRequest.forEmail(address));
            cb.onSuccess(user.get().getAccount());
        } catch (AccountException e) {
            cb.onFailure(e);
        }
    } else {
        try {
            final RegisterNewEmailSender sender;
            sender = registerNewEmailFactory.create(address);
            sender.send();
        } catch (EmailException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        } catch (RuntimeException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        }
    }
}
#end_block

#method_before
public void validateEmail(final String token, final AsyncCallback<VoidResult> callback) {
    try {
        final ValidToken t = authConfig.getEmailRegistrationToken().checkToken(token, null);
        if (t == null || t.getData() == null || "".equals(t.getData())) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        final String newEmail = new String(Base64.decode(t.getData()), "UTF-8");
        registerMail(newEmail, callback);
    } catch (XsrfException e) {
        callback.onFailure(e);
    } catch (UnsupportedEncodingException e) {
        callback.onFailure(e);
    }
}
#method_after
public void validateEmail(final String token, final AsyncCallback<VoidResult> callback) {
    try {
        final ValidToken t = authConfig.getEmailRegistrationToken().checkToken(token, null);
        if (t == null || t.getData() == null || "".equals(t.getData())) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        final String newEmail = new String(Base64.decode(t.getData()), "UTF-8");
        if (!newEmail.contains("@")) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        accountManager.link(user.get().getAccountId(), AuthRequest.forEmail(newEmail));
        callback.onSuccess(VoidResult.INSTANCE);
    } catch (XsrfException e) {
        callback.onFailure(e);
    } catch (UnsupportedEncodingException e) {
        callback.onFailure(e);
    } catch (AccountException e) {
        callback.onFailure(e);
    }
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regex = Pattern.compile(a1.name());
    if (a2.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a2.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regexEdit = Pattern.compile(a2.name());
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    PatchList pl = getPatchList(env, psInfo);
    Repository repo;
    try {
        repo = getRepository(env);
    } catch (RepositoryNotFoundException err) {
        throw new JavaException(this, 1, err);
    }
    final ObjectReader reader = repo.newObjectReader();
    final RevTree aTree;
    final RevTree bTree;
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            final RevCommit p = bCommit.getParent(0);
            rw.parseHeaders(p);
            aTree = p.getTree();
        }
        bTree = bCommit.getTree();
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    } finally {
        reader.release();
    }
    for (PatchListEntry entry : pl.getPatches()) {
        String newName = entry.getNewName();
        String oldName = entry.getOldName();
        if (regex.matcher(newName).find() || (oldName != null && regex.matcher(oldName).find())) {
            List<Edit> edits = entry.getEdits();
            if (edits.isEmpty()) {
                continue;
            }
            try {
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, repo);
                } else {
                    tA = load(aTree, newName, repo);
                }
                Text tB = load(bTree, newName, repo);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (regexEdit.matcher(aDiff).find()) {
                            engine.neckCut();
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (regexEdit.matcher(bDiff).find()) {
                            engine.neckCut();
                            return cont;
                        }
                    }
                }
            } catch (IOException err) {
                throw new JavaException(this, 1, err);
            }
        }
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Pattern fileRegex = getRegexParameter(a1);
    Pattern editRegex = getRegexParameter(a2);
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo = StoredValues.PATCH_SET_INFO.get(engine);
    PatchList pl = StoredValues.PATCH_LIST.get(engine);
    Repository repo = StoredValues.REPOSITORY.get(engine);
    final ObjectReader reader = repo.newObjectReader();
    final RevTree aTree;
    final RevTree bTree;
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            // web UI returns no files to match against, just fail.
            return engine.fail();
        }
        bTree = bCommit.getTree();
        for (PatchListEntry entry : pl.getPatches()) {
            String newName = entry.getNewName();
            String oldName = entry.getOldName();
            if (newName.equals("/COMMIT_MSG")) {
                continue;
            }
            if (fileRegex.matcher(newName).find() || (oldName != null && fileRegex.matcher(oldName).find())) {
                List<Edit> edits = entry.getEdits();
                if (edits.isEmpty()) {
                    continue;
                }
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, reader);
                } else {
                    tA = load(aTree, newName, reader);
                }
                Text tB = load(bTree, newName, reader);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (editRegex.matcher(aDiff).find()) {
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (editRegex.matcher(bDiff).find()) {
                            return cont;
                        }
                    }
                }
            }
        }
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    } finally {
        reader.release();
    }
    return engine.fail();
}
#end_block

#method_before
private Text load(final ObjectId tree, final String path, final Repository repo) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
    if (path == null) {
        return Text.EMPTY;
    }
    final TreeWalk tw = TreeWalk.forPath(repo, path, tree);
    if (tw == null) {
        return Text.EMPTY;
    }
    if (tw.getFileMode(0).getObjectType() != Constants.OBJ_BLOB) {
        return Text.EMPTY;
    }
    return new Text(repo.open(tw.getObjectId(0), Constants.OBJ_BLOB));
}
#method_after
private Text load(final ObjectId tree, final String path, final ObjectReader reader) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
    if (path == null) {
        return Text.EMPTY;
    }
    final TreeWalk tw = TreeWalk.forPath(reader, path, tree);
    if (tw == null) {
        return Text.EMPTY;
    }
    if (tw.getFileMode(0).getObjectType() != Constants.OBJ_BLOB) {
        return Text.EMPTY;
    }
    return new Text(reader.open(tw.getObjectId(0), Constants.OBJ_BLOB));
}
#end_block

#method_before
private void showText(Object data, int depth) {
    for (Field f : fieldsOf(data.getClass())) {
        Object val;
        try {
            val = f.get(data);
        } catch (IllegalArgumentException err) {
            continue;
        } catch (IllegalAccessException err) {
            continue;
        }
        if (val == null) {
            continue;
        }
        indent(depth);
        out.print(f.getName());
        out.print(":");
        if (val instanceof Long && isDateField(f.getName())) {
            out.print(' ');
            out.print(sdf.format(new Date(((Long) val) * 1000L)));
            out.print('\n');
        } else {
            showTextValue(val, depth);
        }
    }
}
#method_after
private void showText(Object data, int depth) {
    for (Field f : fieldsOf(data.getClass())) {
        Object val;
        try {
            val = f.get(data);
        } catch (IllegalArgumentException err) {
            continue;
        } catch (IllegalAccessException err) {
            continue;
        }
        if (val == null) {
            continue;
        }
        showField(f.getName(), val, depth);
    }
}
#end_block

#method_before
private void indent(int depth) {
    for (int i = 0; i < depth; i++) {
        out.print("  ");
    }
}
#method_after
private String indent(int spaces) {
    if (spaces == 0) {
        return "";
    } else {
        return String.format("%" + spaces + "s", " ");
    }
}
#end_block

#method_before
public MessageAttribute asMessageAttribute(ChangeMessage message) {
    MessageAttribute a = new MessageAttribute();
    a.timestamp = message.getWrittenOn().getTime();
    a.author = accountCache.get(message.getAuthor()).getAccount().getFullName();
    a.message = message.getMessage();
    return a;
}
#method_after
public MessageAttribute asMessageAttribute(ChangeMessage message) {
    MessageAttribute a = new MessageAttribute();
    a.timestamp = message.getWrittenOn().getTime() / 1000L;
    a.reviewer = asAccountAttribute(message.getAuthor());
    a.message = message.getMessage();
    return a;
}
#end_block

#method_before
public PatchSetCommentAttribute asPatchSetLineAttribute(PatchLineComment c) {
    PatchSetCommentAttribute a = new PatchSetCommentAttribute();
    a.author = accountCache.get(c.getAuthor()).getAccount().getFullName();
    a.file = c.getKey().getParentKey().get();
    a.line = c.getLine();
    a.message = c.getMessage();
    return a;
}
#method_after
public PatchSetCommentAttribute asPatchSetLineAttribute(PatchLineComment c) {
    PatchSetCommentAttribute a = new PatchSetCommentAttribute();
    a.reviewer = asAccountAttribute(c.getAuthor());
    a.file = c.getKey().getParentKey().get();
    a.line = c.getLine();
    a.message = c.getMessage();
    return a;
}
#end_block

#method_before
public Collection<ChangeMessage> messages(Provider<ReviewDb> db) throws OrmException {
    if (messages == null) {
        messages = db.get().changeMessages().byChange(legacyId).toList();
    }
    return messages;
}
#method_after
public List<ChangeMessage> messages(Provider<ReviewDb> db) throws OrmException {
    if (messages == null) {
        messages = db.get().changeMessages().byChange(legacyId).toList();
    }
    return messages;
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        try {
            while (parentState != null) {
                if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                    // parent has been seen before, stop walk up inheritance tree
                    break;
                }
                PrologEnvironment parentEnv;
                try {
                    parentEnv = parentState.newPrologEnvironment();
                } catch (CompileException err) {
                    return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
                }
                try {
                    parentEnv.copyStoredValues(childEnv);
                    Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
                    if (filterRule != null) {
                        try {
                            Term resultsTerm = toListTerm(results);
                            results.clear();
                            Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                            results.addAll(((ListTerm) template[2]).toJava());
                        } catch (PrologException err) {
                            return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                        } catch (RuntimeException err) {
                            return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                        }
                    }
                    parentState = parentState.getParentState();
                    childEnv = parentEnv;
                } finally {
                    // childEnv.close() below will handle it.
                    if (childEnv != parentEnv) {
                        parentEnv.close();
                    }
                }
            }
        } finally {
            childEnv.close();
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
public void copyStoredValues(PrologEnvironment child) {
    storedValues.putAll(child.storedValues);
    child.delegateCleanup(cleanup);
}
#method_after
public void copyStoredValues(PrologEnvironment child) {
    storedValues.putAll(child.storedValues);
    setCleanup(child.cleanup);
}
#end_block

#method_before
public void close() {
    for (Runnable task : cleanup) {
        task.run();
    }
    // ensure cleanup tasks run only once, even if close() is called again
    cleanup.clear();
}
#method_after
public void close() {
    for (final Iterator<Runnable> i = cleanup.iterator(); i.hasNext(); ) {
        try {
            i.next().run();
        } catch (Throwable err) {
            log.error("Failed to execute cleanup for PrologEnvironment", err);
        }
        i.remove();
    }
}
#end_block

#method_before
public T get(Prolog engine) {
    T obj = getOrNull(engine);
    if (obj == null) {
        // unless createValue() is overridden, will throw an exception
        obj = createValue(engine);
        set(engine, obj);
    }
    return obj;
}
#method_after
public T get(Prolog engine) {
    T obj = getOrNull(engine);
    if (obj == null) {
        // unless createValue() is overridden, will return null
        obj = createValue(engine);
        if (obj == null) {
            throw new SystemException("No " + key + " available");
        }
        set(engine, obj);
    }
    return obj;
}
#end_block

#method_before
protected T createValue(Prolog engine) {
    throw new SystemException("No " + key + " available");
}
#method_after
protected T createValue(Prolog engine) {
    return null;
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        return logRuleError("No user:submit_rule found for " + getProject().getName());
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    } catch (RuntimeException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    }
    ProjectState parentState = projectState.getParentState();
    PrologEnvironment parentEnv;
    PrologEnvironment childEnv = env;
    while (parentState != null) {
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", "locate_filter", new VariableTerm());
        if (filterRule != null) {
            try {
                Term resultsTerm = toListTerm(results);
                results.clear();
                List<Term> filtered = new ArrayList<Term>();
                for (Term[] template : parentEnv.all("gerrit", "filter_results", filterRule, resultsTerm, new VariableTerm())) {
                    results.add(template[2]);
                }
            } catch (PrologException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            } catch (RuntimeException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            }
        }
        parentState = parentState.getParentState();
        childEnv = parentEnv;
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        return logRuleError("No user:submit_rule found for " + getProject().getName());
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    } catch (RuntimeException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    }
    ProjectState parentState = projectState.getParentState();
    PrologEnvironment childEnv = env;
    Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
    projectsSeen.add(getProject().getNameKey());
    while (parentState != null) {
        if (!projectsSeen.add(parentState.getProject().getNameKey())) {
            // parent has been seen before, stop walk up inheritance tree
            break;
        }
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
        if (filterRule != null) {
            try {
                Term resultsTerm = toListTerm(results);
                results.clear();
                Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                results.addAll(((ListTerm) template[2]).toJava());
            } catch (PrologException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            } catch (RuntimeException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            }
        }
        parentState = parentState.getParentState();
        childEnv = parentEnv;
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (Term term : terms) {
        list = new ListTerm(term, list);
    }
    return list;
}
#method_after
private static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#end_block

#method_before
void display(final List<Patch> result) {
    all.clear();
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    table.setText(1, 0, PatchUtil.C.patchHeaderOld());
    fmt.setStyleName(1, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(2, 0, PatchUtil.C.patchHeaderNew());
    fmt.setStyleName(2, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(3, 0, Util.C.patchTableColumnComments());
    fmt.setStyleName(3, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(0, 1, "Base");
    fmt.setStyleName(0, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topMostCell());
    fmt.setStyleName(1, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(2, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(3, 1, Gerrit.RESOURCES.css().dataCell());
    installRadio(1, 1, null, screen.idSideA, 0);
    int col = 2;
    for (final Patch k : result) {
        final PatchSet.Id psId = k.getKey().getParentKey();
        table.setText(0, col, Util.M.patchSetHeader(psId.get()));
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().dataCell());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().topMostCell());
        installRadio(1, col, psId, screen.idSideA, 0);
        installRadio(2, col, psId, screen.idSideB, 1);
        fmt.setStyleName(3, col, Gerrit.RESOURCES.css().dataCell());
        if (k.getCommentCount() > 0) {
            table.setText(3, col, Util.M.patchTableComments(k.getCommentCount()));
        }
        col++;
    }
}
#method_after
void display(final List<Patch> result) {
    all.clear();
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    table.setText(0, 0, PatchUtil.C.patchHeaderPatchSet());
    fmt.setStyleName(0, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(1, 0, PatchUtil.C.patchHeaderOld());
    fmt.setStyleName(1, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(2, 0, PatchUtil.C.patchHeaderNew());
    fmt.setStyleName(2, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(3, 0, Util.C.patchTableColumnComments());
    fmt.setStyleName(3, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(0, 1, PatchUtil.C.patchBase());
    fmt.setStyleName(0, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topMostCell());
    fmt.setStyleName(1, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(2, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(3, 1, Gerrit.RESOURCES.css().dataCell());
    installRadio(1, 1, null, screen.idSideA, 0);
    int col = 2;
    for (final Patch k : result) {
        final PatchSet.Id psId = k.getKey().getParentKey();
        table.setText(0, col, String.valueOf(psId.get()));
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().patchHistoryTablePatchSetHeader());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().dataCell());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().topMostCell());
        installRadio(1, col, psId, screen.idSideA, 0);
        installRadio(2, col, psId, screen.idSideB, 1);
        fmt.setStyleName(3, col, Gerrit.RESOURCES.css().dataCell());
        if (k.getCommentCount() > 0) {
            table.setText(3, col, Util.M.patchTableComments(k.getCommentCount()));
        }
        col++;
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    doPost(req, rsp);
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    doPost(req, rsp);
}
#end_block

#method_before
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(rsp, req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(rsp, req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(rsp, req.getParameter("account_id"));
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        rsp.setContentLength(raw.length);
        final OutputStream out = rsp.getOutputStream();
        try {
            out.write(raw);
        } finally {
            out.close();
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(urlProvider.get());
        if (IS_DEV && req.getParameter("gwt.codesvr") != null) {
            if (rdr.indexOf("?") < 0) {
                rdr.append("?");
            } else {
                rdr.append("&");
            }
            rdr.append("gwt.codesvr=").append(req.getParameter("gwt.codesvr"));
        }
        rdr.append('#');
        if (res.isNew()) {
            rdr.append(PageLinks.REGISTER);
        }
        rdr.append(PageLinks.MINE);
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        final Writer out = rsp.getWriter();
        out.write("<html>");
        out.write("<body>");
        out.write("<h1>Account Not Found</h1>");
        out.write("</body>");
        out.write("</html>");
        out.close();
    }
}
#method_after
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(rsp, req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(rsp, req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(rsp, req.getParameter("account_id"));
    } else {
        byte[] raw;
        try {
            raw = prepareHtmlOutput();
        } catch (OrmException e) {
            throw new ServletException(e);
        }
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        rsp.setContentLength(raw.length);
        final OutputStream out = rsp.getOutputStream();
        try {
            out.write(raw);
        } finally {
            out.close();
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(urlProvider.get());
        if (IS_DEV && req.getParameter("gwt.codesvr") != null) {
            if (rdr.indexOf("?") < 0) {
                rdr.append("?");
            } else {
                rdr.append("&");
            }
            rdr.append("gwt.codesvr=").append(req.getParameter("gwt.codesvr"));
        }
        rdr.append('#');
        if (res.isNew()) {
            rdr.append(PageLinks.REGISTER);
        }
        rdr.append(PageLinks.MINE);
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        final Writer out = rsp.getWriter();
        out.write("<html>");
        out.write("<body>");
        out.write("<h1>Account Not Found</h1>");
        out.write("</body>");
        out.write("</html>");
        out.close();
    }
}
#end_block

#method_before
public void addReviewers(final Change.Id id, final List<String> reviewers, final boolean confirmed, final AsyncCallback<ReviewerResult> callback) {
    addReviewerFactory.create(id, reviewers, confirmed).to(callback);
}
#method_after
public void addReviewers(final Change.Id id, final List<String> reviewers, final boolean confirmed, final AsyncCallback<ReviewerResult> callback) {
    addReviewerHandlerFactory.create(id, reviewers, confirmed).to(callback);
}
#end_block

#method_before
public void removeReviewer(final Change.Id id, final Account.Id reviewerId, final AsyncCallback<ReviewerResult> callback) {
    removeReviewerFactory.create(id, reviewerId).to(callback);
}
#method_after
public void removeReviewer(final Change.Id id, final Account.Id reviewerId, final AsyncCallback<ReviewerResult> callback) {
    removeReviewerHandlerFactory.create(id, reviewerId).to(callback);
}
#end_block

#method_before
public void userApprovals(final Set<Change.Id> cids, final Account.Id aid, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            aicFactory.want(aid);
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (final PatchSetApproval ca : db.patchSetApprovals().byPatchSetUser(ps_id, aid)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        psas.put(category, ca);
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#method_after
public void userApprovals(final Set<Change.Id> cids, final Account.Id aid, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            aicFactory.want(aid);
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(cc, ps_id, psas.values());
                    for (final PatchSetApproval ca : db.patchSetApprovals().byPatchSetUser(ps_id, aid)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        psas.put(category, ca);
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        boolean keep = true;
                        if (psas.containsKey(category)) {
                            final short oldValue = psas.get(category).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(category, ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#method_after
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(cc, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        boolean keep = true;
                        if (psas.containsKey(category)) {
                            final short oldValue = psas.get(category).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(category, ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
private void displayHeader() {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (final ApprovalType t : types) {
        table.setText(0, col, t.getCategory().getName());
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(0, col, Gerrit.RESOURCES.css().rightmost());
    col++;
}
#method_after
private void displayHeader(List<String> labels) {
    table.resizeColumns(2 + labels.size());
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (String name : labels) {
        table.setText(0, col, name);
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    fmt.addStyleName(0, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
public void display(final Change change, final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    changeId = change.getId();
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.resizeRows(1 + rows.size());
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i), change);
        }
        table.setVisible(true);
    }
    final Element missingList = missing.getElement();
    while (DOM.getChildCount(missingList) > 0) {
        DOM.removeChild(missingList, DOM.getChild(missingList, 0));
    }
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Element li = DOM.createElement("li");
                li.setClassName(Gerrit.RESOURCES.css().missingApproval());
                DOM.setInnerText(li, Util.M.needApproval(at.getCategory().getName(), at.getMax().formatValue(), at.getMax().getName()));
                DOM.appendChild(missingList, li);
                missing.setVisible(true);
            }
        }
    }
    addReviewer.setVisible(Gerrit.isSignedIn() && change.getStatus().isOpen());
}
#method_after
void display(ChangeDetail detail) {
    reviewerSuggestOracle.setProject(detail.getChange().getProject());
    List<String> columns = new ArrayList<String>();
    List<ApprovalDetail> rows = detail.getApprovals();
    changeId = detail.getChange().getId();
    final Element missingList = missing.getElement();
    while (DOM.getChildCount(missingList) > 0) {
        DOM.removeChild(missingList, DOM.getChild(missingList, 0));
    }
    missing.setVisible(false);
    if (detail.getSubmitRecords() != null) {
        HashSet<String> reportedMissing = new HashSet<String>();
        HashMap<Account.Id, ApprovalDetail> byUser = new HashMap<Account.Id, ApprovalDetail>();
        for (ApprovalDetail ad : detail.getApprovals()) {
            byUser.put(ad.getAccount(), ad);
        }
        for (SubmitRecord rec : detail.getSubmitRecords()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label lbl : rec.labels) {
                if (!columns.contains(lbl.label)) {
                    columns.add(lbl.label);
                }
                switch(lbl.status) {
                    case OK:
                        {
                            ApprovalDetail ad = byUser.get(lbl.appliedBy);
                            if (ad != null) {
                                ad.approved(lbl.label);
                            }
                            break;
                        }
                    case REJECT:
                        {
                            ApprovalDetail ad = byUser.get(lbl.appliedBy);
                            if (ad != null) {
                                ad.rejected(lbl.label);
                            }
                            break;
                        }
                    case NEED:
                    case IMPOSSIBLE:
                        if (reportedMissing.add(lbl.label)) {
                            Element li = DOM.createElement("li");
                            li.setClassName(Gerrit.RESOURCES.css().missingApproval());
                            DOM.setInnerText(li, Util.M.needApproval(lbl.label));
                            DOM.appendChild(missingList, li);
                        }
                        break;
                }
            }
        }
        missing.setVisible(!reportedMissing.isEmpty());
    } else {
        for (ApprovalDetail ad : rows) {
            for (PatchSetApproval psa : ad.getPatchSetApprovals()) {
                ApprovalType legacyType = types.byId(psa.getCategoryId());
                if (legacyType == null) {
                    continue;
                }
                String labelName = legacyType.getCategory().getLabelName();
                if (psa.getValue() == legacyType.getMax().getValue()) {
                    ad.approved(labelName);
                } else if (psa.getValue() == legacyType.getMin().getValue()) {
                    ad.rejected(labelName);
                }
                if (!columns.contains(labelName)) {
                    columns.add(labelName);
                }
            }
            Collections.sort(columns, new Comparator<String>() {

                @Override
                public int compare(String o1, String o2) {
                    ApprovalType a = types.byLabel(o1);
                    ApprovalType b = types.byLabel(o2);
                    int cmp = 0;
                    if (a != null && b != null) {
                        cmp = a.getCategory().getPosition() - b.getCategory().getPosition();
                    }
                    if (cmp == 0) {
                        cmp = o1.compareTo(o2);
                    }
                    return cmp;
                }
            });
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        displayHeader(columns);
        table.resizeRows(1 + rows.size());
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i), detail.getChange(), columns);
        }
        table.setVisible(true);
    }
    addReviewer.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
private void doAddReviewer() {
    final String userNameOrEmailOrGroupName = addMemberBox.getText();
    if (userNameOrEmailOrGroupName.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(userNameOrEmailOrGroupName);
    addReviewers(reviewers, false);
}
#method_after
private void doAddReviewer() {
    final String reviewer = addMemberBox.getText();
    if (reviewer.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(reviewer);
    addReviewers(reviewers, false);
}
#end_block

#method_before
private void addReviewers(final List<String> reviewers, final boolean confirmed) {
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, confirmed, new GerritCallback<ReviewerResult>() {

        public void onSuccess(final ReviewerResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
            final ChangeDetail changeDetail = result.getChange();
            if (changeDetail != null) {
                setAccountInfoCache(changeDetail.getAccounts());
                display(changeDetail.getChange(), changeDetail.getMissingApprovals(), changeDetail.getApprovals());
            }
            if (!result.getErrors().isEmpty()) {
                final SafeHtmlBuilder r = new SafeHtmlBuilder();
                for (final ReviewerResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case ACCOUNT_OR_GROUP_NOT_FOUND:
                            r.append(Util.M.accountOrGroupNotFound(e.getName()));
                            break;
                        case ACCOUNT_INACTIVE:
                            r.append(Util.M.accountInactive(e.getName()));
                            break;
                        case CHANGE_NOT_VISIBLE:
                            r.append(Util.M.changeNotVisibleTo(e.getName()));
                            break;
                        case GROUP_EMPTY:
                            r.append(Util.M.groupIsEmpty(e.getName()));
                            break;
                        case GROUP_HAS_TOO_MANY_MEMBERS:
                            if (result.askForConfirmation() && !confirmed) {
                                StringBuilder message = new StringBuilder();
                                message.append("<b>");
                                message.append(Util.M.groupManyMembersConfirmation(e.getName(), result.getMemberCount()));
                                message.append("</b>");
                                ConfirmationDialog confirmationDialog = new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

                                    @Override
                                    public void onOk() {
                                        addReviewers(reviewers, true);
                                    }
                                });
                                confirmationDialog.center();
                                return;
                            } else {
                                r.append(Util.M.groupHasTooManyMembers(e.getName()));
                            }
                            break;
                        case GROUP_NOT_ALLOWED:
                            r.append(Util.M.groupIsNotAllowed(e.getName()));
                            break;
                        default:
                            r.append(e.getName());
                            r.append(" - ");
                            r.append(e.getType());
                            r.br();
                            break;
                    }
                }
                new ErrorDialog(r).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void addReviewers(final List<String> reviewers, final boolean confirmed) {
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, confirmed, new GerritCallback<ReviewerResult>() {

        public void onSuccess(final ReviewerResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
            final ChangeDetail changeDetail = result.getChange();
            if (changeDetail != null) {
                setAccountInfoCache(changeDetail.getAccounts());
                display(changeDetail);
            }
            if (!result.getErrors().isEmpty()) {
                final SafeHtmlBuilder r = new SafeHtmlBuilder();
                for (final ReviewerResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case REVIEWER_NOT_FOUND:
                            r.append(Util.M.reviewerNotFound(e.getName()));
                            break;
                        case ACCOUNT_INACTIVE:
                            r.append(Util.M.accountInactive(e.getName()));
                            break;
                        case CHANGE_NOT_VISIBLE:
                            r.append(Util.M.changeNotVisibleTo(e.getName()));
                            break;
                        case GROUP_EMPTY:
                            r.append(Util.M.groupIsEmpty(e.getName()));
                            break;
                        case GROUP_HAS_TOO_MANY_MEMBERS:
                            if (result.askForConfirmation() && !confirmed) {
                                askForConfirmation(e.getName(), result.getMemberCount());
                                return;
                            } else {
                                r.append(Util.M.groupHasTooManyMembers(e.getName()));
                            }
                            break;
                        case GROUP_NOT_ALLOWED:
                            r.append(Util.M.groupIsNotAllowed(e.getName()));
                            break;
                        default:
                            r.append(e.getName());
                            r.append(" - ");
                            r.append(e.getType());
                            r.br();
                            break;
                    }
                }
                new ErrorDialog(r).center();
            }
        }

        private void askForConfirmation(final String groupName, final int memberCount) {
            final StringBuilder message = new StringBuilder();
            message.append("<b>");
            message.append(Util.M.groupManyMembersConfirmation(groupName, memberCount));
            message.append("</b>");
            final ConfirmationDialog confirmationDialog = new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewers(reviewers, true);
                }
            });
            confirmationDialog.center();
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad, final Change change) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> am = ad.getApprovalMap();
    final StringBuilder hint = new StringBuilder();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (final ApprovalType type : types) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        final PatchSetApproval ca = am.get(type.getCategory().getId());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
            col++;
            continue;
        }
        final ApprovalCategoryValue acv = type.getValue(ca);
        if (acv != null) {
            if (hint.length() > 0) {
                hint.append("; ");
            }
            hint.append(acv.getName());
        }
        if (type.isMaxNegative(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (type.isMaxPositive(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    table.setText(row, col, hint.toString());
    fmt.setStyleName(row, col, Gerrit.RESOURCES.css().rightmost());
    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().approvalhint());
    col++;
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
private void doRemove(final ApprovalDetail ad, final PushButton remove) {
    remove.setEnabled(false);
    PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

        @Override
        public void onSuccess(ReviewerResult result) {
            if (result.getErrors().isEmpty()) {
                final ChangeDetail r = result.getChange();
                display(r.getChange(), r.getMissingApprovals(), r.getApprovals());
            } else {
                new ErrorDialog(result.getErrors().get(0).toString()).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            remove.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doRemove(final ApprovalDetail ad, final PushButton remove) {
    remove.setEnabled(false);
    PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

        @Override
        public void onSuccess(ReviewerResult result) {
            if (result.getErrors().isEmpty()) {
                final ChangeDetail r = result.getChange();
                display(r);
            } else {
                final ReviewerResult.Error resultError = result.getErrors().get(0);
                String message;
                switch(resultError.getType()) {
                    case REMOVE_NOT_PERMITTED:
                        message = Util.C.approvalTableRemoveNotPermitted();
                        break;
                    case COULD_NOT_REMOVE:
                    default:
                        message = Util.C.approvalTableCouldNotRemove();
                }
                new ErrorDialog(message + " " + resultError.getName()).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            remove.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.areg2 = arg2;
    engine.areg3 = arg3;
    engine.areg4 = arg4;
    engine.cont = cont;
    engine.setB0();
    Term a1 = arg1.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity author = psInfo.getAuthor();
    PatchListCache plCache = env.getInjector().getInstance(PatchListCache.class);
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey projectKey = change.getProject();
    ObjectId a = null;
    ObjectId b = ObjectId.fromString(psInfo.getRevId());
    Whitespace ws = Whitespace.IGNORE_NONE;
    PatchListKey plKey = new PatchListKey(projectKey, a, b, ws);
    // make a modifiable copy of the patches list
    List<PatchListEntry> patches = new ArrayList<PatchListEntry>();
    PatchList pl = plCache.get(plKey);
    for (PatchListEntry entry : pl.getPatches()) {
        patches.add(entry);
    }
    engine.areg1 = arg1;
    engine.areg5 = new JavaObjectTerm(patches);
    return commit_delta_4_top;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.cont = cont;
    engine.setB0();
    Term a1 = arg1.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regex = Pattern.compile(a1.name());
    engine.areg1 = new JavaObjectTerm(regex);
    engine.areg2 = arg2;
    engine.areg3 = arg3;
    engine.areg4 = arg4;
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    PatchListCache plCache = env.getInjector().getInstance(PatchListCache.class);
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey projectKey = change.getProject();
    ObjectId a = null;
    ObjectId b = ObjectId.fromString(psInfo.getRevId());
    Whitespace ws = Whitespace.IGNORE_NONE;
    PatchListKey plKey = new PatchListKey(projectKey, a, b, ws);
    PatchList pl = plCache.get(plKey);
    Iterator<PatchListEntry> iter = pl.getPatches().iterator();
    engine.areg5 = new JavaObjectTerm(iter);
    return engine.jtry5(commit_delta_check, commit_delta_next);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    a1.dereference();
    a2.dereference();
    a3.dereference();
    a4.dereference();
    a5.dereference();
    String regex = a1.toString();
    List<PatchListEntry> patches = (List<PatchListEntry>) ((JavaObjectTerm) a5).object();
    if (!patches.isEmpty()) {
        PatchListEntry patch = patches.get(0);
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if ((oldName != null && oldName.matches(regex)) || newName.matches(regex)) {
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm changeSym = SymbolTerm.intern(changeType.toString());
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(newSym, engine.trail)) {
                return engine.fail();
            }
            if (!a3.unify(changeSym, engine.trail)) {
                return engine.fail();
            }
            if (!a4.unify(oldSym, engine.trail)) {
                return engine.fail();
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    Pattern regex = (Pattern) ((JavaObjectTerm) a1).object();
    Iterator<PatchListEntry> iter = (Iterator<PatchListEntry>) ((JavaObjectTerm) a5).object();
    if (iter.hasNext()) {
        PatchListEntry patch = iter.next();
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if (regex.matcher(newName).matches() || (oldName != null && regex.matcher(oldName).matches())) {
            SymbolTerm changeSym = getTypeSymbol(changeType);
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(changeSym, engine.trail)) {
                return engine.fail();
            }
            if (!a3.unify(newSym, engine.trail)) {
                return engine.fail();
            }
            if (!a4.unify(oldSym, engine.trail)) {
                return engine.fail();
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) {
    return engine.trust(commit_delta_modify);
}
#method_after
@Override
public Operation exec(Prolog engine) {
    return engine.trust(commit_delta_empty);
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(final Transport tn) throws IOException {
    final ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = db.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!mirror) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<String, Ref>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        final ReviewDb meta;
        try {
            meta = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(db, pc, meta, true, this.tagCache).filter(local);
        } finally {
            meta.close();
        }
    }
    final List<RemoteRefUpdate> cmds = new ArrayList<RemoteRefUpdate>();
    if (mirror) {
        final Map<String, Ref> remote = listRemote(tn);
        for (final Ref src : local.values()) {
            final RefSpec spec = matchSrc(src.getName());
            if (spec != null) {
                final Ref dst = remote.get(spec.getDestination());
                if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                    // Doesn't exist yet, or isn't the same value, request to push.
                    // 
                    send(cmds, spec, src);
                }
            }
        }
        for (final Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                final RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    // 
                    delete(cmds, spec);
                }
            }
        }
    } else {
        for (final String src : delta) {
            final RefSpec spec = matchSrc(src);
            if (spec != null) {
                // If the ref still exists locally, send it, otherwise delete it.
                // 
                Ref srcRef = local.get(src);
                if (srcRef != null) {
                    send(cmds, spec, srcRef);
                } else {
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> generateUpdates(final Transport tn) throws IOException {
    final ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = db.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!mirror) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<String, Ref>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        final ReviewDb meta;
        try {
            meta = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, db, pc, meta, true).filter(local);
        } finally {
            meta.close();
        }
    }
    final List<RemoteRefUpdate> cmds = new ArrayList<RemoteRefUpdate>();
    if (mirror) {
        final Map<String, Ref> remote = listRemote(tn);
        for (final Ref src : local.values()) {
            final RefSpec spec = matchSrc(src.getName());
            if (spec != null) {
                final Ref dst = remote.get(spec.getDestination());
                if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                    // Doesn't exist yet, or isn't the same value, request to push.
                    // 
                    send(cmds, spec, src);
                }
            }
        }
        for (final Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                final RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    // 
                    delete(cmds, spec);
                }
            }
        }
    } else {
        for (final String src : delta) {
            final RefSpec spec = matchSrc(src);
            if (spec != null) {
                // If the ref still exists locally, send it, otherwise delete it.
                // 
                Ref srcRef = local.get(src);
                if (srcRef != null) {
                    send(cmds, spec, srcRef);
                } else {
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(GitTagCacheImpl.module());
    install(RegExpCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(TagCache.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
@Override
public Map<String, Ref> filter(Map<String, Ref> refs) {
    final Set<Change.Id> visibleChanges = visibleChanges();
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            // 
            deferredTags.add(ref);
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && !result.isEmpty()) {
        Map<Ref, List<Ref>> reachableTags = tagCache.get(db);
        for (Ref tag : reachableTags.keySet()) {
            for (Ref ref : reachableTags.get(tag)) {
                if (projectCtl.controlForRef(ref.getName()).isVisible()) {
                    result.put(tag.getName(), tag);
                    break;
                }
            }
        }
    }
    return result;
}
#method_after
@Override
public Map<String, Ref> filter(Map<String, Ref> refs) {
    final Set<Change.Id> visibleChanges = visibleChanges();
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // 
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && !result.isEmpty()) {
        TagMatcher tags = tagCache.get(projectName).matcher(db, result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db.get(), true, tagCache));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(tagCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, pc, db.get(), true, tagCache));
    }
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(tagCache, repo, pc, db.get(), true));
    }
    return up;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey name = change.getProject();
    if (!a1.unify(SymbolTerm.intern(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey name = change.getProject();
    if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Term topicTerm = Prolog.Nil;
    Change change = StoredValues.CHANGE.get(engine);
    String topic = change.getTopic();
    if (topic != null) {
        topicTerm = SymbolTerm.intern(topic);
    }
    if (!a1.unify(topicTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Term topicTerm = Prolog.Nil;
    Change change = StoredValues.CHANGE.get(engine);
    String topic = change.getTopic();
    if (topic != null) {
        topicTerm = SymbolTerm.create(topic);
    }
    if (!a1.unify(topicTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Branch.NameKey name = change.getDest();
    if (!a1.unify(SymbolTerm.intern(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Branch.NameKey name = change.getDest();
    if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Term a3 = arg3.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    final PatchSet.Id id = StoredValues.PATCH_SET_ID.get(engine);
    PatchSetInfoFactory psiFactory = env.getInjector().getInstance(PatchSetInfoFactory.class);
    Term idTerm;
    Term nameTerm = Prolog.Nil;
    Term emailTerm = Prolog.Nil;
    try {
        UserIdentity author = psiFactory.get(id).getAuthor();
        Account.Id authorId = author.getAccount();
        if (authorId == null) {
            idTerm = SymbolTerm.intern("anonymous");
        } else {
            idTerm = new IntegerTerm(authorId.get());
        }
        String name = author.getName();
        if (name != null && !name.equals("")) {
            nameTerm = SymbolTerm.intern(name);
        }
        String email = author.getEmail();
        if (email != null && !email.equals("")) {
            emailTerm = SymbolTerm.intern(email);
        }
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    if (!a1.unify(new StructureTerm(user, idTerm), engine.trail)) {
        return engine.fail();
    }
    if (!a2.unify(nameTerm, engine.trail)) {
        return engine.fail();
    }
    if (!a3.unify(emailTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(engine);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity author = psInfo.getAuthor();
    return exec(engine, author);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Term a3 = arg3.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    final PatchSet.Id id = StoredValues.PATCH_SET_ID.get(engine);
    PatchSetInfoFactory psiFactory = env.getInjector().getInstance(PatchSetInfoFactory.class);
    Term idTerm;
    Term nameTerm = Prolog.Nil;
    Term emailTerm = Prolog.Nil;
    try {
        UserIdentity committer = psiFactory.get(id).getCommitter();
        Account.Id committerId = committer.getAccount();
        if (committerId == null) {
            idTerm = SymbolTerm.intern("anonymous");
        } else {
            idTerm = new IntegerTerm(committerId.get());
        }
        String name = committer.getName();
        if (name != null && !name.equals("")) {
            nameTerm = SymbolTerm.intern(name);
        }
        String email = committer.getEmail();
        if (email != null && !email.equals("")) {
            emailTerm = SymbolTerm.intern(email);
        }
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    if (!a1.unify(new StructureTerm(user, idTerm), engine.trail)) {
        return engine.fail();
    }
    if (!a2.unify(nameTerm, engine.trail)) {
        return engine.fail();
    }
    if (!a3.unify(emailTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(engine);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity committer = psInfo.getCommitter();
    return exec(engine, committer);
}
#end_block

#method_before
public URLClassLoader getClassLoader(ObjectId rulesId) {
    // get rules.pl's sha1, if it exists
    String filePath = "";
    File cacheFolder = site.resolve(config.getString("cache", null, "directory"));
    if (cacheFolder != null) {
        filePath = cacheFolder.getPath();
    }
    // read jar from (site)/cache/rules
    // the included jar file should be in format:
    // rules-(rules.pl's sha1).jar
    File jarFile = null;
    if (rulesId != null) {
        jarFile = new File(filePath + "/rules/rules-" + rulesId.getName() + ".jar");
    }
    ClassLoader defaultLoader = getClass().getClassLoader();
    if (cacheFolder != null && jarFile != null && jarFile.exists()) {
        URL url;
        try {
            url = jarFile.toURI().toURL();
        } catch (MalformedURLException e) {
            return null;
        }
        URL[] urls = new URL[] { url };
        return new URLClassLoader(urls, defaultLoader);
    } else {
        return null;
    }
}
#method_after
public synchronized ClassLoader getClassLoader(ObjectId rulesId) {
    if (rulesId == null || rulesDir == null) {
        return null;
    }
    Reference<? extends ClassLoader> ref = classLoaderCache.get(rulesId);
    if (ref != null) {
        ClassLoader cl = ref.get();
        if (cl != null) {
            return cl;
        }
        classLoaderCache.remove(rulesId);
        ref.enqueue();
    }
    cleanCache();
    // read jar from (site)/cache/rules
    // the included jar file should be in format:
    // rules-(rules.pl's sha1).jar
    File jarFile = new File(rulesDir, "rules-" + rulesId.getName() + ".jar");
    if (!jarFile.isFile()) {
        return null;
    }
    ClassLoader defaultLoader = getClass().getClassLoader();
    URL url;
    try {
        url = jarFile.toURI().toURL();
    } catch (MalformedURLException e) {
        log.error("Path to rules jar is broken", e);
        return null;
    }
    ClassLoader urlLoader = new URLClassLoader(new URL[] { url }, defaultLoader);
    LoaderRef lRef = new LoaderRef(rulesId, urlLoader);
    classLoaderCache.put(rulesId, lRef);
    return urlLoader;
}
#end_block

#method_before
private ProjectState newProjectState() {
    final Map<Project.NameKey, ProjectState> all = new HashMap<Project.NameKey, ProjectState>();
    final ProjectCache projectCache = new ProjectCache() {

        @Override
        public ProjectState get(Project.NameKey projectName) {
            return all.get(projectName);
        }

        @Override
        public void evict(Project p) {
        }

        @Override
        public Iterable<Project.NameKey> all() {
            return Collections.emptySet();
        }

        @Override
        public Iterable<Project.NameKey> byName(String prefix) {
            return Collections.emptySet();
        }

        @Override
        public void onCreateProject(Project.NameKey newProjectName) {
        }
    };
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager mgr = null;
    Project.NameKey wildProject = new Project.NameKey("All-Projects");
    ProjectControl.AssistedFactory projectControlFactory = null;
    all.put(local.getProject().getNameKey(), new ProjectState(anonymousUser, projectCache, wildProject, projectControlFactory, envFactory, mgr, local, null));
    all.put(parent.getProject().getNameKey(), new ProjectState(anonymousUser, projectCache, wildProject, projectControlFactory, envFactory, mgr, parent, null));
    return all.get(local.getProject().getNameKey());
}
#method_after
private ProjectState newProjectState() {
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager mgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    all.put(local.getProject().getNameKey(), new ProjectState(projectCache, allProjectsName, projectControlFactory, envFactory, mgr, rulesCache, local));
    all.put(parent.getProject().getNameKey(), new ProjectState(projectCache, allProjectsName, projectControlFactory, envFactory, mgr, rulesCache, parent));
    return all.get(local.getProject().getNameKey());
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() throws CompileException {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    PrologEnvironment env;
    if (urlLoader != null) {
        env = envFactory.create(urlLoader);
        return env;
    } else {
        env = envFactory.create(getClass().getClassLoader());
    }
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.intern("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    if (ruleLoader != null) {
        return envFactory.create(ruleLoader);
    }
    PrologEnvironment env = envFactory.create(getClass().getClassLoader());
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.intern("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#end_block

#method_before
public Collection<AccessSection> getInheritedAccessSections() {
    if (isWildProject()) {
        return Collections.emptyList();
    }
    List<AccessSection> inherited = new ArrayList<AccessSection>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    Project.NameKey parent = getProject().getParent();
    while (parent != null && seen.add(parent)) {
        ProjectState s = projectCache.get(parent);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
            parent = s.getProject().getParent();
        } else {
            break;
        }
    }
    // Wild project is the parent, or the root of the tree
    if (parent == null) {
        ProjectState s = projectCache.get(wildProject);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
        }
    }
    return inherited;
}
#method_after
public Collection<AccessSection> getInheritedAccessSections() {
    if (isAllProjects) {
        return Collections.emptyList();
    }
    List<AccessSection> inherited = new ArrayList<AccessSection>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    Project.NameKey parent = getProject().getParent();
    while (parent != null && seen.add(parent)) {
        ProjectState s = projectCache.get(parent);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
            parent = s.getProject().getParent();
        } else {
            break;
        }
    }
    // The root of the tree is the special "All-Projects" case.
    if (parent == null) {
        inherited.addAll(projectCache.getAllProjects().getLocalAccessSections());
    }
    return inherited;
}
#end_block

#method_before
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isWildProject()) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#method_after
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isAllProjects) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#end_block

#method_before
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            parseCommandLine();
            boolean ok = true;
            for (final Change.Id changeId : changeIds) {
                try {
                    ok = ok && modifyOne(changeId);
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while modifying reviewers in " + changeId + "\n");
                    log.error("internal error while modifying reviewers in " + changeId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more modifications of reviewers failed; review output above");
            }
        }
    });
}
#method_after
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            parseCommandLine();
            boolean ok = true;
            for (Change.Id changeId : changes) {
                try {
                    ok &= modifyOne(changeId);
                } catch (Exception err) {
                    ok = false;
                    log.error("Error updating reviewers on change " + changeId, err);
                    writeError("fatal", "internal error while updating " + changeId);
                }
            }
            if (!ok) {
                throw error("fatal: one or more updates failed; review output above");
            }
        }
    });
}
#end_block

#method_before
private boolean modifyOne(final Change.Id changeId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException, Exception {
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    boolean ok = true;
    for (final Account.Id accountId : reviewersToRemove) {
        final ReviewerResult result = removeReviewerFactory.create(changeId, accountId).call();
        for (ReviewerResult.Error resultError : result.getErrors()) {
            // sensitive information that we do not want to reveal to the user.
            if (resultError.getType() == ReviewerResult.Error.Type.COULD_NOT_REMOVE) {
                // For COULD_NOT_REMOVE, getName() contains the specific error
                // message with an id at the end
                final String message = resultError.getName();
                String regex = accountId + "$";
                if (message.matches("^.* " + regex)) {
                    writeError("error: " + message.replaceAll(regex, "\"" + allReviewers.get(accountId)) + "\"\n");
                } else {
                    writeError("error: " + "\"" + allReviewers.get(accountId) + "\" could not be removed\n");
                }
                ok = false;
            }
        }
    }
    final ReviewerResult result = addReviewerFactory.create(changeId, reviewersToAdd).call();
    // user and we have checked for this when we parsed the arguments.
    for (ReviewerResult.Error resultError : result.getErrors()) {
        ok = false;
        writeError("\"" + resultError.getName() + "\" could not be added\n");
    }
    return ok;
}
#method_after
private boolean modifyOne(Change.Id changeId) throws Exception {
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    ReviewerResult result;
    boolean ok = true;
    // Remove reviewers
    // 
    result = removeReviewerFactory.create(changeId, toRemove).call();
    ok &= result.getErrors().isEmpty();
    for (ReviewerResult.Error resultError : result.getErrors()) {
        String message;
        switch(resultError.getType()) {
            case REMOVE_NOT_PERMITTED:
                message = "not permitted to remove {0} from {1}";
                break;
            case COULD_NOT_REMOVE:
                message = "could not remove {0} from {1}";
                break;
            default:
                message = "could not remove {0}: {2}";
        }
        writeError("error", MessageFormat.format(message, resultError.getName(), changeId, resultError.getType()));
    }
    // Add reviewers
    // 
    result = addReviewerFactory.create(changeId, stringSet(toAdd)).call();
    ok &= result.getErrors().isEmpty();
    for (ReviewerResult.Error resultError : result.getErrors()) {
        String message;
        switch(resultError.getType()) {
            case ACCOUNT_NOT_FOUND:
                message = "account {0} not found";
                break;
            case ACCOUNT_INACTIVE:
                message = "account {0} inactive";
                break;
            case CHANGE_NOT_VISIBLE:
                message = "change {1} not visible to {0}";
                break;
            default:
                message = "could not add {0}: {2}";
        }
        writeError("error", MessageFormat.format(message, resultError.getName(), changeId, resultError.getType()));
    }
    return ok;
}
#end_block

#method_before
private Set<Change.Id> parseChangeId(final String changeIdentity) throws UnloggedFailure, OrmException {
    final Set<Change.Id> matches = new HashSet<Change.Id>();
    boolean foundInOtherProject = false;
    boolean matchesChangeKey = changeIdentity.matches("^I[0-9a-fA-F]*$");
    boolean matchesChangeId = changeIdentity.matches("^[1-9][0-9]*$");
    // By newer style changeKey?
    // 
    boolean changeKeyParses = matchesChangeKey;
    if (matchesChangeKey) {
        Change.Key changeKey = null;
        try {
            changeKey = Change.Key.parse(changeIdentity);
        } catch (IllegalArgumentException e) {
            changeKeyParses = false;
        }
        if (changeKeyParses) {
            final ResultSet<Change> changes = db.changes().byKeyRange(changeKey, changeKey.max());
            for (final Change change : changes) {
                if (inProject(change)) {
                    matches.add(change.getId());
                } else {
                    foundInOtherProject = true;
                }
            }
        }
    }
    // By older style changeId?
    // 
    boolean changeIdParses = matchesChangeId;
    if (matchesChangeId) {
        Change.Id changeId = null;
        try {
            changeId = Change.Id.parse(changeIdentity);
        } catch (IllegalArgumentException e) {
            changeIdParses = false;
        }
        if (changeIdParses) {
            final Change change = db.changes().get(changeId);
            if (change != null) {
                if (inProject(change)) {
                    matches.add(change.getId());
                } else {
                    foundInOtherProject = true;
                }
            }
        }
    }
    if (!changeKeyParses && !changeIdParses) {
        throw error("\"" + changeIdentity + "\" is not a valid change");
    }
    switch(matches.size()) {
        case 1:
            return matches;
        case 0:
            if (foundInOtherProject) {
                throw error("change " + changeIdentity + " not in project " + projectControl.getProject().getName());
            }
            throw error("\"" + changeIdentity + "\" no such change");
        default:
    }
    throw error("\"" + changeIdentity + "\" matches multiple changes");
}
#method_after
private Set<Change.Id> parseChangeId(String idstr) throws UnloggedFailure, OrmException {
    Set<Change.Id> matched = new HashSet<Change.Id>(4);
    boolean isCommit = idstr.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$");
    // By newer style changeKey?
    // 
    boolean changeKeyParses = false;
    if (idstr.matches("^I[0-9a-fA-F]*$")) {
        Change.Key key;
        try {
            key = Change.Key.parse(idstr);
            changeKeyParses = true;
        } catch (IllegalArgumentException e) {
            key = null;
            changeKeyParses = false;
        }
        if (changeKeyParses) {
            for (Change change : db.changes().byKeyRange(key, key.max())) {
                matchChange(matched, change);
            }
        }
    }
    // 
    if (isCommit) {
        RevId id = new RevId(idstr);
        ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet ps : patches) {
            matchChange(matched, ps.getId().getParentKey());
        }
    }
    // By older style changeId?
    // 
    boolean changeIdParses = false;
    if (idstr.matches("^[1-9][0-9]*$")) {
        Change.Id id;
        try {
            id = Change.Id.parse(idstr);
            changeIdParses = true;
        } catch (IllegalArgumentException e) {
            id = null;
            changeIdParses = false;
        }
        if (changeIdParses) {
            matchChange(matched, id);
        }
    }
    if (!changeKeyParses && !isCommit && !changeIdParses) {
        throw error("\"" + idstr + "\" is not a valid change");
    }
    switch(matched.size()) {
        case 0:
            throw error("\"" + idstr + "\" no such change");
        case 1:
            return matched;
        default:
            throw error("\"" + idstr + "\" matches multiple changes");
    }
}
#end_block

#method_before
private boolean inProject(final Change change) {
    if (projectControl == null) {
        // No --project option, so they want every project.
        return true;
    }
    return projectControl.getProject().getNameKey().equals(change.getProject());
}
#method_after
private boolean inProject(Change change) {
    if (projectControl != null) {
        return projectControl.getProject().getNameKey().equals(change.getProject());
    } else {
        // No --project option, so they want every project.
        return true;
    }
}
#end_block

#method_before
private void writeError(final String msg) {
    try {
        err.write(msg.getBytes(ENC));
    } catch (IOException e) {
    }
}
#method_after
private void writeError(String type, String msg) {
    try {
        err.write((type + ": " + msg + "\n").getBytes(ENC));
    } catch (IOException e) {
    }
}
#end_block

#method_before
private static UnloggedFailure error(final String msg) {
    return new UnloggedFailure(1, msg);
}
#method_after
private static UnloggedFailure error(String msg) {
    return new UnloggedFailure(1, msg);
}
#end_block

#method_before
@Override
protected void onCellSingleClick(final int row, final int column) {
    if (column == 2) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 2) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void appendLineNumber(final SafeHtmlBuilder m, final int idx) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.openAnchor();
    m.append(idx + 1);
    m.closeAnchor();
    m.closeTd();
}
#method_after
private void appendLineNumber(final SafeHtmlBuilder m, final int idx) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(idx + 1);
    m.closeTd();
}
#end_block

#method_before
@Override
protected void onCellSingleClick(final int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.openAnchor();
    m.append(lineNumberMinusOne + 1);
    m.closeAnchor();
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(lineNumberMinusOne + 1);
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    return envFactory.create(getClass().getClassLoader());
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    PrologEnvironment env = envFactory.create(getClass().getClassLoader());
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.makeSymbol("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#end_block

#method_before
public boolean canRestore() {
    // Anyone who can abandon the change can restore it
    return canAbandon();
// back
}
#method_after
public boolean canRestore() {
    // Anyone who can abandon the change can restore it back
    return canAbandon();
}
#end_block

#method_before
public CanSubmitResult canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    CanSubmitResult result = canSubmit(patchSetId);
    if (result != CanSubmitResult.OK) {
        return result;
    }
    PrologEnvironment env = getProjectControl().getProjectState().newPrologEnvironment();
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    StructureTerm submitRule = SymbolTerm.makeSymbol("com.google.gerrit.rules.common", "default_submit", 1);
    ObjectStream ruleStream = getProjectControl().getProjectState().getPrologRules();
    if (ruleStream != null) {
        try {
            PushbackReader in = new PushbackReader(new InputStreamReader(ruleStream, Charset.forName("UTF-8")), Prolog.PUSHBACK_SIZE);
            JavaObjectTerm streamObject = new JavaObjectTerm(in);
            if (!env.execute(Prolog.BUILTIN, "consultStream", SymbolTerm.makeSymbol("submitrules"), streamObject)) {
                throw new CompileException("Cannot consult" + streamObject.toString());
            }
            // Replaces default_submit predicate with the submit_rule predicate in
            // the refs/meta/config:submit_rules.pl (if it exists)
            submitRule = SymbolTerm.makeSymbol("user", "submit_rule", 1);
        } catch (CompileException err) {
            log.error("Cannot consult provided submit_rules.pl", err);
        } finally {
            try {
                ruleStream.close();
            } catch (IOException err) {
                log.error("Close of ruleStream failed", err);
            }
        }
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("com.google.gerrit.rules.common", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        log.error("PrologException calling " + submitRule, err);
        return new CanSubmitResult("Error in submit rule");
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule has no solution: " + submitRule);
        return new CanSubmitResult("Error in submit rule (no solution possible)");
    }
    // The last result produced will be an "ok(P)" format if submit is possible.
    // This is always true because can_submit (called above) will cut away all
    // choice points once a solution is found.
    Term last = results.get(results.size() - 1);
    if (last.isStructure() && 1 == last.arity() && "ok".equals(last.name())) {
        Term solution = last.arg(0);
        return CanSubmitResult.OK;
    }
    // For now only process the first result. Later we can examine all of the
    // results and proposes different alternative paths to a submit solution.
    Term first = results.get(0);
    if (!first.isStructure() || 1 != first.arity() || !"not_ready".equals(first.name())) {
        log.error("Unexpected result from can_submit: " + first);
        return new CanSubmitResult("Error in submit rule");
    }
    Term submitRecord = first.arg(0);
    if (!submitRecord.isStructure()) {
        log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
        return new CanSubmitResult("Error in submit rule");
    }
    for (Term state : ((StructureTerm) submitRecord).args()) {
        if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
            log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
            return new CanSubmitResult("Invalid submit rule result");
        }
        String label = state.arg(0).name();
        Term status = state.arg(1);
        if ("ok".equals(status.name())) {
            continue;
        } else if ("reject".equals(status.name())) {
            return new CanSubmitResult("Submit blocked by " + label);
        } else if ("need".equals(status.name())) {
            if (status.isStructure() && status.arg(0).isInteger()) {
                IntegerTerm val = (IntegerTerm) status.arg(0);
                if (1 < val.intValue()) {
                    label += "+" + val.intValue();
                }
            }
            return new CanSubmitResult("Requires " + label);
        } else if ("impossble".equals(status.name())) {
            return new CanSubmitResult("Requires " + label + " (check permissions)");
        } else {
            return new CanSubmitResult("Invalid submit rule result");
        }
    }
    return CanSubmitResult.OK;
}
#method_after
public CanSubmitResult canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    CanSubmitResult result = canSubmit(patchSetId);
    if (result != CanSubmitResult.OK) {
        return result;
    }
    PrologEnvironment env;
    try {
        env = getProjectControl().getProjectState().newPrologEnvironment();
    } catch (CompileException err) {
        log.error("cannot consult rules.pl", err);
        return new CanSubmitResult("Error reading submit rule");
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("com.google.gerrit.rules.common", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        log.error("Error in locate_submit_rule: no submit_rule found");
        return new CanSubmitResult("Error in finding submit rule");
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("com.google.gerrit.rules.common", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        log.error("PrologException calling " + submitRule, err);
        return new CanSubmitResult("Error in submit rule");
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule has no solution: " + submitRule);
        return new CanSubmitResult("Error in submit rule (no solution possible)");
    }
    // The last result produced will be an "ok(P)" format if submit is possible.
    // This is always true because can_submit (called above) will cut away all
    // choice points once a solution is found.
    Term last = results.get(results.size() - 1);
    if (last.isStructure() && 1 == last.arity() && "ok".equals(last.name())) {
        Term solution = last.arg(0);
        return CanSubmitResult.OK;
    }
    // For now only process the first result. Later we can examine all of the
    // results and proposes different alternative paths to a submit solution.
    Term first = results.get(0);
    if (!first.isStructure() || 1 != first.arity() || !"not_ready".equals(first.name())) {
        log.error("Unexpected result from can_submit: " + first);
        return new CanSubmitResult("Error in submit rule");
    }
    Term submitRecord = first.arg(0);
    if (!submitRecord.isStructure()) {
        log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
        return new CanSubmitResult("Error in submit rule");
    }
    for (Term state : ((StructureTerm) submitRecord).args()) {
        if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
            log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
            return new CanSubmitResult("Invalid submit rule result");
        }
        String label = state.arg(0).name();
        Term status = state.arg(1);
        if ("ok".equals(status.name())) {
            continue;
        } else if ("reject".equals(status.name())) {
            return new CanSubmitResult("Submit blocked by " + label);
        } else if ("need".equals(status.name())) {
            if (status.isStructure() && status.arg(0).isInteger()) {
                IntegerTerm val = (IntegerTerm) status.arg(0);
                if (1 < val.intValue()) {
                    label += "+" + val.intValue();
                }
            }
            return new CanSubmitResult("Requires " + label);
        } else if ("impossble".equals(status.name())) {
            return new CanSubmitResult("Requires " + label + " (check permissions)");
        } else {
            return new CanSubmitResult("Invalid submit rule result");
        }
    }
    return CanSubmitResult.OK;
}
#end_block

#method_before
void create(List<CodeReviewCommit> commits, PersonIdent author) throws MergeException {
    try {
        this.commits = commits;
        this.author = author;
        setBase();
        setOurs();
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        RefUpdate refUpdate = createRefUpdate(oursCommit, baseCommit);
        for (; ; ) {
            Result result = refUpdate.update();
            if (result == Result.LOCK_FAILURE) {
                if (--remainingLockFailureCalls > 0) {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } else {
                    throw new MergeException("Couldn't create code review notes. Failed to lock the ref: " + REFS_NOTES_SUBMITTED);
                }
            } else if (result == Result.REJECTED) {
                RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
                NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
                // TODO: NoteMapMerger.merge(base, ours,
                NoteMap merged = null;
                // theirs);
                RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits", theirsCommit, oursCommit);
                refUpdate = createRefUpdate(mergeCommit, theirsCommit);
                remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
            } else if (result == Result.IO_FAILURE) {
                throw new MergeException("Couldn't create code review notes because of IO_FAILURE");
            } else {
                break;
            }
        }
    } catch (IOException e) {
        throw new MergeException("Couldn't create code review notes", e);
    } catch (InterruptedException e) {
        throw new MergeException("Couldn't create code review notes", e);
    }
}
#method_after
public void create(List<CodeReviewCommit> commits, PersonIdent author) throws CodeReviewNoteCreationException {
    try {
        this.commits = commits;
        this.author = author;
        setBase();
        setOurs();
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        RefUpdate refUpdate = createRefUpdate(oursCommit, baseCommit);
        for (; ; ) {
            Result result = refUpdate.update();
            if (result == Result.LOCK_FAILURE) {
                if (--remainingLockFailureCalls > 0) {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } else {
                    throw new CodeReviewNoteCreationException("Failed to lock the ref: " + REFS_NOTES_REVIEW);
                }
            } else if (result == Result.REJECTED) {
                RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
                NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
                NoteMapMerger merger = new NoteMapMerger(db);
                NoteMap merged = merger.merge(base, ours, theirs);
                RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
                refUpdate = createRefUpdate(mergeCommit, theirsCommit);
                remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
            } else if (result == Result.IO_FAILURE) {
                throw new CodeReviewNoteCreationException("Couldn't create code review notes because of IO_FAILURE");
            } else {
                break;
            }
        }
    } catch (IOException e) {
        throw new CodeReviewNoteCreationException(e);
    } catch (InterruptedException e) {
        throw new CodeReviewNoteCreationException(e);
    } finally {
        reader.release();
        inserter.release();
        revWalk.release();
    }
}
#end_block

#method_before
private void setBase() throws IOException {
    Ref notesBranch = db.getRef(REFS_NOTES_SUBMITTED);
    if (notesBranch != null) {
        baseCommit = revWalk.parseCommit(notesBranch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
}
#method_after
private void setBase() throws IOException {
    Ref notesBranch = db.getRef(REFS_NOTES_REVIEW);
    if (notesBranch != null) {
        baseCommit = revWalk.parseCommit(notesBranch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
}
#end_block

#method_before
private void setOurs() throws IOException {
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
    StringBuilder message = new StringBuilder("Submitted the following changes:");
    for (CodeReviewCommit c : commits) {
        if (ours.contains(c)) {
            throw new IllegalStateException("Review summary note already exists for commit: " + c + ". Merging of notes not yet supported");
        }
        ObjectId id = inserter.insert(Constants.OBJ_BLOB, createNoteContent(c));
        inserter.flush();
        RevBlob blob = revWalk.lookupBlob(id);
        ours.set(c, blob);
        message.append(" ");
        message.append(c.change.getId());
    }
    if (baseCommit != null) {
        oursCommit = createCommit(ours, author, message.toString(), baseCommit);
    } else {
        oursCommit = createCommit(ours, author, message.toString());
    }
}
#method_after
private void setOurs() throws IOException, CodeReviewNoteCreationException {
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
    StringBuilder message = new StringBuilder("Update notes for submitted changes\n\n");
    for (CodeReviewCommit c : commits) {
        ObjectId noteContent = createNoteContent(c);
        if (ours.contains(c)) {
            // merge the existing and the new note as if they are both new
            // means: base == null
            // there is not really a common ancestry for these two note revisions
            // use the same NoteMerger that is used from the NoteMapMerger
            DefaultNoteMerger noteMerger = new DefaultNoteMerger();
            Note newNote = new Note(c, noteContent);
            noteContent = noteMerger.merge(null, newNote, base.getNote(c), reader, inserter).getData();
        }
        ours.set(c, noteContent);
        message.append("* ").append(c.getShortMessage()).append("\n");
    }
    if (baseCommit != null) {
        oursCommit = createCommit(ours, author, message.toString(), baseCommit);
    } else {
        oursCommit = createCommit(ours, author, message.toString());
    }
}
#end_block

#method_before
private byte[] createNoteContent(CodeReviewCommit commit) throws UnsupportedEncodingException {
    try {
        ReviewNoteHeaderFormatter formatter = new ReviewNoteHeaderFormatter();
        formatter.appendChangeId(commit.change.getId());
        ResultSet<PatchSetApproval> approvals = schema.patchSetApprovals().byPatchSet(commit.patchsetId);
        PatchSetApproval submit = null;
        for (PatchSetApproval a : approvals) {
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                submit = a;
            } else {
                formatter.appendApproval(schema.approvalCategories().get(a.getCategoryId()), a.getValue(), schema.accounts().get(a.getAccountId()));
            }
        }
        formatter.appendBranch(schema.projects().get(commit.change.getProject()), commit.change.getDest());
        formatter.appendSubmittedBy(schema.accounts().get(submit.getAccountId()));
        formatter.appendSubmittedOn(submit.getGranted());
        return formatter.toString().getBytes("UTF-8");
    } catch (OrmException e) {
        throw new RuntimeException(e);
    }
}
#method_after
private ObjectId createNoteContent(CodeReviewCommit commit) throws CodeReviewNoteCreationException, IOException {
    try {
        ReviewNoteHeaderFormatter formatter = new ReviewNoteHeaderFormatter(author.getTimeZone());
        final List<String> idList = commit.getFooterLines(CHANGE_ID);
        if (idList.isEmpty())
            formatter.appendChangeId(commit.change.getKey());
        ResultSet<PatchSetApproval> approvals = schema.patchSetApprovals().byPatchSet(commit.patchsetId);
        PatchSetApproval submit = null;
        for (PatchSetApproval a : approvals) {
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                submit = a;
            } else {
                formatter.appendApproval(approvalTypes.getApprovalType(a.getCategoryId()).getCategory(), a.getValue(), accountCache.get(a.getAccountId()).getAccount());
            }
        }
        formatter.appendSubmittedBy(accountCache.get(submit.getAccountId()).getAccount());
        formatter.appendSubmittedAt(submit.getGranted());
        formatter.appendReviewedOn(canonicalWebUrl, commit.change.getId());
        formatter.appendProject(commit.change.getProject().get());
        formatter.appendBranch(commit.change.getDest());
        return inserter.insert(Constants.OBJ_BLOB, formatter.toString().getBytes("UTF-8"));
    } catch (OrmException e) {
        throw new CodeReviewNoteCreationException(commit, e);
    }
}
#end_block

#method_before
private RevCommit createCommit(NoteMap map, PersonIdent author, String message, RevCommit... parents) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    ObjectInserter inserter = db.newObjectInserter();
    CommitBuilder b = new CommitBuilder();
    b.setTreeId(map.writeTree(inserter));
    b.setAuthor(author);
    b.setCommitter(gerritIdent);
    if (parents.length > 0) {
        b.setParentIds(parents);
    }
    b.setMessage(message);
    return revWalk.parseCommit(inserter.insert(b));
}
#method_after
private RevCommit createCommit(NoteMap map, PersonIdent author, String message, RevCommit... parents) throws IOException {
    CommitBuilder b = new CommitBuilder();
    b.setTreeId(map.writeTree(inserter));
    b.setAuthor(author);
    b.setCommitter(gerritIdent);
    if (parents.length > 0) {
        b.setParentIds(parents);
    }
    b.setMessage(message);
    ObjectId commitId = inserter.insert(b);
    inserter.flush();
    return revWalk.parseCommit(commitId);
}
#end_block

#method_before
private RefUpdate createRefUpdate(ObjectId newObjectId, ObjectId expectedOldObjectId) throws IOException {
    RefUpdate refUpdate = db.updateRef(REFS_NOTES_SUBMITTED);
    refUpdate.setNewObjectId(newObjectId);
    if (expectedOldObjectId == null) {
        refUpdate.setExpectedOldObjectId(ObjectId.zeroId());
    } else {
        refUpdate.setExpectedOldObjectId(expectedOldObjectId);
    }
    return refUpdate;
}
#method_after
private RefUpdate createRefUpdate(ObjectId newObjectId, ObjectId expectedOldObjectId) throws IOException {
    RefUpdate refUpdate = db.updateRef(REFS_NOTES_REVIEW);
    refUpdate.setNewObjectId(newObjectId);
    if (expectedOldObjectId == null) {
        refUpdate.setExpectedOldObjectId(ObjectId.zeroId());
    } else {
        refUpdate.setExpectedOldObjectId(expectedOldObjectId);
    }
    return refUpdate;
}
#end_block

#method_before
private void openRepository() throws MergeException {
    final String name = destBranch.getParentKey().get();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#method_after
private void openRepository() throws MergeException {
    final Project.NameKey name = destBranch.getParentKey();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name.get() + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#end_block

#method_before
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = new CreateCodeReviewNotes(schema, db, myIdent);
    codeReviewNotes.create(merged, computeAuthor(merged));
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), CreateCodeReviewNotes.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false, false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#method_after
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
public void appendChangeId(Change.Id changeId) {
    sb.append("Change-Id: ").append(changeId).append("\n");
}
#method_after
void appendChangeId(Change.Key changeKey) {
    sb.append("Change-Id: ").append(changeKey.get()).append("\n");
}
#end_block

#method_before
public void appendApproval(ApprovalCategory category, short value, Account user) {
    sb.append(category.getName());
    sb.append(value < 0 ? "-" : "+").append(value).append(": ");
    appendUserData(user);
    sb.append("\n");
}
#method_after
void appendApproval(ApprovalCategory category, short value, Account user) {
    // TODO: use category.getLabel() when available
    sb.append(category.getName().replace(' ', '-'));
    sb.append(value < 0 ? "-" : "+").append(Math.abs(value)).append(": ");
    appendUserData(user);
    sb.append("\n");
}
#end_block

#method_before
private void appendUserData(Account user) {
    sb.append(user.getFullName()).append(" <").append(user.getPreferredEmail()).append(">");
}
#method_after
private void appendUserData(Account user) {
    boolean needSpace = false;
    boolean wroteData = false;
    if (user.getFullName() != null && !user.getFullName().isEmpty()) {
        sb.append(user.getFullName());
        needSpace = true;
        wroteData = true;
    }
    if (user.getPreferredEmail() != null && !user.getPreferredEmail().isEmpty()) {
        if (needSpace) {
            sb.append(" ");
        }
        sb.append("<").append(user.getPreferredEmail()).append(">");
        wroteData = true;
    }
    if (!wroteData) {
        sb.append("Anonymous Coward #").append(user.getId());
    }
}
#end_block

#method_before
public void appendBranch(Project project, Branch.NameKey branch) {
    sb.append("Branch: ").append(project.getName()).append(" ").append(branch.get()).append("\n");
}
#method_after
void appendBranch(Branch.NameKey branch) {
    sb.append("Branch: ").append(branch.get()).append("\n");
}
#end_block

#method_before
public void appendSubmittedBy(Account user) {
    sb.append("Submitted-by: ");
    appendUserData(user);
    sb.append("\n");
}
#method_after
void appendSubmittedBy(Account user) {
    sb.append("Submitted-by: ");
    appendUserData(user);
    sb.append("\n");
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            members.setEnabled(result.canModify);
            saveType.setVisible(result.canModify);
            display(result);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initGroupNotifications();
    Label spacer = new Label("");
    spacer.setHeight("15px");
    add(spacer);
    initMemberList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initExternal();
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    onlyAuthors.setValue(group.isEmailOnlyAuthors());
    onlyAuthors.setEnabled(true);
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
    visibleToAllCheckBox.setEnabled(true);
    emailOnlyAuthors.setValue(group.isEmailOnlyAuthors());
    emailOnlyAuthors.setEnabled(true);
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            members.setEnabled(result.canModify);
            saveType.setVisible(result.canModify);
            display(result);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initMemberList();
    initIncludedGroupList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initIncludeList();
    initExternal();
}
#end_block

#method_before
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includedGroupPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#method_after
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includePanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includedGroups.display(result.includedGroups);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includes.display(result.includes);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
public IdentifiedUser create(Provider<ReviewDb> db, Account.Id id) {
    return new IdentifiedUser(AccessPath.UNKNOWN, authConfig, canonicalUrl, realm, accountCache, null, db, id);
}
#method_after
public IdentifiedUser create(Provider<ReviewDb> db, Account.Id id) {
    return new IdentifiedUser(AccessPath.UNKNOWN, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, null, db, id);
}
#end_block

#method_before
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, null, id);
}
#method_after
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, remotePeerProvider, null, id);
}
#end_block

#method_before
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, dbProvider, id);
}
#method_after
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, remotePeerProvider, dbProvider, id);
}
#end_block

#method_before
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        Set<AccountGroup.Id> seedGroups = new HashSet<AccountGroup.Id>();
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            seedGroups = realm.groups(state());
        } else {
            seedGroups = authConfig.getRegisteredGroups();
        }
        effectiveGroups = getIncludedGroups(seedGroups);
    }
    return effectiveGroups;
}
#method_after
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        Set<AccountGroup.Id> seedGroups;
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            seedGroups = realm.groups(state());
        } else {
            seedGroups = authConfig.getRegisteredGroups();
        }
        effectiveGroups = getIncludedGroups(seedGroups);
    }
    return effectiveGroups;
}
#end_block

#method_before
private Set<AccountGroup.Id> getIncludedGroups(Set<AccountGroup.Id> seedGroups) {
    Set<AccountGroup.Id> includedGroups = new HashSet<AccountGroup.Id>(seedGroups);
    Queue<AccountGroup.Id> groupQueue = new LinkedList<AccountGroup.Id>(seedGroups);
    while (groupQueue.size() > 0) {
        AccountGroup.Id id = groupQueue.remove();
        try {
            for (final AccountGroupIncludedGroup i : dbProvider.get().accountGroupIncludedGroups().byIncludedGroup(id)) {
                AccountGroup.Id groupId = i.getGroupId();
                if (!includedGroups.contains(groupId)) {
                    includedGroups.add(groupId);
                    groupQueue.add(groupId);
                }
            }
        } catch (OrmException e) {
            log.warn("Cannot query included groups", e);
        }
    }
    return includedGroups;
}
#method_after
private Set<AccountGroup.Id> getIncludedGroups(Set<AccountGroup.Id> seedGroups) {
    Set<AccountGroup.Id> includes = new HashSet<AccountGroup.Id>(seedGroups);
    Queue<AccountGroup.Id> groupQueue = new LinkedList<AccountGroup.Id>(seedGroups);
    while (groupQueue.size() > 0) {
        AccountGroup.Id id = groupQueue.remove();
        for (final AccountGroup.Id groupId : groupIncludeCache.getByInclude(id)) {
            if (includes.add(groupId)) {
                groupQueue.add(groupId);
            }
        }
    }
    return Collections.unmodifiableSet(includes);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public boolean isVisible() {
    return isOwner();
}
#method_after
public boolean isVisible() {
    return group.isVisibleToAll() || isOwner();
}
#end_block

#method_before
public boolean canSeeMember(Account.Id id) {
    return isOwner();
}
#method_after
public boolean canSeeMember(Account.Id id) {
    return isVisible();
}
#end_block

#method_before
private void createGroup() throws OrmException, UnloggedFailure {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    try {
        performCreateGroup.createGroup(groupName, groupDescription, ownerGroupId, initialMembers.toArray(new Account.Id[initialMembers.size()]), initialIncludedGroups.toArray(new AccountGroup.Id[initialIncludedGroups.size()]));
    } catch (NameAlreadyUsedException e) {
        throw die(e);
    }
}
#method_after
private void createGroup() throws OrmException, UnloggedFailure {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    try {
        performCreateGroup.createGroup(groupName, groupDescription, visibleToAll, ownerGroupId, initialMembers, initialGroups);
    } catch (NameAlreadyUsedException e) {
        throw die(e);
    }
}
#end_block

#method_before
@Override
public AccountGroup.Id call() throws OrmException, NameAlreadyUsedException {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    final Account.Id me = user.getAccountId();
    return performCreateGroup.createGroup(groupName, null, null, new Account.Id[] { me }, null);
}
#method_after
@Override
public AccountGroup.Id call() throws OrmException, NameAlreadyUsedException {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    final Account.Id me = user.getAccountId();
    return performCreateGroup.createGroup(groupName, null, false, null, Collections.singleton(me), null);
}
#end_block

#method_before
private AccountGroup findGroup(final String name) throws OrmException, Failure {
    final AccountGroup g = groupCache.get(new AccountGroup.NameKey(name));
    if (g == null) {
        throw new Failure(new NoSuchEntityException());
    }
    return g;
}
#method_after
private AccountGroup findGroup(final String name) throws OrmException, Failure {
    final AccountGroup g = groupCache.get(new AccountGroup.NameKey(name));
    if (g == null) {
        throw new Failure(new NoSuchGroupException(name));
    }
    return g;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = control.getAccountGroup();
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId()));
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludedGroups(loadIncludedGroups());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setGroups(gic.create());
    return detail;
}
#method_after
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = control.getAccountGroup();
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId()));
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludes(loadIncludes());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setCanModify(control.isOwner());
    detail.setGroups(gic.create());
    return detail;
}
#end_block

#method_before
public AccountGroup.Id createGroup(final String groupName, final String groupDescription, final AccountGroup.Id ownerGroupId, final Account.Id[] initialMembers, final AccountGroup.Id[] initialIncludedGroups) throws OrmException, NameAlreadyUsedException {
    final AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    final AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    final AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    final AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new NameAlreadyUsedException();
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers(groupId, initialMembers);
    if (initialIncludedGroups != null) {
        addIncludedGroups(groupId, initialIncludedGroups);
    }
    return groupId;
}
#method_after
public AccountGroup.Id createGroup(final String groupName, final String groupDescription, final boolean visibleToAll, final AccountGroup.Id ownerGroupId, final Collection<? extends Account.Id> initialMembers, final Collection<? extends AccountGroup.Id> initialGroups) throws OrmException, NameAlreadyUsedException {
    final AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    final AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    final AccountGroup group = new AccountGroup(nameKey, groupId);
    group.setVisibleToAll(visibleToAll);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    final AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new NameAlreadyUsedException();
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers(groupId, initialMembers);
    if (initialGroups != null) {
        addGroups(groupId, initialGroups);
    }
    return groupId;
}
#end_block

#method_before
private void addMembers(final AccountGroup.Id groupId, final Account.Id[] members) throws OrmException {
    final List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    final List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : members) {
        final AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        final AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
    for (Account.Id accountId : members) {
        accountCache.evict(accountId);
    }
}
#method_after
private void addMembers(final AccountGroup.Id groupId, final Collection<? extends Account.Id> members) throws OrmException {
    final List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    final List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : members) {
        final AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        final AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
    for (Account.Id accountId : members) {
        accountCache.evict(accountId);
    }
}
#end_block

#method_before
private void displayApprovals(final int row, final ApprovalSummary summary, final AccountInfoCache aic, final boolean highlightUnreviewed) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> approvals = summary.getApprovalMap();
    int col = BASE_COLUMNS;
    boolean haveReview = false;
    for (final ApprovalType type : approvalTypes) {
        final PatchSetApproval ca = approvals.get(type.getCategory().getId());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
        } else {
            haveReview = true;
            final ApprovalCategoryValue acv = type.getValue(ca);
            final AccountInfo ai = aic.get(ca.getAccountId());
            if (type.isMaxNegative(ca)) {
                table.setHTML(row, col, new Image(Gerrit.RESOURCES.redNot()).getElement().getString() + FormatUtil.name(ai));
            } else if (type.isMaxPositive(ca)) {
                table.setHTML(row, col, new Image(Gerrit.RESOURCES.greenCheck()).getElement().getString() + FormatUtil.name(ai));
            } else {
                String vstr = String.valueOf(ca.getValue()) + " " + FormatUtil.name(ai);
                if (ca.getValue() > 0) {
                    vstr = "+" + vstr;
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
                } else {
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                }
                table.setText(row, col, vstr);
            }
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            // 
            fmt.getElement(row, col).setTitle(acv.getName() + " \nby " + FormatUtil.nameEmail(ai));
        }
        col++;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), !haveReview && highlightUnreviewed);
}
#method_after
private void displayApprovals(final int row, final ApprovalSummary summary, final AccountInfoCache aic, final boolean highlightUnreviewed) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> approvals = summary.getApprovalMap();
    int col = BASE_COLUMNS;
    boolean haveReview = false;
    boolean displayPersonNameInReviewCategory = false;
    if (Gerrit.isSignedIn()) {
        AccountGeneralPreferences prefs = Gerrit.getUserAccount().getGeneralPreferences();
        if (prefs.isDisplayPersonNameInReviewCategory()) {
            displayPersonNameInReviewCategory = true;
        }
    }
    for (final ApprovalType type : approvalTypes) {
        final PatchSetApproval ca = approvals.get(type.getCategory().getId());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
        } else {
            haveReview = true;
            final ApprovalCategoryValue acv = type.getValue(ca);
            final AccountInfo ai = aic.get(ca.getAccountId());
            if (type.isMaxNegative(ca)) {
                if (displayPersonNameInReviewCategory) {
                    FlowPanel fp = new FlowPanel();
                    fp.add(new Image(Gerrit.RESOURCES.redNot()));
                    fp.add(new InlineLabel(FormatUtil.name(ai)));
                    table.setWidget(row, col, fp);
                } else {
                    table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
                }
            } else if (type.isMaxPositive(ca)) {
                if (displayPersonNameInReviewCategory) {
                    FlowPanel fp = new FlowPanel();
                    fp.add(new Image(Gerrit.RESOURCES.greenCheck()));
                    fp.add(new InlineLabel(FormatUtil.name(ai)));
                    table.setWidget(row, col, fp);
                } else {
                    table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
                }
            } else {
                String vstr = String.valueOf(ca.getValue());
                if (displayPersonNameInReviewCategory) {
                    vstr = vstr + " " + FormatUtil.name(ai);
                }
                if (ca.getValue() > 0) {
                    vstr = "+" + vstr;
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
                } else {
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                }
                table.setText(row, col, vstr);
            }
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            // 
            fmt.getElement(row, col).setTitle(acv.getName() + " \nby " + FormatUtil.nameEmail(ai));
        }
        col++;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), !haveReview && highlightUnreviewed);
}
#end_block

#method_before
HashSet<RefRight.Key> getRefRightIdsChecked() {
    final HashSet<RefRight.Key> refRightIds = new HashSet<RefRight.Key>();
    for (int row = 1; row < table.getRowCount(); row++) {
        RefRight r = getRowItem(row);
        if (r != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            refRightIds.add(r.getKey());
        }
    }
    return refRightIds;
}
#method_after
HashSet<RefRight.Key> getRefRightIdsChecked() {
    final HashSet<RefRight.Key> refRightIds = new HashSet<RefRight.Key>();
    for (int row = 1; row < table.getRowCount(); row++) {
        RefRight r = getRowItem(row).getRight();
        if (r != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            refRightIds.add(r.getKey());
        }
    }
    return refRightIds;
}
#end_block

#method_before
protected void onOpenRow(final int row) {
    if (row > 0) {
        RefRight right = getRowItem(row);
        rightEditor.load(right, groups.get(right.getAccountGroupId()));
    }
}
#method_after
protected void onOpenRow(final int row) {
    if (row > 0) {
        RefRight right = getRowItem(row).getRight();
        rightEditor.load(right, groups.get(right.getAccountGroupId()));
    }
}
#end_block

#method_before
void populate(final int row, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited() || !r.isOwner()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    }
    if (r.isInherited()) {
        Project.NameKey fromProject = right.getKey().getProjectNameKey();
        table.setWidget(row, 2, new Hyperlink(fromProject.get(), Dispatcher.toProjectAdmin(fromProject, ACCESS)));
    } else {
        table.setText(row, 2, "");
    }
    table.setText(row, 3, ar != null ? ar.getCategory().getName() : right.getApprovalCategoryId().get());
    if (group != null) {
        table.setWidget(row, 4, new Hyperlink(group.getName(), Dispatcher.toAccountGroup(group.getId())));
    } else {
        table.setText(row, 4, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 5, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        if (ar != null && ar.getCategory().isRange()) {
            formatValue(m, right.getMinValue(), min);
            m.br();
        }
        formatValue(m, right.getMaxValue(), max);
        SafeHtml.set(table, row, 6, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 6, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 6, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#method_after
void populate(final int row, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited() || !r.isOwner()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    }
    if (r.isInherited()) {
        Project.NameKey fromProject = right.getKey().getProjectNameKey();
        table.setWidget(row, 2, new Hyperlink(fromProject.get(), Dispatcher.toProjectAdmin(fromProject, ACCESS)));
    } else {
        table.setText(row, 2, "");
    }
    table.setText(row, 3, ar != null ? ar.getCategory().getName() : right.getApprovalCategoryId().get());
    if (group != null) {
        table.setWidget(row, 4, new Hyperlink(group.getName(), Dispatcher.toAccountGroup(group.getId())));
    } else {
        table.setText(row, 4, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 5, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        if (ar != null && ar.getCategory().isRange()) {
            formatValue(m, right.getMinValue(), min);
            m.br();
        }
        formatValue(m, right.getMaxValue(), max);
        SafeHtml.set(table, row, 6, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 6, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 6, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, r);
}
#end_block

#method_before
public void showInherited(boolean visible) {
    for (int r = 0; r < table.getRowCount(); r++) {
        if (table.getWidget(r, 2) instanceof Hyperlink) {
            table.getRowFormatter().setVisible(r, visible);
        }
    }
}
#method_after
public void showInherited(boolean visible) {
    for (int r = 0; r < table.getRowCount(); r++) {
        if (getRowItem(r) != null && getRowItem(r).isInherited()) {
            table.getRowFormatter().setVisible(r, visible);
        }
    }
}
#end_block

#method_before
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            initOptionList();
            parseCommandLine();
            boolean ok = true;
            for (final PatchSet.Id patchSetId : patchSetIds) {
                try {
                    approveOne(patchSetId);
                } catch (UnloggedFailure e) {
                    ok = false;
                    writeError("error: " + e.getMessage() + "\n");
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while approving " + patchSetId + "\n");
                    log.error("internal error while approving " + patchSetId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
            }
        }
    });
}
#method_after
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            initOptionList();
            parseCommandLine();
            if (abandonChange) {
                if (restoreChange) {
                    throw error("abandon and restore actions are mutually exclusive");
                }
                if (submitChange) {
                    throw error("abandon and submit actions are mutually exclusive");
                }
            }
            boolean ok = true;
            for (final PatchSet.Id patchSetId : patchSetIds) {
                try {
                    approveOne(patchSetId);
                } catch (UnloggedFailure e) {
                    ok = false;
                    writeError("error: " + e.getMessage() + "\n");
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while approving " + patchSetId + "\n");
                    log.error("internal error while approving " + patchSetId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
            }
            if (!toSubmit.isEmpty()) {
                final Set<Branch.NameKey> toMerge = new HashSet<Branch.NameKey>();
                try {
                    for (PatchSet.Id patchSetId : toSubmit) {
                        ChangeUtil.submit(opFactory, patchSetId, currentUser, db, new MergeQueue() {

                            @Override
                            public void merge(MergeOp.Factory mof, Branch.NameKey branch) {
                                toMerge.add(branch);
                            }

                            @Override
                            public void schedule(Branch.NameKey branch) {
                                toMerge.add(branch);
                            }

                            @Override
                            public void recheckAfter(Branch.NameKey branch, long delay, TimeUnit delayUnit) {
                                toMerge.add(branch);
                            }
                        });
                    }
                    for (Branch.NameKey branch : toMerge) {
                        merger.merge(opFactory, branch);
                    }
                } catch (OrmException updateError) {
                    throw new Failure(1, "one or more submits failed", updateError);
                }
            }
        }
    });
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    publishCommentsFactory.create(patchSetId, changeComment, aps).call();
    if (submitChange) {
        CanSubmitResult result = changeControl.canSubmit(patchSetId, db, approvalTypes, functionStateFactory);
        if (result == CanSubmitResult.OK) {
            ChangeUtil.submit(opFactory, patchSetId, currentUser, db, merger);
        } else {
            throw error(result.getMessage());
        }
    }
    if (abandonChange) {
        if (changeControl.canAbandon()) {
            ChangeUtil.abandon(patchSetId, changeId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("User does not have the privileges to abandon this change");
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    publishCommentsFactory.create(patchSetId, changeComment, aps).call();
    if (abandonChange) {
        if (changeControl.canAbandon()) {
            ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("Not permitted to abandon change");
        }
    }
    if (restoreChange) {
        if (changeControl.canRestore()) {
            ChangeUtil.restore(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("Not permitted to restore change");
        }
        if (submitChange) {
            changeControl = changeControlFactory.validateFor(changeId);
        }
    }
    if (submitChange) {
        CanSubmitResult result = changeControl.canSubmit(patchSetId, db, approvalTypes, functionStateFactory);
        if (result == CanSubmitResult.OK) {
            toSubmit.add(patchSetId);
        } else {
            throw error(result.getMessage());
        }
    }
}
#end_block

#method_before
public static void abandon(final PatchSet.Id patchSetId, final Change.Id changeId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, EmailException, OrmException {
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, user.getAccount(), message);
}
#method_after
public static void abandon(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, EmailException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, user.getAccount(), message);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.abandon(patchSetId, changeId, currentUser, message, db, abandonedSenderFactory, hooks);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.abandon(patchSetId, currentUser, message, db, abandonedSenderFactory, hooks);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    {
        nameBox = new NpTextBox();
        nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
        nameBox.setVisibleLength(50);
        nameBox.setText(Util.C.defaultProjectName());
        nameBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
        nameBox.addFocusHandler(new FocusHandler() {

            @Override
            public void onFocus(FocusEvent event) {
                if (Util.C.defaultProjectName().equals(nameBox.getText())) {
                    nameBox.setText("");
                    nameBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        nameBox.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(BlurEvent event) {
                if ("".equals(nameBox.getText())) {
                    nameBox.setText(Util.C.defaultProjectName());
                    nameBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        nameBox.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                submitOnSelection = false;
                if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                    if (nameTxt.isSuggestionListShowing()) {
                        submitOnSelection = true;
                    } else {
                        doAddNew();
                    }
                }
            }
        });
        nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

            @Override
            public void onSelection(SelectionEvent<Suggestion> event) {
                if (submitOnSelection) {
                    submitOnSelection = false;
                    doAddNew();
                }
            }
        });
        filterTxt = new NpTextBox();
        filterTxt.setVisibleLength(50);
        filterTxt.setText(Util.C.defaultFilter());
        filterTxt.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
        filterTxt.addFocusHandler(new FocusHandler() {

            @Override
            public void onFocus(FocusEvent event) {
                if (Util.C.defaultFilter().equals(filterTxt.getText())) {
                    filterTxt.setText("");
                    filterTxt.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        filterTxt.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(BlurEvent event) {
                if ("".equals(filterTxt.getText())) {
                    filterTxt.setText(Util.C.defaultFilter());
                    filterTxt.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        filterTxt.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                    doAddNew();
                }
            }
        });
        projects = new ProjectTable();
        addNew = new Button(Util.C.buttonWatchProject());
        addNew.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                doAddNew();
            }
        });
        final Grid grid = new Grid(2, 2);
        grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
        grid.setText(0, 0, Util.C.watchedProjectName());
        grid.setWidget(0, 1, nameTxt);
        grid.setText(1, 0, Util.C.watchedProjectFilter());
        grid.setWidget(1, 1, filterTxt);
        final CellFormatter fmt = grid.getCellFormatter();
        fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
        fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
        fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
        fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
        fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
        DisclosurePanel unwatched = new DisclosurePanel(Util.C.unwatchedProjects());
        unwatched.setContent(projects);
        final Grid grid2 = new Grid(1, 2);
        final FlowPanel fp2 = new FlowPanel();
        fp2.add(addNew);
        grid2.setWidget(0, 0, fp2);
        grid2.setWidget(0, 1, unwatched);
        final CellFormatter fmt2 = grid2.getCellFormatter();
        fmt2.setAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT, HasVerticalAlignment.ALIGN_TOP);
        final FlowPanel fp = new FlowPanel();
        fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
        fp.add(grid);
        fp.add(grid2);
        add(fp);
    }
    watches = new WatchTable();
    add(watches);
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watches.deleteChecked();
        }
    });
    add(delSel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            if (preferredPopupWidth == -1) {
                preferredPopupWidth = offsetWidth;
            }
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            if (top + offsetHeight > Window.getClientHeight()) {
                top = Window.getClientHeight() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.ACCOUNT_SVC.myProjectWatch(new ScreenLoadCallback<List<AccountProjectWatchInfo>>(this) {

        public void preDisplay(final List<AccountProjectWatchInfo> result) {
            watchedProjects = result;
            watches.display(result);
            displayUnwatchedProjects();
        }
    });
    Util.PROJECT_SVC.visibleProjects(new ScreenLoadCallback<List<Project>>(this) {

        @Override
        protected void preDisplay(final List<Project> result) {
            allProjects = new ArrayList(result);
            // unneeded fake "--all projects--" entry
            allProjects.remove(0);
            displayUnwatchedProjects();
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    populateWatches();
}
#end_block

#method_before
void doAddNew() {
    final String projectName = nameTxt.getText();
    if (projectName == null || projectName.length() == 0 || Util.C.defaultProjectName().equals(projectName)) {
        return;
    }
    String filter = filterTxt.getText();
    if (filter == null || filter.isEmpty() || filter.equals(Util.C.defaultFilter())) {
        filter = null;
    }
    addNew.setEnabled(false);
    nameBox.setEnabled(false);
    filterTxt.setEnabled(false);
    Util.ACCOUNT_SVC.addProjectWatch(projectName, filter, new GerritCallback<AccountProjectWatchInfo>() {

        public void onSuccess(final AccountProjectWatchInfo result) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            nameTxt.setText("");
            watches.insertWatch(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
protected void doAddNew() {
    final String projectName = nameTxt.getText();
    if ("".equals(projectName)) {
        return;
    }
    String filter = filterTxt.getText();
    if (filter == null || filter.isEmpty() || filter.equals(Util.C.defaultFilter())) {
        filter = null;
    }
    addNew.setEnabled(false);
    nameBox.setEnabled(false);
    filterTxt.setEnabled(false);
    Util.ACCOUNT_SVC.addProjectWatch(projectName, filter, new GerritCallback<AccountProjectWatchInfo>() {

        public void onSuccess(final AccountProjectWatchInfo result) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            nameTxt.setText("");
            watchesTab.insertWatch(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private Connector[] listen(final Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    reverseProxy = true;
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final SelectChannelConnector c;
        if ("http".equals(u.getScheme())) {
            reverseProxy = false;
            defaultPort = 80;
            c = new SelectChannelConnector();
            String authType = cfg.getString("auth", null, "type");
            if (AuthType.CLIENT_SSL_CERT_LDAP.name().equals(authType)) {
                throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
            }
        } else if ("https".equals(u.getScheme())) {
            final SslSelectChannelConnector ssl = new SslSelectChannelConnector();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeystore(keystore.getAbsolutePath());
            ssl.setTruststore(keystore.getAbsolutePath());
            ssl.setKeyPassword(password);
            ssl.setTrustPassword(password);
            String authType = cfg.getString("auth", null, "type");
            if (AuthType.CLIENT_SSL_CERT_LDAP.name().equals(authType)) {
                ssl.setNeedClientAuth(true);
            }
            reverseProxy = false;
            defaultPort = 443;
            c = ssl;
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            c = new SelectChannelConnector();
            c.setForwarded(true);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            c = new SelectChannelConnector() {

                @Override
                public void customize(EndPoint endpoint, Request request) throws IOException {
                    request.setScheme("https");
                    super.customize(endpoint, request);
                }
            };
            c.setForwarded(true);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setRequestHeaderSize(requestHeaderSize);
        c.setAcceptors(acceptors);
        c.setReuseAddress(reuseAddress);
        c.setStatsOn(false);
        connectors[idx] = c;
    }
    return connectors;
}
#method_after
private Connector[] listen(final Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = ConfigUtil.getEnum(cfg, "auth", null, "type", AuthType.OPENID);
    reverseProxy = true;
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final SelectChannelConnector c;
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            reverseProxy = false;
            defaultPort = 80;
            c = new SelectChannelConnector();
        } else if ("https".equals(u.getScheme())) {
            final SslSelectChannelConnector ssl = new SslSelectChannelConnector();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeystore(keystore.getAbsolutePath());
            ssl.setTruststore(keystore.getAbsolutePath());
            ssl.setKeyPassword(password);
            ssl.setTrustPassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
            }
            reverseProxy = false;
            defaultPort = 443;
            c = ssl;
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            c = new SelectChannelConnector();
            c.setForwarded(true);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            c = new SelectChannelConnector() {

                @Override
                public void customize(EndPoint endpoint, Request request) throws IOException {
                    request.setScheme("https");
                    super.customize(endpoint, request);
                }
            };
            c.setForwarded(true);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setRequestHeaderSize(requestHeaderSize);
        c.setAcceptors(acceptors);
        c.setReuseAddress(reuseAddress);
        c.setStatsOn(false);
        connectors[idx] = c;
    }
    return connectors;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest req, ServletResponse rsp, FilterChain chain) throws IOException, ServletException {
    X509Certificate[] certs = (X509Certificate[]) req.getAttribute("javax.servlet.request.X509Certificate");
    String name = certs[0].getSubjectDN().getName();
    Matcher m = REGEX_USERID.matcher(name);
    String userName = null;
    if (m.matches()) {
        userName = m.group(1);
    } else {
        throw new ServletException("Couldn't extract username from your certificate");
    }
    final AuthRequest areq = AuthRequest.forUser(userName);
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        String err = "Unable to authenticate user \"" + userName + "\"";
        log.error(err, e);
        throw new ServletException(err, e);
    }
    webSession.get().login(arsp, true);
    chain.doFilter(req, rsp);
}
#method_after
@Override
public void doFilter(ServletRequest req, ServletResponse rsp, FilterChain chain) throws IOException, ServletException {
    X509Certificate[] certs = (X509Certificate[]) req.getAttribute("javax.servlet.request.X509Certificate");
    if (certs == null || certs.length == 0) {
        throw new ServletException("Couldn't get the attribute javax.servlet.request.X509Certificate from the request");
    }
    String name = certs[0].getSubjectDN().getName();
    Matcher m = REGEX_USERID.matcher(name);
    String userName;
    if (m.matches()) {
        userName = m.group(1);
    } else {
        throw new ServletException("Couldn't extract username from your certificate");
    }
    final AuthRequest areq = AuthRequest.forUser(userName);
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        String err = "Unable to authenticate user \"" + userName + "\"";
        log.error(err, e);
        throw new ServletException(err, e);
    }
    webSession.get().login(arsp, true);
    chain.doFilter(req, rsp);
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(info.getKey(), detail.getPatches());
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#end_block

#method_before
private void displayDownload() {
    final Branch.NameKey branchKey = changeDetail.getChange().getDest();
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous()) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.HTTP, "HTTP", r.toString()));
    }
    if (Gerrit.getConfig().isUseRepoDownload()) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Branch.NameKey branchKey = changeDetail.getChange().getDest();
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && allowedSchemes.contains(DownloadScheme.ANON_GIT)) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new RestoreChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                SideBySide link = new PatchLink.SideBySide(p.getFileName(), p.getKey(), 0, null);
                Window.open(link.getElement().toString(), p.getFileName(), null);
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Unified link = new PatchLink.Unified(p.getFileName(), p.getKey(), 0, null);
                Window.open(link.getElement().toString(), p.getFileName(), null);
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchSideBySide(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchUnified(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new DashboardKeyCommand(0, 'u', Util.C.upToDashboard()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("98%");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new UpToListKeyCommand(0, 'u', Util.C.upToChangeList()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("98%");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) {
    return new LabelPredicate(args.changeControlGenericFactory, args.userFactory, args.dbProvider, args.approvalTypes, name);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) {
    return new LabelPredicate(args.changeControlGenericFactory, args.userFactory, args.dbProvider, args.approvalTypes, args.projectCache, name);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    install(new PredicateModule());
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    install(new ChangeQueryModule());
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    ChangeDataSource source = source();
    if (source == null) {
        throw new OrmException("No ChangeDataSource: " + this);
    }
    // TODO(spearce) This probably should be more lazy.
    // 
    ArrayList<ChangeData> r = new ArrayList<ChangeData>();
    ChangeData last = null;
    boolean skipped = false;
    for (ChangeData cd : prefetchData(source)) {
        if (match(cd)) {
            r.add(cd);
        } else {
            skipped = true;
        }
        last = cd;
    }
    if (skipped && last != null && source instanceof Paginated) {
        // If our source is a paginated source and we skipped at
        // least one of its results, we may not have filled the full
        // limit the caller wants.  Restart the source and continue.
        // 
        Paginated p = (Paginated) source;
        while (skipped && r.size() < p.limit()) {
            ChangeData lastBeforeRestart = last;
            skipped = false;
            last = null;
            for (ChangeData cd : p.restart(lastBeforeRestart)) {
                if (match(cd)) {
                    r.add(cd);
                } else {
                    skipped = true;
                }
                last = cd;
            }
        }
    }
    return new ListResultSet<ChangeData>(r);
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    ChangeDataSource source = source();
    if (source == null) {
        throw new OrmException("No ChangeDataSource: " + this);
    }
    // TODO(spearce) This probably should be more lazy.
    // 
    ArrayList<ChangeData> r = new ArrayList<ChangeData>();
    ChangeData last = null;
    boolean skipped = false;
    for (ChangeData cd : prefetchData(source.read())) {
        if (match(cd)) {
            r.add(cd);
        } else {
            skipped = true;
        }
        last = cd;
    }
    if (skipped && last != null && source instanceof Paginated) {
        // If our source is a paginated source and we skipped at
        // least one of its results, we may not have filled the full
        // limit the caller wants.  Restart the source and continue.
        // 
        Paginated p = (Paginated) source;
        while (skipped && r.size() < p.limit()) {
            ChangeData lastBeforeRestart = last;
            skipped = false;
            last = null;
            for (ChangeData cd : prefetchData(p.restart(lastBeforeRestart))) {
                if (match(cd)) {
                    r.add(cd);
                } else {
                    skipped = true;
                }
                last = cd;
            }
        }
    }
    return new ListResultSet<ChangeData>(r);
}
#end_block

#method_before
private Collection<ChangeData> prefetchData(ChangeDataSource source) throws OrmException {
    final ReviewDb db = dbProvider.get();
    final ArrayList<ChangeData> data = new ArrayList<ChangeData>();
    final EnumSet<NeededData> needed = getNeededData();
    for (ChangeData cd : source.read()) {
        data.add(cd);
    }
    for (ChangeData cd : data) {
        if (needed.contains(NeededData.APPROVALS)) {
            cd.setApprovals(db.patchSetApprovals().byChange(cd.getId()).toList());
        }
        if (needed.contains(NeededData.CHANGE)) {
            cd.setChange(db.changes().get(cd.getId()));
        }
        if (needed.contains(NeededData.PATCHES)) {
            cd.setPatches(db.patchSets().byChange(cd.getId()).toList());
        }
        if (needed.contains(NeededData.COMMENTS)) {
            cd.setComments(db.patchComments().byChange(cd.getId()).toList());
        }
        if (needed.contains(NeededData.TRACKING_IDS)) {
            cd.setTrackingIds(db.trackingIds().byChange(cd.getId()).toList());
        }
    }
    if (needed.contains(NeededData.PROJECT_STATE)) {
        ArrayList<Project.NameKey> projectNames = new ArrayList<Project.NameKey>();
        for (ChangeData cd : data) {
            projectNames.add(cd.getChange().getProject());
        }
        Map<Project.NameKey, ProjectState> projectMap = projectCache.getAll(projectNames);
        for (ChangeData cd : data) {
            cd.setProjectState(projectMap.get(cd.getChange().getProject()));
        }
    }
    db.close();
    return data;
}
#method_after
private Collection<ChangeData> prefetchData(ResultSet<ChangeData> resultSet) throws OrmException {
    final List<ChangeData> data = resultSet.toList();
    final EnumSet<NeededData> needed = getNeededData();
    if (needed.contains(NeededData.PROJECT_STATE)) {
        needed.add(NeededData.CHANGE);
    }
    if (needed.contains(NeededData.CHANGE)) {
        HashMap<Change.Id, ChangeData> need = new HashMap<Change.Id, ChangeData>();
        for (ChangeData cd : data) {
            if (!cd.hasChange()) {
                need.put(cd.getId(), cd);
            }
        }
        if (!need.isEmpty()) {
            for (Change c : dbProvider.get().changes().get(need.keySet())) {
                need.get(c.getId()).setChange(c);
            }
        }
    }
    if (needed.contains(NeededData.PROJECT_STATE)) {
        HashSet<Project.NameKey> projectNames = new HashSet<Project.NameKey>();
        for (ChangeData cd : data) {
            projectNames.add(cd.getChange().getProject());
        }
        Map<Project.NameKey, ProjectState> projectMap = projectCache.getAll(projectNames);
        for (ChangeData cd : data) {
            cd.setProjectState(projectMap.get(cd.getChange().getProject()));
        }
    }
    return data;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData cd) throws OrmException {
    if (rules == null) {
        ChangeQueryBuilder builder = new ChangeQueryBuilder(args, user);
        rules = new HashMap<Project.NameKey, List<Predicate<ChangeData>>>();
        for (AccountProjectWatch w : user.getNotificationFilters()) {
            List<Predicate<ChangeData>> list = rules.get(w.getProjectNameKey());
            if (list == null) {
                list = new ArrayList<Predicate<ChangeData>>(4);
                rules.put(w.getProjectNameKey(), list);
            }
            Predicate<ChangeData> p = compile(builder, w);
            if (p != null) {
                list.add(p);
            }
        }
    }
    if (rules.isEmpty()) {
        return false;
    }
    Change change = cd.change(args.dbProvider);
    if (change == null) {
        return false;
    }
    Project.NameKey project = change.getDest().getParentKey();
    List<Predicate<ChangeData>> list = rules.get(project);
    if (list == null) {
        list = rules.get(args.wildProjectName);
    }
    if (list != null) {
        for (Predicate<ChangeData> p : list) {
            if (p.match(cd)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
@Override
public boolean match(final ChangeData cd) throws OrmException {
    Map<Project.NameKey, List<Predicate<ChangeData>>> rules = getRules();
    if (rules.isEmpty()) {
        return false;
    }
    Change change = cd.change(args.dbProvider);
    if (change == null) {
        return false;
    }
    Project.NameKey project = change.getDest().getParentKey();
    List<Predicate<ChangeData>> list = rules.get(project);
    if (list == null) {
        list = rules.get(args.wildProjectName);
    }
    if (list != null) {
        for (Predicate<ChangeData> p : list) {
            if (p.match(cd)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public EnumSet<NeededData> getNeededData() {
    return EnumSet.of(NeededData.CHANGE);
}
#method_after
@Override
public EnumSet<NeededData> getNeededData() {
    Map<NameKey, List<Predicate<ChangeData>>> rules = getRules();
    if (rules.isEmpty()) {
        return EnumSet.noneOf(NeededData.class);
    }
    EnumSet<NeededData> needed = EnumSet.of(NeededData.CHANGE);
    for (List<Predicate<ChangeData>> list : rules.values()) {
        for (Predicate<ChangeData> p : list) {
            if (p instanceof Prefetchable) {
                needed.addAll(((Prefetchable) p).getNeededData());
            }
        }
    }
    return needed;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    for (PatchSetApproval p : object.currentApprovals(dbProvider)) {
        if (p.getCategoryId().equals(category)) {
            short psVal = p.getValue();
            if (test.match(psVal, expVal)) {
                // 
                try {
                    ChangeControl cc = // 
                    ccFactory.controlFor(// 
                    object.change(dbProvider), userFactory.create(dbProvider, p.getAccountId()));
                    if (!cc.isVisible()) {
                        // 
                        continue;
                    }
                    psVal = cc.normalize(category, psVal);
                } catch (NoSuchChangeException e) {
                    // 
                    continue;
                }
                if (test.match(psVal, expVal)) {
                    return true;
                }
            }
        }
    }
    return false;
}
#method_after
@Override
public boolean match(final ChangeData object) throws OrmException {
    for (PatchSetApproval p : object.currentApprovals(dbProvider)) {
        if (p.getCategoryId().equals(category)) {
            short psVal = p.getValue();
            if (test.match(psVal, expVal)) {
                // Double check the value is still permitted for the user.
                // 
                Change c = object.change(dbProvider);
                IdentifiedUser user = userFactory.create(dbProvider, p.getAccountId());
                ChangeControl cc = object.projectState(dbProvider, projectCache).controlFor(user).controlFor(c);
                if (!cc.isVisible()) {
                    // 
                    continue;
                }
                psVal = cc.normalize(category, psVal);
                if (test.match(psVal, expVal)) {
                    return true;
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public EnumSet<NeededData> getNeededData() {
    return EnumSet.of(NeededData.APPROVALS, NeededData.CHANGE);
}
#method_after
@Override
public EnumSet<NeededData> getNeededData() {
    return EnumSet.of(NeededData.APPROVALS, NeededData.CHANGE, NeededData.PROJECT_STATE);
}
#end_block

#method_before
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, null, id, starredChangesCache);
}
#method_after
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, starredChangesCache, remotePeerProvider, null, id);
}
#end_block

#method_before
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, dbProvider, id, starredChangesCache);
}
#method_after
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, starredChangesCache, remotePeerProvider, dbProvider, id);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final TypeLiteral<Cache<StarredChange.Key, StarredChange>> byKeyType = new TypeLiteral<Cache<StarredChange.Key, StarredChange>>() {
            };
            core(byKeyType, BY_KEY).populateWith(ByKeyLoader.class);
            final TypeLiteral<Cache<Account.Id, StarredChangeList>> byAccountIdType = new TypeLiteral<Cache<Account.Id, StarredChangeList>>() {
            };
            core(byAccountIdType, BY_ACCOUNT_ID).populateWith(ByAccountIdLoader.class);
            final TypeLiteral<Cache<Change.Id, StarredChangeList>> byChangeIdType = new TypeLiteral<Cache<Change.Id, StarredChangeList>>() {
            };
            core(byChangeIdType, BY_CHANGE_ID).populateWith(ByChangeIdLoader.class);
            bind(StarredChangesCacheImpl.class);
            bind(StarredChangesCache.class).to(StarredChangesCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final TypeLiteral<Cache<Account.Id, StarredChangeList>> byAccountIdType = new TypeLiteral<Cache<Account.Id, StarredChangeList>>() {
            };
            core(byAccountIdType, BY_ACCOUNT_ID).populateWith(ByAccountIdLoader.class);
            final TypeLiteral<Cache<Change.Id, StarredChangeList>> byChangeIdType = new TypeLiteral<Cache<Change.Id, StarredChangeList>>() {
            };
            core(byChangeIdType, BY_CHANGE_ID).populateWith(ByChangeIdLoader.class);
            bind(StarredChangesCacheImpl.class);
            bind(StarredChangesCache.class).to(StarredChangesCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public void evict(StarredChange.Key key) {
    byKey.remove(key);
    byAccountId.remove(key.getParentKey());
    byChangeId.remove(key.getChangeId());
}
#method_after
@Override
public void evict(StarredChange.Key key) {
    byAccountId.remove(key.getParentKey());
    byChangeId.remove(key.getChangeId());
}
#end_block

#method_before
public void toggleStars(final ToggleStarRequest req, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException {
            final Account.Id me = getAccountId();
            final Set<Change.Id> existing = currentUser.get().getStarredChanges();
            List<StarredChange> add = new ArrayList<StarredChange>();
            List<StarredChange.Key> remove = new ArrayList<StarredChange.Key>();
            if (req.getAddSet() != null) {
                for (final Change.Id id : req.getAddSet()) {
                    if (!existing.contains(id)) {
                        StarredChange.Key key = new StarredChange.Key(me, id);
                        add.add(new StarredChange(key));
                        starredChangesCache.evict(key);
                    }
                }
            }
            if (req.getRemoveSet() != null) {
                for (final Change.Id id : req.getRemoveSet()) {
                    StarredChange.Key key = new StarredChange.Key(me, id);
                    remove.add(key);
                    starredChangesCache.evict(key);
                }
            }
            db.starredChanges().insert(add);
            db.starredChanges().deleteKeys(remove);
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void toggleStars(final ToggleStarRequest req, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException {
            final Account.Id me = getAccountId();
            final Set<Change.Id> existing = currentUser.get().getStarredChanges();
            List<StarredChange> add = new ArrayList<StarredChange>();
            List<StarredChange.Key> remove = new ArrayList<StarredChange.Key>();
            if (req.getAddSet() != null) {
                for (final Change.Id id : req.getAddSet()) {
                    if (!existing.contains(id)) {
                        add.add(new StarredChange(new StarredChange.Key(me, id)));
                    }
                }
            }
            if (req.getRemoveSet() != null) {
                for (final Change.Id id : req.getRemoveSet()) {
                    remove.add(new StarredChange.Key(me, id));
                }
            }
            db.starredChanges().insert(add);
            db.starredChanges().deleteKeys(remove);
            for (StarredChange sc : add) {
                starredChangesCache.evict(sc.getKey());
            }
            for (StarredChange.Key key : remove) {
                starredChangesCache.evict(key);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
private void start() {
    synchronized (lock) {
        if (manager != null) {
            throw new IllegalStateException("Cache pool has already been started");
        }
        try {
            System.setProperty("net.sf.ehcache.skipUpdateCheck", "" + true);
        } catch (SecurityException e) {
        // Ignore it, the system is just going to ping some external page
        // using a background thread and there's not much we can do about
        // it now.
        }
        manager = new CacheManager(new Factory().toConfiguration());
        for (CacheProvider<?, ?> p : caches.values()) {
            Ehcache eh = manager.getEhcache(p.getName());
            EntryCreator<?, ?> c = p.getEntryCreator();
            if (c != null) {
                if (p.disk()) {
                    p.bind(new PopulatingProtobufCache(eh, c, p.getKeyClass(), p.getValueClass(), p.getValueProvider()));
                } else {
                    p.bind(new PopulatingCache(eh, c));
                }
            } else {
                if (p.disk()) {
                    p.bind(new SimpleProtobufCache(eh, p.getKeyClass(), p.getValueClass(), p.getValueProvider()));
                } else {
                    p.bind(new SimpleCache(eh));
                }
            }
        }
    }
}
#method_after
private void start() {
    synchronized (lock) {
        if (manager != null) {
            throw new IllegalStateException("Cache pool has already been started");
        }
        try {
            System.setProperty("net.sf.ehcache.skipUpdateCheck", "" + true);
        } catch (SecurityException e) {
        // Ignore it, the system is just going to ping some external page
        // using a background thread and there's not much we can do about
        // it now.
        }
        manager = new CacheManager(new Factory().toConfiguration());
        for (CacheProvider<?, ?> p : caches.values()) {
            Ehcache eh = manager.getEhcache(p.getName());
            EntryCreator<?, ?> c = p.getEntryCreator();
            if (c != null && p.disk()) {
                c = new ProtobufEntryCreator(c, p.getKeyClass(), p.getValueClass());
            }
            Cache m;
            if (c != null) {
                m = new PopulatingCache(eh, c);
            } else {
                m = new SimpleCache(eh);
            }
            if (p.disk()) {
                m = new ProtobufCache(m, p.getKeyClass(), p.getValueClass(), p.getValueProvider());
            }
            p.bind(m);
        }
    }
}
#end_block

#method_before
public T toObject(ProtobufCodec<T> codec, Provider<T> provider) {
    if (object == null) {
        this.codec = codec;
        if (provider == null) {
            object = codec.decode(buf);
        } else {
            object = provider.get();
            try {
                codec.mergeFrom(CodedInputStream.newInstance(buf), object);
            } catch (IOException e) {
                throw new RuntimeException("Cannot decode message", e);
            }
        }
        // Free the memory being taken up by the buffer.
        buf = null;
    }
    return object;
}
#method_after
T toObject(ProtobufCodec<T> codec, Provider<T> provider) {
    if (codec == null) {
        return null;
    }
    Object d = data;
    if (d instanceof byte[]) {
        this.codec = codec;
        if (provider == null) {
            d = codec.decode((byte[]) d);
        } else {
            T tmp = provider.get();
            codec.mergeFrom((byte[]) d, tmp);
            d = tmp;
        }
        data = d;
    }
    return (T) d;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SerializableProtobuf<?>)) {
        return false;
    }
    SerializableProtobuf<?> other = ((SerializableProtobuf<?>) obj);
    if (hash != other.hash) {
        return false;
    }
    if (object != null && other.object != null) {
        return object.equals(other.object);
    }
    return Arrays.equals(buf, other.buf);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SerializableProtobuf<?>)) {
        return false;
    }
    SerializableProtobuf<T> other = ((SerializableProtobuf<T>) obj);
    if (hash != other.hash) {
        return false;
    }
    // Make sure we either both have codecs, or we both do not
    if (this.codec == null && other.codec != null) {
        this.codec = other.codec;
    } else if (this.codec != null && other.codec == null) {
        other.codec = this.codec;
    }
    // Equals is only ever called on keys, which cannot have providers
    T thisObject = this.toObject(codec, null);
    T otherObject = other.toObject(other.codec, null);
    if (thisObject == null && otherObject == null) {
        // Neither of us had codecs, so we must compare byte arrays
        return Arrays.equals((byte[]) this.data, (byte[]) other.data);
    } else if (thisObject != null && otherObject != null) {
        return thisObject.equals(otherObject);
    } else {
        return false;
    }
}
#end_block

#method_before
private void writeObject(ObjectOutputStream oos) throws IOException {
    if (buf == null) {
        // If buffer is null, toObject must have been called, which means that we
        // have the object and the codec.
        buf = new byte[codec.sizeof(object)];
        codec.encode(object, buf);
    }
    oos.defaultWriteObject();
}
#method_after
private void writeObject(ObjectOutputStream oos) throws IOException {
    oos.writeInt(hash);
    Object d = data;
    if (d instanceof byte[]) {
        byte[] buf = (byte[]) d;
        oos.writeInt(buf.length);
        oos.write(buf);
    } else {
        // We assume that if we have an object, we must have a codec
        T obj = (T) d;
        oos.writeInt(codec.sizeof(obj));
        CodedOutputStream cos = CodedOutputStream.newInstance(oos);
        codec.encode(obj, cos);
        cos.flush();
    }
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else if (!Pattern.compile("refs/.*").matcher(refPattern.replace("*", ".*")).matches()) {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    boolean exclusive = refPattern.startsWith("-");
    if (exclusive) {
        refPattern = refPattern.substring(1);
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (refPattern.startsWith(RefRight.REGEX_PREFIX)) {
        String example = RefControl.shortestExample(refPattern);
        if (!example.startsWith(Constants.R_REFS)) {
            refPattern = RefRight.REGEX_PREFIX + Constants.R_HEADS + refPattern.substring(RefRight.REGEX_PREFIX.length());
            example = RefControl.shortestExample(refPattern);
        }
        if (!Repository.isValidRefName(example)) {
            throw new InvalidNameException();
        }
    } else {
        if (!refPattern.startsWith(Constants.R_REFS)) {
            refPattern = Constants.R_HEADS + refPattern;
        }
        if (refPattern.endsWith("/*")) {
            final String prefix = refPattern.substring(0, refPattern.length() - 2);
            if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
                throw new InvalidNameException();
            }
        } else {
            if (!Repository.isValidRefName(refPattern)) {
                throw new InvalidNameException();
            }
        }
    }
    if (exclusive) {
        refPattern = "-" + refPattern;
    }
    if (!projectControl.controlForRef(refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public boolean isOwner() {
    if (canPerform(OWN, (short) 1)) {
        return true;
    }
    // 
    if (!RefRight.ALL.equals(getRefName()) && getProjectControl().isOwner()) {
        return true;
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (canPerform(OWN, (short) 1)) {
        return true;
    }
    // 
    if (getRefName().equals(RefRight.ALL.substring(0, RefRight.ALL.length() - 1)) && getProjectControl().isOwner()) {
        return true;
    }
    return false;
}
#end_block

#method_before
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    for (RefRight right : filterMostSpecific(allRights)) {
        if (groups.contains(right.getAccountGroupId())) {
            val = Math.max(right.getMaxValue(), val);
        }
    }
    return val >= level;
}
#method_after
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (RefRightsForPattern right : perPatternRights.values()) {
        val = Math.max(val, right.allowedValueForRef(groups));
        if (val >= level || right.containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#end_block

#method_before
public static boolean matches(String refName, String refPattern) {
    return Pattern.matches(refPattern.replace("*", "(.*)"), refName);
}
#method_after
public static boolean matches(String refName, String refPattern) {
    if (refPattern.startsWith(RefRight.REGEX_PREFIX)) {
        return Pattern.matches(refPattern, refName);
    }
    if (refPattern.endsWith("/*")) {
        String prefix = refPattern.substring(0, refPattern.length() - 1);
        return refName.startsWith(prefix);
    } else {
        return refName.equals(refPattern);
    }
}
#end_block

#method_before
private void createGroup() throws OrmException {
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    db.accountGroups().insert(Collections.singleton(group));
    AccountGroupName groupName = new AccountGroupName(group);
    db.accountGroupNames().insert(Collections.singleton(groupName));
    List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (String userName : initialMembers) {
        AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, userName);
        Account.Id accountId = db.accountExternalIds().get(key).getAccountId();
        AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
}
#method_after
private void createGroup() throws OrmException, UnloggedFailure {
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw die("group '" + groupName + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : initialMembers) {
        AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
}
#end_block

#method_before
public void addProjectWatch(final String projectName, final String fileMatch, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            final AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, fileMatch));
            db.accountProjectWatches().insert(Collections.singleton(watch));
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#method_after
public void addProjectWatch(final String projectName, final String filter, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException, InvalidQueryException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            if (filter != null) {
                try {
                    ChangeQueryBuilder builder = queryBuilder.create(currentUser.get());
                    builder.setAllowFile(true);
                    builder.parse(filter);
                } catch (QueryParseException badFilter) {
                    throw new InvalidQueryException(badFilter.getMessage(), filter);
                }
            }
            AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, filter));
            try {
                db.accountProjectWatches().insert(Collections.singleton(watch));
            } catch (OrmDuplicateKeyException alreadyHave) {
                watch = db.accountProjectWatches().get(watch.getKey());
            }
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#end_block

#method_before
public void send() throws EmailException {
    if (!emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            // If we are impersonating a user, make sure they receive a CC of
            // this message so they can always review and audit what we sent
            // on their behalf to others.
            // 
            add(RecipientType.CC, fromId);
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
        }
        if (headers.get("Message-ID").isEmpty()) {
            final StringBuilder rndid = new StringBuilder();
            rndid.append("<");
            rndid.append(System.currentTimeMillis());
            rndid.append("-");
            rndid.append(Integer.toString(RNG.nextInt(999999), 36));
            rndid.append("@");
            rndid.append(SystemReader.getInstance().getHostname());
            rndid.append(">");
            setHeader("Message-ID", rndid.toString());
        }
        emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#method_after
public void send() throws EmailException {
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            if (fromUser.getGeneralPreferences().isCopySelfOnEmails()) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                final String fromEmail = fromUser.getPreferredEmail();
                for (Iterator<Address> i = smtpRcptTo.iterator(); i.hasNext(); ) {
                    if (i.next().email.equals(fromEmail)) {
                        i.remove();
                    }
                }
                for (EmailHeader hdr : headers.values()) {
                    if (hdr instanceof AddressList) {
                        ((AddressList) hdr).remove(fromEmail);
                    }
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
            appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
            try {
                HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
                for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
                    reviewers.add(p.getAccountId());
                }
                TreeSet<String> names = new TreeSet<String>();
                for (Account.Id who : reviewers) {
                    names.add(getNameEmailFor(who));
                }
                for (String name : names) {
                    appendText("Gerrit-Reviewer: " + name + "\n");
                }
            } catch (OrmException e) {
            }
        }
        if (headers.get("Message-ID").isEmpty()) {
            final StringBuilder rndid = new StringBuilder();
            rndid.append("<");
            rndid.append(System.currentTimeMillis());
            rndid.append("-");
            rndid.append(Integer.toString(RNG.nextInt(999999), 36));
            rndid.append("@");
            rndid.append(SystemReader.getInstance().getHostname());
            rndid.append(">");
            setHeader("Message-ID", rndid.toString());
        }
        args.emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#end_block

#method_before
protected void init() {
    if (change != null && projectCache != null) {
        projectState = projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    smtpFromAddress = fromAddressGenerator.from(fromId);
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.email.equals(a.email)) {
            setHeader("Reply-To", a.email);
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (fromId != null && fromAddressGenerator.isGenericAddress(fromId)) {
        final Account account = accountCache.get(fromId).getAccount();
        final String name = account.getFullName();
        final String email = account.getPreferredEmail();
        if ((name != null && !name.isEmpty()) || (email != null && !email.isEmpty())) {
            body.append("From");
            if (name != null && !name.isEmpty()) {
                body.append(" ").append(name);
            }
            if (email != null && !email.isEmpty()) {
                body.append(" <").append(email).append(">");
            }
            body.append(":\n\n");
        }
    }
    if (change != null && db != null) {
        if (patchSet == null) {
            try {
                patchSet = db.patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = patchSetInfoFactory.get(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#method_after
protected void init() {
    if (change != null && args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.email.equals(a.email)) {
            setHeader("Reply-To", a.email);
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        final Account account = args.accountCache.get(fromId).getAccount();
        final String name = account.getFullName();
        final String email = account.getPreferredEmail();
        if ((name != null && !name.isEmpty()) || (email != null && !email.isEmpty())) {
            body.append("From");
            if (name != null && !name.isEmpty()) {
                body.append(" ").append(name);
            }
            if (email != null && !email.isEmpty()) {
                body.append(" <").append(email).append(">");
            }
            body.append(":\n\n");
        }
    }
    if (change != null) {
        if (patchSet == null) {
            try {
                patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#end_block

#method_before
protected String getGerritUrl() {
    return urlProvider.get();
}
#method_after
protected String getGerritUrl() {
    return args.urlProvider.get();
}
#end_block

#method_before
protected PatchList getPatchList() {
    if (patchSet != null) {
        return patchListCache.get(change, patchSet);
    }
    return null;
}
#method_after
protected PatchList getPatchList() {
    if (patchSet != null) {
        return args.patchListCache.get(change, patchSet);
    }
    return null;
}
#end_block

#method_before
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return "Anonymous Coward";
    }
    final Account userAccount = accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = "Anonymous Coward #" + accountId;
    }
    return name;
}
#method_after
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return "Anonymous Coward";
    }
    final Account userAccount = args.accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = "Anonymous Coward #" + accountId;
    }
    return name;
}
#end_block

#method_before
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // 
        return false;
    }
    if (rcptTo.isEmpty()) {
        // 
        return false;
    }
    if (rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#method_after
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // 
        return false;
    }
    if (smtpRcptTo.isEmpty()) {
        // 
        return false;
    }
    if (rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#end_block

#method_before
protected Set<AccountGroup.Id> getProjectOwners() {
    final ProjectState r;
    r = projectCache.get(change.getProject());
    return r != null ? r.getOwners() : Collections.<AccountGroup.Id>emptySet();
}
#method_after
protected Set<AccountGroup.Id> getProjectOwners() {
    final ProjectState r;
    r = args.projectCache.get(change.getProject());
    return r != null ? r.getOwners() : Collections.<AccountGroup.Id>emptySet();
}
#end_block

#method_before
protected void bccStarredBy() {
    if (db != null) {
        try {
            // 
            for (StarredChange w : db.starredChanges().byChange(change.getId())) {
                add(RecipientType.BCC, w.getAccountId());
            }
        } catch (OrmException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        }
    }
}
#method_after
protected void bccStarredBy() {
    try {
        // 
        for (StarredChange w : args.db.get().starredChanges().byChange(change.getId())) {
            add(RecipientType.BCC, w.getAccountId());
        }
    } catch (OrmException err) {
    // Just don't BCC everyone. Better to send a partial message to those
    // we already have queued up then to fail deliver entirely to people
    // who have a lower interest in the change.
    }
}
#end_block

#method_before
protected void bccWatchesNotifyAllComments(List<String> specificFileName) {
    if (db != null) {
        if (specificFileName == null) {
            final List<Patch> patches = getPatches(patchSet.getId());
            specificFileName = getPatchesFileNames(patches);
        }
        try {
            // BCC anyone else who has interest in this project's changes
            // 
            final ProjectState ps = getProjectState();
            if (ps != null) {
                for (final AccountProjectWatch w : db.accountProjectWatches().notifyAllComments(ps.getProject().getNameKey())) {
                    if (canAddRecipient(w, specificFileName)) {
                        add(RecipientType.BCC, w.getAccountId());
                    }
                }
            }
        } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        }
    }
}
#method_after
protected void bccWatchesNotifyAllComments() {
    try {
        // 
        for (final AccountProjectWatch w : getWatches()) {
            if (w.isNotifyAllComments()) {
                add(RecipientType.BCC, w.getAccountId());
            }
        }
    } catch (OrmException err) {
    // Just don't CC everyone. Better to send a partial message to those
    // we already have queued up then to fail deliver entirely to people
    // who have a lower interest in the change.
    }
}
#end_block

#method_before
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void add(List<AccountProjectWatch> matching, AccountProjectWatch w) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(args.db, w.getAccountId());
    ChangeQueryBuilder qb = args.queryBuilder.create(user);
    Predicate<ChangeData> p = qb.is_visible();
    if (w.getFilter() != null) {
        try {
            qb.setAllowFile(true);
            p = Predicate.and(qb.parse(w.getFilter()), p);
            p = args.queryRewriter.get().rewrite(p);
            if (p.match(changeData)) {
                matching.add(w);
            }
        } catch (QueryParseException e) {
        // Ignore broken filter expressions.
        }
    } else if (p.match(changeData)) {
        matching.add(w);
    }
}
#end_block

#method_before
private void ccApprovals(final boolean includeZero) {
    if (db != null) {
        try {
            // 
            for (PatchSetApproval ap : db.patchSetApprovals().byChange(change.getId())) {
                if (!includeZero && ap.getValue() == 0) {
                    continue;
                }
                add(RecipientType.CC, ap.getAccountId());
            }
        } catch (OrmException err) {
        }
    }
}
#method_after
private void ccApprovals(final boolean includeZero) {
    try {
        // 
        for (PatchSetApproval ap : args.db.get().patchSetApprovals().byChange(change.getId())) {
            if (!includeZero && ap.getValue() == 0) {
                continue;
            }
            add(RecipientType.CC, ap.getAccountId());
        }
    } catch (OrmException err) {
    }
}
#end_block

#method_before
private boolean isVisibleTo(final Account.Id to) {
    return projectState == null || change == null || projectState.controlFor(identifiedUserFactory.create(to)).controlFor(change).isVisible();
}
#method_after
private boolean isVisibleTo(final Account.Id to) {
    return projectState == null || change == null || projectState.controlFor(args.identifiedUserFactory.create(to)).controlFor(change).isVisible();
}
#end_block

#method_before
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#method_after
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        if (args.emailSender.canEmail(addr.email)) {
            smtpRcptTo.add(addr);
            switch(rt) {
                case TO:
                    ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                    break;
                case CC:
                    ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                    break;
            }
        } else {
            log.warn("Not emailing " + addr.email + " (prohibited by allowrcpt)");
        }
    }
}
#end_block

#method_before
private Address toAddress(final Account.Id id) {
    final Account a = accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#method_after
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#end_block

#method_before
public void setPatchLineComments(final List<PatchLineComment> plc) {
    inlineComments = plc;
}
#method_after
public void setPatchLineComments(final List<PatchLineComment> plc) {
    inlineComments = plc;
    Set<String> paths = new HashSet<String>();
    for (PatchLineComment c : plc) {
        Patch.Key p = c.getKey().getParentKey();
        paths.add(p.getFileName());
    }
    changeData.setCurrentFilePaths(paths);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    final List<String> inlineCommentsFiles = new ArrayList<String>();
    for (final PatchLineComment c : inlineComments) {
        final String fileName = c.getKey().getParentKey().getFileName();
        inlineCommentsFiles.add(fileName);
    }
    bccWatchesNotifyAllComments(inlineCommentsFiles);
}
#method_after
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#end_block

#method_before
private Repository getRepository() {
    try {
        return server.openRepository(projectName);
    } catch (RepositoryNotFoundException e) {
        return null;
    }
}
#method_after
private Repository getRepository() {
    try {
        return args.server.openRepository(projectName);
    } catch (RepositoryNotFoundException e) {
        return null;
    }
}
#end_block

#method_before
protected <K, V> UnnamedCacheBinding<K, V> core(final TypeLiteral<Cache<K, V>> type) {
    return core(Key.get(type));
}
#method_after
protected <K, V> UnnamedCacheBinding<K, V> core(final TypeLiteral<Cache<K, V>> type) {
    return core(Key.get(type), type);
}
#end_block

#method_before
protected <K, V> NamedCacheBinding<K, V> core(final TypeLiteral<Cache<K, V>> type, final String name) {
    return core(Key.get(type, Names.named(name))).name(name);
}
#method_after
protected <K, V> NamedCacheBinding<K, V> core(final TypeLiteral<Cache<K, V>> type, final String name) {
    return core(Key.get(type, Names.named(name)), type).name(name);
}
#end_block

#method_before
private <K, V> UnnamedCacheBinding<K, V> core(final Key<Cache<K, V>> key) {
    final boolean disk = false;
    final CacheProvider<K, V> b = new CacheProvider<K, V>(disk, this);
    bind(key).toProvider(b).in(Scopes.SINGLETON);
    return b;
}
#method_after
private <K, V> UnnamedCacheBinding<K, V> core(final Key<Cache<K, V>> key, final TypeLiteral<Cache<K, V>> type) {
    final boolean disk = false;
    final CacheProvider<K, V> b = new CacheProvider<K, V>(disk, this, type);
    bind(key).toProvider(b).in(Scopes.SINGLETON);
    return b;
}
#end_block

#method_before
protected <K extends Serializable, V extends Serializable> UnnamedCacheBinding<K, V> disk(final TypeLiteral<Cache<K, V>> type) {
    return disk(Key.get(type));
}
#method_after
protected <K extends Serializable, V extends Serializable> UnnamedCacheBinding<K, V> disk(final TypeLiteral<Cache<K, V>> type) {
    return disk(Key.get(type), type);
}
#end_block

#method_before
protected <K extends Serializable, V extends Serializable> NamedCacheBinding<K, V> disk(final TypeLiteral<Cache<K, V>> type, final String name) {
    return disk(Key.get(type, Names.named(name))).name(name);
}
#method_after
protected <K extends Serializable, V extends Serializable> NamedCacheBinding<K, V> disk(final TypeLiteral<Cache<K, V>> type, final String name) {
    return disk(Key.get(type, Names.named(name)), type).name(name);
}
#end_block

#method_before
private <K, V> UnnamedCacheBinding<K, V> disk(final Key<Cache<K, V>> key) {
    final boolean disk = true;
    final CacheProvider<K, V> b = new CacheProvider<K, V>(disk, this);
    bind(key).toProvider(b).in(Scopes.SINGLETON);
    return b;
}
#method_after
private <K, V> UnnamedCacheBinding<K, V> disk(final Key<Cache<K, V>> key, final TypeLiteral<Cache<K, V>> type) {
    final boolean disk = true;
    final CacheProvider<K, V> b = new CacheProvider<K, V>(disk, this, type);
    bind(key).toProvider(b).in(Scopes.SINGLETON);
    return b;
}
#end_block

#method_before
public void setContext(final int ctx) {
    assert 0 <= ctx || ctx == AccountGeneralPreferences.WHOLE_FILE_CONTEXT;
    context = ctx;
}
#method_after
public void setContext(final int ctx) {
    assert 0 <= ctx || ctx == AccountDiffPreference.WHOLE_FILE_CONTEXT;
    context = ctx;
}
#end_block

#method_before
@Override
public void myDiffPreferences(AsyncCallback<AccountDiffPreference> callback) {
    run(callback, new Action<AccountDiffPreference>() {

        @Override
        public AccountDiffPreference run(ReviewDb db) throws OrmException, Failure, NoSuchProjectException, NoSuchGroupException {
            return db.accountDiffPreferences().get(currentUser.get().getAccountId());
        }
    });
}
#method_after
@Override
public void myDiffPreferences(AsyncCallback<AccountDiffPreference> callback) {
    run(callback, new Action<AccountDiffPreference>() {

        @Override
        public AccountDiffPreference run(ReviewDb db) throws OrmException {
            return currentUser.get().getAccountDiffPreference();
        }
    });
}
#end_block

#method_before
@Override
public void changeDiffPreferences(final AccountDiffPreference diffPref, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure, NoSuchProjectException, NoSuchGroupException {
            Id accountId = getAccountId();
            diffPref.setAccountId(accountId);
            final AccountDiffPreference p = db.accountDiffPreferences().get(accountId);
            if (p == null) {
                db.accountDiffPreferences().insert(Collections.singleton(diffPref));
            } else {
                db.accountDiffPreferences().update(Collections.singleton(diffPref));
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
@Override
public void changeDiffPreferences(final AccountDiffPreference diffPref, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id accountId = getAccountId();
            if (!diffPref.getAccountId().equals(getAccountId())) {
                throw new IllegalArgumentException("diffPref.getAccountId() " + diffPref.getAccountId() + " doesn't match" + " the accountId of the signed in user " + getAccountId());
            }
            db.accountDiffPreferences().upsert(Collections.singleton(diffPref));
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public char getIgnoreWhitespace() {
    return ignoreWhitespace;
}
#method_after
public Whitespace getIgnoreWhitespace() {
    return Whitespace.forCode(ignoreWhitespace);
}
#end_block

#method_before
public void setIgnoreWhitespace(char ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace;
}
#method_after
public void setIgnoreWhitespace(Whitespace ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace.getCode();
}
#end_block

#method_before
public void setEnabled(final boolean on) {
    for (Widget w : (HasWidgets) getWidget()) {
        if (w instanceof FocusWidget) {
            ((FocusWidget) w).setEnabled(on);
        }
    }
    toggleEnabledStatus(on);
}
#method_after
public void setEnabled(final boolean on) {
    if (on) {
        setEnabledCounter++;
    } else {
        setEnabledCounter--;
    }
    if (on && setEnabledCounter == 0 || !on) {
        for (Widget w : (HasWidgets) getWidget()) {
            if (w instanceof FocusWidget) {
                ((FocusWidget) w).setEnabled(on);
            }
        }
        toggleEnabledStatus(on);
    }
    ;
}
#end_block

#method_before
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        final PrettySettings p = getValue().getPrettySettings();
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
        showFullFile.setValue(getValue().getContext() == WHOLE_FILE_CONTEXT);
    } else {
        syntaxHighlighting.setValue(false);
        showFullFile.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#method_after
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        final PrettySettings p = getValue().getPrettySettings();
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#end_block

#method_before
private void toggleEnabledStatus(final boolean on) {
    intralineDifference.setEnabled(on & enableIntralineDifference);
    syntaxHighlighting.setEnabled(on & enableSmallFileFeatures);
    showFullFile.setEnabled(on & enableSmallFileFeatures);
    final String title = enableSmallFileFeatures ? null : PatchUtil.C.disabledOnLargeFiles();
    syntaxHighlighting.setTitle(title);
    showFullFile.setTitle(title);
}
#method_after
private void toggleEnabledStatus(final boolean on) {
    intralineDifference.setEnabled(on & enableIntralineDifference);
    syntaxHighlighting.setEnabled(on & enableSmallFileFeatures);
    final String title = enableSmallFileFeatures ? null : PatchUtil.C.disabledOnLargeFiles();
    syntaxHighlighting.setTitle(title);
}
#end_block

#method_before
public void setValue(final PatchScriptSettings s) {
    final PrettySettings p = s.getPrettySettings();
    setIgnoreWhitespace(s.getWhitespace());
    if (enableSmallFileFeatures) {
        showFullFile.setValue(s.getContext() == WHOLE_FILE_CONTEXT);
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        showFullFile.setValue(false);
        syntaxHighlighting.setValue(false);
    }
    tabWidth.setIntValue(p.getTabSize());
    colWidth.setIntValue(p.getLineLength());
    intralineDifference.setValue(p.isIntralineDifference());
    whitespaceErrors.setValue(p.isShowWhiteSpaceErrors());
    showTabs.setValue(p.isShowTabs());
    value = s;
}
#method_after
public void setValue(final PatchScriptSettings s) {
    final PrettySettings p = s.getPrettySettings();
    setIgnoreWhitespace(s.getWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(s.getContext());
    tabWidth.setIntValue(p.getTabSize());
    colWidth.setIntValue(p.getLineLength());
    intralineDifference.setValue(p.isIntralineDifference());
    whitespaceErrors.setValue(p.isShowWhiteSpaceErrors());
    showTabs.setValue(p.isShowTabs());
    value = s;
}
#end_block

#method_before
@UiHandler("update")
void onUpdate(ClickEvent event) {
    update();
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#method_after
@UiHandler("update")
void onUpdate(ClickEvent event) {
    update();
}
#end_block

#method_before
private void update() {
    PatchScriptSettings s = new PatchScriptSettings(getValue());
    PrettySettings p = s.getPrettySettings();
    s.setWhitespace(getIgnoreWhitespace());
    if (showFullFile.getValue()) {
        s.setContext(WHOLE_FILE_CONTEXT);
    } else if (Gerrit.isSignedIn()) {
        final Account u = Gerrit.getUserAccount();
        final AccountGeneralPreferences pref = u.getGeneralPreferences();
        if (pref.getDefaultContext() == WHOLE_FILE_CONTEXT) {
            s.setContext(DEFAULT_CONTEXT);
        } else {
            s.setContext(pref.getDefaultContext());
        }
    } else {
        s.setContext(DEFAULT_CONTEXT);
    }
    p.setTabSize(tabWidth.getIntValue());
    p.setLineLength(colWidth.getIntValue());
    p.setSyntaxHighlighting(syntaxHighlighting.getValue());
    p.setIntralineDifference(intralineDifference.getValue());
    p.setShowWhiteSpaceErrors(whitespaceErrors.getValue());
    p.setShowTabs(showTabs.getValue());
    value = s;
    fireEvent(new ValueChangeEvent<PatchScriptSettings>(s) {
    });
}
#method_after
private void update() {
    PatchScriptSettings s = new PatchScriptSettings(getValue());
    PrettySettings p = s.getPrettySettings();
    s.setWhitespace(getIgnoreWhitespace());
    s.setContext(getContext());
    p.setTabSize(tabWidth.getIntValue());
    p.setLineLength(colWidth.getIntValue());
    p.setSyntaxHighlighting(syntaxHighlighting.getValue());
    p.setIntralineDifference(intralineDifference.getValue());
    p.setShowWhiteSpaceErrors(whitespaceErrors.getValue());
    p.setShowTabs(showTabs.getValue());
    value = s;
    fireEvent(new ValueChangeEvent<PatchScriptSettings>(s) {
    });
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#end_block

#method_before
private void persistDiffPreferences() {
    AccountDiffPreference diffPref = new AccountDiffPreference();
    diffPref.setIgnoreWhitespace(getIgnoreWhitespace().getCode());
    diffPref.setTabSize(tabWidth.getIntValue());
    diffPref.setLineLength(colWidth.getIntValue());
    diffPref.setSyntaxHighlighting(syntaxHighlighting.getValue());
    diffPref.setShowWhitespaceErrors(whitespaceErrors.getValue());
    diffPref.setIntralineDifference(intralineDifference.getValue());
    diffPref.setShowTabs(showTabs.getValue());
    Util.ACCOUNT_SVC.changeDiffPreferences(diffPref, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
        }
    });
}
#method_after
private void persistDiffPreferences() {
    setEnabled(false);
    final AccountDiffPreference diffPref = new AccountDiffPreference(Gerrit.getUserAccount().getId());
    diffPref.setIgnoreWhitespace(getIgnoreWhitespace());
    diffPref.setTabSize(tabWidth.getIntValue());
    diffPref.setLineLength(colWidth.getIntValue());
    diffPref.setSyntaxHighlighting(syntaxHighlighting.getValue());
    diffPref.setShowWhitespaceErrors(whitespaceErrors.getValue());
    diffPref.setIntralineDifference(intralineDifference.getValue());
    diffPref.setShowTabs(showTabs.getValue());
    diffPref.setContext(getContext());
    Util.ACCOUNT_SVC.changeDiffPreferences(diffPref, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            Gerrit.setAccountDiffPreference(diffPref);
            setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            setEnabled(true);
        }
    });
}
#end_block

#method_before
private boolean isWatched(Change c) {
    Set<Project.NameKey> watchedProjects = currentUser.get().getWatchedProjects();
    return watchedProjects.contains(c.getProject()) || watchedProjects.contains(systemConfigProvider.get().wildProjectName);
}
#method_after
private boolean isWatched(Change c) {
    Set<Project.NameKey> watchedProjects = currentUser.get().getWatchedProjects();
    return watchedProjects.contains(c.getProject()) || watchedProjects.contains(wildProject);
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.ALL_OPEN);
    addLink(m, C.menuAllMerged(), PageLinks.ALL_MERGED);
    addLink(m, C.menuAllAbandoned(), PageLinks.ALL_ABANDONED);
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menyMyDrafts(), PageLinks.MINE_DRAFTS);
        addLink(m, C.menuMyWatchedChanges(), PageLinks.MINE_WATCHED);
        addLink(m, C.menuMyStarredChanges(), PageLinks.MINE_STARRED);
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        addLink(m, C.menuProjects(), PageLinks.ADMIN_PROJECTS);
        menuLeft.add(m, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        menuRight.add(anchor(C.menuSignOut(), "logout"));
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", "become"));
                break;
        }
    }
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.ALL_OPEN);
    addLink(m, C.menuAllMerged(), PageLinks.ALL_MERGED);
    addLink(m, C.menuAllAbandoned(), PageLinks.ALL_ABANDONED);
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.MINE_DRAFTS);
        addLink(m, C.menuMyWatchedChanges(), PageLinks.MINE_WATCHED);
        addLink(m, C.menuMyStarredChanges(), PageLinks.MINE_STARRED);
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        addLink(m, C.menuProjects(), PageLinks.ADMIN_PROJECTS);
        menuLeft.add(m, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        menuRight.add(anchor(C.menuSignOut(), "logout"));
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", "become"));
                break;
        }
    }
}
#end_block

#method_before
@Override
public Set<NameKey> getWatchedProjects() {
    if (watchedProjects == null) {
        if (dbProvider == null) {
            throw new OutOfScopeException("Not in request scoped user");
        }
        final Set<Project.NameKey> h = new HashSet<Project.NameKey>();
        try {
            for (AccountProjectWatch projectWatch : dbProvider.get().accountProjectWatches().byAccount(getAccountId()).toList()) {
                h.add(projectWatch.getProjectNameKey());
            }
        } catch (ProvisionException e) {
            log.warn("Cannot query project watches of a user", e);
        } catch (OrmException e) {
            log.warn("Cannot query project watches of a user", e);
        }
        watchedProjects = Collections.unmodifiableSet(h);
    }
    return watchedProjects;
}
#method_after
@Override
public Set<Project.NameKey> getWatchedProjects() {
    if (watchedProjects == null) {
        if (dbProvider == null) {
            throw new OutOfScopeException("Not in request scoped user");
        }
        final Set<Project.NameKey> h = new HashSet<Project.NameKey>();
        try {
            for (AccountProjectWatch projectWatch : dbProvider.get().accountProjectWatches().byAccount(getAccountId())) {
                h.add(projectWatch.getProjectNameKey());
            }
        } catch (OrmException e) {
            log.warn("Cannot query project watches of a user", e);
        }
        watchedProjects = Collections.unmodifiableSet(h);
    }
    return watchedProjects;
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException {
    // TODO(jeffschu) correctly handle file renames
    // TODO(jeffschu) correctly handle merge commits
    // TODO(jeffschu) implement whitespace ignore
    final RevWalk rw = new RevWalk(repo);
    final RevCommit b = rw.parseCommit(key.getNewId());
    final AnyObjectId a = aFor(key, repo, b);
    if (a == null) {
        return new PatchList(a, b, computeIntraline, new PatchListEntry[0]);
    }
    RevTree aTree = rw.parseTree(a);
    RevTree bTree = b.getTree();
    final TreeWalk walk = new TreeWalk(repo);
    walk.reset();
    walk.setRecursive(true);
    walk.addTree(aTree);
    walk.addTree(bTree);
    walk.setFilter(TreeFilter.ANY_DIFF);
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    PrintStream ps = new PrintStream(buf);
    while (walk.next()) {
        outputDiff(ps, walk.getPathString(), walk.getObjectId(0), walk.getFileMode(0), walk.getObjectId(1), walk.getFileMode(1), repo);
    }
    org.eclipse.jgit.patch.Patch p = new org.eclipse.jgit.patch.Patch();
    p.parse(new ByteArrayInputStream(buf.toByteArray()));
    final int cnt = p.getFiles().size();
    final PatchListEntry[] entries = new PatchListEntry[cnt];
    for (int i = 0; i < cnt; i++) {
        entries[i] = newEntry(repo, aTree, bTree, p.getFiles().get(i));
    }
    return new PatchList(a, b, computeIntraline, entries);
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException {
    // TODO(jeffschu) correctly handle file renames
    // TODO(jeffschu) correctly handle merge commits
    // TODO(jeffschu) implement whitespace ignore
    final RevWalk rw = new RevWalk(repo);
    final RevCommit b = rw.parseCommit(key.getNewId());
    final AnyObjectId a = aFor(key, repo, b);
    if (a == null) {
        return new PatchList(a, b, computeIntraline, new PatchListEntry[0]);
    }
    RevTree aTree = rw.parseTree(a);
    RevTree bTree = b.getTree();
    final TreeWalk walk = new TreeWalk(repo);
    walk.reset();
    walk.setRecursive(true);
    walk.addTree(aTree);
    walk.addTree(bTree);
    walk.setFilter(TreeFilter.ANY_DIFF);
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    PrintStream ps = new PrintStream(buf, true, "UTF-8");
    while (walk.next()) {
        outputDiff(ps, walk.getPathString(), walk.getObjectId(0), walk.getFileMode(0), walk.getObjectId(1), walk.getFileMode(1), repo);
    }
    org.eclipse.jgit.patch.Patch p = new org.eclipse.jgit.patch.Patch();
    ps.flush();
    p.parse(new ByteArrayInputStream(buf.toByteArray()));
    final int cnt = p.getFiles().size();
    final PatchListEntry[] entries = new PatchListEntry[cnt];
    for (int i = 0; i < cnt; i++) {
        entries[i] = newEntry(repo, aTree, bTree, p.getFiles().get(i));
    }
    return new PatchList(a, b, computeIntraline, entries);
}
#end_block

#method_before
private void outputDiff(PrintStream out, String path, ObjectId id1, FileMode mode1, ObjectId id2, FileMode mode2, Repository repo) throws IOException {
    DiffFormatter fmt = new DiffFormatter();
    String name1 = "a/" + path;
    String name2 = "b/" + path;
    out.println("diff --git " + name1 + " " + name2);
    boolean isNew = false;
    boolean isDelete = false;
    if (id1.equals(ObjectId.zeroId())) {
        out.println("new file mode " + mode2);
        isNew = true;
    } else if (id2.equals(ObjectId.zeroId())) {
        out.println("deleted file mode " + mode1);
        isDelete = true;
    } else if (!mode1.equals(mode2)) {
        out.println("old mode " + mode1);
        out.println("new mode " + mode2);
    }
    out.println("index " + id1.abbreviate(repo, 7).name() + ".." + id2.abbreviate(repo, 7).name() + (mode1.equals(mode2) ? " " + mode1 : ""));
    out.println("--- " + (isNew ? "/dev/null" : name1));
    out.println("+++ " + (isDelete ? "/dev/null" : name2));
    RawText a = getRawText(id1, repo);
    RawText b = getRawText(id2, repo);
    MyersDiff diff = new MyersDiff(a, b);
    fmt.formatEdits(out, a, b, diff.getEdits());
}
#method_after
private void outputDiff(PrintStream out, String path, ObjectId id1, FileMode mode1, ObjectId id2, FileMode mode2, Repository repo) throws IOException {
    DiffFormatter fmt = new DiffFormatter();
    String name1 = "a/" + path;
    if (needsQuoting(name1)) {
        name1 = QuotedString.GIT_PATH.quote(name1);
    }
    String name2 = "b/" + path;
    if (needsQuoting(name2)) {
        name2 = QuotedString.GIT_PATH.quote(name2);
    }
    out.print("diff --git " + name1 + " " + name2 + "\n");
    boolean isNew = FileMode.MISSING.equals(mode1);
    boolean isDelete = FileMode.MISSING.equals(mode2);
    if (isNew) {
        out.print("new file mode " + mode2 + "\n");
    } else if (isDelete) {
        out.print("deleted file mode " + mode1 + "\n");
    } else if (!mode1.equals(mode2)) {
        out.print("old mode " + mode1 + "\n");
        out.print("new mode " + mode2 + "\n");
    }
    out.print("index " + id1.abbreviate(repo, 7).name() + ".." + id2.abbreviate(repo, 7).name() + (mode1.equals(mode2) ? " " + mode1 : "") + "\n");
    out.print("--- " + (isNew ? "/dev/null" : name1) + "\n");
    out.print("+++ " + (isDelete ? "/dev/null" : name2) + "\n");
    RawText a = getRawText(id1, repo);
    RawText b = getRawText(id2, repo);
    MyersDiff diff = new MyersDiff(a, b);
    fmt.formatEdits(out, a, b, diff.getEdits());
}
#end_block

#method_before
private RawText getRawText(ObjectId id, Repository repo) throws IOException {
    if (id.equals(ObjectId.zeroId()))
        return new RawText(new byte[] {});
    return new RawText(repo.openBlob(id).getCachedBytes());
}
#method_after
private RawText getRawText(ObjectId id, Repository repo) throws IOException {
    if (id.equals(ObjectId.zeroId())) {
        return new RawText(new byte[] {});
    }
    return new RawText(repo.openBlob(id).getCachedBytes());
}
#end_block

#method_before
static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final String cacheName = CACHE_NAME;
            final TypeLiteral<Cache<ActiveSession.Key, ActiveSession>> type = new TypeLiteral<Cache<ActiveSession.Key, ActiveSession>>() {
            };
            // 
            core(type, cacheName).memoryLimit(// reasonable default for many sites
            1024).maxAge(12, // expire sessions if they are inactive
            HOURS).evictionPolicy(// keep most recently used
            EvictionPolicy.LRU);
            bind(WebSession.class).in(RequestScoped.class);
        }
    };
}
#method_after
static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final TypeLiteral<Cache<ActiveSession.Key, ActiveSession>> type = new TypeLiteral<Cache<ActiveSession.Key, ActiveSession>>() {
            };
            // 
            core(type, CACHE_NAME).memoryLimit(// reasonable default for many sites
            1024).maxAge(12, // expire sessions if they are inactive
            HOURS).evictionPolicy(// keep most recently used
            EvictionPolicy.LRU);
            bind(WebSession.class).in(RequestScoped.class);
            bind(WebSession.KeyGenerator.class).in(SINGLETON);
        }
    };
}
#end_block

#method_before
static long now() {
    return System.currentTimeMillis();
}
#method_after
private static long now() {
    return System.currentTimeMillis();
}
#end_block

#method_before
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
    }
    key = createKey(id);
    session = createSession(key, id, rememberMe, identity, null);
    saveCookie();
}
#method_after
public void login(final AuthResult res, final boolean rememberMe) throws OrmException {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
    }
    key = createKey(id);
    session = createSession(key, id, rememberMe, identity, null);
    saveCookie();
}
#end_block

#method_before
void setUserAccountId(Account.Id id) {
    key = new ActiveSession.Key("id:" + id);
    session = new ActiveSession(key, id, 0, false, null, "");
}
#method_after
void setUserAccountId(Account.Id id) {
    key = new ActiveSession.Key("id:" + id);
    session = new ActiveSession(key, id, new Timestamp(0), false, null, "");
}
#end_block

#method_before
public void logout() {
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
        saveCookie();
    }
}
#method_after
public void logout() {
    if (session != null) {
        try {
            destroy(key);
        } catch (OrmException e) {
            log.error("Could not remove session key from cache", e);
        }
        key = null;
        session = null;
        saveCookie();
    }
}
#end_block

#method_before
ActiveSession.Key createKey(final Account.Id who) {
    try {
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        buf = new ByteArrayOutputStream(3 + nonceLen);
        writeVarInt32(buf, who.get());
        writeBytes(buf, rnd);
        return new ActiveSession.Key(CookieBase64.encode(buf.toByteArray()));
    } catch (IOException e) {
        throw new RuntimeException("Cannot produce new account cookie", e);
    }
}
#method_after
private ActiveSession.Key createKey(final Account.Id who) {
    try {
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        buf = new ByteArrayOutputStream(3 + nonceLen);
        writeVarInt32(buf, who.get());
        writeBytes(buf, rnd);
        return new ActiveSession.Key(CookieBase64.encode(buf.toByteArray()));
    } catch (IOException e) {
        throw new RuntimeException("Cannot produce new account cookie", e);
    }
}
#end_block

#method_before
ActiveSession createSession(final ActiveSession.Key key, final ActiveSession session) {
    final Account.Id who = session.getAccountId();
    final boolean remember = session.isPersistentCookie();
    final AccountExternalId.Key lastLogin = session.getExternalId();
    final String xsrfToken = session.getXsrfToken();
    return createSession(key, who, remember, lastLogin, xsrfToken);
}
#method_after
private ActiveSession createSession(final ActiveSession.Key key, final ActiveSession session) throws OrmException {
    final Account.Id who = session.getAccountId();
    final boolean remember = session.isPersistentCookie();
    final AccountExternalId.Key lastLogin = session.getExternalId();
    final String xsrfToken = session.getXsrfToken();
    return createSession(key, who, remember, lastLogin, xsrfToken);
}
#end_block

#method_before
ActiveSession createSession(final ActiveSession.Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = cache.getTimeToLive(MILLISECONDS) >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    ActiveSession session = new ActiveSession(key, who, refreshCookieAt, remember, lastLogin, xsrfToken);
    cache.put(key, session);
    return session;
}
#method_after
private ActiveSession createSession(final ActiveSession.Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) throws OrmException {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = cache.getTimeToLive(MILLISECONDS) >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    ActiveSession session = new ActiveSession(key, who, new Timestamp(refreshCookieAt), remember, lastLogin, xsrfToken);
    put(session);
    return session;
}
#end_block

#method_before
int getCookieAge(final ActiveSession session) {
    if (session.isPersistentCookie()) {
        // 
        return (int) cache.getTimeToLive(SECONDS);
    } else {
        // 
        return -1;
    }
}
#method_after
private int getCookieAge(final ActiveSession session) {
    if (session.isPersistentCookie()) {
        // 
        return (int) cache.getTimeToLive(SECONDS);
    } else {
        // 
        return -1;
    }
}
#end_block

#method_before
ActiveSession get(final ActiveSession.Key key) {
    return cache.get(key);
}
#method_after
private ActiveSession get(final ActiveSession.Key key) throws OrmException {
    ActiveSession as = cache.get(key);
    final ActiveSessionAccess activeSessions = schema.activeSessions();
    if (as == null) {
        as = activeSessions.get(key);
        if (as == null) {
            return null;
        } else {
            if (expiredFromCache(as)) {
                destroy(key);
                return null;
            } else if (needsCacheRefresh(as)) {
                as.updateLastSeen();
                put(as);
            }
            return as;
        }
    } else {
        if (needsCacheRefresh(as)) {
            as.updateLastSeen();
            put(as);
        }
        return as;
    }
}
#end_block

#method_before
void destroy(final ActiveSession.Key key) {
    cache.remove(key);
}
#method_after
private void destroy(final ActiveSession.Key key) throws OrmException {
    schema.activeSessions().deleteKeys(Arrays.asList(key));
    cache.remove(key);
}
#end_block

#method_before
public long getRefreshCookieAt() {
    return refreshCookieAt;
}
#method_after
public Timestamp getRefreshCookieAt() {
    return refreshCookieAt;
}
#end_block

#method_before
public void setRefreshCookieAt(long refreshCookieAt) {
    this.refreshCookieAt = refreshCookieAt;
}
#method_after
public void setRefreshCookieAt(Timestamp refreshCookieAt) {
    this.refreshCookieAt = refreshCookieAt;
}
#end_block

#method_before
public boolean needsCookieRefresh() {
    return refreshCookieAt <= System.currentTimeMillis();
}
#method_after
public boolean needsCookieRefresh() {
    return refreshCookieAt.before(now());
}
#end_block

#method_before
private void publishApprovals() throws OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final List<ApprovalCategoryValue.Id> ignore = new ArrayList<ApprovalCategoryValue.Id>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            if (want.get() != 0) {
                a = new PatchSetApproval(new PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
                a.cache(change);
                ins.add(a);
                all.add(a);
                mine.put(a.getCategoryId(), a);
                dirty.add(a.getCategoryId());
            } else {
                ignore.add(want);
            }
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(change, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        if (ignore.indexOf(want) == -1) {
            final PatchSetApproval a = mine.get(want.getParentKey());
            final short o = a.getValue();
            a.setValue(want.get());
            a.cache(change);
            functionState.normalize(types.getApprovalType(a.getCategoryId()), a);
            if (o != a.getValue()) {
                // Value changed, ensure we update the database.
                // 
                a.setGranted();
                dirty.add(a.getCategoryId());
            }
            if (!ins.contains(a)) {
                upd.add(a);
            }
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    summarizeInlineComments(msgbuf);
    message(msgbuf.toString());
}
#method_after
private void publishApprovals() throws OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            a = new PatchSetApproval(new // 
            PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
            a.cache(change);
            ins.add(a);
            all.add(a);
            mine.put(a.getCategoryId(), a);
            dirty.add(a.getCategoryId());
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(change, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        final PatchSetApproval a = mine.get(want.getParentKey());
        final short o = a.getValue();
        a.setValue(want.get());
        a.cache(change);
        functionState.normalize(types.getApprovalType(a.getCategoryId()), a);
        if (o != a.getValue()) {
            // Value changed, ensure we update the database.
            // 
            a.setGranted();
            dirty.add(a.getCategoryId());
        }
        if (!ins.contains(a)) {
            upd.add(a);
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            if (a.getValue() == 0 && ins.contains(a)) {
                // Don't say "no score" for an initial entry.
                continue;
            }
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    message(msgbuf.toString());
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ApproveCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(CreateProject.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "submit").to(SubmitCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ReviewCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(CreateProject.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "review").to(ReviewCommand.class);
}
#end_block

#method_before
private void applyRightFloor(final PatchSetApproval a) {
    final IdentifiedUser user = userFactory.create(a.getAccountId());
    RefControl rc = controlFor(user);
    // Find the maximal range actually granted to the user.
    // 
    short minAllowed = 0, maxAllowed = 0;
    for (final RefRight r : rc.getAllRights(a.getCategoryId())) {
        final AccountGroup.Id grp = r.getAccountGroupId();
        if (user.getEffectiveGroups().contains(grp)) {
            minAllowed = (short) Math.min(minAllowed, r.getMinValue());
            maxAllowed = (short) Math.max(maxAllowed, r.getMaxValue());
        }
    }
    // 
    if (a.getValue() < minAllowed) {
        a.setValue(minAllowed);
    } else if (a.getValue() > maxAllowed) {
        a.setValue(maxAllowed);
    }
}
#method_after
private void applyRightFloor(final PatchSetApproval a) {
    final IdentifiedUser user = userFactory.create(a.getAccountId());
    RefControl rc = controlFor(user);
    // Find the maximal range actually granted to the user.
    // 
    short minAllowed = 0, maxAllowed = 0;
    for (final RefRight r : rc.getApplicableRights(a.getCategoryId())) {
        final AccountGroup.Id grp = r.getAccountGroupId();
        if (user.getEffectiveGroups().contains(grp)) {
            minAllowed = (short) Math.min(minAllowed, r.getMinValue());
            maxAllowed = (short) Math.max(maxAllowed, r.getMaxValue());
        }
    }
    // 
    if (a.getValue() < minAllowed) {
        a.setValue(minAllowed);
    } else if (a.getValue() > maxAllowed) {
        a.setValue(maxAllowed);
    }
}
#end_block

#method_before
private void initRights(final Panel body) {
    final FlowPanel addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            rights.deleteChecked();
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#method_after
private void initRights(final Panel body) {
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            final HashSet<RefRight.Key> refRightIds = rights.getRefRightIdsChecked();
            doDeleteRefRights(refRightIds);
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#end_block

#method_before
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
}
#method_after
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
    addPanel.setVisible(result.canModifyAccess);
    delRight.setVisible(rights.getCanDelete());
}
#end_block

#method_before
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    idx = rangeMaxBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
    if (max == null) {
        return;
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    if (at.getCategory().isRange()) {
        idx = rangeMaxBox.getSelectedIndex();
        if (idx < 0) {
            return;
        }
        max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
        if (max == null) {
            return;
        }
    } else {
        // If its not a range, the maximum box was disabled.  Use the min
        // value as the max, and select the min from the category values.
        // 
        max = min;
        min = at.getMin();
        for (ApprovalCategoryValue v : at.getValues()) {
            if (0 <= v.getValue() && v.getValue() <= max.getValue()) {
                min = v;
                break;
            }
        }
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#method_after
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    rangeMaxBox.setVisible(at.getCategory().isRange());
    addRight.setEnabled(true);
}
#end_block

#method_before
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<InheritedRefRight> refRights) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final InheritedRefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r);
    }
}
#method_after
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<InheritedRefRight> refRights) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final InheritedRefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r);
    }
}
#end_block

#method_before
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, right.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 4, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        formatValue(m, right.getMinValue(), min);
        if (right.getMinValue() != right.getMaxValue()) {
            m.br();
            formatValue(m, right.getMaxValue(), max);
        }
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#method_after
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited() || !r.isOwner()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, right.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 4, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        if (ar != null && ar.getCategory().isRange()) {
            formatValue(m, right.getMinValue(), min);
            m.br();
        }
        formatValue(m, right.getMaxValue(), max);
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (refPattern.startsWith("-")) {
        if (!refPattern.startsWith("-" + Constants.R_REFS)) {
            refPattern = "-" + Constants.R_HEADS + refPattern;
        }
    } else if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    checkPatternFormat(refPattern);
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    boolean exclusive = refPattern.startsWith("-");
    if (exclusive) {
        refPattern = refPattern.substring(1);
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (exclusive) {
        refPattern = "-" + refPattern;
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public boolean isVisible() {
    return canPerform(READ, (short) 1);
}
#method_after
public boolean isVisible() {
    return getProjectControl().visibleForReplication() || canPerform(READ, (short) 1);
}
#end_block

#method_before
public int allowedValueForRef(Set<AccountGroup.Id> groups) {
    int val = Integer.MIN_VALUE;
    for (RefRight right : rights) {
        if (groups.contains(right.getAccountGroupId())) {
            if ((val < 0 && right.getMaxValue() > 0)) {
                // If one of the user's groups had denied them access, but
                // this group grants them access, prefer the grant over
                // the denial. We have to break the tie somehow and we
                // prefer being "more open" to being "more closed".
                // 
                val = right.getMaxValue();
            } else {
                // Otherwise we use the largest value we can get.
                // 
                val = Math.max(right.getMaxValue(), val);
            }
        }
    }
    return val;
}
#method_after
public int allowedValueForRef(Set<AccountGroup.Id> groups) {
    int val = Integer.MIN_VALUE;
    for (RefRight right : rights) {
        if (groups.contains(right.getAccountGroupId())) {
            val = Math.max(right.getMaxValue(), val);
        }
    }
    return val;
}
#end_block

#method_before
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (String pattern : perPatternRights.keySet()) {
        val = Math.max(val, perPatternRights.get(pattern).allowedValueForRef(groups));
        if (val >= level || perPatternRights.get(pattern).containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#method_after
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (RefRightsForPattern right : perPatternRights.values()) {
        val = Math.max(val, right.allowedValueForRef(groups));
        if (val >= level || right.containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#end_block

#method_before
public static SortedMap<String, RefRightsForPattern> sortedRightsByPattern(List<RefRight> actionRights) {
    SortedMap<String, RefRightsForPattern> rights = new TreeMap<String, RefRightsForPattern>(DESCENDING_SORT);
    for (RefRight right : actionRights) {
        if (rights.containsKey(right.getRefPattern())) {
            rights.get(right.getRefPattern()).addRight(right);
        } else {
            RefRightsForPattern patternRights = new RefRightsForPattern();
            patternRights.addRight(right);
            rights.put(right.getRefPattern(), patternRights);
        }
    }
    return rights;
}
#method_after
private static SortedMap<String, RefRightsForPattern> sortedRightsByPattern(List<RefRight> actionRights) {
    SortedMap<String, RefRightsForPattern> rights = new TreeMap<String, RefRightsForPattern>(DESCENDING_SORT);
    for (RefRight actionRight : actionRights) {
        RefRightsForPattern patternRights = rights.get(actionRight.getRefPattern());
        if (patternRights == null) {
            patternRights = new RefRightsForPattern();
            rights.put(actionRight.getRefPattern(), patternRights);
        }
        patternRights.addRight(actionRight);
    }
    return rights;
}
#end_block

#method_before
private void display() throws Failure {
    final PrintWriter stdout = toPrintWriter(out);
    TreeMap<String, TreeNode> treeMap = null;
    if (showTree) {
        treeMap = new TreeMap<String, TreeNode>();
    }
    try {
        for (final Project p : db.projects().all()) {
            if (p.getNameKey().equals(wildProject)) {
                // 
                continue;
            }
            final ProjectState e = projectCache.get(p.getNameKey());
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (!showTree) {
                if (!pctl.isVisible()) {
                    // 
                    continue;
                }
                if (showBranch != null) {
                    final Ref ref = getBranchRef(p.getNameKey());
                    if (ref == null || ref.getObjectId() == null || !pctl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                        // 
                        continue;
                    }
                    stdout.print(ref.getObjectId().name());
                    stdout.print(' ');
                }
                stdout.print(p.getName());
                stdout.println();
            } else {
                TreeNode node = new TreeNode(p, pctl.isVisible());
                treeMap.put(p.getName(), node);
            }
        }
        if (showTree && treeMap.size() > 0) {
            final List<TreeNode> sortedNodes = new ArrayList<TreeNode>();
            // 
            for (final TreeNode key : treeMap.values()) {
                final String parentName = key.getParentName();
                if (parentName != null) {
                    final TreeNode node = (TreeNode) treeMap.get((String) parentName);
                    node.addChild(key);
                } else {
                    sortedNodes.add(key);
                }
            }
            // Builds a fake root node, which contains the sorted projects.
            // 
            final TreeNode fakeRoot = new TreeNode(null, sortedNodes, false);
            printElement(stdout, fakeRoot, -1, false, sortedNodes.get(sortedNodes.size() - 1));
        }
    } catch (OrmException e) {
        throw new Failure(1, "fatal: database error", e);
    } finally {
        stdout.flush();
    }
}
#method_after
private void display() throws Failure {
    if (showTree && (showBranch != null)) {
        throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
    }
    final PrintWriter stdout = toPrintWriter(out);
    TreeMap<String, TreeNode> treeMap = null;
    if (showTree) {
        treeMap = new TreeMap<String, TreeNode>();
    }
    try {
        for (final Project p : db.projects().all()) {
            if (p.getNameKey().equals(wildProject)) {
                // 
                continue;
            }
            final ProjectState e = projectCache.get(p.getNameKey());
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (!showTree) {
                if (!pctl.isVisible()) {
                    // 
                    continue;
                }
                if (showBranch != null) {
                    final Ref ref = getBranchRef(p.getNameKey());
                    if (ref == null || ref.getObjectId() == null || !pctl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                        // 
                        continue;
                    }
                    stdout.print(ref.getObjectId().name());
                    stdout.print(' ');
                }
                stdout.print(p.getName() + "\n");
            } else {
                treeMap.put(p.getName(), new TreeNode(p, pctl.isVisible()));
            }
        }
        if (showTree && treeMap.size() > 0) {
            final List<TreeNode> sortedNodes = new ArrayList<TreeNode>();
            // 
            for (final TreeNode key : treeMap.values()) {
                final String parentName = key.getParentName();
                if (parentName != null) {
                    final TreeNode node = treeMap.get((String) parentName);
                    if (node != null) {
                        node.addChild(key);
                    } else {
                        sortedNodes.add(key);
                    }
                } else {
                    sortedNodes.add(key);
                }
            }
            // Builds a fake root node, which contains the sorted projects.
            // 
            final TreeNode fakeRoot = new TreeNode(null, sortedNodes, false);
            printElement(stdout, fakeRoot, -1, false, sortedNodes.get(sortedNodes.size() - 1));
            stdout.flush();
        }
    } catch (OrmException e) {
        throw new Failure(1, "fatal: database error", e);
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private void printElement(final PrintWriter stdout, TreeNode node, int level, boolean isLast, final TreeNode lastParentNode) {
    // 
    if (node.getProject() != null) {
        // 
        if (!currentTabSeparator.equals(" ")) {
            final String nodeProject = node.getProject().getName();
            final String lastParentProject = lastParentNode.getProject().getName();
            if (nodeProject.equals(lastParentProject)) {
                currentTabSeparator = " ";
            }
        }
        if (level > 0) {
            stdout.print(String.format("%-" + 4 * level + "s", currentTabSeparator));
        }
        final String prefix = isLast ? LAST_NODE_PREFIX : NODE_PREFIX;
        String printout;
        if (node.isVisible()) {
            printout = prefix + node.getProject().getName();
        } else {
            printout = prefix + NOT_VISIBLE_PROJECT;
        }
        stdout.println(printout);
        stdout.flush();
    }
    if (node.isLeaf()) {
        return;
    } else {
        final List<TreeNode> children = node.getChildren();
        ++level;
        for (TreeNode treeNode : children) {
            final boolean isLastIndex = children.indexOf(treeNode) == children.size() - 1;
            printElement(stdout, treeNode, level, isLastIndex, lastParentNode);
        }
    }
}
#method_after
private void printElement(final PrintWriter stdout, TreeNode node, int level, boolean isLast, final TreeNode lastParentNode) {
    // 
    if (node.getProject() != null) {
        // 
        if (!currentTabSeparator.equals(" ")) {
            final String nodeProject = node.getProject().getName();
            final String lastParentProject = lastParentNode.getProject().getName();
            if (nodeProject.equals(lastParentProject)) {
                currentTabSeparator = " ";
            }
        }
        if (level > 0) {
            stdout.print(String.format("%-" + 4 * level + "s", currentTabSeparator));
        }
        final String prefix = isLast ? LAST_NODE_PREFIX : NODE_PREFIX;
        String printout;
        if (node.isVisible()) {
            printout = prefix + node.getProject().getName();
        } else {
            printout = prefix + NOT_VISIBLE_PROJECT;
        }
        stdout.print(printout + "\n");
    }
    if (node.isLeaf()) {
        return;
    } else {
        final List<TreeNode> children = node.getChildren();
        ++level;
        for (TreeNode treeNode : children) {
            final boolean isLastIndex = children.indexOf(treeNode) == children.size() - 1;
            printElement(stdout, treeNode, level, isLastIndex, lastParentNode);
        }
    }
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            PrintWriter p = toPrintWriter(out);
            try {
                parseCommandLine();
                final ProjectAccess projectAccess = db.projects();
                Project.NameKey parentNameKey = new Project.NameKey(parentName);
                final List<Project.NameKey> grandParents = new ArrayList<Project.NameKey>();
                if (parentName != null) {
                    final ProjectState projectState = projectCache.get(parentNameKey);
                    if (projectState == null) {
                        throw new Failure(1, "parent project " + parentName + " does not exist \n");
                    } else {
                        Project.NameKey grandParent = projectState.getProject().getParent();
                        // avoid deadlocks on retrieving the project rights
                        while (grandParent != null && !grandParent.equals(wildProject)) {
                            grandParents.add(grandParent);
                            grandParent = projectCache.get(grandParent).getProject().getParent();
                        }
                    }
                } else {
                    // if there is no parent, "All projects" is the default
                    parentName = wildProject.get();
                    parentNameKey = new Project.NameKey(parentName);
                }
                for (String child : children) {
                    final Project.NameKey childNameKey = new Project.NameKey(child);
                    Project projectChild = projectAccess.get(childNameKey);
                    // If the child project doesn't exist, just skip it
                    if (projectChild != null && !child.equals(wildProject.get()) && !child.equals(parentName) && (!grandParents.contains(childNameKey))) {
                        projectChild.setParent(parentNameKey);
                        projectAccess.update(Collections.singleton(projectChild));
                    } else {
                        p.print("It was not possible to set the parent project " + parentName + " to the following project : " + child + "\n");
                        p.flush();
                    }
                }
                // invalidates all projects on cache
                projectCache.evict();
            } catch (Throwable e) {
                p.print("Error when trying to set a parent to a project: " + e.getMessage() + "\n");
                p.flush();
            }
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            parseCommandLine();
            updateParents();
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ApproveCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(AdminCreateProject.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ApproveCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(CreateProject.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchProjectException, OrmException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    for (final RefRight.Key k : toRemove) {
        if (!projectName.equals(k.getProjectNameKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!controlForRef(projectControl, k.getRefPattern()).isOwner()) {
            throw new NoSuchRefException(k.getRefPattern());
        }
    }
    for (final RefRight.Key k : toRemove) {
        final RefRight m = db.refRights().get(k);
        if (m != null) {
            db.refRights().delete(Collections.singleton(m));
        }
    }
    projectCache.evict();
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws NoSuchProjectException, OrmException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    for (final RefRight.Key k : toRemove) {
        if (!projectName.equals(k.getProjectNameKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!controlForRef(projectControl, k.getRefPattern()).isOwner()) {
            throw new NoSuchRefException(k.getRefPattern());
        }
    }
    for (final RefRight.Key k : toRemove) {
        final RefRight m = db.refRights().get(k);
        if (m != null) {
            db.refRights().delete(Collections.singleton(m));
        }
    }
    projectCache.evictAll();
    return VoidResult.INSTANCE;
}
#end_block

#method_before
private ProjectState lookup(final Project.NameKey key) throws OrmException {
    if (key == null) {
        return null;
    }
    // handles the "wildcard" project state (recursion break)
    if (key.equals(wildProject) || key.get() == null || key.get().isEmpty()) {
        return getWildProjectState();
    }
    final ReviewDb db = schema.open();
    try {
        final Project project = db.projects().get(key);
        if (project == null) {
            return null;
        }
        // retrieves the parent project state (recursively)
        ProjectState parentProjectState = null;
        Project.NameKey parentNameKey = project.getParent();
        if (parentNameKey == null || parentNameKey.get() == null || parentNameKey.get().isEmpty()) {
            // if the parent project name is not defined, uses the wildcard project
            parentProjectState = getWildProjectState();
        } else {
            // gets parent project state recursively (unless its available on cache)
            parentProjectState = ProjectCacheImpl.this.get(parentNameKey);
            if (parentProjectState == null) {
                parentProjectState = lookup(parentNameKey);
            }
        }
        // retrieves the project rights
        final Collection<RefRight> projectRights = Collections.unmodifiableCollection(db.refRights().byProject(project.getNameKey()).toList());
        // evaluates the project inherited rights from parent project state
        final ProjectState.InheritedRights inheritedRights = new InheritedRightsComposer(parentProjectState);
        return projectStateFactory.create(project, projectRights, inheritedRights);
    } finally {
        db.close();
    }
}
#method_after
private ProjectState lookup(final Project.NameKey key) throws OrmException {
    final ReviewDb db = schema.open();
    try {
        final Project p = db.projects().get(key);
        if (p == null) {
            return null;
        }
        final Collection<RefRight> rights = Collections.unmodifiableCollection(db.refRights().byProject(p.getNameKey()).toList());
        return projectStateFactory.create(p, rights);
    } finally {
        db.close();
    }
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = "refs/heads/*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = "refs/heads/*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = "refs/tags/*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = "refs/*";
        } else {
            // Assume project wide for the default.
            refPattern = "refs/*";
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    // TODO Support per-branch READ access.
    if (ApprovalCategory.READ.equals(categoryId) && !refPattern.equals("refs/*")) {
        throw new UnsupportedOperationException("READ on " + refPattern + " not yet supported.");
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evict();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    InheritedRefRight inheritedRefRight = (InheritedRefRight) o;
    RefRight refRight = inheritedRefRight.getRight();
    if (refRight.getAccountGroupId().equals(this.getRight().getAccountGroupId()) && refRight.getApprovalCategoryId().equals(this.getRight().getApprovalCategoryId()) && refRight.getMinValue() == this.getRight().getMinValue() && refRight.getMaxValue() == this.getRight().getMaxValue() && refRight.getRefPattern().equals(this.getRight().getRefPattern())) {
        return true;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o instanceof InheritedRefRight) {
        InheritedRefRight a = this;
        InheritedRefRight b = (InheritedRefRight) o;
        return a.getRight().equals(b.getRight()) && a.isInherited() == b.isInherited();
    }
    return false;
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ErrorSlaveMode.class);
    command(gerrit, "create-account").to(ErrorSlaveMode.class);
    command(gerrit, "create-project").to(ErrorSlaveMode.class);
    command(gerrit, "set-project-parent").to(ErrorSlaveMode.class);
    command(gerrit, "gsql").to(ErrorSlaveMode.class);
    command(gerrit, "receive-pack").to(ErrorSlaveMode.class);
    command(gerrit, "replicate").to(ErrorSlaveMode.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ErrorSlaveMode.class);
    command(gerrit, "create-account").to(ErrorSlaveMode.class);
    command(gerrit, "create-project").to(ErrorSlaveMode.class);
    command(gerrit, "gsql").to(ErrorSlaveMode.class);
    command(gerrit, "receive-pack").to(ErrorSlaveMode.class);
    command(gerrit, "replicate").to(ErrorSlaveMode.class);
    command(gerrit, "set-project-parent").to(ErrorSlaveMode.class);
}
#end_block

#method_before
void display(final ProjectDetail result) {
    rights.display(result.groups, result.rights);
}
#method_after
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
}
#end_block

#method_before
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    // TODO Support per-branch READ access.
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        referenceTxt.setText("");
        referenceTxt.setEnabled(false);
    } else {
        referenceTxt.setEnabled(true);
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#method_after
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = "refs/heads/*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = "refs/heads/*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = "refs/tags/*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = "refs/*";
        } else {
            // Assume project wide for the default.
            refPattern = "refs/*";
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evict(projectControl.getProject());
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evict(projectControl.getProject());
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException {
    final UploadPack up = new UploadPack(repo);
    up.setRefFilter(this);
    up.upload(in, out, err);
}
#method_after
@Override
protected void runImpl() throws IOException {
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db));
    }
    up.upload(in, out, err);
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        checkVisibility(cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(AdminFlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "show-caches").to(AdminShowCaches.class);
    command(gerrit, "show-connections").to(AdminShowConnections.class);
    command(gerrit, "show-queue").to(AdminShowQueue.class);
    command(gerrit, "stream-changes").to(StreamChangeEvents.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(AdminShowCaches.class);
    command("kill").to(AdminKill.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(AdminFlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "show-caches").to(AdminShowCaches.class);
    command(gerrit, "show-connections").to(AdminShowConnections.class);
    command(gerrit, "show-queue").to(AdminShowQueue.class);
    command(gerrit, "stream-events").to(StreamEvents.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(AdminShowCaches.class);
    command("kill").to(AdminKill.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
}
#end_block

#method_before
public void addChangeListener(ChangeListener listener) {
    listeners.add(listener);
}
#method_after
public void addChangeListener(ChangeListener listener, IdentifiedUser user) {
    listeners.put(listener, new ChangeListenerHolder(listener, user));
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    for (ChangeListener listener : listeners) {
        listener.onPatchsetCreated(change, patchSet);
    }
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    args.add("--patchset");
    args.add(Integer.toString(patchSet.getPatchSetId()));
    runHook(getRepo(change), args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.commit = patchSet.getRevision().get();
    event.patchSet = Integer.toString(patchSet.getPatchSetId());
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--commit");
    args.add(event.commit);
    args.add("--patchset");
    args.add(event.patchSet);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    for (ChangeListener listener : listeners) {
        listener.onCommentAdded(change, patchSet, account, approvals, comment);
    }
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.author = getAuthorAttribute(account);
    event.revision = patchSet.getRevision().get();
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            ApprovalAttribute a = new ApprovalAttribute();
            a.type = approval.getKey().get();
            a.value = Short.toString(approval.getValue().get());
            event.approvals[i++] = a;
        }
    }
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.revision);
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    for (ChangeListener listener : listeners) {
        listener.onChangeMerged(change, account, patchSet);
    }
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    runHook(getRepo(change), args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.submitter = getAuthorAttribute(account);
    event.patchSet = patchSet.getRevision().get();
    event.description = change.getSubject();
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    for (ChangeListener listener : listeners) {
        listener.onChangeAbandoned(change, account, reason);
    }
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.author = getAuthorAttribute(account);
    event.reason = reason;
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    // Get the LDAP authentication username and password
    // from the user's input.
    // 
    final String authUsername = who.getLocalUser();
    final String authPassword = who.getPassword();
    // 
    if (this.username == null) {
        this.username = authUsername;
        this.password = authPassword;
    }
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, authUsername);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), authPassword);
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(authUsername)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(authUsername));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(authUsername, queryForGroups(ctx, authUsername, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = authenticate(username, who.getPassword());
        } else {
            ctx = open();
        }
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private void authenticate(String dn, String password) throws AccountException {
    final Properties env = createContextProperties();
    env.put(Context.SECURITY_AUTHENTICATION, "simple");
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        new InitialDirContext(env).close();
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#method_after
private DirContext authenticate(String dn, String password) throws AccountException {
    final Properties env = createContextProperties();
    env.put(Context.SECURITY_AUTHENTICATION, "simple");
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        return new InitialDirContext(env);
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#end_block

#method_before
private List<ReplicationConfig> allConfigs(final File path) throws ConfigInvalidException, IOException {
    final File cfgFile = new File(path, "replication.config");
    final FileBasedConfig cfg = new FileBasedConfig(cfgFile);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfgFile + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg));
    }
    return Collections.unmodifiableList(r);
}
#method_after
private List<ReplicationConfig> allConfigs(final File path) throws ConfigInvalidException, IOException {
    final File cfgFile = new File(path, "replication.config");
    final FileBasedConfig cfg = new FileBasedConfig(cfgFile);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfgFile + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg, database, replicationUserFactory));
    }
    return Collections.unmodifiableList(r);
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri) {
    try {
        if (!projectControlFactory.controlFor(project).isVisible()) {
            return;
        }
    } catch (NoSuchProjectException e1) {
        log.error("Internal error: project " + project + " not found during replication");
        return;
    }
    synchronized (pending) {
        PushOp e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project.get(), uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri) {
    try {
        if (authEnabled && !projectControlFactory.controlFor(project).isVisible()) {
            return;
        }
    } catch (NoSuchProjectException e1) {
        log.error("Internal error: project " + project + " not found during replication");
        return;
    }
    synchronized (pending) {
        PushOp e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project.get(), uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
    }
}
#end_block

#method_before
@Override
public Set<Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        effectiveGroups = new HashSet<Id>();
        if (authGroupNames == null) {
            effectiveGroups.addAll(authConfig.getAnonymousGroups());
        } else {
            effectiveGroups.addAll(authConfig.getRegisteredGroups());
            for (String authGroupName : authGroupNames) {
                AccountGroup group = groupCache.lookup(authGroupName);
                if (group != null) {
                    effectiveGroups.add(group.getId());
                }
            }
        }
    }
    return effectiveGroups;
}
#method_after
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    return Collections.unmodifiableSet(effectiveGroups);
}
#end_block

#method_before
@Override
public Set<Change.Id> getStarredChanges() {
    return null;
}
#method_after
@Override
public Set<Change.Id> getStarredChanges() {
    return Collections.emptySet();
}
#end_block

#method_before
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg.setFindReplaceList(Gerrit.getConfig().getCommentLinks());
    msg = msg.runFindReplaceList();
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#method_after
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg = msg.replaceAll(Gerrit.getConfig().getCommentLinks());
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#end_block

#method_before
protected void setMessageText(String message) {
    if (message == null) {
        message = "";
    } else {
        message = message.trim();
    }
    messageSummary.setText(summarize(message));
    SafeHtml msg = new SafeHtmlBuilder().append(message);
    msg.setFindReplaceList(Gerrit.getConfig().getCommentLinks());
    SafeHtml.set(messageText, msg.wikify().runFindReplaceList());
}
#method_after
protected void setMessageText(String message) {
    if (message == null) {
        message = "";
    } else {
        message = message.trim();
    }
    messageSummary.setText(summarize(message));
    SafeHtml.set(messageText, new SafeHtmlBuilder().append(message).wikify().replaceAll(Gerrit.getConfig().getCommentLinks()));
}
#end_block

#method_before
private GerritConfig create() {
    final GerritConfig config = new GerritConfig();
    config.setCanonicalUrl(canonicalWebUrl);
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseRepoDownload(cfg.getBoolean("repo", null, "showdownloadcommand", false));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    final String gitwebUrl = cfg.getString("gitweb", null, "url");
    if (gitwebUrl != null) {
        config.setGitwebLink(new GitwebLink(gitwebUrl));
    }
    config.setSshdAddress(sshInfo != null ? sshInfo.getSshdAddress() : null);
    ArrayList<String> commentLinkNames = new ArrayList<String>(cfg.getSubsections("CommentLink"));
    ArrayList<RegexFindReplace> commentLinks = new ArrayList<RegexFindReplace>(commentLinkNames.size());
    for (String commentLinkName : commentLinkNames) {
        String match = cfg.getString("CommentLink", commentLinkName, "match");
        String link = cfg.getString("CommentLink", commentLinkName, "link");
        commentLinks.add(new RegexFindReplace(match, link));
    }
    config.setCommentLinks(commentLinks);
    return config;
}
#method_after
private GerritConfig create() {
    final GerritConfig config = new GerritConfig();
    config.setCanonicalUrl(canonicalWebUrl);
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseRepoDownload(cfg.getBoolean("repo", null, "showdownloadcommand", false));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    final String gitwebUrl = cfg.getString("gitweb", null, "url");
    if (gitwebUrl != null) {
        config.setGitwebLink(new GitwebLink(gitwebUrl));
    }
    config.setSshdAddress(sshInfo != null ? sshInfo.getSshdAddress() : null);
    ArrayList<String> commentLinkNames = new ArrayList<String>(cfg.getSubsections("CommentLink"));
    ArrayList<RegexFindReplace> commentLinks = new ArrayList<RegexFindReplace>(commentLinkNames.size());
    for (String commentLinkName : commentLinkNames) {
        String match = cfg.getString("commentlink", commentLinkName, "match");
        String link = "<a href=\"" + cfg.getString("commentlink", commentLinkName, "link") + "\">$&</a>";
        commentLinks.add(new RegexFindReplace(match, link));
    }
    config.setCommentLinks(commentLinks);
    return config;
}
#end_block

#method_before
public SafeHtml replaceAll(final String regex, final String repl) {
    return new SafeHtmlString(asString().replaceAll(regex, repl));
}
#method_after
public SafeHtml replaceAll(final List<RegexFindReplace> findReplaceList) {
    if (findReplaceList == null) {
        return this;
    }
    String html = this.asString();
    for (RegexFindReplace findReplace : findReplaceList) {
        html = html.replaceAll(findReplace.find(), findReplace.replace());
    }
    return new SafeHtmlString(html);
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            who.setDisplayName(m.get(accountFullName));
            who.setSshUserName(m.get(accountSshUserName));
            if (accountEmailAddress != null) {
                who.setEmailAddress(m.get(accountEmailAddress));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setSshUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    final HashMap<String, String> params = new HashMap<String, String>();
    params.put(USERNAME, username);
    if (groupNeedsAccount) {
        if (account == null) {
            account = findAccount(ctx, username);
        }
        for (final String name : groupMemberQueryList.get(0).getParameters()) {
            params.put(name, account.get(name));
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (LdapQuery groupMemberQuery : groupMemberQueryList) {
        for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
            NamingEnumeration groups = r.getAll(memberField).getAll();
            while (groups.hasMore()) {
                final String name = String.valueOf(groups.next());
                final AccountGroup group = groupCache.lookup(name);
                if (group != null && isLdapGroup(group)) {
                    actual.add(group.getId());
                }
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#method_after
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    if (account == null) {
        account = findAccount(ctx, username);
    }
    final HashMap<String, String> params = new HashMap<String, String>();
    params.put(USERNAME, username);
    if (groupNeedsAccount) {
        for (final String name : groupMemberQueryList.get(0).getParameters()) {
            params.put(name, account.get(name));
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (LdapQuery groupMemberQuery : groupMemberQueryList) {
        for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
            final String name = r.get(groupName);
            final AccountGroup group = groupCache.lookup(name);
            if (group != null && isLdapGroup(group)) {
                actual.add(group.getId());
            }
        }
    }
    NamingEnumeration groups = account.getAll(accountMemberField).getAll();
    while (groups.hasMore()) {
        final String dn = (String) groups.next();
        for (String cn : groupsFor(ctx, dn)) {
            AccountGroup group = groupCache.lookup(cn);
            if (null != group && isLdapGroup(group)) {
                actual.add(group.getId());
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#end_block

#method_before
@Override
public List<RealmProperty> getProperties(final AccountGroup group) {
    if (!isLdapGroup(group)) {
        return Collections.emptyList();
    }
    try {
        final DirContext ctx = open();
        try {
            final Map<String, String> params = new HashMap<String, String>();
            params.put(GROUPNAME, group.getName());
            final List<RealmProperty> props = new ArrayList<RealmProperty>();
            final List<LdapQuery.Result> q = new ArrayList<LdapQuery.Result>();
            for (LdapQuery groupByNameQuery : groupByNameQueryList) {
                q.addAll(groupByNameQuery.query(ctx, params));
            }
            switch(q.size()) {
                case 0:
                    log.warn("Group \"" + group.getName() + "\" not found in LDAP.");
                    props.add(new RealmProperty("error", "NOT FOUND"));
                    break;
                case 1:
                    for (final String name : q.get(0).keySet()) {
                        props.add(new RealmProperty(name, q.get(0).get(name)));
                    }
                    Collections.sort(props, new Comparator<RealmProperty>() {

                        @Override
                        public int compare(final RealmProperty a, final RealmProperty b) {
                            int sort = classOf(a) - classOf(b);
                            if (sort == 0)
                                sort = a.getName().compareTo(b.getName());
                            return sort;
                        }

                        private int classOf(final RealmProperty p) {
                            final String n = p.getName();
                            if ("dn".equals(n) || "distinguishedName".equals(n))
                                return 0;
                            if ("cn".equals(n))
                                return 1;
                            return 5000;
                        }
                    });
                    break;
                default:
                    log.warn("Group \"" + group.getName() + "\" has multiple matches in LDAP: " + q);
                    props.add(new RealmProperty("error", "MULTIPLE MATCHES"));
                    break;
            }
            return props;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP directory for group " + group.getName(), e);
        return Collections.emptyList();
    }
}
#method_after
@Override
public List<RealmProperty> getProperties(final AccountGroup group) {
    if (!isLdapGroup(group)) {
        return Collections.emptyList();
    }
    try {
        final DirContext ctx = open();
        try {
            final Map<String, String> params = new HashMap<String, String>();
            params.put(GROUPNAME, group.getName());
            final List<RealmProperty> props = new ArrayList<RealmProperty>();
            final List<LdapQuery.Result> q = new ArrayList<LdapQuery.Result>();
            for (LdapQuery groupByNameQuery : groupByNameQueryList) {
                q.addAll(groupByNameQuery.query(ctx, params));
            }
            switch(q.size()) {
                case 0:
                    log.warn("Group \"" + group.getName() + "\" not found in LDAP.");
                    props.add(new RealmProperty("error", "NOT FOUND"));
                    break;
                case 1:
                    for (final String name : q.get(0).map().keySet()) {
                        props.add(new RealmProperty(name, q.get(0).get(name)));
                    }
                    Collections.sort(props, new Comparator<RealmProperty>() {

                        @Override
                        public int compare(final RealmProperty a, final RealmProperty b) {
                            int sort = classOf(a) - classOf(b);
                            if (sort == 0)
                                sort = a.getName().compareTo(b.getName());
                            return sort;
                        }

                        private int classOf(final RealmProperty p) {
                            final String n = p.getName();
                            if ("dn".equals(n) || "distinguishedName".equals(n))
                                return 0;
                            if ("cn".equals(n))
                                return 1;
                            return 5000;
                        }
                    });
                    break;
                default:
                    log.warn("Group \"" + group.getName() + "\" has multiple matches in LDAP: " + q);
                    props.add(new RealmProperty("error", "MULTIPLE MATCHES"));
                    break;
            }
            return props;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP directory for group " + group.getName(), e);
        return Collections.emptyList();
    }
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            who.setDisplayName(m.get(accountFullName));
            who.setSshUserName(m.get(accountSshUserName));
            if (accountEmailAddress != null) {
                who.setEmailAddress(m.get(accountEmailAddress));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
private void authenticate(String dn, String password) throws AccountException {
    final Properties env = new Properties();
    env.put(Context.INITIAL_CONTEXT_FACTORY, LDAP);
    env.put(Context.PROVIDER_URL, server);
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        new InitialDirContext(env).close();
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#end_block

#method_before
@Override
public String toString() {
    String data = "";
    try {
        String.valueOf(atts.get("dn").get(0));
    } catch (NamingException e) {
    }
    return data;
}
#method_after
@Override
public String toString() {
    try {
        return getDN();
    } catch (NamingException e) {
        return "";
    }
}
#end_block

#method_before
public static String toProject(final Project.NameKey proj, Status status) {
    switch(status) {
        case ABANDONED:
            return "project,abandoned," + proj.toString() + ",n,z";
        case MERGED:
            return "project,merged," + proj.toString() + ",n,z";
        default:
            return "project,open," + proj.toString() + ",n,z";
    }
}
#method_after
public static String toProject(final Project.NameKey proj, Status status) {
    switch(status) {
        case ABANDONED:
            return "project,abandoned," + proj.toString() + ",n,z";
        case MERGED:
            return "project,merged," + proj.toString() + ",n,z";
        case NEW:
        case SUBMITTED:
        default:
            return "project,open," + proj.toString() + ",n,z";
    }
}
#end_block

#method_before
@Override
protected Screen createScreen() {
    switch(status) {
        case ABANDONED:
            return new ByProjectAbandonedChangesScreen(project, "n,z");
        case MERGED:
            return new ByProjectMergedChangesScreen(project, "n,z");
        default:
            return new ByProjectOpenChangesScreen(project, "n,z");
    }
}
#method_after
@Override
protected Screen createScreen() {
    switch(status) {
        case ABANDONED:
            return new ByProjectAbandonedChangesScreen(project, "n,z");
        case MERGED:
            return new ByProjectMergedChangesScreen(project, "n,z");
        case NEW:
        case SUBMITTED:
        default:
            return new ByProjectOpenChangesScreen(project, "n,z");
    }
}
#end_block

#method_before
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#method_after
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
private static List<String> optionalList(final Config config, final String name) {
    String[] s = config.getStringList("ldap", null, name);
    if (s == null || s.length == 0) {
        return null;
    }
    final List<String> vlist = new ArrayList<String>();
    for (int i = 0; i < s.length; i++) {
        vlist.add(s[i]);
    }
    return vlist;
}
#method_after
private static List<String> optionalList(final Config config, final String name) {
    String[] s = config.getStringList("ldap", null, name);
    return Arrays.asList(s);
}
#end_block

#method_before
private static List<String> requiredList(final Config config, final String name) {
    List<String> vlist = optionalList(config, name);
    if (vlist == null) {
        throw new IllegalArgumentException("No ldap." + name + " configured");
    }
    return vlist;
}
#method_after
private static List<String> requiredList(final Config config, final String name) {
    List<String> vlist = optionalList(config, name);
    if (vlist.isEmpty()) {
        throw new IllegalArgumentException("No ldap " + name + " configured");
    }
    return vlist;
}
#end_block

#method_before
public void strongestApprovals(final Change.Id id, final AsyncCallback<ApprovalDetail> callback) {
    run(callback, new Action<ApprovalDetail>() {

        public ApprovalDetail run(ReviewDb db) throws OrmException {
            final List<PatchSet> last_pset = db.patchSets().lastChange(id).toList();
            if (last_pset.isEmpty()) {
                return null;
            }
            final PatchSet.Id ps_id = last_pset.get(0).getId();
            final Map<ApprovalCategory.Id, PatchSetApproval> have = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
            for (PatchSetApproval a : db.patchSetApprovals().byPatchSet(ps_id)) {
                boolean keep = true;
                if (have.containsKey(a.getCategoryId())) {
                    final short oldValue = have.get(a.getCategoryId()).getValue();
                    final short newValue = a.getValue();
                    keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                }
                if (keep) {
                    have.put(a.getCategoryId(), a);
                }
            }
            final ApprovalDetail ad = new ApprovalDetail(getAccountId());
            for (PatchSetApproval a : have.values()) {
                ad.add(a);
            }
            return ad;
        }
    });
}
#method_after
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        fs.normalize(approvalTypes.getApprovalType(ca.getCategoryId()), ca);
                        boolean keep = true;
                        if (psas.containsKey(ca.getCategoryId())) {
                            final short oldValue = psas.get(ca.getCategoryId()).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(ca.getCategoryId(), ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /* The user has no access to see this change, so we
             * simply do not provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable(true);
    byOwner = new ChangeTable.Section("", ChangeTable.ApprovalViewType.STRONGEST);
    forReview = new ChangeTable.Section("", ChangeTable.ApprovalViewType.MINE);
    closed = new ChangeTable.Section("", ChangeTable.ApprovalViewType.STRONGEST);
    table.addSection(byOwner);
    table.addSection(forReview);
    table.addSection(closed);
    add(table);
    table.setSavePointerId(Link.toAccountDashboard(ownerId));
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable(true);
    byOwner = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null);
    forReview = new ChangeTable.Section("", ApprovalViewType.USER, ownerId);
    closed = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null);
    table.addSection(byOwner);
    table.addSection(forReview);
    table.addSection(closed);
    add(table);
    table.setSavePointerId(Link.toAccountDashboard(ownerId));
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, S_ICON_CELL);
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, S_DATA_CELL);
    }
    fmt.addStyleName(row, C_ID, S_C_ID);
    fmt.addStyleName(row, C_SUBJECT, S_C_SUBJECT);
    fmt.addStyleName(row, C_PROJECT, S_C_PROJECT);
    fmt.addStyleName(row, C_BRANCH, S_C_PROJECT);
    fmt.addStyleName(row, C_LAST_UPDATE, S_C_LAST_UPDATE);
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, "approvalscore");
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, S_ICON_CELL);
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, S_DATA_CELL);
    }
    fmt.addStyleName(row, C_ID, S_C_ID);
    fmt.addStyleName(row, C_SUBJECT, S_C_SUBJECT);
    fmt.addStyleName(row, C_PROJECT, S_C_PROJECT);
    fmt.addStyleName(row, C_BRANCH, S_C_PROJECT);
    fmt.addStyleName(row, C_LAST_UPDATE, S_C_LAST_UPDATE);
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, final ApprovalViewType viewType) {
    final String idstr = c.getKey().abbreviate();
    table.setWidget(row, C_ARROW, null);
    if (Gerrit.isSignedIn()) {
        setStar(row, c);
    }
    table.setWidget(row, C_ID, new TableChangeLink(idstr, c));
    String s = c.getSubject();
    if (s.length() > 80) {
        s = s.substring(0, 80);
    }
    if (c.getStatus() != null && c.getStatus() != Change.Status.NEW) {
        s += " (" + c.getStatus().name() + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(s, c));
    table.setWidget(row, C_OWNER, link(c.getOwner()));
    table.setWidget(row, C_PROJECT, new ProjectOpenLink(c.getProject().getKey()));
    table.setText(row, C_BRANCH, c.getBranch());
    table.setText(row, C_LAST_UPDATE, mediumFormat(c.getLastUpdatedOn()));
    switch(viewType) {
        case NONE:
            break;
        case MINE:
            PatchUtil.DETAIL_SVC.myApprovals(c.getId(), approvalFormatter(row));
            break;
        case STRONGEST:
            PatchUtil.DETAIL_SVC.strongestApprovals(c.getId(), approvalFormatter(row));
            break;
    }
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c) {
    final String idstr = c.getKey().abbreviate();
    table.setWidget(row, C_ARROW, null);
    if (Gerrit.isSignedIn()) {
        setStar(row, c);
    }
    table.setWidget(row, C_ID, new TableChangeLink(idstr, c));
    String s = c.getSubject();
    if (s.length() > 80) {
        s = s.substring(0, 80);
    }
    if (c.getStatus() != null && c.getStatus() != Change.Status.NEW) {
        s += " (" + c.getStatus().name() + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(s, c));
    table.setWidget(row, C_OWNER, link(c.getOwner()));
    table.setWidget(row, C_PROJECT, new ProjectOpenLink(c.getProject().getKey()));
    table.setText(row, C_BRANCH, c.getBranch());
    table.setText(row, C_LAST_UPDATE, mediumFormat(c.getLastUpdatedOn()));
    setRowItem(row, c);
}
#end_block

#method_before
GerritCallback<ApprovalDetail> approvalFormatter(final int row) {
    return new GerritCallback<ApprovalDetail>() {

        @Override
        public void onSuccess(final ApprovalDetail detail) {
            final CellFormatter fmt = table.getCellFormatter();
            final Map<ApprovalCategory.Id, PatchSetApproval> am = detail.getApprovalMap();
            int col = BASE_COLUMNS;
            for (final ApprovalType type : approvalTypes) {
                final PatchSetApproval ca = am.get(type.getCategory().getId());
                if (ca == null || ca.getValue() == 0) {
                    table.clearCell(row, col);
                } else if (type.isMaxNegative(ca)) {
                    table.setWidget(row, col, Gerrit.ICONS.redNot().createImage());
                } else if (type.isMaxPositive(ca)) {
                    table.setWidget(row, col, Gerrit.ICONS.greenCheck().createImage());
                } else {
                    String vstr = String.valueOf(ca.getValue());
                    if (ca.getValue() > 0) {
                        vstr = "+" + vstr;
                        fmt.removeStyleName(row, col, "negscore");
                        fmt.addStyleName(row, col, "posscore");
                    } else {
                        fmt.addStyleName(row, col, "negscore");
                        fmt.removeStyleName(row, col, "posscore");
                    }
                    table.setText(row, col, vstr);
                }
                col++;
            }
        }
    };
}
#method_after
GerritCallback<ApprovalSummarySet> approvalFormatter(final int dataBegin, final int rows) {
    return new GerritCallback<ApprovalSummarySet>() {

        @Override
        public void onSuccess(final ApprovalSummarySet as) {
            Map<Change.Id, ApprovalSummary> ids = as.getSummaryMap();
            AccountInfoCache aic = as.getAccountInfoCache();
            for (int row = dataBegin; row < dataBegin + rows; row++) {
                final ChangeInfo c = getRowItem(row);
                if (ids.containsKey(c.getId())) {
                    displayApprovals(row, ids.get(c.getId()), aic);
                }
            }
        }
    };
}
#end_block

#method_before
public void display(final List<ChangeInfo> changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    }
    if (sz == 0) {
        if (hadData) {
            parent.insertNoneRow(dataBegin);
        }
    } else {
        if (!hadData) {
            parent.removeRow(dataBegin);
        }
        while (rows < sz) {
            parent.insertChangeRow(dataBegin + rows);
            rows++;
        }
        for (int i = 0; i < sz; i++) {
            parent.populateChangeRow(dataBegin + i, changeList.get(i), viewType);
        }
    }
}
#method_after
public void display(final List<ChangeInfo> changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    }
    if (sz == 0) {
        if (hadData) {
            parent.insertNoneRow(dataBegin);
        }
    } else {
        Set<Change.Id> cids = new HashSet<Change.Id>();
        if (!hadData) {
            parent.removeRow(dataBegin);
        }
        while (rows < sz) {
            parent.insertChangeRow(dataBegin + rows);
            rows++;
        }
        for (int i = 0; i < sz; i++) {
            ChangeInfo c = changeList.get(i);
            parent.populateChangeRow(dataBegin + i, c);
            cids.add(c.getId());
        }
        switch(viewType) {
            case NONE:
                break;
            case USER:
                PatchUtil.DETAIL_SVC.userApprovals(cids, ownerId, parent.approvalFormatter(dataBegin, rows));
                break;
            case STRONGEST:
                PatchUtil.DETAIL_SVC.strongestApprovals(cids, parent.approvalFormatter(dataBegin, rows));
                break;
        }
    }
}
#end_block

#method_before
protected final CmdLineParser newCmdLineParserInstance(final Object bean) {
    Field f = null;
    ApproveCmdLineParser parser = new ApproveCmdLineParser(bean);
    try {
        f = CmdOption.class.getField("value");
        for (CmdOption c : optionList) {
            parser.addOption(new FieldSetter(c, f), c);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return parser;
}
#method_after
protected final CmdLineParser newCmdLineParserInstance(final Object bean) {
    CmdLineParser parser = new CmdLineParser(bean);
    for (CmdOption c : optionList) {
        parser.addOption(c, c);
    }
    return parser;
}
#end_block

#method_before
@Override
public final void start() throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            getApprovalNames();
            parseCommandLine();
            PrintWriter p = toPrintWriter(out);
            validateParameters();
            try {
                final Transaction txn = db.beginTransaction();
                final Change.Id cid = new Change.Id(changeId);
                final Change c = db.changes().get(cid);
                StringBuffer sb = new StringBuffer();
                sb.append("Patch Set: ");
                sb.append(c.currentPatchSetId().get());
                sb.append(" ");
                for (CmdOption co : optionList) {
                    String message = "";
                    Short score = co.value();
                    ApprovalCategory.Id category = new ApprovalCategory.Id(co.approvalKey());
                    if (co.value() != null) {
                        addApproval(c, category, co.value(), txn);
                    } else {
                        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(c.currentPatchSetId(), currentUser.getAccountId(), category);
                        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
                        if (psa == null) {
                            score = null;
                        } else {
                            score = psa.getValue();
                        }
                    }
                    if (score != null) {
                        message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
                    }
                    sb.append(" " + message + ";");
                }
                sb.deleteCharAt(sb.length() - 1);
                sb.append("\n\n");
                if (changeComment != null) {
                    sb.append(changeComment);
                }
                String uuid = ChangeUtil.messageUUID(db);
                ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(cid, uuid), currentUser.getAccountId());
                cm.setMessage(sb.toString());
                db.changeMessages().insert(Collections.singleton(cm), txn);
                ChangeUtil.updated(c);
                db.changes().update(Collections.singleton(c), txn);
                txn.commit();
                sendMail(c, c.currentPatchSetId(), cm);
                p.print(sb.toString() + "\n");
                p.flush();
            } catch (OrmException e) {
                throw new Failure(CMD_ERR, "Error accessing the database\n" + "Detailed message:\n" + e.getMessage());
            } catch (EmailException e) {
                throw new Failure(CMD_ERR, "Error when trying to send email\n" + "Detailed message:\n" + e.getMessage());
            } catch (Exception e) {
                throw new Failure(CMD_ERR, "Received an error\n" + "Detailed message:\n" + e.getMessage());
            }
        }
    });
}
#method_after
@Override
public final void start() throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            getApprovalNames();
            parseCommandLine();
            final Transaction txn = db.beginTransaction();
            final PatchSet ps = db.patchSets().get(patchSetId);
            if (ps == null) {
                throw new UnloggedFailure(CMD_ERR, "Invalid patchset id");
            }
            final Change.Id cid = ps.getId().getParentKey();
            final ChangeControl control = changeControlFactory.validateFor(cid);
            final Change c = control.getChange();
            if (c.getStatus().isClosed()) {
                throw new UnloggedFailure(CMD_ERR, "Change is closed.");
            }
            StringBuffer sb = new StringBuffer();
            sb.append("Patch Set ");
            sb.append(patchSetId.get());
            sb.append(": ");
            for (CmdOption co : optionList) {
                ApprovalCategory.Id category = new ApprovalCategory.Id(co.approvalKey());
                PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
                PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
                Short score = co.value();
                if (score != null) {
                    addApproval(psaKey, score, c, co, txn);
                } else {
                    if (psa == null) {
                        score = 0;
                        addApproval(psaKey, score, c, co, txn);
                    } else {
                        score = psa.getValue();
                    }
                }
                String message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
                sb.append(" " + message + ";");
            }
            sb.deleteCharAt(sb.length() - 1);
            sb.append("\n\n");
            if (changeComment != null) {
                sb.append(changeComment);
            }
            String uuid = ChangeUtil.messageUUID(db);
            ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(cid, uuid), currentUser.getAccountId());
            cm.setMessage(sb.toString());
            db.changeMessages().insert(Collections.singleton(cm), txn);
            ChangeUtil.updated(c);
            db.changes().update(Collections.singleton(c), txn);
            txn.commit();
            sendMail(c, c.currentPatchSetId(), cm);
        }
    });
}
#end_block

#method_before
private void addApproval(final Change c, final ApprovalCategory.Id cat, final short score, final Transaction txn) throws OrmException {
    PatchSetApproval.Key psaKey = new PatchSetApproval.Key(c.currentPatchSetId(), currentUser.getAccountId(), cat);
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    if (psa == null) {
        psa = new PatchSetApproval(psaKey, score);
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        psa.setGranted();
        psa.setValue(score);
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#method_after
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final CmdOption co, final Transaction txn) throws OrmException, UnloggedFailure {
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    boolean insert = false;
    if (psa == null) {
        insert = true;
        psa = new PatchSetApproval(psaKey, score);
    }
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, patchSetId, approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw new UnloggedFailure(CMD_ERR, co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    if (insert) {
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#end_block

#method_before
private void getApprovalNames() throws OrmException {
    SortedMap<Short, String> acvMap = new TreeMap<Short, String>();
    optionList = new ArrayList<CmdOption>();
    ResultSet<ApprovalCategory> rs = db.approvalCategories().all();
    for (ApprovalCategory c : rs) {
        if (c.getFunctionName().equals("MaxWithBlock")) {
            ResultSet<ApprovalCategoryValue> acvrs = db.approvalCategoryValues().byCategory(c.getId());
            short min = Short.MAX_VALUE;
            short max = Short.MIN_VALUE;
            String usage = "";
            for (ApprovalCategoryValue acv : acvrs) {
                if (min > acv.getValue()) {
                    min = acv.getValue();
                }
                if (max < acv.getValue()) {
                    max = acv.getValue();
                }
                acvMap.put(acv.getValue(), acv.getName());
            }
            usage += "Score for " + c.getName() + "\n";
            // This is to make sure that the values are in sorted order.
            Iterator<Short> i = acvMap.keySet().iterator();
            while (i.hasNext()) {
                Short key = i.next();
                usage += String.format("%4d", key) + "  -  " + acvMap.get(key) + "\n";
            }
            optionList.add(new CmdOption("--" + c.getName().toLowerCase().replace(' ', '-'), usage, c.getId().get(), min, max, c.getName()));
            usage = "";
            acvMap.clear();
        }
    }
}
#method_after
private void getApprovalNames() throws OrmException {
    optionList = new ArrayList<CmdOption>();
    for (ApprovalType type : approvalTypes.getApprovalTypes()) {
        String usage = "";
        final ApprovalCategory category = type.getCategory();
        usage = "Score for " + category.getName() + "\n";
        for (ApprovalCategoryValue v : type.getValues()) {
            usage += String.format("%4d", v.getValue()) + "  -  " + v.getName() + "\n";
        }
        optionList.add(new CmdOption("--" + category.getName().toLowerCase().replace(' ', '-'), usage, category.getId().get(), type.getMin().getValue(), type.getMax().getValue(), category.getName()));
    }
}
#end_block

#method_before
private void createContext(final Grid parent, final int row, final int col) {
    parent.resizeRows(row + 1);
    // Show full files
    final CheckBox cb = new CheckBox(PatchUtil.C.showFullFiles());
    cb.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (event.getValue()) {
                // Show a diff of the full files
                scriptSettings.setContext(WHOLE_FILE_CONTEXT);
            } else {
                // Restore the context lines to the user's preference
                initContextLines();
            }
            refresh(false);
        }
    });
    parent.setWidget(row, col + 1, cb);
    // Keep unreviewed
    if (Gerrit.isSignedIn()) {
        final CheckBox ku = new CheckBox(PatchUtil.C.keepUnreviewed());
        ku.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

            @Override
            public void onValueChange(ValueChangeEvent<Boolean> event) {
                updateReviewedStatus(event.getValue() ? 0 : 1);
            }
        });
        parent.setWidget(row, col + 2, ku);
    }
}
#method_after
private void createContext(final Grid parent, final int row, final int col) {
    parent.resizeRows(row + 1);
    // Show full files
    final CheckBox cb = new CheckBox(PatchUtil.C.showFullFiles());
    cb.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (event.getValue()) {
                // Show a diff of the full files
                scriptSettings.setContext(WHOLE_FILE_CONTEXT);
            } else {
                // Restore the context lines to the user's preference
                initContextLines();
            }
            refresh(false);
        }
    });
    parent.setWidget(row, col + 1, cb);
    // "Reviewed" check box
    if (Gerrit.isSignedIn()) {
        final CheckBox ku = new CheckBox(PatchUtil.C.reviewed());
        ku.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

            @Override
            public void onValueChange(ValueChangeEvent<Boolean> event) {
                setReviewedByCurrentUser(event.getValue());
            }
        });
        // Checked by default
        ku.setValue(true);
        parent.setWidget(row, col + 2, ku);
    }
}
#end_block

#method_before
private Widget createNextPrevLinks() {
    final Grid table = new Grid(1, 3);
    final CellFormatter fmt = table.getCellFormatter();
    table.setStyleName("gerrit-SideBySideScreen-LinkTable");
    fmt.setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    fmt.setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_CENTER);
    fmt.setHorizontalAlignment(0, 2, HasHorizontalAlignment.ALIGN_RIGHT);
    // Next and previous
    if (fileList != null) {
        previousFileLink = fileList.getPreviousPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 0, previousFileLink);
        nextFileLink = fileList.getNextPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 2, nextFileLink);
    }
    // Keep unreviewed
    // Up
    final ChangeLink up = new ChangeLink("", patchKey.getParentKey().getParentKey());
    SafeHtml.set(up, SafeHtml.asis(Util.C.upToChangeIconLink()));
    table.setWidget(0, 1, up);
    return table;
}
#method_after
private Widget createNextPrevLinks() {
    final Grid table = new Grid(1, 3);
    final CellFormatter fmt = table.getCellFormatter();
    table.setStyleName("gerrit-SideBySideScreen-LinkTable");
    fmt.setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    fmt.setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_CENTER);
    fmt.setHorizontalAlignment(0, 2, HasHorizontalAlignment.ALIGN_RIGHT);
    if (fileList != null) {
        previousFileLink = fileList.getPreviousPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 0, previousFileLink);
        nextFileLink = fileList.getNextPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 2, nextFileLink);
    }
    final ChangeLink up = new ChangeLink("", patchKey.getParentKey().getParentKey());
    SafeHtml.set(up, SafeHtml.asis(Util.C.upToChangeIconLink()));
    table.setWidget(0, 1, up);
    return table;
}
#end_block

#method_before
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    // Mark this file reviewed
    if (Gerrit.isSignedIn()) {
        updateReviewedStatus(1);
    }
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                if (isNoDifferences(caught) && !isFirst) {
                    historyTable.enableAll(true);
                    showPatch(false);
                } else {
                    super.onFailure(caught);
                }
            }
        }

        private boolean isNoDifferences(final Throwable caught) {
            if (caught instanceof NoDifferencesException) {
                return true;
            }
            return caught instanceof RemoteJsonException && caught.getMessage().equals(NoDifferencesException.MESSAGE);
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#method_after
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        setReviewedByCurrentUser(true);
    }
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        if (contentTable instanceof SideBySideTable && script.getEdits().isEmpty() && !script.getPatchHeader().isEmpty()) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        // True if there are differences between the two patch sets
        boolean hasEdits = !script.getEdits().isEmpty();
        // True if this change is a mode change or a pure rename/copy
        boolean hasMeta = !script.getPatchHeader().isEmpty();
        boolean hasDifferences = hasEdits || hasMeta;
        boolean pureMetaChange = !hasEdits && hasMeta;
        if (contentTable instanceof SideBySideTable && pureMetaChange) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        if (hasDifferences) {
            contentTable.display(patchKey, idSideA, idSideB, script);
            contentTable.display(comments);
            contentTable.finishDisplay();
        }
        showPatch(hasDifferences);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
public void saveDraft(final PatchLineComment comment, final AsyncCallback<PatchLineComment> callback) {
    run(callback, new Action<PatchLineComment>() {

        public PatchLineComment run(ReviewDb db) throws OrmException, Failure {
            if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                throw new Failure(new IllegalStateException("Comment published"));
            }
            final Patch patch = db.patches().get(comment.getKey().getParentKey());
            final Change change;
            if (patch == null) {
                throw new Failure(new NoSuchEntityException());
            }
            change = db.changes().get(patch.getKey().getParentKey().getParentKey());
            assertCanRead(change);
            final Account.Id me = Common.getAccountId();
            if (comment.getKey().get() == null) {
                final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patch.getKey(), ChangeUtil.messageUUID(db)), comment.getLine(), me);
                nc.setSide(comment.getSide());
                nc.setMessage(comment.getMessage());
                db.patchComments().insert(Collections.singleton(nc));
                return nc;
            } else {
                if (!me.equals(comment.getAuthor())) {
                    throw new Failure(new NoSuchEntityException());
                }
                comment.updated();
                db.patchComments().update(Collections.singleton(comment));
                return comment;
            }
        }
    });
}
#method_after
public void saveDraft(final PatchLineComment comment, final AsyncCallback<PatchLineComment> callback) {
    run(callback, new Action<PatchLineComment>() {

        public PatchLineComment run(ReviewDb db) throws OrmException, Failure {
            if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                throw new Failure(new IllegalStateException("Comment published"));
            }
            final Patch patch = db.patches().get(comment.getKey().getParentKey());
            final Change change;
            if (patch == null) {
                throw new Failure(new NoSuchEntityException());
            }
            change = db.changes().get(patch.getKey().getParentKey().getParentKey());
            assertCanRead(change);
            final Account.Id me = Common.getAccountId();
            if (comment.getKey().get() == null) {
                final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patch.getKey(), ChangeUtil.messageUUID(db)), comment.getLine(), me, comment.getParentUuid());
                nc.setSide(comment.getSide());
                nc.setMessage(comment.getMessage());
                db.patchComments().insert(Collections.singleton(nc));
                return nc;
            } else {
                if (!me.equals(comment.getAuthor())) {
                    throw new Failure(new NoSuchEntityException());
                }
                comment.updated();
                db.patchComments().update(Collections.singleton(comment));
                return comment;
            }
        }
    });
}
#end_block

#method_before
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(S_ICON_CELL);
    m.addStyleName("LeftMostCell");
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName("ChangeTypeCell");
    m.append(p.getChangeType().getCode());
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("FilePathCell");
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("CommentCell");
    appendCommentCount(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(S_DATA_CELL);
        if (Gerrit.isSignedIn() && p.hasBeenReviewedBy(Gerrit.getUserAccount().getSshUserName())) {
            m.append(SafeHtml.asis(Gerrit.ICONS.greenCheck().getHTML()));
        } else {
            m.nbsp();
        }
        m.closeTd();
    }
    m.closeTr();
}
#method_after
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(S_ICON_CELL);
    m.addStyleName("LeftMostCell");
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName("ChangeTypeCell");
    m.append(p.getChangeType().getCode());
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("FilePathCell");
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("CommentCell");
    appendCommentCount(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    // Green check mark if the user is logged in and they reviewed that file
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(S_DATA_CELL);
        if (p.isReviewedByCurrentUser()) {
            m.append(SafeHtml.asis(Gerrit.ICONS.greenCheck().getHTML()));
        } else {
            m.nbsp();
        }
        m.closeTd();
    }
    m.closeTr();
}
#end_block

#method_before
@Override
protected void render(final PatchScript script) {
    final SparseFileContent a = script.getA();
    final SparseFileContent b = script.getB();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    if (directUrlLeft != null || directUrlRight != null) {
        // The left url can be null if a file is being added and the right url can be null if a
        // file is being deleted. They will both be non-null if this change is modifying an existing
        // file.
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("halign", "center");
        nc.openTd();
        maybeAppendImgTag(nc, directUrlLeft);
        nc.closeTd();
        nc.openTd();
        maybeAppendImgTag(nc, directUrlRight);
        nc.closeTd();
        nc.closeTr();
    } else {
        // result
        for (final String line : script.getPatchHeader()) {
            appendFileHeader(nc, line);
        }
    }
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final PatchScript.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.hasNextLine()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && a.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && b.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            }
            hunk.next();
        }
    }
    resetHtml(nc);
    onlyOneHunk = script.getEdits().size() == 1;
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n = "DiffText-" + l.getType().name();
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#method_after
@Override
protected void render(final PatchScript script) {
    final SparseFileContent a = script.getA();
    final SparseFileContent b = script.getB();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            } else {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final PatchScript.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.hasNextLine()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && a.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && b.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            }
            hunk.next();
        }
    }
    resetHtml(nc);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n = "DiffText-" + l.getType().name();
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, final PatchLine.Type type, final SparseFileContent src, final int i) {
    final int len = PatchUtil.DEFAULT_LINE_LENGTH;
    final String text = src.get(i);
    m.openTd();
    m.addStyleName("DiffText");
    m.addStyleName("DiffText-" + type.name());
    switch(type) {
        case CONTEXT:
            if ("".equals(text)) {
                m.nbsp();
            } else {
                m.append(" ");
                m.append(PatchUtil.lineToSafeHtml(text, len, false));
            }
            break;
        case DELETE:
            m.append("-");
            m.append(PatchUtil.lineToSafeHtml(text, len, false));
            break;
        case INSERT:
            m.append("+");
            m.append(PatchUtil.lineToSafeHtml(text, len, true));
            break;
    }
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, final PatchLine.Type type, final SparseFileContent src, final int i) {
    final int len = PatchUtil.DEFAULT_LINE_LENGTH;
    final String text = src.get(i);
    m.openTd();
    m.addStyleName("DiffText");
    m.addStyleName("DiffText-" + type.name());
    switch(type) {
        case CONTEXT:
            m.nbsp();
            break;
        case DELETE:
            m.append("-");
            break;
        case INSERT:
            m.append("+");
            break;
    }
    m.append(PatchUtil.lineToSafeHtml(text, len, false));
    m.closeTd();
}
#end_block

#method_before
private void openLine(final SafeHtmlBuilder m) {
    m.openTr();
    m.setAttribute("valign", "top");
    m.openTd();
    m.setStyleName(S_ICON_CELL);
    m.nbsp();
    m.closeTd();
}
#method_after
private void openLine(final SafeHtmlBuilder m) {
    m.openTr();
    m.setAttribute("valign", "top");
    m.openTd();
    m.setStyleName(S_ICON_CELL);
    m.closeTd();
}
#end_block

#method_before
private void padLineNumber(final SafeHtmlBuilder m) {
    m.openTd();
    m.setStyleName("LineNumber");
    m.nbsp();
    m.closeTd();
}
#method_after
private void padLineNumber(final SafeHtmlBuilder m) {
    m.openTd();
    m.setStyleName("LineNumber");
    m.closeTd();
}
#end_block

#method_before
public void display(final PatchSet.Id id, final List<Patch> list) {
    psid = id;
    myTable = null;
    final DisplayCommand cmd = new DisplayCommand(list);
    if (cmd.execute()) {
        cmd.initMeter();
        DeferredCommand.addCommand(cmd);
    } else {
        cmd.showTable();
    }
}
#method_after
public void display(final PatchSet.Id id, final List<Patch> list) {
    psid = id;
    myTable = null;
    patchList = list;
    final DisplayCommand cmd = new DisplayCommand(list);
    if (cmd.execute()) {
        cmd.initMeter();
        DeferredCommand.addCommand(cmd);
    } else {
        cmd.showTable();
    }
}
#end_block

#method_before
void initializeRow(List<Patch> patches, int row) {
    Patch patch = patches.get(row - 1);
    PatchSetKeys psk = new PatchSetKeys(patchesToKeys(patches), row - 1, PatchTable.this.psid.getParentKey());
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(patch.getFileName(), psk);
    } else {
        nameCol = new PatchLink.Unified(patch.getFileName(), psk);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName("SourceFilePath");
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), psk));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), psk));
}
#method_after
void initializeRow(int row) {
    Patch patch = PatchTable.this.patchList.get(row - 1);
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(patch.getFileName(), patch.getKey(), row - 1, PatchTable.this);
    } else {
        nameCol = new PatchLink.Unified(patch.getFileName(), patch.getKey(), row - 1, PatchTable.this);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName("SourceFilePath");
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), patch.getKey(), row - 1, PatchTable.this));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), patch.getKey(), row - 1, PatchTable.this));
}
#end_block

#method_before
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
            }
            while (row < list.size()) {
                table.appendRow(nc, list.get(row));
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(list, row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#method_after
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
            }
            while (row < list.size()) {
                table.appendRow(nc, list.get(row));
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    add(historyPanel);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    fileList = null;
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    fp.add(noDifference);
    fp.add(contentTable);
    add(fp);
    // Links to the next/previous file
    FlexTable dp = new FlexTable();
    dp.setStyleName("gerrit-SideBySideScreen-LinkTable");
    dp.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    dp.getFlexCellFormatter().setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_RIGHT);
    if (previousPatchLink != null)
        dp.setWidget(0, 0, previousPatchLink);
    if (nextPatchLink != null)
        dp.setWidget(0, 1, nextPatchLink);
    add(dp);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    add(historyPanel);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    fp.add(noDifference);
    fp.add(contentTable);
    add(fp);
    add(createNextPrevLinks());
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        display();
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
@Override
protected Screen createScreen() {
    return new PatchScreen.SideBySide(patch.getKey(), patch, parentPatchTable());
}
#method_after
@Override
protected Screen createScreen() {
    return new PatchScreen.SideBySide(patchKey, patchIndex, parentPatchTable);
}
#end_block

#method_before
@Override
protected Screen createScreen() {
    return new PatchScreen.Unified(patch.getKey(), patch, parentPatchTable());
}
#method_after
@Override
protected Screen createScreen() {
    return new PatchScreen.Unified(patchKey, patchIndex, parentPatchTable);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName("gerrit-PatchComments");
                draftsPanel.add(panel);
                panel.add(new PatchLink.SideBySide(fn, new PatchSetKeys(patchKey)));
                priorFile = fn;
            }
            Label m;
            m = new DoubleClickLinkLabel(patchKey);
            m.setText(Util.M.lineHeader(c.getLine()));
            m.setStyleName("gerrit-LineHeader");
            panel.add(m);
            m = new DoubleClickLinkLabel(patchKey);
            SafeHtml.set(m.getElement(), LineCommentPanel.toSafeHtml(c));
            m.setStyleName("gerrit-PatchLineComment");
            panel.add(m);
        }
    }
}
#method_after
private void display(final PatchSetPublishDetail r) {
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName("gerrit-PatchComments");
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any next/previous links
                panel.add(new PatchLink.SideBySide(fn, patchKey, 0, null));
                priorFile = fn;
            }
            Label m;
            m = new DoubleClickLinkLabel(patchKey);
            m.setText(Util.M.lineHeader(c.getLine()));
            m.setStyleName("gerrit-LineHeader");
            panel.add(m);
            m = new DoubleClickLinkLabel(patchKey);
            SafeHtml.set(m.getElement(), LineCommentPanel.toSafeHtml(c));
            m.setStyleName("gerrit-PatchLineComment");
            panel.add(m);
        }
    }
}
#end_block

#method_before
private Screen select(final String token) {
    String p;
    if (token == null) {
        return null;
    }
    if (SETTINGS.equals(token) || token.startsWith("settings,")) {
        if (SETTINGS_NEW_AGREEMENT.equals(token)) {
            return new NewAgreementScreen();
        }
        return new AccountSettings(token);
    }
    if (MINE.equals(token)) {
        return new AccountDashboardScreen(Common.getAccountId());
    }
    if (token.startsWith("mine,")) {
        if (MINE_STARRED.equals(token)) {
            return new MineStarredScreen();
        }
        if (MINE_DRAFTS.equals(token)) {
            return new MineDraftsScreen();
        }
    }
    if (token.startsWith("all,")) {
        p = "all,abandoned,";
        if (token.startsWith(p)) {
            return new AllAbandonedChangesScreen(skip(p, token));
        }
        p = "all,merged,";
        if (token.startsWith(p)) {
            return new AllMergedChangesScreen(skip(p, token));
        }
        p = "all,open,";
        if (token.startsWith(p)) {
            return new AllOpenChangesScreen(skip(p, token));
        }
    }
    if (token.startsWith("project,")) {
        p = "project,open,";
        if (token.startsWith(p)) {
            final String s = skip(p, token);
            final int c = s.indexOf(',');
            return new ByProjectOpenChangesScreen(Project.NameKey.parse(s.substring(0, c)), s.substring(c + 1));
        }
    }
    if (token.startsWith("patch,")) {
        p = "patch,sidebyside,";
        if (token.startsWith(p))
            return new PatchScreen.SideBySide(Patch.Key.parse(skip(p, token)), null, /* patch */
            null);
        p = "patch,unified,";
        if (token.startsWith(p))
            return new PatchScreen.Unified(Patch.Key.parse(skip(p, token)), null, /* patch */
            null);
    }
    p = "change,publish,";
    if (token.startsWith(p))
        return new PublishCommentScreen(PatchSet.Id.parse(skip(p, token)));
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    if (token.startsWith("admin,")) {
        p = "admin,group,";
        if (token.startsWith(p))
            return new AccountGroupScreen(AccountGroup.Id.parse(skip(p, token)));
        p = "admin,project,";
        if (token.startsWith(p)) {
            p = skip(p, token);
            final int c = p.indexOf(',');
            final String idstr = p.substring(0, c);
            return new ProjectAdminScreen(Project.Id.parse(idstr), token);
        }
        if (ADMIN_GROUPS.equals(token)) {
            return new GroupListScreen();
        }
        if (ADMIN_PROJECTS.equals(token)) {
            return new ProjectListScreen();
        }
    }
    p = "VE,";
    if (token.startsWith(p)) {
        return new ValidateEmailScreen(skip(p, token));
    }
    return null;
}
#method_after
private Screen select(final String token) {
    String p;
    if (token == null) {
        return null;
    }
    if (SETTINGS.equals(token) || token.startsWith("settings,")) {
        if (SETTINGS_NEW_AGREEMENT.equals(token)) {
            return new NewAgreementScreen();
        }
        return new AccountSettings(token);
    }
    if (MINE.equals(token)) {
        return new AccountDashboardScreen(Common.getAccountId());
    }
    if (token.startsWith("mine,")) {
        if (MINE_STARRED.equals(token)) {
            return new MineStarredScreen();
        }
        if (MINE_DRAFTS.equals(token)) {
            return new MineDraftsScreen();
        }
    }
    if (token.startsWith("all,")) {
        p = "all,abandoned,";
        if (token.startsWith(p)) {
            return new AllAbandonedChangesScreen(skip(p, token));
        }
        p = "all,merged,";
        if (token.startsWith(p)) {
            return new AllMergedChangesScreen(skip(p, token));
        }
        p = "all,open,";
        if (token.startsWith(p)) {
            return new AllOpenChangesScreen(skip(p, token));
        }
    }
    if (token.startsWith("project,")) {
        p = "project,open,";
        if (token.startsWith(p)) {
            final String s = skip(p, token);
            final int c = s.indexOf(',');
            return new ByProjectOpenChangesScreen(Project.NameKey.parse(s.substring(0, c)), s.substring(c + 1));
        }
    }
    if (token.startsWith("patch,")) {
        p = "patch,sidebyside,";
        if (token.startsWith(p))
            return new PatchScreen.SideBySide(Patch.Key.parse(skip(p, token)), 0, /* patchIndex */
            null);
        p = "patch,unified,";
        if (token.startsWith(p))
            return new PatchScreen.Unified(Patch.Key.parse(skip(p, token)), 0, /* patchIndex */
            null);
    }
    p = "change,publish,";
    if (token.startsWith(p))
        return new PublishCommentScreen(PatchSet.Id.parse(skip(p, token)));
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    if (token.startsWith("admin,")) {
        p = "admin,group,";
        if (token.startsWith(p))
            return new AccountGroupScreen(AccountGroup.Id.parse(skip(p, token)));
        p = "admin,project,";
        if (token.startsWith(p)) {
            p = skip(p, token);
            final int c = p.indexOf(',');
            final String idstr = p.substring(0, c);
            return new ProjectAdminScreen(Project.Id.parse(idstr), token);
        }
        if (ADMIN_GROUPS.equals(token)) {
            return new GroupListScreen();
        }
        if (ADMIN_PROJECTS.equals(token)) {
            return new ProjectListScreen();
        }
    }
    p = "VE,";
    if (token.startsWith(p)) {
        return new ValidateEmailScreen(skip(p, token));
    }
    return null;
}
#end_block

#method_before
private void populateAbandonAction() {
    final Button b = new Button(Util.C.buttonAbandonChangeBegin());
    b.addClickListener(new ClickListener() {

        public void onClick(Widget sender) {
            b.setEnabled(false);
            new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<Object>() {

                public void onSuccess(Object result) {
                    actionsPanel.remove(b);
                    fireOnSuggestRefresh();
                }

                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                }
            }).center();
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateAbandonAction() {
    final Button b = new Button(Util.C.buttonAbandonChangeBegin());
    b.addClickListener(new ClickListener() {

        public void onClick(Widget sender) {
            new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<Object>() {

                public void onSuccess(Object result) {
                    actionsPanel.remove(b);
                    fireOnSuggestRefresh();
                }

                public void onFailure(Throwable caught) {
                }
            }).center();
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
public void changeDetail(final Change.Id id, final AsyncCallback<ChangeDetail> callback) {
    run(callback, new Action<ChangeDetail>() {

        public ChangeDetail run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(id);
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final Project proj = db.projects().get(change.getDest().getParentKey());
            if (change == null || patch == null || proj == null) {
                throw new Failure(new NoSuchEntityException());
            }
            assertCanRead(change);
            final boolean anon;
            boolean canAbandon = false;
            if (me == null) {
                // Safe assumption, this wouldn't be allowed if it wasn't.
                // 
                anon = true;
            } else {
                // Ask if the anonymous user can read this project; even if
                // we can that doesn't mean the anonymous user could.
                // 
                anon = canRead(null, change.getDest().getParentKey());
                // The change owner, current patchset uploader, Gerrit administrator,
                // and project administrator can mark the change as abandoned.
                // 
                canAbandon = me.equals(change.getOwner()) || me.equals(patch.getUploader()) || Common.getGroupCache().isAdministrator(me) || Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId());
            }
            final ChangeDetail d = new ChangeDetail();
            d.load(db, new AccountInfoCacheFactory(db), change, anon, canAbandon);
            return d;
        }
    });
}
#method_after
public void changeDetail(final Change.Id id, final AsyncCallback<ChangeDetail> callback) {
    run(callback, new Action<ChangeDetail>() {

        public ChangeDetail run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(id);
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            assertCanRead(change);
            final boolean anon;
            boolean canAbandon = false;
            if (me == null) {
                // Safe assumption, this wouldn't be allowed if it wasn't.
                // 
                anon = true;
            } else {
                // Ask if the anonymous user can read this project; even if
                // we can that doesn't mean the anonymous user could.
                // 
                anon = canRead(null, change.getDest().getParentKey());
                // The change owner, current patchset uploader, Gerrit administrator,
                // and project administrator can mark the change as abandoned.
                // 
                canAbandon = me.equals(change.getOwner()) || me.equals(patch.getUploader()) || Common.getGroupCache().isAdministrator(me) || Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId());
            }
            final ChangeDetail d = new ChangeDetail();
            d.load(db, new AccountInfoCacheFactory(db), change, anon, canAbandon);
            return d;
        }
    });
}
#end_block

#method_before
public void abandonChange(final String message, final PatchSet.Id patchSetId, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final Project proj = db.projects().get(change.getDest().getParentKey());
            if (me == null || change == null || patch == null || proj == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId())) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            db.run(new OrmRunnable<VoidResult, ReviewDb>() {

                public VoidResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, cmsg, db, txn);
                }
            });
            // Email the reviewers
            try {
                final ChangeMail cm = new ChangeMail(server, change);
                cm.setFrom(Common.getAccountId());
                cm.setReviewDb(db);
                cm.setChangeMessage(cmsg);
                cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                cm.sendAbandoned();
            } catch (MessagingException e) {
                log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void abandonChange(final PatchSet.Id patchSetId, final String message, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(patchSetId);
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (me == null || patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId())) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            Boolean dbSuccess = db.run(new OrmRunnable<Boolean, ReviewDb>() {

                public Boolean run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, patchSetId, cmsg, db, txn);
                }
            });
            if (dbSuccess) {
                // Email the reviewers
                try {
                    final ChangeMail cm = new ChangeMail(server, change);
                    cm.setFrom(me);
                    cm.setReviewDb(db);
                    cm.setChangeMessage(cmsg);
                    cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                    cm.sendAbandoned();
                } catch (MessagingException e) {
                    log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                    throw new Failure(e);
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
private VoidResult doAbandonChange(final String message, final Change change, final ChangeMessage cm, final ReviewDb db, final Transaction txn) throws OrmException {
    if (change.getStatus() == Change.Status.NEW) {
        change.setStatus(Change.Status.ABANDONED);
        ChangeUtil.updated(change);
    }
    db.changeMessages().insert(Collections.singleton(cm), txn);
    db.changes().update(Collections.singleton(change), txn);
    return VoidResult.INSTANCE;
}
#method_after
private Boolean doAbandonChange(final String message, final Change change, final PatchSet.Id psid, final ChangeMessage cm, final ReviewDb db, final Transaction txn) throws OrmException {
    // changed while the user was typing an abandon message
    if (change.getStatus() == Change.Status.NEW && change.currentPatchSetId().equals(psid)) {
        change.setStatus(Change.Status.ABANDONED);
        ChangeUtil.updated(change);
        final List<ChangeApproval> approvals = db.changeApprovals().byChange(change.getId()).toList();
        for (ChangeApproval a : approvals) {
            a.cache(change);
        }
        db.changeApprovals().update(approvals, txn);
        db.changeMessages().insert(Collections.singleton(cm), txn);
        db.changes().update(Collections.singleton(change), txn);
        return Boolean.TRUE;
    }
    return Boolean.FALSE;
}
#end_block

#method_before
private void initUI() {
    addStyleName("gerrit-ChangeScreen");
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    dependencies = new ChangeTable();
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    approvals = new ApprovalTable(changeId);
    approvalsPanel = new DisclosurePanel(Util.C.changeScreenApprovals());
    approvalsPanel.setContent(wrap(approvals));
    dependenciesPanel.setWidth("95%");
    add(approvalsPanel);
    patchSetPanels = new FlowPanel();
    add(patchSetPanels);
    messagesContent = new FlowPanel();
    messagesContent.setStyleName("gerrit-ChangeMessages");
    messagesPanel = new DisclosurePanel(Util.C.changeScreenMessages());
    messagesPanel.setContent(messagesContent);
    add(messagesPanel);
}
#method_after
private void initUI() {
    addStyleName("gerrit-ChangeScreen");
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    dependencies = new ChangeTable();
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    approvals = new ApprovalTable();
    approvalsPanel = new DisclosurePanel(Util.C.changeScreenApprovals());
    approvalsPanel.setContent(wrap(approvals));
    dependenciesPanel.setWidth("95%");
    add(approvalsPanel);
    patchSetPanels = new FlowPanel();
    add(patchSetPanels);
    messagesContent = new FlowPanel();
    messagesContent.setStyleName("gerrit-ChangeMessages");
    messagesPanel = new DisclosurePanel(Util.C.changeScreenMessages());
    messagesPanel.setContent(messagesContent);
    add(messagesPanel);
}
#end_block

#method_before
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getSubject());
    refreshOnSignIn = !detail.getChange().getStatus().isClosed();
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getMissingApprovals(), detail.getApprovals());
    addPatchSets(detail);
    addMessages(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    approvalsPanel.setOpen(true);
}
#method_after
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getSubject());
    refreshOnSignIn = !detail.getChange().getStatus().isClosed();
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getChange(), detail.getMissingApprovals(), detail.getApprovals());
    addPatchSets(detail);
    addMessages(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    approvalsPanel.setOpen(true);
}
#end_block

#method_before
public void sendRequestReview() throws MessagingException {
    if (begin("requestReview")) {
        final Account a = Common.getAccountCache().get(fromId);
        if (a == null) {
            body.append("A Gerrit user");
        } else {
            final String e = a.getFullName();
            body.append(e);
        }
        body.append(" has requested that you review a change\n\n");
        if (changeUrl() != null) {
            openFooter();
            body.append("To respond visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
        if (fromId != null) {
            add(RecipientType.CC, fromId);
        }
        send();
    }
}
#method_after
public void sendRequestReview() throws MessagingException {
    if (begin("requestReview")) {
        final Account a = Common.getAccountCache().get(fromId);
        if (a == null || a.getFullName() == null || a.getFullName().length() == 0) {
            body.append("A Gerrit user");
        } else {
            body.append(a.getFullName());
        }
        body.append(" has requested that you review a change:\n\n");
        body.append(change.getChangeId());
        body.append(" - ");
        body.append(change.getSubject());
        body.append("\n\n");
        if (changeUrl() != null) {
            openFooter();
            body.append("To respond visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
        if (fromId != null) {
            add(RecipientType.CC, fromId);
        }
        send();
    }
}
#end_block

#method_before
private String changeMessageThreadId() {
    final StringBuilder r = new StringBuilder();
    r.append('<');
    r.append("gerrit");
    r.append('.');
    r.append(change.getCreatedOn().getTime());
    r.append('.');
    r.append(change.getChangeId());
    if (fromId != null) {
        r.append('.');
        r.append(fromId.get());
    }
    r.append('@');
    r.append(gerritHost());
    r.append('>');
    return r.toString();
}
#method_after
private String changeMessageThreadId() {
    final StringBuilder r = new StringBuilder();
    r.append('<');
    r.append("gerrit");
    r.append('.');
    r.append(change.getCreatedOn().getTime());
    r.append('.');
    r.append(change.getChangeId());
    r.append('@');
    r.append(gerritHost());
    r.append('>');
    return r.toString();
}
#end_block

#method_before
public void display(final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    final int oldcnt = table.getRowCount();
    table.resizeRows(1 + rows.size());
    if (oldcnt < 1 + rows.size()) {
        for (int row = oldcnt; row < 1 + rows.size(); row++) {
            applyEdgeStyles(row);
            applyScoreStyles(row);
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.setVisible(true);
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i));
        }
    }
    missing.clear();
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Label l = new Label(Util.M.needApproval(at.getCategory().getName()));
                l.setStyleName("gerrit-Change-MissingApproval");
                missing.add(l);
                missing.setVisible(true);
            }
        }
    }
    addReviewer.clear();
    if (need != null && Gerrit.isSignedIn()) {
        final Label l = new Label(Util.C.approvalTableAddReviewer());
        l.setStyleName("gerrit-Change-AddReviewer");
        addReviewer.add(l);
        addReviewer.add(addMemberBox);
    }
}
#method_after
public void display(final Change change, final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    changeId = change.getId();
    final int oldcnt = table.getRowCount();
    table.resizeRows(1 + rows.size());
    if (oldcnt < 1 + rows.size()) {
        for (int row = oldcnt; row < 1 + rows.size(); row++) {
            applyEdgeStyles(row);
            applyScoreStyles(row);
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.setVisible(true);
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i));
        }
    }
    missing.clear();
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Label l = new Label(Util.M.needApproval(at.getCategory().getName()));
                l.setStyleName("gerrit-Change-MissingApproval");
                missing.add(l);
                missing.setVisible(true);
            }
        }
    }
    changeIsOpen = change.getStatus().isOpen();
    addReviewer.setVisible(Gerrit.isSignedIn() && changeIsOpen);
}
#end_block

#method_before
private void doAddReviewer() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail == null || nameEmail.length() == 0 || com.google.gerrit.client.admin.Util.C.defaultAccountName().equals(nameEmail)) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = Arrays.asList(nameEmail.split(";"));
    Util.DETAIL_SVC.addReviewers(reviewers, changeId, new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddReviewer() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(nameEmail);
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

