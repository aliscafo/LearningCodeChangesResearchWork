391
#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    {
        nameBox = new NpTextBox();
        nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
        nameBox.setVisibleLength(50);
        nameBox.setText(Util.C.defaultProjectName());
        nameBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
        nameBox.addFocusHandler(new FocusHandler() {

            @Override
            public void onFocus(FocusEvent event) {
                if (Util.C.defaultProjectName().equals(nameBox.getText())) {
                    nameBox.setText("");
                    nameBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        nameBox.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(BlurEvent event) {
                if ("".equals(nameBox.getText())) {
                    nameBox.setText(Util.C.defaultProjectName());
                    nameBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        nameBox.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                submitOnSelection = false;
                if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                    if (nameTxt.isSuggestionListShowing()) {
                        submitOnSelection = true;
                    } else {
                        doAddNew();
                    }
                }
            }
        });
        nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

            @Override
            public void onSelection(SelectionEvent<Suggestion> event) {
                if (submitOnSelection) {
                    submitOnSelection = false;
                    doAddNew();
                }
            }
        });
        filterTxt = new NpTextBox();
        filterTxt.setVisibleLength(50);
        filterTxt.setText(Util.C.defaultFilter());
        filterTxt.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
        filterTxt.addFocusHandler(new FocusHandler() {

            @Override
            public void onFocus(FocusEvent event) {
                if (Util.C.defaultFilter().equals(filterTxt.getText())) {
                    filterTxt.setText("");
                    filterTxt.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        filterTxt.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(BlurEvent event) {
                if ("".equals(filterTxt.getText())) {
                    filterTxt.setText(Util.C.defaultFilter());
                    filterTxt.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        filterTxt.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                    doAddNew();
                }
            }
        });
        projects = new ProjectTable();
        addNew = new Button(Util.C.buttonWatchProject());
        addNew.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                doAddNew();
            }
        });
        final Grid grid = new Grid(2, 2);
        grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
        grid.setText(0, 0, Util.C.watchedProjectName());
        grid.setWidget(0, 1, nameTxt);
        grid.setText(1, 0, Util.C.watchedProjectFilter());
        grid.setWidget(1, 1, filterTxt);
        final CellFormatter fmt = grid.getCellFormatter();
        fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
        fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
        fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
        fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
        fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
        DisclosurePanel unwatched = new DisclosurePanel(Util.C.unwatchedProjects());
        unwatched.setContent(projects);
        final Grid grid2 = new Grid(1, 2);
        final FlowPanel fp2 = new FlowPanel();
        fp2.add(addNew);
        grid2.setWidget(0, 0, fp2);
        grid2.setWidget(0, 1, unwatched);
        final CellFormatter fmt2 = grid2.getCellFormatter();
        fmt2.setAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT, HasVerticalAlignment.ALIGN_TOP);
        final FlowPanel fp = new FlowPanel();
        fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
        fp.add(grid);
        fp.add(grid2);
        add(fp);
    }
    watches = new WatchTable();
    add(watches);
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watches.deleteChecked();
        }
    });
    add(delSel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            if (preferredPopupWidth == -1) {
                preferredPopupWidth = offsetWidth;
            }
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            if (top + offsetHeight > Window.getClientHeight()) {
                top = Window.getClientHeight() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.ACCOUNT_SVC.myProjectWatch(new ScreenLoadCallback<List<AccountProjectWatchInfo>>(this) {

        public void preDisplay(final List<AccountProjectWatchInfo> result) {
            watchedProjects = result;
            watches.display(result);
            displayUnwatchedProjects();
        }
    });
    Util.PROJECT_SVC.visibleProjects(new ScreenLoadCallback<List<Project>>(this) {

        @Override
        protected void preDisplay(final List<Project> result) {
            allProjects = new ArrayList(result);
            // unneeded fake "--all projects--" entry
            allProjects.remove(0);
            displayUnwatchedProjects();
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    populateWatches();
}
#end_block

#method_before
void doAddNew() {
    final String projectName = nameTxt.getText();
    if (projectName == null || projectName.length() == 0 || Util.C.defaultProjectName().equals(projectName)) {
        return;
    }
    String filter = filterTxt.getText();
    if (filter == null || filter.isEmpty() || filter.equals(Util.C.defaultFilter())) {
        filter = null;
    }
    addNew.setEnabled(false);
    nameBox.setEnabled(false);
    filterTxt.setEnabled(false);
    Util.ACCOUNT_SVC.addProjectWatch(projectName, filter, new GerritCallback<AccountProjectWatchInfo>() {

        public void onSuccess(final AccountProjectWatchInfo result) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            nameTxt.setText("");
            watches.insertWatch(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
protected void doAddNew() {
    final String projectName = nameTxt.getText();
    if ("".equals(projectName)) {
        return;
    }
    String filter = filterTxt.getText();
    if (filter == null || filter.isEmpty() || filter.equals(Util.C.defaultFilter())) {
        filter = null;
    }
    addNew.setEnabled(false);
    nameBox.setEnabled(false);
    filterTxt.setEnabled(false);
    Util.ACCOUNT_SVC.addProjectWatch(projectName, filter, new GerritCallback<AccountProjectWatchInfo>() {

        public void onSuccess(final AccountProjectWatchInfo result) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            nameTxt.setText("");
            watchesTab.insertWatch(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    for (index--; index > -1; index--) {
        InlineHyperlink link = createLink(index, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
        if (link != null) {
            return link;
        }
    }
    return null;
}
#method_after
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    for (index--; index > -1; index--) {
        InlineHyperlink link = createLink(index, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
        if (link != null) {
            return link;
        }
    }
    return null;
}
#end_block

#method_before
private PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    if ((isSkipDeleted() && patch.getChangeType().equals(ChangeType.DELETED)) || (isSkipUncommented() && patch.getCommentCount() == 0)) {
        return null;
    }
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#method_after
private PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    if ((listenablePrefs.get().isSkipDeleted() && patch.getChangeType().equals(ChangeType.DELETED)) || (listenablePrefs.get().isSkipUncommented() && patch.getCommentCount() == 0)) {
        return null;
    }
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#end_block

#method_before
private static String getFileNameOnly(Patch patch) {
    // Note: use '/' here and not File.pathSeparator since git paths
    // are always separated by /
    // 
    String fileName = patch.getFileName();
    int s = fileName.lastIndexOf('/');
    if (s >= 0) {
        fileName = fileName.substring(s + 1);
    }
    return fileName;
}
#method_after
private static String getFileNameOnly(Patch patch) {
    // Note: use '/' here and not File.pathSeparator since git paths
    // are always separated by /
    // 
    String fileName = getDisplayFileName(patch);
    int s = fileName.lastIndexOf('/');
    if (s >= 0) {
        fileName = fileName.substring(s + 1);
    }
    return fileName;
}
#end_block

#method_before
void initializeRow(int row) {
    Patch patch = PatchTable.this.patchList.get(row - 1);
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(patch.getFileName(), patch.getKey(), row - 1, detail, PatchTable.this);
    } else {
        nameCol = new PatchLink.Unified(patch.getFileName(), patch.getKey(), row - 1, detail, PatchTable.this);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName(Gerrit.RESOURCES.css().sourceFilePath());
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), patch.getKey(), row - 1, detail, PatchTable.this));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), patch.getKey(), row - 1, detail, PatchTable.this));
}
#method_after
void initializeRow(int row) {
    Patch patch = PatchTable.this.patchList.get(row - 1);
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(getDisplayFileName(patch), patch.getKey(), row - 1, detail, PatchTable.this);
    } else {
        nameCol = new PatchLink.Unified(getDisplayFileName(patch), patch.getKey(), row - 1, detail, PatchTable.this);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName(Gerrit.RESOURCES.css().sourceFilePath());
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), patch.getKey(), row - 1, detail, PatchTable.this));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), patch.getKey(), row - 1, detail, PatchTable.this));
}
#end_block

#method_before
void appendHeader(final SafeHtmlBuilder m) {
    m.openTr();
    // Cursor
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconHeader());
    m.addStyleName(Gerrit.RESOURCES.css().leftMostCell());
    m.nbsp();
    m.closeTd();
    // Mode
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().iconHeader());
    m.nbsp();
    m.closeTd();
    // "File path"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.append(Util.C.patchTableColumnName());
    m.closeTd();
    // "Comments"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.append(Util.C.patchTableColumnComments());
    m.closeTd();
    // "Diff"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.setAttribute("colspan", 3);
    m.append(Util.C.patchTableColumnDiff());
    m.closeTd();
    // "Reviewed"
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(Gerrit.RESOURCES.css().iconHeader());
        m.addStyleName(Gerrit.RESOURCES.css().dataHeader());
        m.append(Util.C.reviewed());
        m.closeTd();
    }
    m.closeTr();
}
#method_after
void appendHeader(final SafeHtmlBuilder m) {
    m.openTr();
    // Cursor
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconHeader());
    m.addStyleName(Gerrit.RESOURCES.css().leftMostCell());
    m.nbsp();
    m.closeTd();
    // Mode
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().iconHeader());
    m.nbsp();
    m.closeTd();
    // "File path"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.append(Util.C.patchTableColumnName());
    m.closeTd();
    // "Comments"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.append(Util.C.patchTableColumnComments());
    m.closeTd();
    // "Size"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.append(Util.C.patchTableColumnSize());
    m.closeTd();
    // "Diff"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.setAttribute("colspan", 3);
    m.append(Util.C.patchTableColumnDiff());
    m.closeTd();
    // "Reviewed"
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(Gerrit.RESOURCES.css().iconHeader());
        m.addStyleName(Gerrit.RESOURCES.css().dataHeader());
        m.append(Util.C.reviewed());
        m.closeTd();
    }
    m.closeTr();
}
#end_block

#method_before
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconCell());
    m.addStyleName(Gerrit.RESOURCES.css().leftMostCell());
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().changeTypeCell());
    m.append(p.getChangeType().getCode());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().dataCell());
    m.addStyleName(Gerrit.RESOURCES.css().filePathCell());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().dataCell());
    m.addStyleName(Gerrit.RESOURCES.css().commentCell());
    appendCommentCount(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    // Green check mark if the user is logged in and they reviewed that file
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(Gerrit.RESOURCES.css().dataCell());
        if (p.isReviewedByCurrentUser()) {
            m.openDiv();
            m.setStyleName(Gerrit.RESOURCES.css().greenCheckClass());
            m.closeSelf();
        }
        m.closeTd();
    }
    m.closeTr();
}
#method_after
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconCell());
    m.addStyleName(Gerrit.RESOURCES.css().leftMostCell());
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().changeTypeCell());
    if (Patch.COMMIT_MSG.equals(p.getFileName())) {
        m.nbsp();
    } else {
        m.append(p.getChangeType().getCode());
    }
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().dataCell());
    m.addStyleName(Gerrit.RESOURCES.css().filePathCell());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().dataCell());
    m.addStyleName(Gerrit.RESOURCES.css().commentCell());
    appendCommentCount(m, p);
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().dataCell());
    m.addStyleName(Gerrit.RESOURCES.css().patchSizeCell());
    appendSize(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    // Green check mark if the user is logged in and they reviewed that file
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(Gerrit.RESOURCES.css().dataCell());
        if (p.isReviewedByCurrentUser()) {
            m.openDiv();
            m.setStyleName(Gerrit.RESOURCES.css().greenCheckClass());
            m.closeSelf();
        }
        m.closeTd();
    }
    m.closeTr();
}
#end_block

#method_before
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
            }
            while (row < list.size()) {
                table.appendRow(nc, list.get(row));
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#method_after
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
                table.appendRow(nc, list.get(row++));
            }
            while (row < list.size()) {
                Patch p = list.get(row);
                insertions += p.getInsertions();
                deletions += p.getDeletions();
                table.appendRow(nc, p);
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.appendTotals(nc, insertions, deletions);
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either
    // side, expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null || (historyOpen != null && historyOpen));
    historyPanel.addOpenHandler(cacheOpenState);
    historyPanel.addCloseHandler(cacheCloseState);
    VerticalPanel vp = new VerticalPanel();
    vp.add(historyPanel);
    vp.add(settingsPanel);
    commitMessageBlock = new CommitMessageBlock("6em");
    HorizontalPanel hp = new HorizontalPanel();
    hp.setWidth("100%");
    hp.add(vp);
    hp.add(commitMessageBlock);
    add(hp);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey().getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey().getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        fileList.setSkipDeleted(settingsPanel.skipDeleted.getValue());
        fileList.setSkipUncommented(settingsPanel.skipUncommented.getValue());
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id ck = patchKey.getParentKey().getParentKey();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(ck, 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either
    // side, expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null || (historyOpen != null && historyOpen));
    historyPanel.addOpenHandler(cacheOpenState);
    historyPanel.addCloseHandler(cacheCloseState);
    VerticalPanel vp = new VerticalPanel();
    vp.add(historyPanel);
    vp.add(settingsPanel);
    commitMessageBlock = new CommitMessageBlock("6em");
    HorizontalPanel hp = new HorizontalPanel();
    hp.setWidth("100%");
    hp.add(vp);
    hp.add(commitMessageBlock);
    add(hp);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey().getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey().getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable();
                    fileList.setSkipDeleted(settingsPanel.skipDeleted.getValue());
                    fileList.setSkipUncommented(settingsPanel.skipUncommented.getValue());
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    contentTable.setRegisterKeys(contentTable.isVisible());
    regNavigation = GlobalKey.add(this, keysNavigation);
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    contentTable.setRegisterKeys(contentTable.isVisible());
    if (regNavigation != null) {
        regNavigation.removeHandler();
        regNavigation = null;
    }
    regNavigation = GlobalKey.add(this, keysNavigation);
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final Change.Key cid = script.getChangeId();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(cid.abbreviate(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(cid.abbreviate(), path + "(" + ++mtn + ")"));
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    historyPanel.setVisible(true);
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    fileList.setSkipDeleted(settingsPanel.skipDeleted.getValue());
    fileList.setSkipUncommented(settingsPanel.skipUncommented.getValue());
    topNav.display(patchIndex, getPatchScreenType(), fileList);
    bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        settingsPanel.getReviewedCheckBox().setValue(true);
        setReviewedByCurrentUser(true);
    }
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final Change.Key cid = script.getChangeId();
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(cid.abbreviate(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(cid.abbreviate(), path));
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    historyPanel.setVisible(true);
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    registerKeys();
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        settingsPanel.getReviewedCheckBox().setValue(true);
        setReviewedByCurrentUser(true);
    }
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable();
        fileList.setSkipDeleted(settingsPanel.skipDeleted.getValue());
        fileList.setSkipUncommented(settingsPanel.skipUncommented.getValue());
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#end_block

#method_before
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(value.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#method_after
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#end_block

#method_before
public void setEnableIntralineDifference(final boolean on) {
    enableIntralineDifference = on;
    if (enableIntralineDifference) {
        intralineDifference.setValue(value.isIntralineDifference());
    } else {
        intralineDifference.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#method_after
public void setEnableIntralineDifference(final boolean on) {
    enableIntralineDifference = on;
    if (enableIntralineDifference) {
        intralineDifference.setValue(getValue().isIntralineDifference());
    } else {
        intralineDifference.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#end_block

#method_before
public AccountDiffPreference getValue() {
    return value;
}
#method_after
public AccountDiffPreference getValue() {
    return listenablePrefs.get();
}
#end_block

#method_before
public void setValue(final AccountDiffPreference dp) {
    setIgnoreWhitespace(dp.getIgnoreWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(dp.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(dp.getContext());
    tabWidth.setIntValue(dp.getTabSize());
    colWidth.setIntValue(dp.getLineLength());
    intralineDifference.setValue(dp.isIntralineDifference());
    whitespaceErrors.setValue(dp.isShowWhitespaceErrors());
    showTabs.setValue(dp.isShowTabs());
    value = dp;
}
#method_after
public void setValue(final AccountDiffPreference dp) {
    listenablePrefs.set(dp);
    display();
}
#end_block

#method_before
private void update() {
    AccountDiffPreference dp = new AccountDiffPreference(value);
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    value = dp;
    fireEvent(new ValueChangeEvent<AccountDiffPreference>(dp) {
    });
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#method_after
private void update() {
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    listenablePrefs.set(dp);
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#end_block

#method_before
private void persistDiffPreferences() {
    setEnabled(false);
    Util.ACCOUNT_SVC.changeDiffPreferences(value, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            Gerrit.setAccountDiffPreference(value);
            setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            setEnabled(true);
        }
    });
}
#method_after
private void persistDiffPreferences() {
    setEnabled(false);
    Util.ACCOUNT_SVC.changeDiffPreferences(getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            Gerrit.setAccountDiffPreference(getValue());
            setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            setEnabled(true);
        }
    });
}
#end_block

#method_before
private Whitespace getIgnoreWhitespace() {
    final int sel = ignoreWhitespace.getSelectedIndex();
    if (0 <= sel) {
        return Whitespace.valueOf(ignoreWhitespace.getValue(sel));
    }
    return value.getIgnoreWhitespace();
}
#method_after
private Whitespace getIgnoreWhitespace() {
    final int sel = ignoreWhitespace.getSelectedIndex();
    if (0 <= sel) {
        return Whitespace.valueOf(ignoreWhitespace.getValue(sel));
    }
    return getValue().getIgnoreWhitespace();
}
#end_block

#method_before
private short getContext() {
    final int sel = context.getSelectedIndex();
    if (0 <= sel) {
        return Short.parseShort(context.getValue(sel));
    }
    return (short) value.getContext();
}
#method_after
private short getContext() {
    final int sel = context.getSelectedIndex();
    if (0 <= sel) {
        return Short.parseShort(context.getValue(sel));
    }
    return (short) getValue().getContext();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    saveProject = new Button(Util.C.buttonSaveChanges());
    saveProject.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doSave();
        }
    });
    initDescription();
    initSubmitType();
    initAgreements();
    add(saveProject);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    saveProject = new Button(Util.C.buttonSaveChanges());
    saveProject.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doSave();
        }
    });
    initDescription();
    initProjectOptions();
    initAgreements();
    add(saveProject);
}
#end_block

#method_before
private void enableForm(final boolean canModifyAgreements, final boolean canModifyDescription, final boolean canModifyMergeType) {
    submitType.setEnabled(canModifyMergeType);
    descTxt.setEnabled(canModifyDescription);
    useContributorAgreements.setEnabled(canModifyAgreements);
    useSignedOffBy.setEnabled(canModifyAgreements);
    saveProject.setEnabled(canModifyAgreements || canModifyDescription || canModifyMergeType);
}
#method_after
private void enableForm(final boolean canModifyAgreements, final boolean canModifyDescription, final boolean canModifyMergeType) {
    submitType.setEnabled(canModifyMergeType);
    descTxt.setEnabled(canModifyDescription);
    useContributorAgreements.setEnabled(canModifyAgreements);
    useSignedOffBy.setEnabled(canModifyAgreements);
    requireChangeID.setEnabled(canModifyMergeType);
    saveProject.setEnabled(canModifyAgreements || canModifyDescription || canModifyMergeType);
}
#end_block

#method_before
private void initDescription() {
    final VerticalPanel vp = new VerticalPanel();
    vp.add(new SmallHeading(Util.C.headingDescription()));
    descTxt = new NpTextArea();
    descTxt.setVisibleLines(6);
    descTxt.setCharacterWidth(60);
    vp.add(descTxt);
    add(vp);
    saveEnabler = new OnEditEnabler(saveProject, descTxt);
}
#method_after
private void initDescription() {
    final VerticalPanel vp = new VerticalPanel();
    vp.add(new SmallHeading(Util.C.headingDescription()));
    descTxt = new NpTextArea();
    descTxt.setVisibleLines(6);
    descTxt.setCharacterWidth(60);
    vp.add(descTxt);
    add(vp);
    saveEnabler = new OnEditEnabler(saveProject);
    saveEnabler.listenTo(descTxt);
}
#end_block

#method_before
void display(final ProjectDetail result) {
    project = result.project;
    final boolean isall = Gerrit.getConfig().getWildProject().equals(project.getNameKey());
    submitTypePanel.setVisible(!isall);
    agreementsPanel.setVisible(!isall);
    useContributorAgreements.setVisible(Gerrit.getConfig().isUseContributorAgreements());
    descTxt.setText(project.getDescription());
    useContributorAgreements.setValue(project.isUseContributorAgreements());
    useSignedOffBy.setValue(project.isUseSignedOffBy());
    setSubmitType(project.getSubmitType());
    saveProject.setEnabled(false);
}
#method_after
void display(final ProjectDetail result) {
    project = result.project;
    final boolean isall = Gerrit.getConfig().getWildProject().equals(project.getNameKey());
    projectOptionsPanel.setVisible(!isall);
    agreementsPanel.setVisible(!isall);
    useContributorAgreements.setVisible(Gerrit.getConfig().isUseContributorAgreements());
    descTxt.setText(project.getDescription());
    useContributorAgreements.setValue(project.isUseContributorAgreements());
    useSignedOffBy.setValue(project.isUseSignedOffBy());
    requireChangeID.setValue(project.isRequireChangeID());
    setSubmitType(project.getSubmitType());
    saveProject.setEnabled(false);
}
#end_block

#method_before
private void doSave() {
    project.setDescription(descTxt.getText().trim());
    project.setUseContributorAgreements(useContributorAgreements.getValue());
    project.setUseSignedOffBy(useSignedOffBy.getValue());
    if (submitType.getSelectedIndex() >= 0) {
        project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())));
    }
    enableForm(false, false, false);
    Util.PROJECT_SVC.changeProjectSettings(project, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType);
            display(result);
        }
    });
}
#method_after
private void doSave() {
    project.setDescription(descTxt.getText().trim());
    project.setUseContributorAgreements(useContributorAgreements.getValue());
    project.setUseSignedOffBy(useSignedOffBy.getValue());
    project.setRequireChangeID(requireChangeID.getValue());
    if (submitType.getSelectedIndex() >= 0) {
        project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())));
    }
    enableForm(false, false, false);
    Util.PROJECT_SVC.changeProjectSettings(project, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType);
            display(result);
        }
    });
}
#end_block

#method_before
// Register input widgets to be listened to
public void listenTo(final TextBoxBase tb) {
    strings.put(tb, tb.getText());
    tb.addKeyPressHandler(this);
    // Is there another way to capture middle button X11 pastes in browsers
    // which do not yet support ONPASTE events (Firefox)?
    tb.addMouseUpHandler(this);
    // Resetting the "original text" on focus ensures that we are
    // up to date with non-user updates of the text (calls to
    // setText()...) and also up to date with user changes which
    // occured after enabling "widget".
    tb.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            strings.put(tb, tb.getText());
        }
    });
    // CTRL-V Pastes in Chrome seem only detectable via BrowserEvents.
    // Since passed in widgets cannot be extended, go straight to the
    // Element itself and intercept all its events!
    tb.sinkEvents(Event.ONPASTE);
    Element el = tb.getElement();
    tbis.put(el, new TBBInfo(tb, Event.getEventListener(el)));
    Event.setEventListener(el, this);
}
#method_after
// Register input widgets to be listened to
public void listenTo(final TextBoxBase tb) {
    strings.put(tb, tb.getText());
    tb.addKeyPressHandler(this);
    // Is there another way to capture middle button X11 pastes in browsers
    // which do not yet support ONPASTE events (Firefox)?
    tb.addMouseUpHandler(this);
    // Resetting the "original text" on focus ensures that we are
    // up to date with non-user updates of the text (calls to
    // setText()...) and also up to date with user changes which
    // occured after enabling "widget".
    tb.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            strings.put(tb, tb.getText());
        }
    });
    // CTRL-V Pastes in Chrome seem only detectable via BrowserEvents or
    // KeyDownEvents, the latter is better.
    tb.addKeyDownHandler(this);
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent e) {
    on(e);
}
#method_after
// Handlers
@Override
public void onKeyPress(final KeyPressEvent e) {
    on(e);
}
#end_block

#method_before
// Handlers
@Override
public void onMouseUp(final MouseUpEvent e) {
    on(e);
}
#method_after
@Override
public void onMouseUp(final MouseUpEvent e) {
    on(e);
}
#end_block

#method_before
private void onTextBoxBase(final TextBoxBase tb) {
    // The text appears to not get updated until the handlers complete.
    DeferredCommand.add(new Command() {

        public void execute() {
            String orig = strings.get(tb);
            orig = orig == null ? "" : orig;
            if (!orig.equals(tb.getText())) {
                widget.setEnabled(true);
            }
        }
    });
}
#method_after
private void onTextBoxBase(final TextBoxBase tb) {
    // The text appears to not get updated until the handlers complete.
    DeferredCommand.add(new Command() {

        @Override
        public void execute() {
            String orig = strings.get(tb);
            if (orig == null) {
                orig = "";
            }
            if (!orig.equals(tb.getText())) {
                widget.setEnabled(true);
            }
        }
    });
}
#end_block

#method_before
private void initGroupType() {
    typeSystem = new Label(Util.C.groupType_SYSTEM());
    typeSelect = new ListBox();
    typeSelect.addItem(Util.C.groupType_INTERNAL(), AccountGroup.Type.INTERNAL.name());
    typeSelect.addItem(Util.C.groupType_LDAP(), AccountGroup.Type.LDAP.name());
    typeSelect.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            saveType.setEnabled(true);
        }
    });
    saveType = new Button(Util.C.buttonChangeGroupType());
    saveType.setEnabled(false);
    saveType.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            onSaveType();
        }
    });
    switch(Gerrit.getConfig().getAuthType()) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
            break;
        default:
            return;
    }
    final VerticalPanel fp = new VerticalPanel();
    fp.add(new SmallHeading(Util.C.headingGroupType()));
    fp.add(typeSystem);
    fp.add(typeSelect);
    fp.add(saveType);
    add(fp);
}
#method_after
private void initGroupType() {
    typeSystem = new Label(Util.C.groupType_SYSTEM());
    typeSelect = new ListBox();
    typeSelect.addItem(Util.C.groupType_INTERNAL(), AccountGroup.Type.INTERNAL.name());
    typeSelect.addItem(Util.C.groupType_LDAP(), AccountGroup.Type.LDAP.name());
    typeSelect.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            saveType.setEnabled(true);
        }
    });
    saveType = new Button(Util.C.buttonChangeGroupType());
    saveType.setEnabled(false);
    saveType.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            onSaveType();
        }
    });
    switch(Gerrit.getConfig().getAuthType()) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            break;
        default:
            return;
    }
    final VerticalPanel fp = new VerticalPanel();
    fp.add(new SmallHeading(Util.C.headingGroupType()));
    fp.add(typeSystem);
    fp.add(typeSelect);
    fp.add(saveType);
    add(fp);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addressTxt = new NpTextArea();
    addressTxt.setVisibleLines(4);
    addressTxt.setCharacterWidth(60);
    countryTxt = new NpTextBox();
    countryTxt.setVisibleLength(40);
    countryTxt.setMaxLength(40);
    phoneTxt = new NpTextBox();
    phoneTxt.setVisibleLength(30);
    phoneTxt.setMaxLength(30);
    faxTxt = new NpTextBox();
    faxTxt.setVisibleLength(30);
    faxTxt.setMaxLength(30);
    final Grid infoSecure = new Grid(4, 2);
    infoSecure.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoSecure.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    final HTML privhtml = new HTML(Util.C.contactPrivacyDetailsHtml());
    privhtml.setStyleName(Gerrit.RESOURCES.css().accountContactPrivacyDetails());
    hasContact = new Label();
    hasContact.setStyleName(Gerrit.RESOURCES.css().accountContactOnFile());
    hasContact.setVisible(false);
    if (Gerrit.getConfig().isUseContactInfo()) {
        body.add(privhtml);
        body.add(hasContact);
        body.add(infoSecure);
    }
    row(infoSecure, 0, Util.C.contactFieldAddress(), addressTxt);
    row(infoSecure, 1, Util.C.contactFieldCountry(), countryTxt);
    row(infoSecure, 2, Util.C.contactFieldPhone(), phoneTxt);
    row(infoSecure, 3, Util.C.contactFieldFax(), faxTxt);
    infoSecure.getCellFormatter().addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    infoSecure.getCellFormatter().addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    infoSecure.getCellFormatter().addStyleName(3, 0, Gerrit.RESOURCES.css().bottomheader());
    final OnEditEnabler sbl = new OnEditEnabler(save, addressTxt);
    sbl.listenTo(countryTxt);
    sbl.listenTo(phoneTxt);
    sbl.listenTo(faxTxt);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addressTxt = new NpTextArea();
    addressTxt.setVisibleLines(4);
    addressTxt.setCharacterWidth(60);
    countryTxt = new NpTextBox();
    countryTxt.setVisibleLength(40);
    countryTxt.setMaxLength(40);
    phoneTxt = new NpTextBox();
    phoneTxt.setVisibleLength(30);
    phoneTxt.setMaxLength(30);
    faxTxt = new NpTextBox();
    faxTxt.setVisibleLength(30);
    faxTxt.setMaxLength(30);
    final Grid infoSecure = new Grid(4, 2);
    infoSecure.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoSecure.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    final HTML privhtml = new HTML(Util.C.contactPrivacyDetailsHtml());
    privhtml.setStyleName(Gerrit.RESOURCES.css().accountContactPrivacyDetails());
    hasContact = new Label();
    hasContact.setStyleName(Gerrit.RESOURCES.css().accountContactOnFile());
    hasContact.setVisible(false);
    if (Gerrit.getConfig().isUseContactInfo()) {
        body.add(privhtml);
        body.add(hasContact);
        body.add(infoSecure);
    }
    row(infoSecure, 0, Util.C.contactFieldAddress(), addressTxt);
    row(infoSecure, 1, Util.C.contactFieldCountry(), countryTxt);
    row(infoSecure, 2, Util.C.contactFieldPhone(), phoneTxt);
    row(infoSecure, 3, Util.C.contactFieldFax(), faxTxt);
    infoSecure.getCellFormatter().addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    infoSecure.getCellFormatter().addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    infoSecure.getCellFormatter().addStyleName(3, 0, Gerrit.RESOURCES.css().bottomheader());
    final OnEditEnabler sbl = new OnEditEnabler(save);
    sbl.listenTo(addressTxt);
    sbl.listenTo(countryTxt);
    sbl.listenTo(phoneTxt);
    sbl.listenTo(faxTxt);
}
#end_block

#method_before
private Connector[] listen(final Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    reverseProxy = true;
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final SelectChannelConnector c;
        if ("http".equals(u.getScheme())) {
            reverseProxy = false;
            defaultPort = 80;
            c = new SelectChannelConnector();
            String authType = cfg.getString("auth", null, "type");
            if (AuthType.CLIENT_SSL_CERT_LDAP.name().equals(authType)) {
                throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
            }
        } else if ("https".equals(u.getScheme())) {
            final SslSelectChannelConnector ssl = new SslSelectChannelConnector();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeystore(keystore.getAbsolutePath());
            ssl.setTruststore(keystore.getAbsolutePath());
            ssl.setKeyPassword(password);
            ssl.setTrustPassword(password);
            String authType = cfg.getString("auth", null, "type");
            if (AuthType.CLIENT_SSL_CERT_LDAP.name().equals(authType)) {
                ssl.setNeedClientAuth(true);
            }
            reverseProxy = false;
            defaultPort = 443;
            c = ssl;
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            c = new SelectChannelConnector();
            c.setForwarded(true);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            c = new SelectChannelConnector() {

                @Override
                public void customize(EndPoint endpoint, Request request) throws IOException {
                    request.setScheme("https");
                    super.customize(endpoint, request);
                }
            };
            c.setForwarded(true);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setRequestHeaderSize(requestHeaderSize);
        c.setAcceptors(acceptors);
        c.setReuseAddress(reuseAddress);
        c.setStatsOn(false);
        connectors[idx] = c;
    }
    return connectors;
}
#method_after
private Connector[] listen(final Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = ConfigUtil.getEnum(cfg, "auth", null, "type", AuthType.OPENID);
    reverseProxy = true;
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final SelectChannelConnector c;
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            reverseProxy = false;
            defaultPort = 80;
            c = new SelectChannelConnector();
        } else if ("https".equals(u.getScheme())) {
            final SslSelectChannelConnector ssl = new SslSelectChannelConnector();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeystore(keystore.getAbsolutePath());
            ssl.setTruststore(keystore.getAbsolutePath());
            ssl.setKeyPassword(password);
            ssl.setTrustPassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
            }
            reverseProxy = false;
            defaultPort = 443;
            c = ssl;
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            c = new SelectChannelConnector();
            c.setForwarded(true);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            c = new SelectChannelConnector() {

                @Override
                public void customize(EndPoint endpoint, Request request) throws IOException {
                    request.setScheme("https");
                    super.customize(endpoint, request);
                }
            };
            c.setForwarded(true);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setRequestHeaderSize(requestHeaderSize);
        c.setAcceptors(acceptors);
        c.setReuseAddress(reuseAddress);
        c.setStatsOn(false);
        connectors[idx] = c;
    }
    return connectors;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest req, ServletResponse rsp, FilterChain chain) throws IOException, ServletException {
    X509Certificate[] certs = (X509Certificate[]) req.getAttribute("javax.servlet.request.X509Certificate");
    String name = certs[0].getSubjectDN().getName();
    Matcher m = REGEX_USERID.matcher(name);
    String userName = null;
    if (m.matches()) {
        userName = m.group(1);
    } else {
        throw new ServletException("Couldn't extract username from your certificate");
    }
    final AuthRequest areq = AuthRequest.forUser(userName);
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        String err = "Unable to authenticate user \"" + userName + "\"";
        log.error(err, e);
        throw new ServletException(err, e);
    }
    webSession.get().login(arsp, true);
    chain.doFilter(req, rsp);
}
#method_after
@Override
public void doFilter(ServletRequest req, ServletResponse rsp, FilterChain chain) throws IOException, ServletException {
    X509Certificate[] certs = (X509Certificate[]) req.getAttribute("javax.servlet.request.X509Certificate");
    if (certs == null || certs.length == 0) {
        throw new ServletException("Couldn't get the attribute javax.servlet.request.X509Certificate from the request");
    }
    String name = certs[0].getSubjectDN().getName();
    Matcher m = REGEX_USERID.matcher(name);
    String userName;
    if (m.matches()) {
        userName = m.group(1);
    } else {
        throw new ServletException("Couldn't extract username from your certificate");
    }
    final AuthRequest areq = AuthRequest.forUser(userName);
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        String err = "Unable to authenticate user \"" + userName + "\"";
        log.error(err, e);
        throw new ServletException(err, e);
    }
    webSession.get().login(arsp, true);
    chain.doFilter(req, rsp);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    saveProject = new Button(Util.C.buttonSaveChanges());
    saveProject.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doSave();
        }
    });
    initDescription();
    initSubmitType();
    initAgreements();
    add(saveProject);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    saveProject = new Button(Util.C.buttonSaveChanges());
    saveProject.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doSave();
        }
    });
    initDescription();
    initProjectOptions();
    initAgreements();
    add(saveProject);
}
#end_block

#method_before
private void initAgreements() {
    final ValueChangeHandler<Boolean> onChangeSave = new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            saveProject.setEnabled(true);
        }
    };
    agreementsPanel = new VerticalPanel();
    agreementsPanel.add(new SmallHeading(Util.C.headingAgreements()));
    useContributorAgreements = new CheckBox(Util.C.useContributorAgreements());
    useContributorAgreements.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useContributorAgreements);
    useSignedOffBy = new CheckBox(Util.C.useSignedOffBy(), true);
    useSignedOffBy.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useSignedOffBy);
    requireChangeID = new CheckBox(Util.C.requireChangeID(), true);
    requireChangeID.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(requireChangeID);
    add(agreementsPanel);
}
#method_after
private void initAgreements() {
    final ValueChangeHandler<Boolean> onChangeSave = new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            saveProject.setEnabled(true);
        }
    };
    agreementsPanel = new VerticalPanel();
    agreementsPanel.add(new SmallHeading(Util.C.headingAgreements()));
    useContributorAgreements = new CheckBox(Util.C.useContributorAgreements());
    useContributorAgreements.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useContributorAgreements);
    useSignedOffBy = new CheckBox(Util.C.useSignedOffBy(), true);
    useSignedOffBy.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useSignedOffBy);
    add(agreementsPanel);
}
#end_block

#method_before
void display(final ProjectDetail result) {
    project = result.project;
    final boolean isall = Gerrit.getConfig().getWildProject().equals(project.getNameKey());
    submitTypePanel.setVisible(!isall);
    agreementsPanel.setVisible(!isall);
    useContributorAgreements.setVisible(Gerrit.getConfig().isUseContributorAgreements());
    descTxt.setText(project.getDescription());
    useContributorAgreements.setValue(project.isUseContributorAgreements());
    useSignedOffBy.setValue(project.isUseSignedOffBy());
    requireChangeID.setValue(project.isRequireChangeID());
    setSubmitType(project.getSubmitType());
}
#method_after
void display(final ProjectDetail result) {
    project = result.project;
    final boolean isall = Gerrit.getConfig().getWildProject().equals(project.getNameKey());
    projectOptionsPanel.setVisible(!isall);
    agreementsPanel.setVisible(!isall);
    useContributorAgreements.setVisible(Gerrit.getConfig().isUseContributorAgreements());
    descTxt.setText(project.getDescription());
    useContributorAgreements.setValue(project.isUseContributorAgreements());
    useSignedOffBy.setValue(project.isUseSignedOffBy());
    requireChangeID.setValue(project.isRequireChangeID());
    setSubmitType(project.getSubmitType());
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    if (project.isRequireChangeID()) {
        // If the project wants Change-ID line, verify we
        // have it and it's legal.
        // 
        final List<String> idList = c.getFooterLines(CHANGE_ID);
        if (idList.isEmpty()) {
            reject(cmd, "missing Change-Id in commit message ");
            return false;
        }
        if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message ");
            return false;
        }
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    if (project.isRequireChangeID()) {
        final List<String> idList = c.getFooterLines(CHANGE_ID);
        if (idList.isEmpty()) {
            reject(cmd, "missing Change-Id in commit message ");
            return false;
        }
        if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message ");
            return false;
        }
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(info.getKey(), detail.getPatches());
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#end_block

#method_before
private void displayDownload() {
    final Branch.NameKey branchKey = changeDetail.getChange().getDest();
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous()) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.HTTP, "HTTP", r.toString()));
    }
    if (Gerrit.getConfig().isUseRepoDownload()) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Branch.NameKey branchKey = changeDetail.getChange().getDest();
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && allowedSchemes.contains(DownloadScheme.ANON_GIT)) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new RestoreChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                SideBySide link = new PatchLink.SideBySide(p.getFileName(), p.getKey(), 0, null);
                Window.open(link.getElement().toString(), p.getFileName(), null);
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Unified link = new PatchLink.Unified(p.getFileName(), p.getKey(), 0, null);
                Window.open(link.getElement().toString(), p.getFileName(), null);
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchSideBySide(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchUnified(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new DashboardKeyCommand(0, 'u', Util.C.upToDashboard()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("98%");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new UpToListKeyCommand(0, 'u', Util.C.upToChangeList()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("98%");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#end_block

#method_before
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    serveRegex("^/(.*?)/?$").with(new HttpServlet() {

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
            ProjectControl pc;
            try {
                pc = getProjectControl(req);
            } catch (ServiceNotEnabledException e) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            Project.NameKey dst = pc.getProject().getNameKey();
            StringBuilder r = new StringBuilder();
            r.append(urlProvider.get());
            r.append('#');
            r.append(PageLinks.toProject(dst, Change.Status.NEW));
            rsp.sendRedirect(r.toString());
        }
    });
}
#method_after
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    serveRegex("^/(.*?)/?$").with(new HttpServlet() {

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
            ProjectControl pc;
            try {
                pc = getProjectControl(req);
            } catch (ServiceNotEnabledException e) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            Project.NameKey dst = pc.getProject().getNameKey();
            StringBuilder r = new StringBuilder();
            r.append(urlProvider.get());
            r.append('#');
            r.append(PageLinks.toChangeQuery(PageLinks.projectQuery(dst, Change.Status.NEW)));
            rsp.sendRedirect(r.toString());
        }
    });
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    final ProjectControl pc = getProjectControl(req);
    final CurrentUser user = pc.getCurrentUser();
    final Set<AccountGroup.Id> uploadGroup = serverCommandConfig.getUploadGroup();
    if (uploadGroup != null && !uploadGroup.isEmpty()) {
        if (!CollectionsUtil.isAnyIncludedIn(user.getEffectiveGroups(), uploadGroup)) {
            throw new ServiceNotAuthorizedException();
        }
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, pc, db.get()));
    }
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, pc, db.get()));
    }
    return up;
}
#end_block

#method_before
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    final ProjectControl pc = getProjectControl(req);
    if (pc.getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
        final Set<AccountGroup.Id> receiveGroup = serverCommandConfig.getReceiveGroup();
        if (receiveGroup != null && !receiveGroup.isEmpty()) {
            if (!CollectionsUtil.isAnyIncludedIn(user.getEffectiveGroups(), receiveGroup)) {
                throw new ServiceNotAuthorizedException();
            }
        }
        final ReceiveCommits rc = factory.create(pc, db);
        final ReceiveCommits.Capable s = rc.canUpload();
        if (s != ReceiveCommits.Capable.OK) {
            // TODO We should alert the user to this message on the HTTP
            // response channel, assuming Git will even report it to them.
            // 
            final String who = user.getUserName();
            final String why = s.getMessage();
            log.warn("Rejected push from " + who + ": " + why);
            throw new ServiceNotEnabledException();
        }
        rc.getReceivePack().setRefLogIdent(user.newRefLogIdent());
        return rc.getReceivePack();
    } else {
        throw new ServiceNotAuthorizedException();
    }
}
#method_after
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    final ProjectControl pc = getProjectControl(req);
    if (!pc.canRunReceivePack()) {
        throw new ServiceNotAuthorizedException();
    }
    if (pc.getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
        final ReceiveCommits rc = factory.create(pc, db);
        final ReceiveCommits.Capable s = rc.canUpload();
        if (s != ReceiveCommits.Capable.OK) {
            // TODO We should alert the user to this message on the HTTP
            // response channel, assuming Git will even report it to them.
            // 
            final String who = user.getUserName();
            final String why = s.getMessage();
            log.warn("Rejected push from " + who + ": " + why);
            throw new ServiceNotEnabledException();
        }
        rc.getReceivePack().setRefLogIdent(user.newRefLogIdent());
        return rc.getReceivePack();
    } else {
        throw new ServiceNotAuthorizedException();
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    final Set<AccountGroup.Id> receiveGroup = getServerCommandConfig().getReceiveGroup();
    if (receiveGroup != null && !receiveGroup.isEmpty()) {
        if (!CollectionsUtil.isAnyIncludedIn(currentUser.getEffectiveGroups(), receiveGroup)) {
            throw new Failure(1, "User: " + currentUser.getUserName() + " not allowed to execute this command on this server");
        }
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    ReceiveCommits.Capable r = receive.canUpload();
    if (r != ReceiveCommits.Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = receive.getReceivePack();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    try {
        rp.receive(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunReceivePack()) {
        throw new Failure(1, "fatal: receive-pack not permitted on this server");
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    ReceiveCommits.Capable r = receive.canUpload();
    if (r != ReceiveCommits.Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = receive.getReceivePack();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    try {
        rp.receive(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    final Set<AccountGroup.Id> uploadGroup = getServerCommandConfig().getUploadGroup();
    if (uploadGroup != null && !uploadGroup.isEmpty()) {
        if (!CollectionsUtil.isAnyIncludedIn(currentUser.getEffectiveGroups(), uploadGroup)) {
            throw new Failure(1, "User: " + currentUser.getUserName() + " not allowed to execute this command on this server");
        }
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db.get()));
    }
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db.get()));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.Id>>() {
    }).annotatedWith(ProjectCreatorGroups.class).toProvider(ProjectCreatorGroupsProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.Id>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(new TypeLiteral<ServerCommand>() {
    }).annotatedWith(ServerCommandConfig.class).toProvider(ServerCommandConfigProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(MergeOp.Factory.class);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    factory(FunctionState.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
protected void init() {
    setupVelocityContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.email.equals(a.email)) {
            setHeader("Reply-To", a.email);
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    body = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#method_after
protected void init() throws EmailException {
    setupVelocityContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.email.equals(a.email)) {
            setHeader("Reply-To", a.email);
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    body = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#end_block

#method_before
private String getFromLine() {
    velocityContext.put("from", args.accountCache.get(fromId).getAccount());
    return velocify("#if ($from.fullName || $from.preferredEmail)From" + "#if ($from.fullName) $from.fullName#endif" + "#if ($from.preferredEmail) <$from.preferredEmail>#endif" + ":\n\n#endif");
}
#method_after
protected String getFromLine() {
    final Account account = args.accountCache.get(fromId).getAccount();
    final String name = account.getFullName();
    final String email = account.getPreferredEmail();
    StringBuilder f = new StringBuilder();
    if ((name != null && !name.isEmpty()) || (email != null && !email.isEmpty())) {
        f.append("From");
        if (name != null && !name.isEmpty()) {
            f.append(" ").append(name);
        }
        if (email != null && !email.isEmpty()) {
            f.append(" <").append(email).append(">");
        }
        f.append(":\n\n");
    }
    return f.toString();
}
#end_block

#method_before
protected String getGerritUrl() {
    return args.urlProvider.get();
}
#method_after
public String getGerritUrl() {
    return args.urlProvider.get();
}
#end_block

#method_before
protected void setVHeader(final String name, final String value) {
    setHeader(name, velocify(value));
}
#method_after
protected void setVHeader(final String name, final String value) throws EmailException {
    setHeader(name, velocify(value));
}
#end_block

#method_before
protected String getNameEmailFor(Account.Id accountId) {
    AccountState who = args.accountCache.get(accountId);
    String name = who.getAccount().getFullName();
    String email = who.getAccount().getPreferredEmail();
    if (name != null && email != null) {
        return name + " <" + email + ">";
    } else if (name != null) {
        return name;
    } else if (email != null) {
        return email;
    } else /* (name == null && email == null) */
    {
        return "Anonymous Coward #" + accountId;
    }
}
#method_after
public String getNameEmailFor(Account.Id accountId) {
    AccountState who = args.accountCache.get(accountId);
    String name = who.getAccount().getFullName();
    String email = who.getAccount().getPreferredEmail();
    if (name != null && email != null) {
        return name + " <" + email + ">";
    } else if (name != null) {
        return name;
    } else if (email != null) {
        return email;
    } else /* (name == null && email == null) */
    {
        return "Anonymous Coward #" + accountId;
    }
}
#end_block

#method_before
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#method_after
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (!a.isActive() || e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#end_block

#method_before
protected void setupVelocityContext() {
    String rl = "resource.loader";
    String pkg = "org.apache.velocity.runtime.resource.loader";
    Properties p = new Properties();
    p.setProperty(rl, "file, class");
    p.setProperty("file." + rl + ".class", pkg + ".FileResourceLoader");
    p.setProperty("file." + rl + ".path", args.site.mail_dir.getAbsolutePath());
    p.setProperty("class." + rl + ".class", pkg + ".ClasspathResourceLoader");
    p.setProperty(org.apache.velocity.runtime.RuntimeConstants.RUNTIME_LOG, new File(args.site.logs_dir, "error_log").getAbsolutePath());
    try {
        Velocity.init(p);
    } catch (Exception e) {
    }
    velocityContext = new VelocityContext();
    velocityContext.put("email", this);
    velocityContext.put("messageClass", messageClass);
    velocityContext.put("StringUtils", StringUtils.class);
}
#method_after
protected void setupVelocityContext() {
    velocityContext = new VelocityContext();
    velocityContext.put("email", this);
    velocityContext.put("messageClass", messageClass);
    velocityContext.put("StringUtils", StringUtils.class);
}
#end_block

#method_before
protected String velocify(String tpl) {
    try {
        StringWriter w = new StringWriter();
        Velocity.evaluate(velocityContext, w, "OutgoingEmail", tpl);
        return w.toString();
    } catch (Exception e) {
        return tpl.toString();
    }
}
#method_after
protected String velocify(String tpl) throws EmailException {
    try {
        StringWriter w = new StringWriter();
        Velocity.evaluate(velocityContext, w, "OutgoingEmail", tpl);
        return w.toString();
    } catch (Exception e) {
        throw new EmailException("Velocity template " + tpl.toString(), e);
    }
}
#end_block

#method_before
protected String velocifyFile(String name) {
    Exception eo;
    try {
        StringWriter w = new StringWriter();
        Velocity.mergeTemplate(name, velocityContext, w);
        return w.toString();
    } catch (ResourceNotFoundException e) {
        try {
            StringWriter w = new StringWriter();
            String pkg = "com/google/gerrit/server/mail/";
            Velocity.mergeTemplate(pkg + name, velocityContext, w);
            return w.toString();
        } catch (Exception e2) {
            eo = e;
        }
    } catch (Exception e) {
        eo = e;
    }
    return "Velocity exception in template " + name + ".\n" + eo.toString();
}
#method_after
protected String velocifyFile(String name) throws EmailException {
    try {
        StringWriter w = new StringWriter();
        Velocity.mergeTemplate(name, velocityContext, w);
        return w.toString();
    } catch (ResourceNotFoundException e) {
        try {
            StringWriter w = new StringWriter();
            String pkg = "com/google/gerrit/server/mail/";
            Velocity.mergeTemplate(pkg + name, velocityContext, w);
            return w.toString();
        } catch (Exception e2) {
            throw new EmailException("Velocity WAR template" + name + ".\n", e2);
        }
    } catch (Exception e) {
        throw new EmailException("Velocity template " + name + ".\n", e);
    }
}
#end_block

#method_before
protected void format() {
    formatChange();
    if (getChangeUrl() != null) {
        openFooter();
        appendText("To view visit ");
        appendText(getChangeUrl());
        appendText("\n");
    }
    if (getSettingsUrl() != null) {
        openFooter();
        appendText("To unsubscribe, visit ");
        appendText(getSettingsUrl());
        appendText("\n");
    }
    if (inFooter) {
        appendText("\n");
    } else {
        openFooter();
    }
    appendText("Gerrit-MessageType: " + messageClass + "\n");
    appendText("Gerrit-Project: " + projectName + "\n");
    appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
    appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#method_after
protected void format() throws EmailException {
    formatChange();
    appendText(velocifyFile("ChangeFooter.vm"));
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#end_block

#method_before
protected void init() {
    super.init();
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
    inFooter = false;
}
#method_after
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    super.init();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
}
#end_block

#method_before
private void setListIdHeader() {
    // Set a reasonable list id so that filters can be used to sort messages
    setVHeader("Mailing-List", "list $email.listId");
    setVHeader("List-Id", "<$email.listId.replace('@', '.')>");
    if (getSettingsUrl() != null) {
        setVHeader("List-Unsubscribe", "<$email.settingsUrl>");
    }
}
#method_after
private void setListIdHeader() throws EmailException {
    // Set a reasonable list id so that filters can be used to sort messages
    setVHeader("Mailing-List", "list $email.listId");
    setVHeader("List-Id", "<$email.listId.replace('@', '.')>");
    if (getSettingsUrl() != null) {
        setVHeader("List-Unsubscribe", "<$email.settingsUrl>");
    }
}
#end_block

#method_before
public String getListId() {
    return velocify("gerrit-$projectName.replace('/', '-')@$email.gerritHost");
}
#method_after
public String getListId() throws EmailException {
    return velocify("gerrit-$projectName.replace('/', '-')@$email.gerritHost");
}
#end_block

#method_before
private void setChangeSubjectHeader() {
    final StringBuilder subj = new StringBuilder();
    subj.append("[");
    subj.append(change.getDest().getShortName());
    subj.append("] ");
    subj.append("Change ");
    subj.append(change.getKey().abbreviate());
    subj.append(": (");
    subj.append(projectName);
    subj.append(") ");
    if (change.getSubject().length() > 60) {
        subj.append(change.getSubject().substring(0, 60));
        subj.append("...");
    } else {
        subj.append(change.getSubject());
    }
    setHeader("Subject", subj.toString());
}
#method_after
private void setChangeSubjectHeader() throws EmailException {
    setHeader("Subject", velocifyFile("ChangeSubject.vm"));
}
#end_block

#method_before
protected String getChangeUrl() {
    if (change != null && getGerritUrl() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(getGerritUrl());
        r.append(change.getChangeId());
        return r.toString();
    }
    return null;
}
#method_after
public String getChangeUrl() {
    if (change != null && getGerritUrl() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(getGerritUrl());
        r.append(change.getChangeId());
        return r.toString();
    }
    return null;
}
#end_block

#method_before
public String getChangeMessageThreadId() {
    return velocify("<gerrit.${change.createdOn.time}.$change.key.get()" + "@$email.gerritHost>");
}
#method_after
public String getChangeMessageThreadId() throws EmailException {
    return velocify("<gerrit.${change.createdOn.time}.$change.key.get()" + "@$email.gerritHost>");
}
#end_block

#method_before
protected String getCoverLetter() {
    if (changeMessage != null) {
        final String txt = changeMessage.getMessage();
        if (txt != null) {
            return txt.trim();
        }
    }
    return "";
}
#method_after
public String getCoverLetter() {
    if (changeMessage != null) {
        final String txt = changeMessage.getMessage();
        if (txt != null) {
            return txt.trim();
        }
    }
    return "";
}
#end_block

#method_before
protected void formatChangeDetail() {
    if (patchSetInfo != null) {
        appendText(patchSetInfo.getMessage().trim());
        appendText("\n");
    } else {
        appendText(change.getSubject().trim());
        appendText("\n");
    }
    if (patchSet != null) {
        appendText("---\n");
        for (PatchListEntry p : getPatchList().getPatches()) {
            appendText(p.getChangeType().getCode() + " " + p.getNewName() + "\n");
        }
        appendText("\n");
    }
}
#method_after
protected void formatChangeDetail() {
    appendText(getChangeDetail());
}
#end_block

#method_before
@Override
protected void setupVelocityContext() {
    super.setupVelocityContext();
    velocityContext.put("change", change);
    velocityContext.put("branch", change.getDest());
    velocityContext.put("projectName", projectName);
    velocityContext.put("patchSet", patchSet);
    velocityContext.put("patchSetInfo", patchSetInfo);
}
#method_after
@Override
protected void setupVelocityContext() {
    super.setupVelocityContext();
    velocityContext.put("change", change);
    velocityContext.put("changeId", change.getKey());
    velocityContext.put("coverLetter", getCoverLetter());
    velocityContext.put("branch", change.getDest());
    velocityContext.put("fromName", getNameFor(fromId));
    velocityContext.put("projectName", projectName);
    velocityContext.put("patchSet", patchSet);
    velocityContext.put("patchSetInfo", patchSetInfo);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    setHeader("Subject", "[Gerrit Code Review] Email Verification");
    add(RecipientType.TO, new Address(addr));
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    setHeader("Subject", "[Gerrit Code Review] Email Verification");
    add(RecipientType.TO, new Address(addr));
}
#end_block

#method_before
@Override
protected void format() {
    appendText(velocifyFile("RegisterNewEmail.vm"));
}
#method_after
@Override
protected void format() throws EmailException {
    appendText(velocifyFile("RegisterNewEmail.vm"));
}
#end_block

#method_before
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("NewChange.vm");
    extractMailExample("RegisterNewEmail.vm");
    extractMailExample("ReplacePatchSet.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#method_after
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("Abandoned.vm");
    extractMailExample("ChangeFooter.vm");
    extractMailExample("ChangeSubject.vm");
    extractMailExample("Comment.vm");
    extractMailExample("Merged.vm");
    extractMailExample("MergeFail.vm");
    extractMailExample("NewChange.vm");
    extractMailExample("RegisterNewEmail.vm");
    extractMailExample("ReplacePatchSet.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#end_block

#method_before
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, "/" + orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#method_after
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    setHeader("Message-ID", getChangeMessageThreadId());
    add(RecipientType.TO, reviewers);
    add(RecipientType.CC, extraCC);
    rcptToAuthors(RecipientType.CC);
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    setHeader("Message-ID", getChangeMessageThreadId());
    add(RecipientType.TO, reviewers);
    add(RecipientType.CC, extraCC);
    rcptToAuthors(RecipientType.CC);
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("NewChange.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("NewChange.vm"));
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (fromId != null) {
        // Don't call yourself a reviewer of your own patch set.
        // 
        reviewers.remove(fromId);
    }
    add(RecipientType.TO, reviewers);
    add(RecipientType.CC, extraCC);
    rcptToAuthors(RecipientType.CC);
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    if (fromId != null) {
        // Don't call yourself a reviewer of your own patch set.
        // 
        reviewers.remove(fromId);
    }
    add(RecipientType.TO, reviewers);
    add(RecipientType.CC, extraCC);
    rcptToAuthors(RecipientType.CC);
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("ReplacePatchSet.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("ReplacePatchSet.vm"));
}
#end_block

#method_before
protected void format() {
    formatChange();
    if (getChangeUrl() != null) {
        openFooter();
        appendText("To view visit ");
        appendText(getChangeUrl());
        appendText("\n");
    }
    if (getSettingsUrl() != null) {
        openFooter();
        appendText("To unsubscribe, visit ");
        appendText(getSettingsUrl());
        appendText("\n");
    }
    if (inFooter) {
        appendText("\n");
    } else {
        openFooter();
    }
    appendText("Gerrit-MessageType: " + messageClass + "\n");
    appendText("Gerrit-Project: " + projectName + "\n");
    appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
    appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#method_after
protected void format() throws EmailException {
    formatChange();
    appendText(velocifyFile("ChangeFooter.vm"));
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#end_block

#method_before
protected void init() {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    super.init();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
    inFooter = false;
}
#method_after
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    super.init();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
}
#end_block

#method_before
private void setChangeSubjectHeader() {
    final StringBuilder subj = new StringBuilder();
    subj.append("[");
    subj.append(change.getDest().getShortName());
    subj.append("] ");
    subj.append("Change ");
    subj.append(change.getKey().abbreviate());
    subj.append(": (");
    subj.append(projectName);
    subj.append(") ");
    if (change.getSubject().length() > 60) {
        subj.append(change.getSubject().substring(0, 60));
        subj.append("...");
    } else {
        subj.append(change.getSubject());
    }
    setHeader("Subject", subj.toString());
}
#method_after
private void setChangeSubjectHeader() throws EmailException {
    setHeader("Subject", velocifyFile("ChangeSubject.vm"));
}
#end_block

#method_before
@Override
protected void setupVelocityContext() {
    super.setupVelocityContext();
    velocityContext.put("change", change);
    velocityContext.put("branch", change.getDest());
    velocityContext.put("projectName", projectName);
    velocityContext.put("patchSet", patchSet);
    velocityContext.put("patchSetInfo", patchSetInfo);
}
#method_after
@Override
protected void setupVelocityContext() {
    super.setupVelocityContext();
    velocityContext.put("change", change);
    velocityContext.put("changeId", change.getKey());
    velocityContext.put("coverLetter", getCoverLetter());
    velocityContext.put("branch", change.getDest());
    velocityContext.put("fromName", getNameFor(fromId));
    velocityContext.put("projectName", projectName);
    velocityContext.put("patchSet", patchSet);
    velocityContext.put("patchSetInfo", patchSetInfo);
}
#end_block

#method_before
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("Abandoned.vm");
    extractMailExample("MergeFail.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#method_after
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("Abandoned.vm");
    extractMailExample("ChangeFooter.vm");
    extractMailExample("ChangeSubject.vm");
    extractMailExample("Comment.vm");
    extractMailExample("Merged.vm");
    extractMailExample("MergeFail.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#end_block

#method_before
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, "/" + orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#method_after
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccExistingReviewers();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccExistingReviewers();
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("MergeFail.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("MergeFail.vm"));
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("Abandoned.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("Abandoned.vm"));
}
#end_block

#method_before
protected void format() {
    formatChange();
    if (getChangeUrl() != null) {
        openFooter();
        appendText("To view visit ");
        appendText(getChangeUrl());
        appendText("\n");
    }
    if (getSettingsUrl() != null) {
        openFooter();
        appendText("To unsubscribe, visit ");
        appendText(getSettingsUrl());
        appendText("\n");
    }
    if (inFooter) {
        appendText("\n");
    } else {
        openFooter();
    }
    appendText("Gerrit-MessageType: " + messageClass + "\n");
    appendText("Gerrit-Project: " + projectName + "\n");
    appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
    appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#method_after
protected void format() throws EmailException {
    formatChange();
    if (getChangeUrl() != null) {
        openFooter();
        appendText("To view visit ");
        appendText(getChangeUrl());
        appendText("\n");
    }
    if (getSettingsUrl() != null) {
        openFooter();
        appendText("To unsubscribe, visit ");
        appendText(getSettingsUrl());
        appendText("\n");
    }
    if (inFooter) {
        appendText("\n");
    } else {
        openFooter();
    }
    appendText("Gerrit-MessageType: " + messageClass + "\n");
    appendText("Gerrit-Project: " + projectName + "\n");
    appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
    appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#end_block

#method_before
protected void init() {
    super.init();
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
    inFooter = false;
}
#method_after
protected void init() {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    super.init();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
    inFooter = false;
}
#end_block

#method_before
private String getSettingsUrl() {
    if (getGerritUrl() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(getGerritUrl());
        r.append("settings");
        return r.toString();
    }
    return null;
}
#method_after
public String getSettingsUrl() {
    if (getGerritUrl() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(getGerritUrl());
        r.append("settings");
        return r.toString();
    }
    return null;
}
#end_block

#method_before
protected void setVHeader(final String name, final String value) {
    setHeader(name, velocify(value));
}
#method_after
protected void setVHeader(final String name, final String value) throws EmailException {
    setHeader(name, velocify(value));
}
#end_block

#method_before
private void add(final RecipientType rt, final UserIdentity who) {
    if (who != null && who.getAccount() != null) {
        add(rt, who.getAccount());
    }
}
#method_after
protected void add(final RecipientType rt, final UserIdentity who) {
    if (who != null && who.getAccount() != null) {
        add(rt, who.getAccount());
    }
}
#end_block

#method_before
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#method_after
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (!a.isActive() || e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#end_block

#method_before
protected void setupVelocityContext() {
    String rl = "resource.loader";
    String pkg = "org.apache.velocity.runtime.resource.loader";
    Properties p = new Properties();
    p.setProperty(rl, "file, class");
    p.setProperty("file." + rl + ".class", pkg + ".FileResourceLoader");
    p.setProperty("file." + rl + ".path", args.site.mail_dir.getAbsolutePath());
    p.setProperty("class." + rl + ".class", pkg + ".ClasspathResourceLoader");
    p.setProperty(org.apache.velocity.runtime.RuntimeConstants.RUNTIME_LOG, args.site.logs_dir.getAbsolutePath() + java.io.File.separator + "velocity_log");
    try {
        Velocity.init(p);
    } catch (Exception e) {
    }
    velocityContext = new VelocityContext();
    velocityContext.put("email", this);
    velocityContext.put("messageClass", messageClass);
    velocityContext.put("StringUtils", StringUtils.class);
}
#method_after
protected void setupVelocityContext() {
    velocityContext = new VelocityContext();
    velocityContext.put("email", this);
    velocityContext.put("messageClass", messageClass);
    velocityContext.put("StringUtils", StringUtils.class);
}
#end_block

#method_before
protected String velocify(String tpl) {
    try {
        StringWriter w = new StringWriter();
        Velocity.evaluate(velocityContext, w, "OutgoingEmail", tpl);
        return w.toString();
    } catch (Exception e) {
        return tpl.toString();
    }
}
#method_after
protected String velocify(String tpl) throws EmailException {
    try {
        StringWriter w = new StringWriter();
        Velocity.evaluate(velocityContext, w, "OutgoingEmail", tpl);
        return w.toString();
    } catch (Exception e) {
        throw new EmailException("Velocity template " + tpl.toString(), e);
    }
}
#end_block

#method_before
protected String velocifyFile(String name) {
    Exception eo;
    StringWriter w = new StringWriter();
    try {
        Velocity.mergeTemplate(name, velocityContext, w);
        return w.toString();
    } catch (ResourceNotFoundException e) {
        try {
            String pkg = "com/google/gerrit/server/mail/";
            Velocity.mergeTemplate(pkg + name, velocityContext, w);
            return w.toString();
        } catch (Exception e2) {
            eo = e;
        }
    } catch (Exception e) {
        eo = e;
    }
    return "Velocity exception in template " + name + ".\n" + eo.toString();
}
#method_after
protected String velocifyFile(String name) throws EmailException {
    try {
        StringWriter w = new StringWriter();
        Velocity.mergeTemplate(name, velocityContext, w);
        return w.toString();
    } catch (ResourceNotFoundException e) {
        try {
            StringWriter w = new StringWriter();
            String pkg = "com/google/gerrit/server/mail/";
            Velocity.mergeTemplate(pkg + name, velocityContext, w);
            return w.toString();
        } catch (Exception e2) {
            throw new EmailException("Velocity WAR template" + name + ".\n", e2);
        }
    } catch (Exception e) {
        throw new EmailException("Velocity template " + name + ".\n", e);
    }
}
#end_block

#method_before
@Override
public void onRequestSuggestions(final Request req, final Callback callback) {
    RpcStatus.hide(new Runnable() {

        public void run() {
            SuggestUtil.SVC.suggestAccount(req.getQuery(), new Boolean(true), req.getLimit(), new GerritCallback<List<AccountInfo>>() {

                public void onSuccess(final List<AccountInfo> result) {
                    final ArrayList<AccountSuggestion> r = new ArrayList<AccountSuggestion>(result.size());
                    for (final AccountInfo p : result) {
                        r.add(new AccountSuggestion(p));
                    }
                    callback.onSuggestionsReady(req, new Response(r));
                }
            });
        }
    });
}
#method_after
@Override
public void onRequestSuggestions(final Request req, final Callback callback) {
    RpcStatus.hide(new Runnable() {

        public void run() {
            SuggestUtil.SVC.suggestAccount(req.getQuery(), Boolean.TRUE, req.getLimit(), new GerritCallback<List<AccountInfo>>() {

                public void onSuccess(final List<AccountInfo> result) {
                    final ArrayList<AccountSuggestion> r = new ArrayList<AccountSuggestion>(result.size());
                    for (final AccountInfo p : result) {
                        r.add(new AccountSuggestion(p));
                    }
                    callback.onSuggestionsReady(req, new Response(r));
                }
            });
        }
    });
}
#end_block

#method_before
private void addSuggestion(Map map, Account account, AccountInfo info, Boolean active) {
    if (active != null) {
        if (active.booleanValue() != account.isActive()) {
            return;
        }
    }
    map.put(account.getId(), info);
}
#method_after
private void addSuggestion(Map map, Account account, AccountInfo info, Boolean active) {
    if (active == null || active == account.isActive()) {
        map.put(account.getId(), info);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) {
    return new LabelPredicate(args.changeControlGenericFactory, args.userFactory, args.dbProvider, args.approvalTypes, name);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) {
    return new LabelPredicate(args.changeControlGenericFactory, args.userFactory, args.dbProvider, args.approvalTypes, args.projectCache, name);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    install(new PredicateModule());
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    install(new ChangeQueryModule());
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    ChangeDataSource source = source();
    if (source == null) {
        throw new OrmException("No ChangeDataSource: " + this);
    }
    // TODO(spearce) This probably should be more lazy.
    // 
    ArrayList<ChangeData> r = new ArrayList<ChangeData>();
    ChangeData last = null;
    boolean skipped = false;
    for (ChangeData cd : prefetchData(source)) {
        if (match(cd)) {
            r.add(cd);
        } else {
            skipped = true;
        }
        last = cd;
    }
    if (skipped && last != null && source instanceof Paginated) {
        // If our source is a paginated source and we skipped at
        // least one of its results, we may not have filled the full
        // limit the caller wants.  Restart the source and continue.
        // 
        Paginated p = (Paginated) source;
        while (skipped && r.size() < p.limit()) {
            ChangeData lastBeforeRestart = last;
            skipped = false;
            last = null;
            for (ChangeData cd : p.restart(lastBeforeRestart)) {
                if (match(cd)) {
                    r.add(cd);
                } else {
                    skipped = true;
                }
                last = cd;
            }
        }
    }
    return new ListResultSet<ChangeData>(r);
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    ChangeDataSource source = source();
    if (source == null) {
        throw new OrmException("No ChangeDataSource: " + this);
    }
    // TODO(spearce) This probably should be more lazy.
    // 
    ArrayList<ChangeData> r = new ArrayList<ChangeData>();
    ChangeData last = null;
    boolean skipped = false;
    for (ChangeData cd : prefetchData(source.read())) {
        if (match(cd)) {
            r.add(cd);
        } else {
            skipped = true;
        }
        last = cd;
    }
    if (skipped && last != null && source instanceof Paginated) {
        // If our source is a paginated source and we skipped at
        // least one of its results, we may not have filled the full
        // limit the caller wants.  Restart the source and continue.
        // 
        Paginated p = (Paginated) source;
        while (skipped && r.size() < p.limit()) {
            ChangeData lastBeforeRestart = last;
            skipped = false;
            last = null;
            for (ChangeData cd : prefetchData(p.restart(lastBeforeRestart))) {
                if (match(cd)) {
                    r.add(cd);
                } else {
                    skipped = true;
                }
                last = cd;
            }
        }
    }
    return new ListResultSet<ChangeData>(r);
}
#end_block

#method_before
private Collection<ChangeData> prefetchData(ChangeDataSource source) throws OrmException {
    final ReviewDb db = dbProvider.get();
    final ArrayList<ChangeData> data = new ArrayList<ChangeData>();
    final EnumSet<NeededData> needed = getNeededData();
    for (ChangeData cd : source.read()) {
        data.add(cd);
    }
    for (ChangeData cd : data) {
        if (needed.contains(NeededData.APPROVALS)) {
            cd.setApprovals(db.patchSetApprovals().byChange(cd.getId()).toList());
        }
        if (needed.contains(NeededData.CHANGE)) {
            cd.setChange(db.changes().get(cd.getId()));
        }
        if (needed.contains(NeededData.PATCHES)) {
            cd.setPatches(db.patchSets().byChange(cd.getId()).toList());
        }
        if (needed.contains(NeededData.COMMENTS)) {
            cd.setComments(db.patchComments().byChange(cd.getId()).toList());
        }
        if (needed.contains(NeededData.TRACKING_IDS)) {
            cd.setTrackingIds(db.trackingIds().byChange(cd.getId()).toList());
        }
    }
    if (needed.contains(NeededData.PROJECT_STATE)) {
        ArrayList<Project.NameKey> projectNames = new ArrayList<Project.NameKey>();
        for (ChangeData cd : data) {
            projectNames.add(cd.getChange().getProject());
        }
        Map<Project.NameKey, ProjectState> projectMap = projectCache.getAll(projectNames);
        for (ChangeData cd : data) {
            cd.setProjectState(projectMap.get(cd.getChange().getProject()));
        }
    }
    db.close();
    return data;
}
#method_after
private Collection<ChangeData> prefetchData(ResultSet<ChangeData> resultSet) throws OrmException {
    final List<ChangeData> data = resultSet.toList();
    final EnumSet<NeededData> needed = getNeededData();
    if (needed.contains(NeededData.PROJECT_STATE)) {
        needed.add(NeededData.CHANGE);
    }
    if (needed.contains(NeededData.CHANGE)) {
        HashMap<Change.Id, ChangeData> need = new HashMap<Change.Id, ChangeData>();
        for (ChangeData cd : data) {
            if (!cd.hasChange()) {
                need.put(cd.getId(), cd);
            }
        }
        if (!need.isEmpty()) {
            for (Change c : dbProvider.get().changes().get(need.keySet())) {
                need.get(c.getId()).setChange(c);
            }
        }
    }
    if (needed.contains(NeededData.PROJECT_STATE)) {
        HashSet<Project.NameKey> projectNames = new HashSet<Project.NameKey>();
        for (ChangeData cd : data) {
            projectNames.add(cd.getChange().getProject());
        }
        Map<Project.NameKey, ProjectState> projectMap = projectCache.getAll(projectNames);
        for (ChangeData cd : data) {
            cd.setProjectState(projectMap.get(cd.getChange().getProject()));
        }
    }
    return data;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData cd) throws OrmException {
    if (rules == null) {
        ChangeQueryBuilder builder = new ChangeQueryBuilder(args, user);
        rules = new HashMap<Project.NameKey, List<Predicate<ChangeData>>>();
        for (AccountProjectWatch w : user.getNotificationFilters()) {
            List<Predicate<ChangeData>> list = rules.get(w.getProjectNameKey());
            if (list == null) {
                list = new ArrayList<Predicate<ChangeData>>(4);
                rules.put(w.getProjectNameKey(), list);
            }
            Predicate<ChangeData> p = compile(builder, w);
            if (p != null) {
                list.add(p);
            }
        }
    }
    if (rules.isEmpty()) {
        return false;
    }
    Change change = cd.change(args.dbProvider);
    if (change == null) {
        return false;
    }
    Project.NameKey project = change.getDest().getParentKey();
    List<Predicate<ChangeData>> list = rules.get(project);
    if (list == null) {
        list = rules.get(args.wildProjectName);
    }
    if (list != null) {
        for (Predicate<ChangeData> p : list) {
            if (p.match(cd)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
@Override
public boolean match(final ChangeData cd) throws OrmException {
    Map<Project.NameKey, List<Predicate<ChangeData>>> rules = getRules();
    if (rules.isEmpty()) {
        return false;
    }
    Change change = cd.change(args.dbProvider);
    if (change == null) {
        return false;
    }
    Project.NameKey project = change.getDest().getParentKey();
    List<Predicate<ChangeData>> list = rules.get(project);
    if (list == null) {
        list = rules.get(args.wildProjectName);
    }
    if (list != null) {
        for (Predicate<ChangeData> p : list) {
            if (p.match(cd)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public EnumSet<NeededData> getNeededData() {
    return EnumSet.of(NeededData.CHANGE);
}
#method_after
@Override
public EnumSet<NeededData> getNeededData() {
    Map<NameKey, List<Predicate<ChangeData>>> rules = getRules();
    if (rules.isEmpty()) {
        return EnumSet.noneOf(NeededData.class);
    }
    EnumSet<NeededData> needed = EnumSet.of(NeededData.CHANGE);
    for (List<Predicate<ChangeData>> list : rules.values()) {
        for (Predicate<ChangeData> p : list) {
            if (p instanceof Prefetchable) {
                needed.addAll(((Prefetchable) p).getNeededData());
            }
        }
    }
    return needed;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    for (PatchSetApproval p : object.currentApprovals(dbProvider)) {
        if (p.getCategoryId().equals(category)) {
            short psVal = p.getValue();
            if (test.match(psVal, expVal)) {
                // 
                try {
                    ChangeControl cc = // 
                    ccFactory.controlFor(// 
                    object.change(dbProvider), userFactory.create(dbProvider, p.getAccountId()));
                    if (!cc.isVisible()) {
                        // 
                        continue;
                    }
                    psVal = cc.normalize(category, psVal);
                } catch (NoSuchChangeException e) {
                    // 
                    continue;
                }
                if (test.match(psVal, expVal)) {
                    return true;
                }
            }
        }
    }
    return false;
}
#method_after
@Override
public boolean match(final ChangeData object) throws OrmException {
    for (PatchSetApproval p : object.currentApprovals(dbProvider)) {
        if (p.getCategoryId().equals(category)) {
            short psVal = p.getValue();
            if (test.match(psVal, expVal)) {
                // Double check the value is still permitted for the user.
                // 
                Change c = object.change(dbProvider);
                IdentifiedUser user = userFactory.create(dbProvider, p.getAccountId());
                ChangeControl cc = object.projectState(dbProvider, projectCache).controlFor(user).controlFor(c);
                if (!cc.isVisible()) {
                    // 
                    continue;
                }
                psVal = cc.normalize(category, psVal);
                if (test.match(psVal, expVal)) {
                    return true;
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public EnumSet<NeededData> getNeededData() {
    return EnumSet.of(NeededData.APPROVALS, NeededData.CHANGE);
}
#method_after
@Override
public EnumSet<NeededData> getNeededData() {
    return EnumSet.of(NeededData.APPROVALS, NeededData.CHANGE, NeededData.PROJECT_STATE);
}
#end_block

#method_before
@Override
public Map<K, V> getAll(Iterable<? extends K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#method_after
@Override
public Map<K, V> getAll(Iterable<K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#end_block

#method_before
@Override
public Map<K, V> getAll(Iterable<? extends K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#method_after
@Override
public Map<K, V> getAll(Iterable<K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#end_block

#method_before
@Override
public Map<K, V> getAll(Iterable<? extends K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#method_after
@Override
public Map<K, V> getAll(Iterable<K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#end_block

#method_before
@Override
public Map<K, V> getAll(Iterable<? extends K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#method_after
@Override
public Map<K, V> getAll(Iterable<K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#end_block

#method_before
void print(PrintWriter out) {
    seen.clear();
    collisions.clear();
    for (RelationModel r : rels) {
        for (ColumnModel c : r.getColumns()) {
            if (c.isNested()) {
                String type = getShortClassName(c);
                if (seen.contains(type)) {
                    collisions.add(type);
                } else {
                    seen.add(type);
                }
            }
        }
    }
    seen.clear();
    for (RelationModel r : rels) {
        generateMessage(r, out);
    }
    out.print("message " + schemaName + " {\n");
    for (RelationModel r : sortRelations(rels)) {
        out.print("\toptional " + getName(r) + " " + r.getRelationName().toLowerCase() + " = " + r.getRelationId() + ";\n");
    }
    out.print("}\n");
}
#method_after
void print(PrintWriter out) {
    seen.clear();
    collisions.clear();
    for (RelationModel r : rels) {
        for (ColumnModel c : r.getColumns()) {
            if (c.isNested()) {
                String type = getShortClassName(c);
                if (seen.contains(type)) {
                    collisions.add(type);
                } else {
                    seen.add(type);
                }
            }
        }
    }
    seen.clear();
    for (RelationModel r : rels) {
        generateMessage(r, out);
    }
    out.print("message " + schemaName + " {\n");
    for (RelationModel r : sortRelations(rels)) {
        out.print("\toptional " + getMessageName(r) + " " + r.getRelationName().toLowerCase() + " = " + r.getRelationID() + ";\n");
    }
    out.print("}\n");
}
#end_block

#method_before
private void generateMessage(RelationModel rel, PrintWriter out) {
    List<ColumnModel> cols = sortColumns(rel.getFields());
    for (ColumnModel c : cols) {
        generateMessage(c, out);
    }
    out.print("message " + getName(rel) + " {\n");
    for (ColumnModel c : cols) {
        out.append("\toptional " + getType(c) + " " + getName(c) + " = " + c.getColumnID() + ";\n");
    }
    out.print("}\n\n");
}
#method_after
private void generateMessage(RelationModel rel, PrintWriter out) {
    List<ColumnModel> cols = sortColumns(rel.getFields());
    for (ColumnModel c : cols) {
        generateMessage(c, out);
    }
    out.print("message " + getMessageName(rel) + " {\n");
    for (ColumnModel c : cols) {
        out.append("\toptional " + getType(c) + " " + getName(c) + " = " + c.getColumnID() + ";\n");
    }
    out.print("}\n\n");
}
#end_block

#method_before
private static String toProtoType(Class<?> clazz) {
    switch(Type.getType(clazz).getSort()) {
        case Type.BOOLEAN:
            return "bool";
        case Type.CHAR:
            return "uint32";
        case Type.BYTE:
        case Type.SHORT:
        case Type.INT:
            return "sint32";
        case Type.FLOAT:
            return "float";
        case Type.DOUBLE:
            return "double";
        case Type.LONG:
            return "sint64";
        case Type.ARRAY:
        case Type.OBJECT:
            {
                if (clazz == byte[].class) {
                    return "bytes";
                } else if (clazz == String.class) {
                    return "string";
                } else if (clazz == java.sql.Timestamp.class) {
                    return "fixed64";
                } else if (clazz.isEnum()) {
                    // TODO handle enums
                    return "enum";
                } else {
                    throw new RuntimeException("Type " + clazz + " not supported on protobuf!");
                }
            }
        default:
            throw new RuntimeException("Type " + clazz + " not supported on protobuf!");
    }
}
#method_after
private static String toProtoType(Class<?> clazz) {
    switch(Type.getType(clazz).getSort()) {
        case Type.BOOLEAN:
            return "bool";
        case Type.CHAR:
            return "uint32";
        case Type.BYTE:
        case Type.SHORT:
        case Type.INT:
            return "sint32";
        case Type.FLOAT:
            return "float";
        case Type.DOUBLE:
            return "double";
        case Type.LONG:
            return "sint64";
        case Type.ARRAY:
        case Type.OBJECT:
            {
                if (clazz == byte[].class) {
                    return "bytes";
                } else if (clazz == String.class) {
                    return "string";
                } else if (clazz == java.sql.Timestamp.class) {
                    return "fixed64";
                } else {
                    throw new RuntimeException("Type " + clazz + " not supported on protobuf!");
                }
            }
        default:
            throw new RuntimeException("Type " + clazz + " not supported on protobuf!");
    }
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case OPENID:
            config.setAllowedOpenIDs(authConfig.getAllowedOpenIDs());
            break;
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            break;
    }
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseRepoDownload(cfg.getBoolean("repo", null, "showdownloadcommand", false));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadProtocol(protocolConfig.getDownloadUrl());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebLink(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    List<RegexFindReplace> links = new ArrayList<RegexFindReplace>();
    for (String name : cfg.getSubsections("commentlink")) {
        String match = cfg.getString("commentlink", name, "match");
        // At the minimum, we can trap problems related to unmatched groups.
        try {
            Pattern.compile(match);
        } catch (PatternSyntaxException e) {
            throw new ProvisionException("Invalid pattern \"" + match + "\" in commentlink." + name + ".match: " + e.getMessage());
        }
        String link = cfg.getString("commentlink", name, "link");
        String html = cfg.getString("commentlink", name, "html");
        if (html == null || html.isEmpty()) {
            html = "<a href=\"" + link + "\">$&</a>";
        }
        links.add(new RegexFindReplace(match, html));
    }
    config.setCommentLinks(links);
    config.setBackgroundColor(getThemeColor("backgroundColor", "#FFFFFF"));
    config.setTextColor(getThemeColor("textColor", "#000000"));
    config.setTrimColor(getThemeColor("trimColor", "#D4E9A9"));
    config.setSelectionColor(getThemeColor("selectionColor", "#FFFFCC"));
    config.setTopMenuColor(getThemeColor("topMenuColor", config.getTrimColor()));
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case OPENID:
            config.setAllowedOpenIDs(authConfig.getAllowedOpenIDs());
            break;
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            break;
    }
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(schemeConfig.getDownloadScheme());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebLink(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    List<RegexFindReplace> links = new ArrayList<RegexFindReplace>();
    for (String name : cfg.getSubsections("commentlink")) {
        String match = cfg.getString("commentlink", name, "match");
        // At the minimum, we can trap problems related to unmatched groups.
        try {
            Pattern.compile(match);
        } catch (PatternSyntaxException e) {
            throw new ProvisionException("Invalid pattern \"" + match + "\" in commentlink." + name + ".match: " + e.getMessage());
        }
        String link = cfg.getString("commentlink", name, "link");
        String html = cfg.getString("commentlink", name, "html");
        if (html == null || html.isEmpty()) {
            html = "<a href=\"" + link + "\">$&</a>";
        }
        links.add(new RegexFindReplace(match, html));
    }
    config.setCommentLinks(links);
    config.setBackgroundColor(getThemeColor("backgroundColor", "#FFFFFF"));
    config.setTextColor(getThemeColor("textColor", "#000000"));
    config.setTrimColor(getThemeColor("trimColor", "#D4E9A9"));
    config.setSelectionColor(getThemeColor("selectionColor", "#FFFFCC"));
    config.setTopMenuColor(getThemeColor("topMenuColor", config.getTrimColor()));
    return config;
}
#end_block

#method_before
public DownloadUrl getDownloadUrl() {
    if (downloadUrl == null) {
        return null;
    }
    return DownloadUrl.valueOf(downloadUrl);
}
#method_after
public DownloadScheme getDownloadUrl() {
    if (downloadUrl == null) {
        return null;
    }
    return DownloadScheme.valueOf(downloadUrl);
}
#end_block

#method_before
public void setDownloadUrl(DownloadUrl url) {
    if (url != null) {
        downloadUrl = url.name();
    } else {
        downloadUrl = null;
    }
}
#method_after
public void setDownloadUrl(DownloadScheme url) {
    if (url != null) {
        downloadUrl = url.name();
    } else {
        downloadUrl = null;
    }
}
#end_block

#method_before
public void resetToDefaults() {
    defaultContext = DEFAULT_CONTEXT;
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    downloadUrl = null;
    downloadCommand = null;
}
#method_after
public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    copySelfOnEmail = false;
    downloadUrl = null;
    downloadCommand = null;
}
#end_block

#method_before
private void start() {
    synchronized (lock) {
        if (manager != null) {
            throw new IllegalStateException("Cache pool has already been started");
        }
        try {
            System.setProperty("net.sf.ehcache.skipUpdateCheck", "" + true);
        } catch (SecurityException e) {
        // Ignore it, the system is just going to ping some external page
        // using a background thread and there's not much we can do about
        // it now.
        }
        manager = new CacheManager(new Factory().toConfiguration());
        for (CacheProvider<?, ?> p : caches.values()) {
            Ehcache eh = manager.getEhcache(p.getName());
            EntryCreator<?, ?> c = p.getEntryCreator();
            if (c != null) {
                if (p.disk()) {
                    p.bind(new PopulatingProtobufCache(eh, c, p.getKeyClass(), p.getValueClass(), p.getValueProvider()));
                } else {
                    p.bind(new PopulatingCache(eh, c));
                }
            } else {
                if (p.disk()) {
                    p.bind(new SimpleProtobufCache(eh, p.getKeyClass(), p.getValueClass(), p.getValueProvider()));
                } else {
                    p.bind(new SimpleCache(eh));
                }
            }
        }
    }
}
#method_after
private void start() {
    synchronized (lock) {
        if (manager != null) {
            throw new IllegalStateException("Cache pool has already been started");
        }
        try {
            System.setProperty("net.sf.ehcache.skipUpdateCheck", "" + true);
        } catch (SecurityException e) {
        // Ignore it, the system is just going to ping some external page
        // using a background thread and there's not much we can do about
        // it now.
        }
        manager = new CacheManager(new Factory().toConfiguration());
        for (CacheProvider<?, ?> p : caches.values()) {
            Ehcache eh = manager.getEhcache(p.getName());
            EntryCreator<?, ?> c = p.getEntryCreator();
            if (c != null && p.disk()) {
                c = new ProtobufEntryCreator(c, p.getKeyClass(), p.getValueClass());
            }
            Cache m;
            if (c != null) {
                m = new PopulatingCache(eh, c);
            } else {
                m = new SimpleCache(eh);
            }
            if (p.disk()) {
                m = new ProtobufCache(m, p.getKeyClass(), p.getValueClass(), p.getValueProvider());
            }
            p.bind(m);
        }
    }
}
#end_block

#method_before
public T toObject(ProtobufCodec<T> codec, Provider<T> provider) {
    if (object == null) {
        this.codec = codec;
        if (provider == null) {
            object = codec.decode(buf);
        } else {
            object = provider.get();
            try {
                codec.mergeFrom(CodedInputStream.newInstance(buf), object);
            } catch (IOException e) {
                throw new RuntimeException("Cannot decode message", e);
            }
        }
        // Free the memory being taken up by the buffer.
        buf = null;
    }
    return object;
}
#method_after
T toObject(ProtobufCodec<T> codec, Provider<T> provider) {
    if (codec == null) {
        return null;
    }
    Object d = data;
    if (d instanceof byte[]) {
        this.codec = codec;
        if (provider == null) {
            d = codec.decode((byte[]) d);
        } else {
            T tmp = provider.get();
            codec.mergeFrom((byte[]) d, tmp);
            d = tmp;
        }
        data = d;
    }
    return (T) d;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SerializableProtobuf<?>)) {
        return false;
    }
    SerializableProtobuf<?> other = ((SerializableProtobuf<?>) obj);
    if (hash != other.hash) {
        return false;
    }
    if (object != null && other.object != null) {
        return object.equals(other.object);
    }
    return Arrays.equals(buf, other.buf);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SerializableProtobuf<?>)) {
        return false;
    }
    SerializableProtobuf<T> other = ((SerializableProtobuf<T>) obj);
    if (hash != other.hash) {
        return false;
    }
    // Make sure we either both have codecs, or we both do not
    if (this.codec == null && other.codec != null) {
        this.codec = other.codec;
    } else if (this.codec != null && other.codec == null) {
        other.codec = this.codec;
    }
    // Equals is only ever called on keys, which cannot have providers
    T thisObject = this.toObject(codec, null);
    T otherObject = other.toObject(other.codec, null);
    if (thisObject == null && otherObject == null) {
        // Neither of us had codecs, so we must compare byte arrays
        return Arrays.equals((byte[]) this.data, (byte[]) other.data);
    } else if (thisObject != null && otherObject != null) {
        return thisObject.equals(otherObject);
    } else {
        return false;
    }
}
#end_block

#method_before
private void writeObject(ObjectOutputStream oos) throws IOException {
    if (buf == null) {
        // If buffer is null, toObject must have been called, which means that we
        // have the object and the codec.
        buf = new byte[codec.sizeof(object)];
        codec.encode(object, buf);
    }
    oos.defaultWriteObject();
}
#method_after
private void writeObject(ObjectOutputStream oos) throws IOException {
    oos.writeInt(hash);
    Object d = data;
    if (d instanceof byte[]) {
        byte[] buf = (byte[]) d;
        oos.writeInt(buf.length);
        oos.write(buf);
    } else {
        // We assume that if we have an object, we must have a codec
        T obj = (T) d;
        oos.writeInt(codec.sizeof(obj));
        CodedOutputStream cos = CodedOutputStream.newInstance(oos);
        codec.encode(obj, cos);
        cos.flush();
    }
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else if (!Pattern.compile("refs/.*").matcher(refPattern.replace("*", ".*")).matches()) {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    boolean exclusive = refPattern.startsWith("-");
    if (exclusive) {
        refPattern = refPattern.substring(1);
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (refPattern.startsWith(RefRight.REGEX_PREFIX)) {
        String example = RefControl.shortestExample(refPattern);
        if (!example.startsWith(Constants.R_REFS)) {
            refPattern = RefRight.REGEX_PREFIX + Constants.R_HEADS + refPattern.substring(RefRight.REGEX_PREFIX.length());
            example = RefControl.shortestExample(refPattern);
        }
        if (!Repository.isValidRefName(example)) {
            throw new InvalidNameException();
        }
    } else {
        if (!refPattern.startsWith(Constants.R_REFS)) {
            refPattern = Constants.R_HEADS + refPattern;
        }
        if (refPattern.endsWith("/*")) {
            final String prefix = refPattern.substring(0, refPattern.length() - 2);
            if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
                throw new InvalidNameException();
            }
        } else {
            if (!Repository.isValidRefName(refPattern)) {
                throw new InvalidNameException();
            }
        }
    }
    if (exclusive) {
        refPattern = "-" + refPattern;
    }
    if (!projectControl.controlForRef(refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public boolean isOwner() {
    if (canPerform(OWN, (short) 1)) {
        return true;
    }
    // 
    if (!RefRight.ALL.equals(getRefName()) && getProjectControl().isOwner()) {
        return true;
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (canPerform(OWN, (short) 1)) {
        return true;
    }
    // 
    if (getRefName().equals(RefRight.ALL.substring(0, RefRight.ALL.length() - 1)) && getProjectControl().isOwner()) {
        return true;
    }
    return false;
}
#end_block

#method_before
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    for (RefRight right : filterMostSpecific(allRights)) {
        if (groups.contains(right.getAccountGroupId())) {
            val = Math.max(right.getMaxValue(), val);
        }
    }
    return val >= level;
}
#method_after
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (RefRightsForPattern right : perPatternRights.values()) {
        val = Math.max(val, right.allowedValueForRef(groups));
        if (val >= level || right.containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#end_block

#method_before
public static boolean matches(String refName, String refPattern) {
    return Pattern.matches(refPattern.replace("*", "(.*)"), refName);
}
#method_after
public static boolean matches(String refName, String refPattern) {
    if (refPattern.startsWith(RefRight.REGEX_PREFIX)) {
        return Pattern.matches(refPattern, refName);
    }
    if (refPattern.endsWith("/*")) {
        String prefix = refPattern.substring(0, refPattern.length() - 1);
        return refName.startsWith(prefix);
    } else {
        return refName.equals(refPattern);
    }
}
#end_block

#method_before
private void createGroup() throws OrmException {
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    db.accountGroups().insert(Collections.singleton(group));
    AccountGroupName groupName = new AccountGroupName(group);
    db.accountGroupNames().insert(Collections.singleton(groupName));
    List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (String userName : initialMembers) {
        AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, userName);
        Account.Id accountId = db.accountExternalIds().get(key).getAccountId();
        AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
}
#method_after
private void createGroup() throws OrmException, UnloggedFailure {
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw die("group '" + groupName + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : initialMembers) {
        AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
}
#end_block

#method_before
public Iterable<SshKeyCacheEntry> get(String username) {
    return cache.get(username).sshKeyIter;
}
#method_after
public Iterable<SshKeyCacheEntry> get(String username) {
    return cache.get(username).getSshKeyCacheEntries();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either
    // side, expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null || (historyOpen != null && historyOpen));
    historyPanel.addOpenHandler(cacheOpenState);
    historyPanel.addCloseHandler(cacheCloseState);
    add(historyPanel);
    add(settingsPanel);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
    // these fields
    if (previousFileLink != null) {
        installLinkShortCut(previousFileLink, SHORTCUT_PREVIOUS_FILE, PatchUtil.C.previousFileHelp());
    }
    if (nextFileLink != null) {
        installLinkShortCut(nextFileLink, SHORTCUT_NEXT_FILE, PatchUtil.C.nextFileHelp());
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either
    // side, expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null || (historyOpen != null && historyOpen));
    historyPanel.addOpenHandler(cacheOpenState);
    historyPanel.addCloseHandler(cacheCloseState);
    VerticalPanel vp = new VerticalPanel();
    vp.add(historyPanel);
    vp.add(settingsPanel);
    commitMessageBlock = new CommitMessageBlock("6em");
    HorizontalPanel hp = new HorizontalPanel();
    hp.setWidth("100%");
    hp.add(vp);
    hp.add(commitMessageBlock);
    add(hp);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey().getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey().getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    refresh(true);
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable();
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                    topNav.display(patchIndex, getPatchScreenType(), fileList);
                    bottomNav.display(patchIndex, getPatchScreenType(), fileList);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final Change.Key cid = script.getChangeId();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(cid.abbreviate(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(cid.abbreviate(), path));
    historyTable.display(script.getHistory());
    historyPanel.setVisible(true);
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        settingsPanel.getReviewedCheckBox().setValue(true);
        setReviewedByCurrentUser(true);
    }
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final Change.Key cid = script.getChangeId();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(cid.abbreviate(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(cid.abbreviate(), path));
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    historyPanel.setVisible(true);
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        settingsPanel.getReviewedCheckBox().setValue(true);
        setReviewedByCurrentUser(true);
    }
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable();
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(psid, result.getPatches());
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable();
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#end_block

#method_before
public void addProjectWatch(final String projectName, final String fileMatch, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            final AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, fileMatch));
            db.accountProjectWatches().insert(Collections.singleton(watch));
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#method_after
public void addProjectWatch(final String projectName, final String filter, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException, InvalidQueryException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            if (filter != null) {
                try {
                    ChangeQueryBuilder builder = queryBuilder.create(currentUser.get());
                    builder.setAllowFile(true);
                    builder.parse(filter);
                } catch (QueryParseException badFilter) {
                    throw new InvalidQueryException(badFilter.getMessage(), filter);
                }
            }
            AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, filter));
            try {
                db.accountProjectWatches().insert(Collections.singleton(watch));
            } catch (OrmDuplicateKeyException alreadyHave) {
                watch = db.accountProjectWatches().get(watch.getKey());
            }
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#end_block

#method_before
public void send() throws EmailException {
    if (!emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            // If we are impersonating a user, make sure they receive a CC of
            // this message so they can always review and audit what we sent
            // on their behalf to others.
            // 
            add(RecipientType.CC, fromId);
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
        }
        if (headers.get("Message-ID").isEmpty()) {
            final StringBuilder rndid = new StringBuilder();
            rndid.append("<");
            rndid.append(System.currentTimeMillis());
            rndid.append("-");
            rndid.append(Integer.toString(RNG.nextInt(999999), 36));
            rndid.append("@");
            rndid.append(SystemReader.getInstance().getHostname());
            rndid.append(">");
            setHeader("Message-ID", rndid.toString());
        }
        emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#method_after
public void send() throws EmailException {
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            if (fromUser.getGeneralPreferences().isCopySelfOnEmails()) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                final String fromEmail = fromUser.getPreferredEmail();
                for (Iterator<Address> i = smtpRcptTo.iterator(); i.hasNext(); ) {
                    if (i.next().email.equals(fromEmail)) {
                        i.remove();
                    }
                }
                for (EmailHeader hdr : headers.values()) {
                    if (hdr instanceof AddressList) {
                        ((AddressList) hdr).remove(fromEmail);
                    }
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
            appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
            try {
                HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
                for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
                    reviewers.add(p.getAccountId());
                }
                TreeSet<String> names = new TreeSet<String>();
                for (Account.Id who : reviewers) {
                    names.add(getNameEmailFor(who));
                }
                for (String name : names) {
                    appendText("Gerrit-Reviewer: " + name + "\n");
                }
            } catch (OrmException e) {
            }
        }
        if (headers.get("Message-ID").isEmpty()) {
            final StringBuilder rndid = new StringBuilder();
            rndid.append("<");
            rndid.append(System.currentTimeMillis());
            rndid.append("-");
            rndid.append(Integer.toString(RNG.nextInt(999999), 36));
            rndid.append("@");
            rndid.append(SystemReader.getInstance().getHostname());
            rndid.append(">");
            setHeader("Message-ID", rndid.toString());
        }
        args.emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#end_block

#method_before
protected void init() {
    if (change != null && projectCache != null) {
        projectState = projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    smtpFromAddress = fromAddressGenerator.from(fromId);
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.email.equals(a.email)) {
            setHeader("Reply-To", a.email);
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (fromId != null && fromAddressGenerator.isGenericAddress(fromId)) {
        final Account account = accountCache.get(fromId).getAccount();
        final String name = account.getFullName();
        final String email = account.getPreferredEmail();
        if ((name != null && !name.isEmpty()) || (email != null && !email.isEmpty())) {
            body.append("From");
            if (name != null && !name.isEmpty()) {
                body.append(" ").append(name);
            }
            if (email != null && !email.isEmpty()) {
                body.append(" <").append(email).append(">");
            }
            body.append(":\n\n");
        }
    }
    if (change != null && db != null) {
        if (patchSet == null) {
            try {
                patchSet = db.patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = patchSetInfoFactory.get(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#method_after
protected void init() {
    if (change != null && args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.email.equals(a.email)) {
            setHeader("Reply-To", a.email);
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        final Account account = args.accountCache.get(fromId).getAccount();
        final String name = account.getFullName();
        final String email = account.getPreferredEmail();
        if ((name != null && !name.isEmpty()) || (email != null && !email.isEmpty())) {
            body.append("From");
            if (name != null && !name.isEmpty()) {
                body.append(" ").append(name);
            }
            if (email != null && !email.isEmpty()) {
                body.append(" <").append(email).append(">");
            }
            body.append(":\n\n");
        }
    }
    if (change != null) {
        if (patchSet == null) {
            try {
                patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#end_block

#method_before
protected String getGerritUrl() {
    return urlProvider.get();
}
#method_after
protected String getGerritUrl() {
    return args.urlProvider.get();
}
#end_block

#method_before
protected PatchList getPatchList() {
    if (patchSet != null) {
        return patchListCache.get(change, patchSet);
    }
    return null;
}
#method_after
protected PatchList getPatchList() {
    if (patchSet != null) {
        return args.patchListCache.get(change, patchSet);
    }
    return null;
}
#end_block

#method_before
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return "Anonymous Coward";
    }
    final Account userAccount = accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = "Anonymous Coward #" + accountId;
    }
    return name;
}
#method_after
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return "Anonymous Coward";
    }
    final Account userAccount = args.accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = "Anonymous Coward #" + accountId;
    }
    return name;
}
#end_block

#method_before
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // 
        return false;
    }
    if (rcptTo.isEmpty()) {
        // 
        return false;
    }
    if (rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#method_after
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // 
        return false;
    }
    if (smtpRcptTo.isEmpty()) {
        // 
        return false;
    }
    if (rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#end_block

#method_before
protected Set<AccountGroup.Id> getProjectOwners() {
    final ProjectState r;
    r = projectCache.get(change.getProject());
    return r != null ? r.getOwners() : Collections.<AccountGroup.Id>emptySet();
}
#method_after
protected Set<AccountGroup.Id> getProjectOwners() {
    final ProjectState r;
    r = args.projectCache.get(change.getProject());
    return r != null ? r.getOwners() : Collections.<AccountGroup.Id>emptySet();
}
#end_block

#method_before
protected void bccStarredBy() {
    if (db != null) {
        try {
            // 
            for (StarredChange w : db.starredChanges().byChange(change.getId())) {
                add(RecipientType.BCC, w.getAccountId());
            }
        } catch (OrmException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        }
    }
}
#method_after
protected void bccStarredBy() {
    try {
        // 
        for (StarredChange w : args.db.get().starredChanges().byChange(change.getId())) {
            add(RecipientType.BCC, w.getAccountId());
        }
    } catch (OrmException err) {
    // Just don't BCC everyone. Better to send a partial message to those
    // we already have queued up then to fail deliver entirely to people
    // who have a lower interest in the change.
    }
}
#end_block

#method_before
protected void bccWatchesNotifyAllComments(List<String> specificFileName) {
    if (db != null) {
        if (specificFileName == null) {
            final List<Patch> patches = getPatches(patchSet.getId());
            specificFileName = getPatchesFileNames(patches);
        }
        try {
            // BCC anyone else who has interest in this project's changes
            // 
            final ProjectState ps = getProjectState();
            if (ps != null) {
                for (final AccountProjectWatch w : db.accountProjectWatches().notifyAllComments(ps.getProject().getNameKey())) {
                    if (canAddRecipient(w, specificFileName)) {
                        add(RecipientType.BCC, w.getAccountId());
                    }
                }
            }
        } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        }
    }
}
#method_after
protected void bccWatchesNotifyAllComments() {
    try {
        // 
        for (final AccountProjectWatch w : getWatches()) {
            if (w.isNotifyAllComments()) {
                add(RecipientType.BCC, w.getAccountId());
            }
        }
    } catch (OrmException err) {
    // Just don't CC everyone. Better to send a partial message to those
    // we already have queued up then to fail deliver entirely to people
    // who have a lower interest in the change.
    }
}
#end_block

#method_before
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void add(List<AccountProjectWatch> matching, AccountProjectWatch w) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(args.db, w.getAccountId());
    ChangeQueryBuilder qb = args.queryBuilder.create(user);
    Predicate<ChangeData> p = qb.is_visible();
    if (w.getFilter() != null) {
        try {
            qb.setAllowFile(true);
            p = Predicate.and(qb.parse(w.getFilter()), p);
            p = args.queryRewriter.get().rewrite(p);
            if (p.match(changeData)) {
                matching.add(w);
            }
        } catch (QueryParseException e) {
        // Ignore broken filter expressions.
        }
    } else if (p.match(changeData)) {
        matching.add(w);
    }
}
#end_block

#method_before
private void ccApprovals(final boolean includeZero) {
    if (db != null) {
        try {
            // 
            for (PatchSetApproval ap : db.patchSetApprovals().byChange(change.getId())) {
                if (!includeZero && ap.getValue() == 0) {
                    continue;
                }
                add(RecipientType.CC, ap.getAccountId());
            }
        } catch (OrmException err) {
        }
    }
}
#method_after
private void ccApprovals(final boolean includeZero) {
    try {
        // 
        for (PatchSetApproval ap : args.db.get().patchSetApprovals().byChange(change.getId())) {
            if (!includeZero && ap.getValue() == 0) {
                continue;
            }
            add(RecipientType.CC, ap.getAccountId());
        }
    } catch (OrmException err) {
    }
}
#end_block

#method_before
private boolean isVisibleTo(final Account.Id to) {
    return projectState == null || change == null || projectState.controlFor(identifiedUserFactory.create(to)).controlFor(change).isVisible();
}
#method_after
private boolean isVisibleTo(final Account.Id to) {
    return projectState == null || change == null || projectState.controlFor(args.identifiedUserFactory.create(to)).controlFor(change).isVisible();
}
#end_block

#method_before
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#method_after
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        if (args.emailSender.canEmail(addr.email)) {
            smtpRcptTo.add(addr);
            switch(rt) {
                case TO:
                    ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                    break;
                case CC:
                    ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                    break;
            }
        } else {
            log.warn("Not emailing " + addr.email + " (prohibited by allowrcpt)");
        }
    }
}
#end_block

#method_before
private Address toAddress(final Account.Id id) {
    final Account a = accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#method_after
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#end_block

#method_before
public void setPatchLineComments(final List<PatchLineComment> plc) {
    inlineComments = plc;
}
#method_after
public void setPatchLineComments(final List<PatchLineComment> plc) {
    inlineComments = plc;
    Set<String> paths = new HashSet<String>();
    for (PatchLineComment c : plc) {
        Patch.Key p = c.getKey().getParentKey();
        paths.add(p.getFileName());
    }
    changeData.setCurrentFilePaths(paths);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    final List<String> inlineCommentsFiles = new ArrayList<String>();
    for (final PatchLineComment c : inlineComments) {
        final String fileName = c.getKey().getParentKey().getFileName();
        inlineCommentsFiles.add(fileName);
    }
    bccWatchesNotifyAllComments(inlineCommentsFiles);
}
#method_after
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#end_block

#method_before
private Repository getRepository() {
    try {
        return server.openRepository(projectName);
    } catch (RepositoryNotFoundException e) {
        return null;
    }
}
#method_after
private Repository getRepository() {
    try {
        return args.server.openRepository(projectName);
    } catch (RepositoryNotFoundException e) {
        return null;
    }
}
#end_block

#method_before
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    messageBlock.display(info);
}
#method_after
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    messageBlock.display(info.getMessage());
}
#end_block

#method_before
public void display(final PatchSetInfo info) {
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg = CommentLinkProcessor.apply(msg);
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#method_after
public void display(final String commitMessage) {
    SafeHtml msg = new SafeHtmlBuilder().append(commitMessage);
    msg = msg.linkify();
    msg = CommentLinkProcessor.apply(msg);
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#end_block

#method_before
private boolean canReuse(PatchScriptSettings s, PatchScript last) {
    if (last.getSettings().getWhitespace() != s.getWhitespace()) {
        // Whitespace ignore setting requires server computation.
        return false;
    }
    final int ctx = s.getContext();
    if (ctx == WHOLE_FILE_CONTEXT && !last.getA().isWholeFile()) {
        // We don't have the entire file here, so we can't render it.
        return false;
    }
    if (last.getSettings().getContext() < ctx && !last.getA().isWholeFile()) {
        // We don't have sufficient context.
        return false;
    }
    if (s.getPrettySettings().isSyntaxHighlighting() && !last.getA().isWholeFile()) {
        // We need the whole file to syntax highlight accurately.
        return false;
    }
    return true;
}
#method_after
private boolean canReuse(PatchScriptSettings s, PatchScript last) {
    if (last.getSettings().getWhitespace() != s.getWhitespace()) {
        // Whitespace ignore setting requires server computation.
        return false;
    }
    final int ctx = s.getContext();
    if (ctx == AccountDiffPreference.WHOLE_FILE_CONTEXT && !last.getA().isWholeFile()) {
        // We don't have the entire file here, so we can't render it.
        return false;
    }
    if (last.getSettings().getContext() < ctx && !last.getA().isWholeFile()) {
        // We don't have sufficient context.
        return false;
    }
    if (s.getPrettySettings().isSyntaxHighlighting() && !last.getA().isWholeFile()) {
        // We need the whole file to syntax highlight accurately.
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either
    // side, expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null || (historyOpen != null && historyOpen));
    historyPanel.addOpenHandler(cacheOpenState);
    historyPanel.addCloseHandler(cacheCloseState);
    VerticalPanel vp = new VerticalPanel();
    vp.add(historyPanel);
    vp.add(settingsPanel);
    commitMessageBlock = new CommitMessageBlock("6em");
    HorizontalPanel hp = new HorizontalPanel();
    hp.setWidth("100%");
    hp.add(vp);
    hp.add(commitMessageBlock);
    add(hp);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
    // these fields
    if (previousFileLink != null) {
        installLinkShortCut(previousFileLink, SHORTCUT_PREVIOUS_FILE, PatchUtil.C.previousFileHelp());
    }
    if (nextFileLink != null) {
        installLinkShortCut(nextFileLink, SHORTCUT_NEXT_FILE, PatchUtil.C.nextFileHelp());
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either
    // side, expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null || (historyOpen != null && historyOpen));
    historyPanel.addOpenHandler(cacheOpenState);
    historyPanel.addCloseHandler(cacheCloseState);
    VerticalPanel vp = new VerticalPanel();
    vp.add(historyPanel);
    vp.add(settingsPanel);
    commitMessageBlock = new CommitMessageBlock("6em");
    HorizontalPanel hp = new HorizontalPanel();
    hp.setWidth("100%");
    hp.add(vp);
    hp.add(commitMessageBlock);
    add(hp);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey().getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey().getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    refresh(true);
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable();
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                    topNav.display(patchIndex, getPatchScreenType(), fileList);
                    bottomNav.display(patchIndex, getPatchScreenType(), fileList);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final Change.Key cid = script.getChangeId();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(cid.abbreviate(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(cid.abbreviate(), path));
    Util.DETAIL_SVC.changeDetail(currentChangeId, new GerritCallback<ChangeDetail>() {

        @Override
        public void onSuccess(ChangeDetail detail) {
            commitMessageBlock.display(detail.getCurrentPatchSetDetail().getInfo());
        }
    });
    historyTable.display(script.getHistory());
    historyPanel.setVisible(true);
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        settingsPanel.getReviewedCheckBox().setValue(true);
        setReviewedByCurrentUser(true);
    }
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final Change.Key cid = script.getChangeId();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(cid.abbreviate(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(cid.abbreviate(), path));
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    historyPanel.setVisible(true);
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        settingsPanel.getReviewedCheckBox().setValue(true);
        setReviewedByCurrentUser(true);
    }
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable();
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(psid, result.getPatches());
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable();
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.display(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
    final Button diffAllSideBySide = new Button("Diff All Side-by-Side");
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                SideBySide link = new PatchLink.SideBySide(p.getFileName(), p.getKey(), 0, null);
                Window.open(link.getElement().toString(), p.getFileName(), null);
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button("Diff All Unified");
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Unified link = new PatchLink.Unified(p.getFileName(), p.getKey(), 0, null);
                Window.open(link.getElement().toString(), p.getFileName(), null);
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.display(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                SideBySide link = new PatchLink.SideBySide(p.getFileName(), p.getKey(), 0, null);
                Window.open(link.getElement().toString(), p.getFileName(), null);
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Unified link = new PatchLink.Unified(p.getFileName(), p.getKey(), 0, null);
                Window.open(link.getElement().toString(), p.getFileName(), null);
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
public void setContext(final int ctx) {
    assert 0 <= ctx || ctx == AccountGeneralPreferences.WHOLE_FILE_CONTEXT;
    context = ctx;
}
#method_after
public void setContext(final int ctx) {
    assert 0 <= ctx || ctx == AccountDiffPreference.WHOLE_FILE_CONTEXT;
    context = ctx;
}
#end_block

#method_before
@Override
public void myDiffPreferences(AsyncCallback<AccountDiffPreference> callback) {
    run(callback, new Action<AccountDiffPreference>() {

        @Override
        public AccountDiffPreference run(ReviewDb db) throws OrmException, Failure, NoSuchProjectException, NoSuchGroupException {
            return db.accountDiffPreferences().get(currentUser.get().getAccountId());
        }
    });
}
#method_after
@Override
public void myDiffPreferences(AsyncCallback<AccountDiffPreference> callback) {
    run(callback, new Action<AccountDiffPreference>() {

        @Override
        public AccountDiffPreference run(ReviewDb db) throws OrmException {
            return currentUser.get().getAccountDiffPreference();
        }
    });
}
#end_block

#method_before
@Override
public void changeDiffPreferences(final AccountDiffPreference diffPref, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure, NoSuchProjectException, NoSuchGroupException {
            Id accountId = getAccountId();
            diffPref.setAccountId(accountId);
            final AccountDiffPreference p = db.accountDiffPreferences().get(accountId);
            if (p == null) {
                db.accountDiffPreferences().insert(Collections.singleton(diffPref));
            } else {
                db.accountDiffPreferences().update(Collections.singleton(diffPref));
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
@Override
public void changeDiffPreferences(final AccountDiffPreference diffPref, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id accountId = getAccountId();
            if (!diffPref.getAccountId().equals(getAccountId())) {
                throw new IllegalArgumentException("diffPref.getAccountId() " + diffPref.getAccountId() + " doesn't match" + " the accountId of the signed in user " + getAccountId());
            }
            db.accountDiffPreferences().upsert(Collections.singleton(diffPref));
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public char getIgnoreWhitespace() {
    return ignoreWhitespace;
}
#method_after
public Whitespace getIgnoreWhitespace() {
    return Whitespace.forCode(ignoreWhitespace);
}
#end_block

#method_before
public void setIgnoreWhitespace(char ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace;
}
#method_after
public void setIgnoreWhitespace(Whitespace ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace.getCode();
}
#end_block

#method_before
public void setEnabled(final boolean on) {
    for (Widget w : (HasWidgets) getWidget()) {
        if (w instanceof FocusWidget) {
            ((FocusWidget) w).setEnabled(on);
        }
    }
    toggleEnabledStatus(on);
}
#method_after
public void setEnabled(final boolean on) {
    if (on) {
        setEnabledCounter++;
    } else {
        setEnabledCounter--;
    }
    if (on && setEnabledCounter == 0 || !on) {
        for (Widget w : (HasWidgets) getWidget()) {
            if (w instanceof FocusWidget) {
                ((FocusWidget) w).setEnabled(on);
            }
        }
        toggleEnabledStatus(on);
    }
    ;
}
#end_block

#method_before
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        final PrettySettings p = getValue().getPrettySettings();
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
        showFullFile.setValue(getValue().getContext() == WHOLE_FILE_CONTEXT);
    } else {
        syntaxHighlighting.setValue(false);
        showFullFile.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#method_after
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        final PrettySettings p = getValue().getPrettySettings();
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#end_block

#method_before
private void toggleEnabledStatus(final boolean on) {
    intralineDifference.setEnabled(on & enableIntralineDifference);
    syntaxHighlighting.setEnabled(on & enableSmallFileFeatures);
    showFullFile.setEnabled(on & enableSmallFileFeatures);
    final String title = enableSmallFileFeatures ? null : PatchUtil.C.disabledOnLargeFiles();
    syntaxHighlighting.setTitle(title);
    showFullFile.setTitle(title);
}
#method_after
private void toggleEnabledStatus(final boolean on) {
    intralineDifference.setEnabled(on & enableIntralineDifference);
    syntaxHighlighting.setEnabled(on & enableSmallFileFeatures);
    final String title = enableSmallFileFeatures ? null : PatchUtil.C.disabledOnLargeFiles();
    syntaxHighlighting.setTitle(title);
}
#end_block

#method_before
public void setValue(final PatchScriptSettings s) {
    final PrettySettings p = s.getPrettySettings();
    setIgnoreWhitespace(s.getWhitespace());
    if (enableSmallFileFeatures) {
        showFullFile.setValue(s.getContext() == WHOLE_FILE_CONTEXT);
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        showFullFile.setValue(false);
        syntaxHighlighting.setValue(false);
    }
    tabWidth.setIntValue(p.getTabSize());
    colWidth.setIntValue(p.getLineLength());
    intralineDifference.setValue(p.isIntralineDifference());
    whitespaceErrors.setValue(p.isShowWhiteSpaceErrors());
    showTabs.setValue(p.isShowTabs());
    value = s;
}
#method_after
public void setValue(final PatchScriptSettings s) {
    final PrettySettings p = s.getPrettySettings();
    setIgnoreWhitespace(s.getWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(s.getContext());
    tabWidth.setIntValue(p.getTabSize());
    colWidth.setIntValue(p.getLineLength());
    intralineDifference.setValue(p.isIntralineDifference());
    whitespaceErrors.setValue(p.isShowWhiteSpaceErrors());
    showTabs.setValue(p.isShowTabs());
    value = s;
}
#end_block

#method_before
@UiHandler("update")
void onUpdate(ClickEvent event) {
    update();
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#method_after
@UiHandler("update")
void onUpdate(ClickEvent event) {
    update();
}
#end_block

#method_before
private void update() {
    PatchScriptSettings s = new PatchScriptSettings(getValue());
    PrettySettings p = s.getPrettySettings();
    s.setWhitespace(getIgnoreWhitespace());
    if (showFullFile.getValue()) {
        s.setContext(WHOLE_FILE_CONTEXT);
    } else if (Gerrit.isSignedIn()) {
        final Account u = Gerrit.getUserAccount();
        final AccountGeneralPreferences pref = u.getGeneralPreferences();
        if (pref.getDefaultContext() == WHOLE_FILE_CONTEXT) {
            s.setContext(DEFAULT_CONTEXT);
        } else {
            s.setContext(pref.getDefaultContext());
        }
    } else {
        s.setContext(DEFAULT_CONTEXT);
    }
    p.setTabSize(tabWidth.getIntValue());
    p.setLineLength(colWidth.getIntValue());
    p.setSyntaxHighlighting(syntaxHighlighting.getValue());
    p.setIntralineDifference(intralineDifference.getValue());
    p.setShowWhiteSpaceErrors(whitespaceErrors.getValue());
    p.setShowTabs(showTabs.getValue());
    value = s;
    fireEvent(new ValueChangeEvent<PatchScriptSettings>(s) {
    });
}
#method_after
private void update() {
    PatchScriptSettings s = new PatchScriptSettings(getValue());
    PrettySettings p = s.getPrettySettings();
    s.setWhitespace(getIgnoreWhitespace());
    s.setContext(getContext());
    p.setTabSize(tabWidth.getIntValue());
    p.setLineLength(colWidth.getIntValue());
    p.setSyntaxHighlighting(syntaxHighlighting.getValue());
    p.setIntralineDifference(intralineDifference.getValue());
    p.setShowWhiteSpaceErrors(whitespaceErrors.getValue());
    p.setShowTabs(showTabs.getValue());
    value = s;
    fireEvent(new ValueChangeEvent<PatchScriptSettings>(s) {
    });
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#end_block

#method_before
private void persistDiffPreferences() {
    AccountDiffPreference diffPref = new AccountDiffPreference();
    diffPref.setIgnoreWhitespace(getIgnoreWhitespace().getCode());
    diffPref.setTabSize(tabWidth.getIntValue());
    diffPref.setLineLength(colWidth.getIntValue());
    diffPref.setSyntaxHighlighting(syntaxHighlighting.getValue());
    diffPref.setShowWhitespaceErrors(whitespaceErrors.getValue());
    diffPref.setIntralineDifference(intralineDifference.getValue());
    diffPref.setShowTabs(showTabs.getValue());
    Util.ACCOUNT_SVC.changeDiffPreferences(diffPref, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
        }
    });
}
#method_after
private void persistDiffPreferences() {
    setEnabled(false);
    final AccountDiffPreference diffPref = new AccountDiffPreference(Gerrit.getUserAccount().getId());
    diffPref.setIgnoreWhitespace(getIgnoreWhitespace());
    diffPref.setTabSize(tabWidth.getIntValue());
    diffPref.setLineLength(colWidth.getIntValue());
    diffPref.setSyntaxHighlighting(syntaxHighlighting.getValue());
    diffPref.setShowWhitespaceErrors(whitespaceErrors.getValue());
    diffPref.setIntralineDifference(intralineDifference.getValue());
    diffPref.setShowTabs(showTabs.getValue());
    diffPref.setContext(getContext());
    Util.ACCOUNT_SVC.changeDiffPreferences(diffPref, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            Gerrit.setAccountDiffPreference(diffPref);
            setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            setEnabled(true);
        }
    });
}
#end_block

#method_before
final protected List<AccountProjectWatch> getProjectWatches() throws OrmException {
    final List<AccountProjectWatch> projectWatches = new LinkedList<AccountProjectWatch>();
    final List<Account.Id> projectWatchers = new LinkedList<Account.Id>();
    final ProjectState ps = getProjectState();
    if (ps != null) {
        for (final AccountProjectWatch w : db.accountProjectWatches().byProject(ps.getProject().getNameKey())) {
            projectWatches.add(w);
            projectWatchers.add(w.getAccountId());
        }
    }
    for (final AccountProjectWatch w : db.accountProjectWatches().byProject(wildProject)) {
        if (!projectWatchers.contains(w.getAccountId())) {
            // the all projects watch settings are only relevant if the user did not configure
            // any specific rules for the concrete project
            projectWatches.add(w);
        }
    }
    return Collections.unmodifiableList(projectWatches);
}
#method_after
final protected Set<AccountProjectWatch> getProjectWatches() throws OrmException {
    final Set<AccountProjectWatch> projectWatches = new HashSet<AccountProjectWatch>();
    final Set<Account.Id> projectWatchers = new HashSet<Account.Id>();
    final ProjectState ps = getProjectState();
    if (ps != null) {
        for (final AccountProjectWatch w : db.accountProjectWatches().byProject(ps.getProject().getNameKey())) {
            projectWatches.add(w);
            projectWatchers.add(w.getAccountId());
        }
    }
    for (final AccountProjectWatch w : db.accountProjectWatches().byProject(wildProject)) {
        if (!projectWatchers.contains(w.getAccountId())) {
            // the all projects watch settings are only relevant if the user did not configure
            // any specific rules for the concrete project
            projectWatches.add(w);
        }
    }
    return Collections.unmodifiableSet(projectWatches);
}
#end_block

#method_before
private boolean isWatched(Change c) {
    Set<Project.NameKey> watchedProjects = currentUser.get().getWatchedProjects();
    return watchedProjects.contains(c.getProject()) || watchedProjects.contains(systemConfigProvider.get().wildProjectName);
}
#method_after
private boolean isWatched(Change c) {
    Set<Project.NameKey> watchedProjects = currentUser.get().getWatchedProjects();
    return watchedProjects.contains(c.getProject()) || watchedProjects.contains(wildProject);
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.ALL_OPEN);
    addLink(m, C.menuAllMerged(), PageLinks.ALL_MERGED);
    addLink(m, C.menuAllAbandoned(), PageLinks.ALL_ABANDONED);
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menyMyDrafts(), PageLinks.MINE_DRAFTS);
        addLink(m, C.menuMyWatchedChanges(), PageLinks.MINE_WATCHED);
        addLink(m, C.menuMyStarredChanges(), PageLinks.MINE_STARRED);
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        addLink(m, C.menuProjects(), PageLinks.ADMIN_PROJECTS);
        menuLeft.add(m, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        menuRight.add(anchor(C.menuSignOut(), "logout"));
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", "become"));
                break;
        }
    }
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.ALL_OPEN);
    addLink(m, C.menuAllMerged(), PageLinks.ALL_MERGED);
    addLink(m, C.menuAllAbandoned(), PageLinks.ALL_ABANDONED);
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.MINE_DRAFTS);
        addLink(m, C.menuMyWatchedChanges(), PageLinks.MINE_WATCHED);
        addLink(m, C.menuMyStarredChanges(), PageLinks.MINE_STARRED);
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        addLink(m, C.menuProjects(), PageLinks.ADMIN_PROJECTS);
        menuLeft.add(m, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        menuRight.add(anchor(C.menuSignOut(), "logout"));
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", "become"));
                break;
        }
    }
}
#end_block

#method_before
@Override
public Set<NameKey> getWatchedProjects() {
    if (watchedProjects == null) {
        if (dbProvider == null) {
            throw new OutOfScopeException("Not in request scoped user");
        }
        final Set<Project.NameKey> h = new HashSet<Project.NameKey>();
        try {
            for (AccountProjectWatch projectWatch : dbProvider.get().accountProjectWatches().byAccount(getAccountId()).toList()) {
                h.add(projectWatch.getProjectNameKey());
            }
        } catch (ProvisionException e) {
            log.warn("Cannot query project watches of a user", e);
        } catch (OrmException e) {
            log.warn("Cannot query project watches of a user", e);
        }
        watchedProjects = Collections.unmodifiableSet(h);
    }
    return watchedProjects;
}
#method_after
@Override
public Set<Project.NameKey> getWatchedProjects() {
    if (watchedProjects == null) {
        if (dbProvider == null) {
            throw new OutOfScopeException("Not in request scoped user");
        }
        final Set<Project.NameKey> h = new HashSet<Project.NameKey>();
        try {
            for (AccountProjectWatch projectWatch : dbProvider.get().accountProjectWatches().byAccount(getAccountId())) {
                h.add(projectWatch.getProjectNameKey());
            }
        } catch (OrmException e) {
            log.warn("Cannot query project watches of a user", e);
        }
        watchedProjects = Collections.unmodifiableSet(h);
    }
    return watchedProjects;
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException {
    // TODO(jeffschu) correctly handle file renames
    // TODO(jeffschu) correctly handle merge commits
    // TODO(jeffschu) implement whitespace ignore
    final RevWalk rw = new RevWalk(repo);
    final RevCommit b = rw.parseCommit(key.getNewId());
    final AnyObjectId a = aFor(key, repo, b);
    if (a == null) {
        return new PatchList(a, b, computeIntraline, new PatchListEntry[0]);
    }
    RevTree aTree = rw.parseTree(a);
    RevTree bTree = b.getTree();
    final TreeWalk walk = new TreeWalk(repo);
    walk.reset();
    walk.setRecursive(true);
    walk.addTree(aTree);
    walk.addTree(bTree);
    walk.setFilter(TreeFilter.ANY_DIFF);
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    PrintStream ps = new PrintStream(buf);
    while (walk.next()) {
        outputDiff(ps, walk.getPathString(), walk.getObjectId(0), walk.getFileMode(0), walk.getObjectId(1), walk.getFileMode(1), repo);
    }
    org.eclipse.jgit.patch.Patch p = new org.eclipse.jgit.patch.Patch();
    p.parse(new ByteArrayInputStream(buf.toByteArray()));
    final int cnt = p.getFiles().size();
    final PatchListEntry[] entries = new PatchListEntry[cnt];
    for (int i = 0; i < cnt; i++) {
        entries[i] = newEntry(repo, aTree, bTree, p.getFiles().get(i));
    }
    return new PatchList(a, b, computeIntraline, entries);
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException {
    // TODO(jeffschu) correctly handle file renames
    // TODO(jeffschu) correctly handle merge commits
    // TODO(jeffschu) implement whitespace ignore
    final RevWalk rw = new RevWalk(repo);
    final RevCommit b = rw.parseCommit(key.getNewId());
    final AnyObjectId a = aFor(key, repo, b);
    if (a == null) {
        return new PatchList(a, b, computeIntraline, new PatchListEntry[0]);
    }
    RevTree aTree = rw.parseTree(a);
    RevTree bTree = b.getTree();
    final TreeWalk walk = new TreeWalk(repo);
    walk.reset();
    walk.setRecursive(true);
    walk.addTree(aTree);
    walk.addTree(bTree);
    walk.setFilter(TreeFilter.ANY_DIFF);
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    PrintStream ps = new PrintStream(buf, true, "UTF-8");
    while (walk.next()) {
        outputDiff(ps, walk.getPathString(), walk.getObjectId(0), walk.getFileMode(0), walk.getObjectId(1), walk.getFileMode(1), repo);
    }
    org.eclipse.jgit.patch.Patch p = new org.eclipse.jgit.patch.Patch();
    ps.flush();
    p.parse(new ByteArrayInputStream(buf.toByteArray()));
    final int cnt = p.getFiles().size();
    final PatchListEntry[] entries = new PatchListEntry[cnt];
    for (int i = 0; i < cnt; i++) {
        entries[i] = newEntry(repo, aTree, bTree, p.getFiles().get(i));
    }
    return new PatchList(a, b, computeIntraline, entries);
}
#end_block

#method_before
private void outputDiff(PrintStream out, String path, ObjectId id1, FileMode mode1, ObjectId id2, FileMode mode2, Repository repo) throws IOException {
    DiffFormatter fmt = new DiffFormatter();
    String name1 = "a/" + path;
    String name2 = "b/" + path;
    out.println("diff --git " + name1 + " " + name2);
    boolean isNew = false;
    boolean isDelete = false;
    if (id1.equals(ObjectId.zeroId())) {
        out.println("new file mode " + mode2);
        isNew = true;
    } else if (id2.equals(ObjectId.zeroId())) {
        out.println("deleted file mode " + mode1);
        isDelete = true;
    } else if (!mode1.equals(mode2)) {
        out.println("old mode " + mode1);
        out.println("new mode " + mode2);
    }
    out.println("index " + id1.abbreviate(repo, 7).name() + ".." + id2.abbreviate(repo, 7).name() + (mode1.equals(mode2) ? " " + mode1 : ""));
    out.println("--- " + (isNew ? "/dev/null" : name1));
    out.println("+++ " + (isDelete ? "/dev/null" : name2));
    RawText a = getRawText(id1, repo);
    RawText b = getRawText(id2, repo);
    MyersDiff diff = new MyersDiff(a, b);
    fmt.formatEdits(out, a, b, diff.getEdits());
}
#method_after
private void outputDiff(PrintStream out, String path, ObjectId id1, FileMode mode1, ObjectId id2, FileMode mode2, Repository repo) throws IOException {
    DiffFormatter fmt = new DiffFormatter();
    String name1 = "a/" + path;
    if (needsQuoting(name1)) {
        name1 = QuotedString.GIT_PATH.quote(name1);
    }
    String name2 = "b/" + path;
    if (needsQuoting(name2)) {
        name2 = QuotedString.GIT_PATH.quote(name2);
    }
    out.print("diff --git " + name1 + " " + name2 + "\n");
    boolean isNew = FileMode.MISSING.equals(mode1);
    boolean isDelete = FileMode.MISSING.equals(mode2);
    if (isNew) {
        out.print("new file mode " + mode2 + "\n");
    } else if (isDelete) {
        out.print("deleted file mode " + mode1 + "\n");
    } else if (!mode1.equals(mode2)) {
        out.print("old mode " + mode1 + "\n");
        out.print("new mode " + mode2 + "\n");
    }
    out.print("index " + id1.abbreviate(repo, 7).name() + ".." + id2.abbreviate(repo, 7).name() + (mode1.equals(mode2) ? " " + mode1 : "") + "\n");
    out.print("--- " + (isNew ? "/dev/null" : name1) + "\n");
    out.print("+++ " + (isDelete ? "/dev/null" : name2) + "\n");
    RawText a = getRawText(id1, repo);
    RawText b = getRawText(id2, repo);
    MyersDiff diff = new MyersDiff(a, b);
    fmt.formatEdits(out, a, b, diff.getEdits());
}
#end_block

#method_before
private RawText getRawText(ObjectId id, Repository repo) throws IOException {
    if (id.equals(ObjectId.zeroId()))
        return new RawText(new byte[] {});
    return new RawText(repo.openBlob(id).getCachedBytes());
}
#method_after
private RawText getRawText(ObjectId id, Repository repo) throws IOException {
    if (id.equals(ObjectId.zeroId())) {
        return new RawText(new byte[] {});
    }
    return new RawText(repo.openBlob(id).getCachedBytes());
}
#end_block

#method_before
private Set<Change.Id> changesReferencingTr(final ReviewDb db, final String trackingId) throws OrmException {
    final Set<Change.Id> resultChanges = new HashSet<Change.Id>();
    for (final TrackingId tr : db.trackingIds().getTrackingId(new TrackingId.Id(trackingId))) {
        resultChanges.add(tr.getChangeId());
    }
    return resultChanges;
}
#method_after
private Set<Change.Id> changesReferencingTr(final ReviewDb db, final String trackingId) throws OrmException {
    final Set<Change.Id> resultChanges = new HashSet<Change.Id>();
    for (final TrackingId tr : db.trackingIds().byTrackingId(new TrackingId.Id(trackingId))) {
        resultChanges.add(tr.getChangeId());
    }
    return resultChanges;
}
#end_block

#method_before
@Override
public boolean equals(final Object obj) {
    if (obj instanceof TrackingId) {
        final TrackingId tr = (TrackingId) obj;
        return tr.key.changeId.get() == key.changeId.get() && tr.key.trackingId.get().equals(key.trackingId.get()) && tr.key.trackingSystem.get().equals(key.trackingSystem.get());
    }
    return false;
}
#method_after
@Override
public boolean equals(final Object obj) {
    if (obj instanceof TrackingId) {
        final TrackingId tr = (TrackingId) obj;
        return tr.key.equals(tr.key);
    }
    return false;
}
#end_block

#method_before
private Capable verifyActiveContributorAgreement() throws OrmException {
    AbstractAgreement bestAgreement = null;
    ContributorAgreement bestCla = null;
    OUTER: for (AccountGroup.Id groupId : currentUser.getEffectiveGroups()) {
        for (final AccountGroupAgreement a : db.accountGroupAgreements().byGroup(groupId)) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break OUTER;
        }
    }
    if (bestAgreement == null) {
        for (final AccountAgreement a : db.accountAgreements().byAccount(currentUser.getAccountId()).toList()) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break;
        }
    }
    if (bestCla != null && !bestCla.isActive()) {
        final StringBuilder msg = new StringBuilder();
        msg.append(bestCla.getShortName());
        msg.append(" contributor agreement is expired.\n");
        if (canonicalWebUrl != null) {
            msg.append("\nPlease complete a new agreement");
            msg.append(":\n\n  ");
            msg.append(canonicalWebUrl);
            msg.append("#");
            msg.append(PageLinks.SETTINGS_AGREEMENTS);
            msg.append("\n");
        }
        msg.append("\n");
        return new Capable(msg.toString());
    }
    if (bestCla != null && bestCla.isRequireContactInformation()) {
        boolean fail = false;
        fail |= missing(currentUser.getAccount().getFullName());
        fail |= missing(currentUser.getAccount().getPreferredEmail());
        fail |= !currentUser.getAccount().isContactFiled();
        if (fail) {
            final StringBuilder msg = new StringBuilder();
            msg.append(bestCla.getShortName());
            msg.append(" contributor agreement requires");
            msg.append(" current contact information.\n");
            if (canonicalWebUrl != null) {
                msg.append("\nPlease review your contact information");
                msg.append(":\n\n  ");
                msg.append(canonicalWebUrl);
                msg.append("#");
                msg.append(PageLinks.SETTINGS_CONTACT);
                msg.append("\n");
            }
            msg.append("\n");
            return new Capable(msg.toString());
        }
    }
    if (bestAgreement != null) {
        switch(bestAgreement.getStatus()) {
            case VERIFIED:
                return Capable.OK;
            case REJECTED:
                return new Capable(bestCla.getShortName() + " contributor agreement was rejected." + "\n       (rejected on " + bestAgreement.getReviewedOn() + ")\n");
            case NEW:
                return new Capable(bestCla.getShortName() + " contributor agreement is still pending review.\n");
        }
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#method_after
private Capable verifyActiveContributorAgreement() throws OrmException {
    AbstractAgreement bestAgreement = null;
    ContributorAgreement bestCla = null;
    OUTER: for (AccountGroup.Id groupId : currentUser.getEffectiveGroups()) {
        final List<AccountGroupAgreement> temp = db.accountGroupAgreements().byGroup(groupId).toList();
        Collections.reverse(temp);
        for (final AccountGroupAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break OUTER;
        }
    }
    if (bestAgreement == null) {
        final List<AccountAgreement> temp = db.accountAgreements().byAccount(currentUser.getAccountId()).toList();
        Collections.reverse(temp);
        for (final AccountAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break;
        }
    }
    if (bestCla != null && !bestCla.isActive()) {
        final StringBuilder msg = new StringBuilder();
        msg.append(bestCla.getShortName());
        msg.append(" contributor agreement is expired.\n");
        if (canonicalWebUrl != null) {
            msg.append("\nPlease complete a new agreement");
            msg.append(":\n\n  ");
            msg.append(canonicalWebUrl);
            msg.append("#");
            msg.append(PageLinks.SETTINGS_AGREEMENTS);
            msg.append("\n");
        }
        msg.append("\n");
        return new Capable(msg.toString());
    }
    if (bestCla != null && bestCla.isRequireContactInformation()) {
        boolean fail = false;
        fail |= missing(currentUser.getAccount().getFullName());
        fail |= missing(currentUser.getAccount().getPreferredEmail());
        fail |= !currentUser.getAccount().isContactFiled();
        if (fail) {
            final StringBuilder msg = new StringBuilder();
            msg.append(bestCla.getShortName());
            msg.append(" contributor agreement requires");
            msg.append(" current contact information.\n");
            if (canonicalWebUrl != null) {
                msg.append("\nPlease review your contact information");
                msg.append(":\n\n  ");
                msg.append(canonicalWebUrl);
                msg.append("#");
                msg.append(PageLinks.SETTINGS_CONTACT);
                msg.append("\n");
            }
            msg.append("\n");
            return new Capable(msg.toString());
        }
    }
    if (bestAgreement != null) {
        switch(bestAgreement.getStatus()) {
            case VERIFIED:
                return Capable.OK;
            case REJECTED:
                return new Capable(bestCla.getShortName() + " contributor agreement was rejected." + "\n       (rejected on " + bestAgreement.getReviewedOn() + ")\n");
            case NEW:
                return new Capable(bestCla.getShortName() + " contributor agreement is still pending review.\n");
        }
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#end_block

#method_before
private void addTrackingIds(final Change change, final List<FooterLine> footerLines) throws OrmException {
    if (trackingFooters.getTrackingFooters().isEmpty() || footerLines.isEmpty()) {
        return;
    }
    List<TrackingId> trackingIds = new ArrayList<TrackingId>();
    TrackingId trId = null;
    for (final TrackingFooter footer : trackingFooters.getTrackingFooters()) {
        Pattern p;
        try {
            p = Pattern.compile(footer.match());
        } catch (PatternSyntaxException e) {
            // should already been caught in TrackingFootersProvider
            log.error("Invalid regex pattern " + footer.toString() + " " + e.getMessage());
            continue;
        }
        for (final FooterLine footerLine : footerLines) {
            if (footerLine.matches(footer.footerKey())) {
                final Matcher m = p.matcher(footerLine.getValue());
                // supporting multiple tracking-ids on a single line
                while (m.find()) {
                    trId = null;
                    if (!m.group().isEmpty()) {
                        if (m.groupCount() > 0 && m.group(1) != "") {
                            if (m.group(1).length() <= TrackingId.TRACKING_ID_MAX_CHAR) {
                                trId = new TrackingId(change.getId(), m.group(1), footer.system());
                            }
                        } else if (m.group().length() <= TrackingId.TRACKING_ID_MAX_CHAR) {
                            trId = new TrackingId(change.getId(), m.group(), footer.system());
                        }
                        if (trId != null && !trackingIds.contains(trId)) {
                            trackingIds.add(trId);
                        }
                    }
                }
            }
        }
    }
    if (change.currentPatchSetId().get() > 1) {
        db.trackingIds().delete(db.trackingIds().getTrackingId(change.getId()));
    }
    if (!trackingIds.isEmpty()) {
        db.trackingIds().insert(trackingIds);
    }
}
#method_after
private void addTrackingIds(final Change change, final List<FooterLine> footerLines) throws OrmException {
    if (trackingFooters.getTrackingFooters().isEmpty() || footerLines.isEmpty()) {
        return;
    }
    final Set<TrackingId> want = new HashSet<TrackingId>();
    final Set<TrackingId> have = new // 
    HashSet<TrackingId>(db.trackingIds().byChange(change.getId()).toList());
    for (final TrackingFooter footer : trackingFooters.getTrackingFooters()) {
        for (final FooterLine footerLine : footerLines) {
            if (footerLine.matches(footer.footerKey())) {
                // supporting multiple tracking-ids on a single line
                final Matcher m = footer.match().matcher(footerLine.getValue());
                while (m.find()) {
                    if (m.group().isEmpty()) {
                        continue;
                    }
                    String idstr;
                    if (m.groupCount() > 0) {
                        idstr = m.group(1);
                    } else {
                        idstr = m.group();
                    }
                    if (idstr.isEmpty()) {
                        continue;
                    }
                    if (idstr.length() > TrackingId.TRACKING_ID_MAX_CHAR) {
                        continue;
                    }
                    want.add(new TrackingId(change.getId(), idstr, footer.system()));
                }
            }
        }
    }
    // Only insert the rows we don't have, and delete rows we don't match.
    // 
    final Set<TrackingId> toInsert = new HashSet<TrackingId>(want);
    final Set<TrackingId> toDelete = new HashSet<TrackingId>(have);
    toInsert.removeAll(have);
    toDelete.removeAll(want);
    db.trackingIds().insert(toInsert);
    db.trackingIds().delete(toDelete);
}
#end_block

#method_before
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db);
    }
}
#method_after
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db, toTargetVersion);
    }
}
#end_block

#method_before
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        final List<String> pruneList = new ArrayList<String>();
        s.pruneSchema(new StatementExecutor() {

            public void execute(String sql) {
                pruneList.add(sql);
            }
        });
        if (!pruneList.isEmpty()) {
            ui.pruneSchema(e, pruneList);
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#method_after
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db, false);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        if (toTargetVersion) {
            final List<String> pruneList = new ArrayList<String>();
            s.pruneSchema(new StatementExecutor() {

                public void execute(String sql) {
                    pruneList.add(sql);
                }
            });
            if (!pruneList.isEmpty()) {
                ui.pruneSchema(e, pruneList);
            }
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#end_block

#method_before
public String match() {
    return match;
}
#method_after
public Pattern match() {
    return match;
}
#end_block

#method_before
@Override
public String toString() {
    return "footer = " + key.getName() + ", match = " + match + ", system = " + system;
}
#method_after
@Override
public String toString() {
    return "footer = " + key.getName() + ", match = " + match.pattern() + ", system = " + system;
}
#end_block

#method_before
static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final String cacheName = CACHE_NAME;
            final TypeLiteral<Cache<ActiveSession.Key, ActiveSession>> type = new TypeLiteral<Cache<ActiveSession.Key, ActiveSession>>() {
            };
            // 
            core(type, cacheName).memoryLimit(// reasonable default for many sites
            1024).maxAge(12, // expire sessions if they are inactive
            HOURS).evictionPolicy(// keep most recently used
            EvictionPolicy.LRU);
            bind(WebSession.class).in(RequestScoped.class);
        }
    };
}
#method_after
static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final TypeLiteral<Cache<ActiveSession.Key, ActiveSession>> type = new TypeLiteral<Cache<ActiveSession.Key, ActiveSession>>() {
            };
            // 
            core(type, CACHE_NAME).memoryLimit(// reasonable default for many sites
            1024).maxAge(12, // expire sessions if they are inactive
            HOURS).evictionPolicy(// keep most recently used
            EvictionPolicy.LRU);
            bind(WebSession.class).in(RequestScoped.class);
            bind(WebSession.KeyGenerator.class).in(SINGLETON);
        }
    };
}
#end_block

#method_before
static long now() {
    return System.currentTimeMillis();
}
#method_after
private static long now() {
    return System.currentTimeMillis();
}
#end_block

#method_before
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
    }
    key = createKey(id);
    session = createSession(key, id, rememberMe, identity, null);
    saveCookie();
}
#method_after
public void login(final AuthResult res, final boolean rememberMe) throws OrmException {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
    }
    key = createKey(id);
    session = createSession(key, id, rememberMe, identity, null);
    saveCookie();
}
#end_block

#method_before
void setUserAccountId(Account.Id id) {
    key = new ActiveSession.Key("id:" + id);
    session = new ActiveSession(key, id, 0, false, null, "");
}
#method_after
void setUserAccountId(Account.Id id) {
    key = new ActiveSession.Key("id:" + id);
    session = new ActiveSession(key, id, new Timestamp(0), false, null, "");
}
#end_block

#method_before
public void logout() {
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
        saveCookie();
    }
}
#method_after
public void logout() {
    if (session != null) {
        try {
            destroy(key);
        } catch (OrmException e) {
            log.error("Could not remove session key from cache", e);
        }
        key = null;
        session = null;
        saveCookie();
    }
}
#end_block

#method_before
ActiveSession.Key createKey(final Account.Id who) {
    try {
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        buf = new ByteArrayOutputStream(3 + nonceLen);
        writeVarInt32(buf, who.get());
        writeBytes(buf, rnd);
        return new ActiveSession.Key(CookieBase64.encode(buf.toByteArray()));
    } catch (IOException e) {
        throw new RuntimeException("Cannot produce new account cookie", e);
    }
}
#method_after
private ActiveSession.Key createKey(final Account.Id who) {
    try {
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        buf = new ByteArrayOutputStream(3 + nonceLen);
        writeVarInt32(buf, who.get());
        writeBytes(buf, rnd);
        return new ActiveSession.Key(CookieBase64.encode(buf.toByteArray()));
    } catch (IOException e) {
        throw new RuntimeException("Cannot produce new account cookie", e);
    }
}
#end_block

#method_before
ActiveSession createSession(final ActiveSession.Key key, final ActiveSession session) {
    final Account.Id who = session.getAccountId();
    final boolean remember = session.isPersistentCookie();
    final AccountExternalId.Key lastLogin = session.getExternalId();
    final String xsrfToken = session.getXsrfToken();
    return createSession(key, who, remember, lastLogin, xsrfToken);
}
#method_after
private ActiveSession createSession(final ActiveSession.Key key, final ActiveSession session) throws OrmException {
    final Account.Id who = session.getAccountId();
    final boolean remember = session.isPersistentCookie();
    final AccountExternalId.Key lastLogin = session.getExternalId();
    final String xsrfToken = session.getXsrfToken();
    return createSession(key, who, remember, lastLogin, xsrfToken);
}
#end_block

#method_before
ActiveSession createSession(final ActiveSession.Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = cache.getTimeToLive(MILLISECONDS) >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    ActiveSession session = new ActiveSession(key, who, refreshCookieAt, remember, lastLogin, xsrfToken);
    cache.put(key, session);
    return session;
}
#method_after
private ActiveSession createSession(final ActiveSession.Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) throws OrmException {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = cache.getTimeToLive(MILLISECONDS) >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    ActiveSession session = new ActiveSession(key, who, new Timestamp(refreshCookieAt), remember, lastLogin, xsrfToken);
    put(session);
    return session;
}
#end_block

#method_before
int getCookieAge(final ActiveSession session) {
    if (session.isPersistentCookie()) {
        // 
        return (int) cache.getTimeToLive(SECONDS);
    } else {
        // 
        return -1;
    }
}
#method_after
private int getCookieAge(final ActiveSession session) {
    if (session.isPersistentCookie()) {
        // 
        return (int) cache.getTimeToLive(SECONDS);
    } else {
        // 
        return -1;
    }
}
#end_block

#method_before
ActiveSession get(final ActiveSession.Key key) {
    return cache.get(key);
}
#method_after
private ActiveSession get(final ActiveSession.Key key) throws OrmException {
    ActiveSession as = cache.get(key);
    final ActiveSessionAccess activeSessions = schema.activeSessions();
    if (as == null) {
        as = activeSessions.get(key);
        if (as == null) {
            return null;
        } else {
            if (expiredFromCache(as)) {
                destroy(key);
                return null;
            } else if (needsCacheRefresh(as)) {
                as.updateLastSeen();
                put(as);
            }
            return as;
        }
    } else {
        if (needsCacheRefresh(as)) {
            as.updateLastSeen();
            put(as);
        }
        return as;
    }
}
#end_block

#method_before
void destroy(final ActiveSession.Key key) {
    cache.remove(key);
}
#method_after
private void destroy(final ActiveSession.Key key) throws OrmException {
    schema.activeSessions().deleteKeys(Arrays.asList(key));
    cache.remove(key);
}
#end_block

#method_before
public long getRefreshCookieAt() {
    return refreshCookieAt;
}
#method_after
public Timestamp getRefreshCookieAt() {
    return refreshCookieAt;
}
#end_block

#method_before
public void setRefreshCookieAt(long refreshCookieAt) {
    this.refreshCookieAt = refreshCookieAt;
}
#method_after
public void setRefreshCookieAt(Timestamp refreshCookieAt) {
    this.refreshCookieAt = refreshCookieAt;
}
#end_block

#method_before
public boolean needsCookieRefresh() {
    return refreshCookieAt <= System.currentTimeMillis();
}
#method_after
public boolean needsCookieRefresh() {
    return refreshCookieAt.before(now());
}
#end_block

#method_before
private void publishApprovals() throws OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final List<ApprovalCategoryValue.Id> ignore = new ArrayList<ApprovalCategoryValue.Id>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            if (want.get() != 0) {
                a = new PatchSetApproval(new PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
                a.cache(change);
                ins.add(a);
                all.add(a);
                mine.put(a.getCategoryId(), a);
                dirty.add(a.getCategoryId());
            } else {
                ignore.add(want);
            }
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(change, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        if (ignore.indexOf(want) == -1) {
            final PatchSetApproval a = mine.get(want.getParentKey());
            final short o = a.getValue();
            a.setValue(want.get());
            a.cache(change);
            functionState.normalize(types.getApprovalType(a.getCategoryId()), a);
            if (o != a.getValue()) {
                // Value changed, ensure we update the database.
                // 
                a.setGranted();
                dirty.add(a.getCategoryId());
            }
            if (!ins.contains(a)) {
                upd.add(a);
            }
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    summarizeInlineComments(msgbuf);
    message(msgbuf.toString());
}
#method_after
private void publishApprovals() throws OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            a = new PatchSetApproval(new // 
            PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
            a.cache(change);
            ins.add(a);
            all.add(a);
            mine.put(a.getCategoryId(), a);
            dirty.add(a.getCategoryId());
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(change, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        final PatchSetApproval a = mine.get(want.getParentKey());
        final short o = a.getValue();
        a.setValue(want.get());
        a.cache(change);
        functionState.normalize(types.getApprovalType(a.getCategoryId()), a);
        if (o != a.getValue()) {
            // Value changed, ensure we update the database.
            // 
            a.setGranted();
            dirty.add(a.getCategoryId());
        }
        if (!ins.contains(a)) {
            upd.add(a);
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            if (a.getValue() == 0 && ins.contains(a)) {
                // Don't say "no score" for an initial entry.
                continue;
            }
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    message(msgbuf.toString());
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ApproveCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(CreateProject.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "submit").to(SubmitCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ReviewCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(CreateProject.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "review").to(ReviewCommand.class);
}
#end_block

#method_before
private void applyRightFloor(final PatchSetApproval a) {
    final IdentifiedUser user = userFactory.create(a.getAccountId());
    RefControl rc = controlFor(user);
    // Find the maximal range actually granted to the user.
    // 
    short minAllowed = 0, maxAllowed = 0;
    for (final RefRight r : rc.getAllRights(a.getCategoryId())) {
        final AccountGroup.Id grp = r.getAccountGroupId();
        if (user.getEffectiveGroups().contains(grp)) {
            minAllowed = (short) Math.min(minAllowed, r.getMinValue());
            maxAllowed = (short) Math.max(maxAllowed, r.getMaxValue());
        }
    }
    // 
    if (a.getValue() < minAllowed) {
        a.setValue(minAllowed);
    } else if (a.getValue() > maxAllowed) {
        a.setValue(maxAllowed);
    }
}
#method_after
private void applyRightFloor(final PatchSetApproval a) {
    final IdentifiedUser user = userFactory.create(a.getAccountId());
    RefControl rc = controlFor(user);
    // Find the maximal range actually granted to the user.
    // 
    short minAllowed = 0, maxAllowed = 0;
    for (final RefRight r : rc.getApplicableRights(a.getCategoryId())) {
        final AccountGroup.Id grp = r.getAccountGroupId();
        if (user.getEffectiveGroups().contains(grp)) {
            minAllowed = (short) Math.min(minAllowed, r.getMinValue());
            maxAllowed = (short) Math.max(maxAllowed, r.getMaxValue());
        }
    }
    // 
    if (a.getValue() < minAllowed) {
        a.setValue(minAllowed);
    } else if (a.getValue() > maxAllowed) {
        a.setValue(maxAllowed);
    }
}
#end_block

#method_before
private void initRights(final Panel body) {
    final FlowPanel addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            rights.deleteChecked();
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#method_after
private void initRights(final Panel body) {
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            final HashSet<RefRight.Key> refRightIds = rights.getRefRightIdsChecked();
            doDeleteRefRights(refRightIds);
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#end_block

#method_before
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
}
#method_after
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
    addPanel.setVisible(result.canModifyAccess);
    delRight.setVisible(rights.getCanDelete());
}
#end_block

#method_before
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    idx = rangeMaxBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
    if (max == null) {
        return;
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    if (at.getCategory().isRange()) {
        idx = rangeMaxBox.getSelectedIndex();
        if (idx < 0) {
            return;
        }
        max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
        if (max == null) {
            return;
        }
    } else {
        // If its not a range, the maximum box was disabled.  Use the min
        // value as the max, and select the min from the category values.
        // 
        max = min;
        min = at.getMin();
        for (ApprovalCategoryValue v : at.getValues()) {
            if (0 <= v.getValue() && v.getValue() <= max.getValue()) {
                min = v;
                break;
            }
        }
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#method_after
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    rangeMaxBox.setVisible(at.getCategory().isRange());
    addRight.setEnabled(true);
}
#end_block

#method_before
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<InheritedRefRight> refRights) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final InheritedRefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r);
    }
}
#method_after
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<InheritedRefRight> refRights) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final InheritedRefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r);
    }
}
#end_block

#method_before
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, right.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 4, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        formatValue(m, right.getMinValue(), min);
        if (right.getMinValue() != right.getMaxValue()) {
            m.br();
            formatValue(m, right.getMaxValue(), max);
        }
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#method_after
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited() || !r.isOwner()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, right.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 4, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        if (ar != null && ar.getCategory().isRange()) {
            formatValue(m, right.getMinValue(), min);
            m.br();
        }
        formatValue(m, right.getMaxValue(), max);
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (refPattern.startsWith("-")) {
        if (!refPattern.startsWith("-" + Constants.R_REFS)) {
            refPattern = "-" + Constants.R_HEADS + refPattern;
        }
    } else if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    checkPatternFormat(refPattern);
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    boolean exclusive = refPattern.startsWith("-");
    if (exclusive) {
        refPattern = refPattern.substring(1);
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (exclusive) {
        refPattern = "-" + refPattern;
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public boolean isVisible() {
    return canPerform(READ, (short) 1);
}
#method_after
public boolean isVisible() {
    return getProjectControl().visibleForReplication() || canPerform(READ, (short) 1);
}
#end_block

#method_before
public int allowedValueForRef(Set<AccountGroup.Id> groups) {
    int val = Integer.MIN_VALUE;
    for (RefRight right : rights) {
        if (groups.contains(right.getAccountGroupId())) {
            if ((val < 0 && right.getMaxValue() > 0)) {
                // If one of the user's groups had denied them access, but
                // this group grants them access, prefer the grant over
                // the denial. We have to break the tie somehow and we
                // prefer being "more open" to being "more closed".
                // 
                val = right.getMaxValue();
            } else {
                // Otherwise we use the largest value we can get.
                // 
                val = Math.max(right.getMaxValue(), val);
            }
        }
    }
    return val;
}
#method_after
public int allowedValueForRef(Set<AccountGroup.Id> groups) {
    int val = Integer.MIN_VALUE;
    for (RefRight right : rights) {
        if (groups.contains(right.getAccountGroupId())) {
            val = Math.max(right.getMaxValue(), val);
        }
    }
    return val;
}
#end_block

#method_before
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (String pattern : perPatternRights.keySet()) {
        val = Math.max(val, perPatternRights.get(pattern).allowedValueForRef(groups));
        if (val >= level || perPatternRights.get(pattern).containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#method_after
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (RefRightsForPattern right : perPatternRights.values()) {
        val = Math.max(val, right.allowedValueForRef(groups));
        if (val >= level || right.containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#end_block

#method_before
public static SortedMap<String, RefRightsForPattern> sortedRightsByPattern(List<RefRight> actionRights) {
    SortedMap<String, RefRightsForPattern> rights = new TreeMap<String, RefRightsForPattern>(DESCENDING_SORT);
    for (RefRight right : actionRights) {
        if (rights.containsKey(right.getRefPattern())) {
            rights.get(right.getRefPattern()).addRight(right);
        } else {
            RefRightsForPattern patternRights = new RefRightsForPattern();
            patternRights.addRight(right);
            rights.put(right.getRefPattern(), patternRights);
        }
    }
    return rights;
}
#method_after
private static SortedMap<String, RefRightsForPattern> sortedRightsByPattern(List<RefRight> actionRights) {
    SortedMap<String, RefRightsForPattern> rights = new TreeMap<String, RefRightsForPattern>(DESCENDING_SORT);
    for (RefRight actionRight : actionRights) {
        RefRightsForPattern patternRights = rights.get(actionRight.getRefPattern());
        if (patternRights == null) {
            patternRights = new RefRightsForPattern();
            rights.put(actionRight.getRefPattern(), patternRights);
        }
        patternRights.addRight(actionRight);
    }
    return rights;
}
#end_block

#method_before
public void testInvertSortKey() {
    assertEquals("FFFFFFFFFFFFFFFF", ChangeUtil.invertSortKey("0000000000000000").toUpperCase());
    assertEquals("0000000000000001", ChangeUtil.invertSortKey("FFFFFFFFFFFFFFFE").toUpperCase());
    assertEquals("0001600000000000", ChangeUtil.invertSortKey("FFFE9FFFFFFFFFFF").toUpperCase());
    assertEquals("/", ChangeUtil.invertSortKey("z").toUpperCase());
    assertEquals("Z", ChangeUtil.invertSortKey("/").toUpperCase());
}
#method_after
public void testInvertSortKey() {
    assertEquals("ffffffffffffffff", ChangeUtil.invertSortKey("0000000000000000"));
    assertEquals("0000000000000001", ChangeUtil.invertSortKey("fffffffffffffffe"));
    assertEquals("0001600000000000", ChangeUtil.invertSortKey("fffe9fffffffffff"));
    assertEquals("/", ChangeUtil.invertSortKey("z"));
    assertEquals("z", ChangeUtil.invertSortKey("/"));
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws SQLException {
    List<String> toCalc = new ArrayList<String>(1000);
    PreparedStatement selectStmt = ((JdbcSchema) db).getConnection().prepareStatement("SELECT sort_key FROM changes WHERE sort_key_desc IS NULL" + " OR sort_key_desc='';");
    selectStmt.setMaxRows(1000);
    PreparedStatement updateStmt = ((JdbcSchema) db).getConnection().prepareStatement("UPDATE changes SET sort_key_desc = ? WHERE sort_key = ?;");
    try {
        while (true) {
            ResultSet rs = selectStmt.executeQuery();
            try {
                while (rs.next()) {
                    toCalc.add(rs.getString(1));
                }
            } finally {
                rs.close();
            }
            if (toCalc.isEmpty())
                break;
            for (String s : toCalc) {
                String sortKeyDesc = Long.toHexString(-1l - Long.parseLong(s, 16));
                updateStmt.setString(1, sortKeyDesc);
                updateStmt.setString(2, s);
                updateStmt.addBatch();
            }
            updateStmt.executeBatch();
            toCalc.clear();
        }
    } finally {
        updateStmt.close();
        selectStmt.close();
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws SQLException {
    List<ToUpdate> changes = new ArrayList<ToUpdate>(MAX_SCAN_SIZE);
    PreparedStatement selectStmt = ((JdbcSchema) db).getConnection().prepareStatement("SELECT change_id, sort_key FROM changes" + " WHERE sort_key_desc IS NULL OR sort_key_desc=''");
    selectStmt.setMaxRows(MAX_SCAN_SIZE);
    PreparedStatement updateStmt = ((JdbcSchema) db).getConnection().prepareStatement("UPDATE changes SET sort_key_desc = ? WHERE change_id = ?");
    try {
        while (true) {
            ResultSet rs = selectStmt.executeQuery();
            try {
                while (rs.next() && changes.size() < MAX_SCAN_SIZE) {
                    changes.add(new ToUpdate(rs.getInt(1), rs.getString(2)));
                }
            } finally {
                rs.close();
            }
            if (changes.isEmpty()) {
                break;
            }
            int batchSize = 0;
            for (ToUpdate u : changes) {
                String desc = Long.toHexString(-1l - Long.parseLong(u.sortKey, 16));
                updateStmt.setString(1, desc);
                updateStmt.setInt(2, u.id);
                updateStmt.addBatch();
                batchSize++;
                if (batchSize >= 200) {
                    updateStmt.executeBatch();
                    batchSize = 0;
                }
            }
            if (batchSize > 0) {
                updateStmt.executeBatch();
            }
            changes.clear();
        }
    } finally {
        updateStmt.close();
        selectStmt.close();
    }
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    event.change = getChangeAttribute(change);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--patchset");
    args.add(event.patchSet.number);
    runHook(getRepo(change), args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    event.change = getChangeAttribute(change);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--patchset");
    args.add(event.patchSet.number);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = getChangeAttribute(change);
    event.author = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = getChangeAttribute(change);
    event.author = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = getChangeAttribute(change);
    event.submitter = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    runHook(getRepo(change), args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = getChangeAttribute(change);
    event.submitter = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = getChangeAttribute(change);
    event.abandoner = getAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = getChangeAttribute(change);
    event.abandoner = getAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#end_block

#method_before
private void display() throws Failure {
    final PrintWriter stdout = toPrintWriter(out);
    TreeMap<String, TreeNode> treeMap = null;
    if (showTree) {
        treeMap = new TreeMap<String, TreeNode>();
    }
    try {
        for (final Project p : db.projects().all()) {
            if (p.getNameKey().equals(wildProject)) {
                // 
                continue;
            }
            final ProjectState e = projectCache.get(p.getNameKey());
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (!showTree) {
                if (!pctl.isVisible()) {
                    // 
                    continue;
                }
                if (showBranch != null) {
                    final Ref ref = getBranchRef(p.getNameKey());
                    if (ref == null || ref.getObjectId() == null || !pctl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                        // 
                        continue;
                    }
                    stdout.print(ref.getObjectId().name());
                    stdout.print(' ');
                }
                stdout.print(p.getName());
                stdout.println();
            } else {
                TreeNode node = new TreeNode(p, pctl.isVisible());
                treeMap.put(p.getName(), node);
            }
        }
        if (showTree && treeMap.size() > 0) {
            final List<TreeNode> sortedNodes = new ArrayList<TreeNode>();
            // 
            for (final TreeNode key : treeMap.values()) {
                final String parentName = key.getParentName();
                if (parentName != null) {
                    final TreeNode node = (TreeNode) treeMap.get((String) parentName);
                    node.addChild(key);
                } else {
                    sortedNodes.add(key);
                }
            }
            // Builds a fake root node, which contains the sorted projects.
            // 
            final TreeNode fakeRoot = new TreeNode(null, sortedNodes, false);
            printElement(stdout, fakeRoot, -1, false, sortedNodes.get(sortedNodes.size() - 1));
        }
    } catch (OrmException e) {
        throw new Failure(1, "fatal: database error", e);
    } finally {
        stdout.flush();
    }
}
#method_after
private void display() throws Failure {
    if (showTree && (showBranch != null)) {
        throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
    }
    final PrintWriter stdout = toPrintWriter(out);
    TreeMap<String, TreeNode> treeMap = null;
    if (showTree) {
        treeMap = new TreeMap<String, TreeNode>();
    }
    try {
        for (final Project p : db.projects().all()) {
            if (p.getNameKey().equals(wildProject)) {
                // 
                continue;
            }
            final ProjectState e = projectCache.get(p.getNameKey());
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (!showTree) {
                if (!pctl.isVisible()) {
                    // 
                    continue;
                }
                if (showBranch != null) {
                    final Ref ref = getBranchRef(p.getNameKey());
                    if (ref == null || ref.getObjectId() == null || !pctl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                        // 
                        continue;
                    }
                    stdout.print(ref.getObjectId().name());
                    stdout.print(' ');
                }
                stdout.print(p.getName() + "\n");
            } else {
                treeMap.put(p.getName(), new TreeNode(p, pctl.isVisible()));
            }
        }
        if (showTree && treeMap.size() > 0) {
            final List<TreeNode> sortedNodes = new ArrayList<TreeNode>();
            // 
            for (final TreeNode key : treeMap.values()) {
                final String parentName = key.getParentName();
                if (parentName != null) {
                    final TreeNode node = treeMap.get((String) parentName);
                    if (node != null) {
                        node.addChild(key);
                    } else {
                        sortedNodes.add(key);
                    }
                } else {
                    sortedNodes.add(key);
                }
            }
            // Builds a fake root node, which contains the sorted projects.
            // 
            final TreeNode fakeRoot = new TreeNode(null, sortedNodes, false);
            printElement(stdout, fakeRoot, -1, false, sortedNodes.get(sortedNodes.size() - 1));
            stdout.flush();
        }
    } catch (OrmException e) {
        throw new Failure(1, "fatal: database error", e);
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private void printElement(final PrintWriter stdout, TreeNode node, int level, boolean isLast, final TreeNode lastParentNode) {
    // 
    if (node.getProject() != null) {
        // 
        if (!currentTabSeparator.equals(" ")) {
            final String nodeProject = node.getProject().getName();
            final String lastParentProject = lastParentNode.getProject().getName();
            if (nodeProject.equals(lastParentProject)) {
                currentTabSeparator = " ";
            }
        }
        if (level > 0) {
            stdout.print(String.format("%-" + 4 * level + "s", currentTabSeparator));
        }
        final String prefix = isLast ? LAST_NODE_PREFIX : NODE_PREFIX;
        String printout;
        if (node.isVisible()) {
            printout = prefix + node.getProject().getName();
        } else {
            printout = prefix + NOT_VISIBLE_PROJECT;
        }
        stdout.println(printout);
        stdout.flush();
    }
    if (node.isLeaf()) {
        return;
    } else {
        final List<TreeNode> children = node.getChildren();
        ++level;
        for (TreeNode treeNode : children) {
            final boolean isLastIndex = children.indexOf(treeNode) == children.size() - 1;
            printElement(stdout, treeNode, level, isLastIndex, lastParentNode);
        }
    }
}
#method_after
private void printElement(final PrintWriter stdout, TreeNode node, int level, boolean isLast, final TreeNode lastParentNode) {
    // 
    if (node.getProject() != null) {
        // 
        if (!currentTabSeparator.equals(" ")) {
            final String nodeProject = node.getProject().getName();
            final String lastParentProject = lastParentNode.getProject().getName();
            if (nodeProject.equals(lastParentProject)) {
                currentTabSeparator = " ";
            }
        }
        if (level > 0) {
            stdout.print(String.format("%-" + 4 * level + "s", currentTabSeparator));
        }
        final String prefix = isLast ? LAST_NODE_PREFIX : NODE_PREFIX;
        String printout;
        if (node.isVisible()) {
            printout = prefix + node.getProject().getName();
        } else {
            printout = prefix + NOT_VISIBLE_PROJECT;
        }
        stdout.print(printout + "\n");
    }
    if (node.isLeaf()) {
        return;
    } else {
        final List<TreeNode> children = node.getChildren();
        ++level;
        for (TreeNode treeNode : children) {
            final boolean isLastIndex = children.indexOf(treeNode) == children.size() - 1;
            printElement(stdout, treeNode, level, isLastIndex, lastParentNode);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.listBranches(projectName, new GerritCallback<List<Branch>>() {

        public void onSuccess(final List<Branch> result) {
            Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

                public void onSuccess(final ProjectDetail projectDetail) {
                    com.google.gerrit.client.account.Util.ACCOUNT_SEC.myGroups(new GerritCallback<List<AccountGroup>>() {

                        public void onSuccess(List<AccountGroup> myGroups) {
                            boolean userHasOwnRight = Util.hasOwnRight(projectDetail, myGroups);
                            enableForm(true);
                            branches.display(result, userHasOwnRight);
                            addPanel.setVisible(userHasOwnRight);
                            delBranch.setVisible(userHasOwnRight);
                        }
                    });
                }
            });
        }
    });
}
#method_after
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.listBranches(projectName, new GerritCallback<ListBranchesResult>() {

        public void onSuccess(final ListBranchesResult result) {
            enableForm(true);
            display(result.getBranches());
            addPanel.setVisible(result.getCanAdd());
        }
    });
}
#end_block

#method_before
private void doAddNewBranch() {
    String branchName = nameTxtBox.getText();
    if ("".equals(branchName) || Util.C.defaultBranchName().equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    String rev = irevTxtBox.getText();
    if ("".equals(rev) || Util.C.defaultRevisionSpec().equals(rev)) {
        irevTxtBox.setText("HEAD");
        DeferredCommand.addCommand(new Command() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    if (!branchName.startsWith(Branch.R_REFS)) {
        branchName = Branch.R_HEADS + branchName;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(projectName, branchName, rev, new GerritCallback<List<Branch>>() {

        public void onSuccess(final List<Branch> result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            branches.display(result, true);
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (caught instanceof InvalidNameException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidNameException.MESSAGE)) {
                nameTxtBox.selectAll();
                nameTxtBox.setFocus(true);
            } else if (caught instanceof InvalidRevisionException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidRevisionException.MESSAGE)) {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
            addBranch.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewBranch() {
    String branchName = nameTxtBox.getText();
    if ("".equals(branchName) || Util.C.defaultBranchName().equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    String rev = irevTxtBox.getText();
    if ("".equals(rev) || Util.C.defaultRevisionSpec().equals(rev)) {
        irevTxtBox.setText("HEAD");
        DeferredCommand.addCommand(new Command() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    if (!branchName.startsWith(Branch.R_REFS)) {
        branchName = Branch.R_HEADS + branchName;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(projectName, branchName, rev, new GerritCallback<ListBranchesResult>() {

        public void onSuccess(final ListBranchesResult result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            display(result.getBranches());
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (caught instanceof InvalidNameException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidNameException.MESSAGE)) {
                nameTxtBox.selectAll();
                nameTxtBox.setFocus(true);
            } else if (caught instanceof InvalidRevisionException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidRevisionException.MESSAGE)) {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
            addBranch.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
void display(final List<Branch> result, final boolean canEdit) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final Branch k : result) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, k, canEdit);
    }
}
#method_after
void display(final List<Branch> result) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final Branch k : result) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, k);
    }
}
#end_block

#method_before
void populate(final int row, final Branch k, final boolean canEdit) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (canEdit) {
        table.setWidget(row, 1, new CheckBox());
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    if (c != null) {
        fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    }
    setRowItem(row, k);
}
#method_after
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    if (c != null) {
        fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    }
    setRowItem(row, k);
}
#end_block

#method_before
@Override
public void deleteRight(final Project.NameKey projectName, final Set<RefRight.Key> toRemove, final AsyncCallback<VoidResult> callback) {
    deleteRefRightsFactory.create(projectName, toRemove).to(callback);
}
#method_after
@Override
public void deleteRight(final Project.NameKey projectName, final Set<RefRight.Key> toRemove, final AsyncCallback<ProjectDetail> callback) {
    deleteRefRightsFactory.create(projectName, toRemove).to(callback);
}
#end_block

#method_before
@Override
public void listBranches(final Project.NameKey projectName, final AsyncCallback<List<Branch>> callback) {
    listBranchesFactory.create(projectName).to(callback);
}
#method_after
@Override
public void listBranches(final Project.NameKey projectName, final AsyncCallback<ListBranchesResult> callback) {
    listBranchesFactory.create(projectName).to(callback);
}
#end_block

#method_before
@Override
public void addBranch(final Project.NameKey projectName, final String branchName, final String startingRevision, final AsyncCallback<List<Branch>> callback) {
    addBranchFactory.create(projectName, branchName, startingRevision).to(callback);
}
#method_after
@Override
public void addBranch(final Project.NameKey projectName, final String branchName, final String startingRevision, final AsyncCallback<ListBranchesResult> callback) {
    addBranchFactory.create(projectName, branchName, startingRevision).to(callback);
}
#end_block

#method_before
@Override
protected void onLoad() {
    enableForm(false);
    saveProject.setEnabled(false);
    super.onLoad();
    refresh();
}
#method_after
@Override
protected void onLoad() {
    enableForm(false, false, false);
    saveProject.setEnabled(false);
    super.onLoad();
    refresh();
}
#end_block

#method_before
private void refresh() {
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            com.google.gerrit.client.account.Util.ACCOUNT_SEC.myGroups(new GerritCallback<List<AccountGroup>>() {

                public void onSuccess(List<AccountGroup> myGroups) {
                    boolean userHasOwnRight = Util.hasOwnRight(result, myGroups);
                    enableForm(userHasOwnRight);
                    saveProject.setVisible(userHasOwnRight);
                    saveProject.setEnabled(false);
                    display(result);
                }
            });
        }
    });
}
#method_after
private void refresh() {
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType);
            saveProject.setVisible(result.canModifyAgreements || result.canModifyDescription || result.canModifyMergeType);
            saveProject.setEnabled(false);
            display(result);
        }
    });
}
#end_block

#method_before
private void enableForm(final boolean on) {
    submitType.setEnabled(on);
    descTxt.setEnabled(on);
    useContributorAgreements.setEnabled(on);
    useSignedOffBy.setEnabled(on);
    saveProject.setEnabled(on);
}
#method_after
private void enableForm(final boolean canModifyAgreements, final boolean canModifyDescription, final boolean canModifyMergeType) {
    submitType.setEnabled(canModifyMergeType);
    descTxt.setEnabled(canModifyDescription);
    useContributorAgreements.setEnabled(canModifyAgreements);
    useSignedOffBy.setEnabled(canModifyAgreements);
    saveProject.setEnabled(canModifyAgreements || canModifyDescription || canModifyMergeType);
}
#end_block

#method_before
private void doSave() {
    project.setDescription(descTxt.getText().trim());
    project.setUseContributorAgreements(useContributorAgreements.getValue());
    project.setUseSignedOffBy(useSignedOffBy.getValue());
    if (submitType.getSelectedIndex() >= 0) {
        project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())));
    }
    enableForm(false);
    saveProject.setEnabled(false);
    Util.PROJECT_SVC.changeProjectSettings(project, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(true);
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            refresh();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    project.setDescription(descTxt.getText().trim());
    project.setUseContributorAgreements(useContributorAgreements.getValue());
    project.setUseSignedOffBy(useSignedOffBy.getValue());
    if (submitType.getSelectedIndex() >= 0) {
        project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())));
    }
    enableForm(false, false, false);
    saveProject.setEnabled(false);
    Util.PROJECT_SVC.changeProjectSettings(project, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType);
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            refresh();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            com.google.gerrit.client.account.Util.ACCOUNT_SEC.myGroups(new GerritCallback<List<AccountGroup>>() {

                public void onSuccess(List<AccountGroup> myGroups) {
                    boolean hasOwnRights = Util.hasOwnRight(result, myGroups);
                    enableForm(true);
                    display(result, !hasOwnRights);
                    addPanel.setVisible(hasOwnRights);
                    delRight.setVisible(hasOwnRights);
                }
            });
        }
    });
}
#method_after
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(true);
            display(result);
        }
    });
}
#end_block

#method_before
private void initRights(final Panel body) {
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            rights.deleteChecked();
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#method_after
private void initRights(final Panel body) {
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            final HashSet<RefRight.Key> refRightIds = rights.getRefRightIdsChecked();
            doDeleteRefRights(refRightIds);
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#end_block

#method_before
void display(final ProjectDetail result, final boolean readOnly) {
    rights.display(result.groups, result.rights, readOnly);
}
#method_after
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
    addPanel.setVisible(result.canModifyAccess);
    delRight.setVisible(rights.getCanDelete());
}
#end_block

#method_before
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    idx = rangeMaxBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
    if (max == null) {
        return;
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result, false);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    if (at.getCategory().isRange()) {
        idx = rangeMaxBox.getSelectedIndex();
        if (idx < 0) {
            return;
        }
        max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
        if (max == null) {
            return;
        }
    } else {
        // If its not a range, the maximum box was disabled.  Use the min
        // value as the max, and select the min from the category values.
        // 
        max = min;
        min = at.getMin();
        for (ApprovalCategoryValue v : at.getValues()) {
            if (0 <= v.getValue() && v.getValue() <= max.getValue()) {
                min = v;
                break;
            }
        }
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    // TODO Support per-branch READ access.
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        referenceTxt.setText("");
        referenceTxt.setEnabled(false);
    } else {
        referenceTxt.setEnabled(true);
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#method_after
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    rangeMaxBox.setVisible(at.getCategory().isRange());
    addRight.setEnabled(true);
}
#end_block

#method_before
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<RefRight> refRights, final boolean readOnly) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final RefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r, readOnly);
    }
}
#method_after
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<InheritedRefRight> refRights) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final InheritedRefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r);
    }
}
#end_block

#method_before
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final RefRight r, final boolean readOnly) {
    final GerritConfig config = Gerrit.getConfig();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(r.getApprovalCategoryId());
    final AccountGroup group = groups.get(r.getAccountGroupId());
    if (readOnly || (!projectName.equals(Gerrit.getConfig().getWildProject()) && Gerrit.getConfig().getWildProject().equals(r.getProjectNameKey()))) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, r.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(r.getAccountGroupId().get()));
    }
    table.setText(row, 4, r.getRefPattern());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(r.getMinValue()) : null;
        max = ar != null ? ar.getValue(r.getMaxValue()) : null;
        formatValue(m, r.getMinValue(), min);
        if (r.getMinValue() != r.getMaxValue()) {
            m.br();
            formatValue(m, r.getMaxValue(), max);
        }
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, r);
}
#method_after
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited() || !r.isOwner()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, right.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 4, right.getRefPattern());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        if (ar != null && ar.getCategory().isRange()) {
            formatValue(m, right.getMinValue(), min);
            m.br();
        }
        formatValue(m, right.getMaxValue(), max);
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#end_block

#method_before
@Override
public T atomicUpdate(final K key, final AtomicUpdate<T> update) throws OrmException {
    return schema.run(new OrmRunnable<T, JdbcSchema>() {

        @Override
        public T run(JdbcSchema db, boolean retry) throws OrmException {
            final T obj = get(key);
            if (obj == null) {
                return null;
            }
            final T res = update.update(obj);
            update(Collections.singleton(obj));
            return res;
        }
    });
}
#method_after
@Override
public T atomicUpdate(final K key, final AtomicUpdate<T> update) throws OrmException {
    for (int attempts = 1; ; attempts++) {
        try {
            final T obj = get(key);
            if (obj == null) {
                return null;
            }
            final T res = update.update(obj);
            update(Collections.singleton(obj));
            return res;
        } catch (OrmConcurrencyException err) {
            if (attempts < MAX_TRIES) {
                continue;
            }
            throw err;
        }
    }
}
#end_block

#method_before
public boolean isBatchUser() {
    return false;
}
#method_after
public boolean isBatchUser() {
    return getEffectiveGroups().contains(authConfig.getBatchUsersGroup());
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.addContinuationListener(task);
        cont.setAttribute(TASK, task);
        executor.submit(task);
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    WorkQueue.Executor executor = getExecutor();
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.addContinuationListener(task);
        cont.setAttribute(TASK, task);
        executor.submit(task);
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#end_block

#method_before
@Override
public void onTimeout(Continuation self) {
    executor.remove(this);
}
#method_after
@Override
public void onTimeout(Continuation self) {
    WorkQueue.Executor executor = getExecutor();
    executor.remove(this);
}
#end_block

#method_before
@Override
public WorkQueue.Executor get() {
    CurrentUser user = userProvider.get();
    WorkQueue.Executor executor = queues.getInteractiveQueue();
    if (user.isBatchUser()) {
        executor = queues.getBatchQueue();
    }
    return executor;
}
#method_after
@Override
public WorkQueue.Executor get() {
    WorkQueue.Executor executor;
    if (user.isBatchUser()) {
        executor = queues.getBatchQueue();
    } else {
        executor = queues.getInteractiveQueue();
    }
    return executor;
}
#end_block

#method_before
@Override
public WorkQueue.Executor getBatchQueue() {
    System.out.println("Job scheduled in batch Queue");
    return batchExecutor;
}
#method_after
@Override
public WorkQueue.Executor getBatchQueue() {
    return batchExecutor;
}
#end_block

#method_before
protected synchronized void startThread(final CommandRunnable thunk) {
    final TaskThunk tt = new TaskThunk(thunk);
    if (isAdminCommand() || userProvider.get().isAdministrator()) {
        // Admin commands should not block the main work threads (there
        // might be an interactive shell there), nor should they wait
        // for the main work threads.
        // 
        new Thread(tt, tt.toString()).start();
    } else {
        task = executor.submit(tt);
    }
}
#method_after
protected synchronized void startThread(final CommandRunnable thunk) {
    final TaskThunk tt = new TaskThunk(thunk);
    if (isAdminCommand() || (isAdminHighPriorityCommand() && userProvider.get().isAdministrator())) {
        // Admin commands should not block the main work threads (there
        // might be an interactive shell there), nor should they wait
        // for the main work threads.
        // 
        new Thread(tt, tt.toString()).start();
    } else {
        task = executor.submit(tt);
    }
}
#end_block

#method_before
private void display() {
    p = toPrintWriter(out);
    final List<Task<?>> pending = workQueue.getTasks();
    Collections.sort(pending, new Comparator<Task<?>>() {

        public int compare(Task<?> a, Task<?> b) {
            final Task.State aState = a.getState();
            final Task.State bState = b.getState();
            if (aState != bState) {
                return aState.ordinal() - bState.ordinal();
            }
            final long aDelay = a.getDelay(TimeUnit.MILLISECONDS);
            final long bDelay = b.getDelay(TimeUnit.MILLISECONDS);
            if (aDelay < bDelay) {
                return -1;
            } else if (aDelay > bDelay) {
                return 1;
            }
            return format(a).compareTo(format(b));
        }
    });
    taskNameWidth = wide ? Integer.MAX_VALUE : columns - 8 - 12 - 8 - 4;
    p.print(// 
    String.format(// 
    "%-8s %-12s %-8s %s\n", "Task", "State", "", "Command"));
    p.print("----------------------------------------------" + "--------------------------------\n");
    int numberOfPendingTasks = 0;
    final long now = System.currentTimeMillis();
    boolean isAdministrator = userProvider.get().isAdministrator();
    for (final Task<?> task : pending) {
        final long delay = task.getDelay(TimeUnit.MILLISECONDS);
        final Task.State state = task.getState();
        final String start;
        switch(state) {
            case DONE:
            case CANCELLED:
            case RUNNING:
            case READY:
                start = format(state);
                break;
            default:
                start = time(now, delay);
                break;
        }
        boolean regularUserCanSee = false;
        // If the user is not administrator, check if has rights to see
        // the Task
        Project.NameKey projectName = null;
        String remoteName = null;
        if (!isAdministrator) {
            if (task instanceof ProjectTask<?>) {
                projectName = ((ProjectTask<?>) task).getProjectNameKey();
                remoteName = ((ProjectTask<?>) task).getRemoteName();
            }
            ProjectState e = null;
            if (projectName != null) {
                e = projectCache.get(projectName);
            }
            regularUserCanSee = (e != null && e.controlFor(userProvider.get()).isVisible());
            if (regularUserCanSee) {
                numberOfPendingTasks++;
            }
        }
        // Shows information about tasks depending on the user rights
        if (isAdministrator) {
            p.print(// 
            String.format(// 
            "%8s %-12s %-8s %s\n", id(task.getTaskId()), start, "", format(task)));
        } else {
            if (regularUserCanSee) {
                p.print(// 
                String.format(// 
                "%8s %-12s %-8s %s\n", id(task.getTaskId()), start, "", remoteName + "/" + projectName));
            }
        }
    }
    p.print("----------------------------------------------" + "--------------------------------\n");
    if (isAdministrator) {
        numberOfPendingTasks = pending.size();
    }
    p.print("  " + numberOfPendingTasks + " tasks\n");
    p.flush();
}
#method_after
private void display() {
    p = toPrintWriter(out);
    final List<Task<?>> pending = workQueue.getTasks();
    Collections.sort(pending, new Comparator<Task<?>>() {

        public int compare(Task<?> a, Task<?> b) {
            final Task.State aState = a.getState();
            final Task.State bState = b.getState();
            if (aState != bState) {
                return aState.ordinal() - bState.ordinal();
            }
            final long aDelay = a.getDelay(TimeUnit.MILLISECONDS);
            final long bDelay = b.getDelay(TimeUnit.MILLISECONDS);
            if (aDelay < bDelay) {
                return -1;
            } else if (aDelay > bDelay) {
                return 1;
            }
            return format(a).compareTo(format(b));
        }
    });
    taskNameWidth = wide ? Integer.MAX_VALUE : columns - 8 - 12 - 8 - 4;
    p.print(// 
    String.format(// 
    "%-8s %-12s %-8s %s\n", "Task", "State", "", "Command"));
    p.print("----------------------------------------------" + "--------------------------------\n");
    int numberOfPendingTasks = 0;
    final long now = System.currentTimeMillis();
    final boolean isAdministrator = userProvider.isAdministrator();
    for (final Task<?> task : pending) {
        final long delay = task.getDelay(TimeUnit.MILLISECONDS);
        final Task.State state = task.getState();
        final String start;
        switch(state) {
            case DONE:
            case CANCELLED:
            case RUNNING:
            case READY:
                start = format(state);
                break;
            default:
                start = time(now, delay);
                break;
        }
        boolean regularUserCanSee = false;
        boolean hasCustomizedPrint = true;
        // If the user is not administrator, check if has rights to see
        // the Task
        Project.NameKey projectName = null;
        String remoteName = null;
        if (!isAdministrator) {
            if (task instanceof ProjectTask<?>) {
                projectName = ((ProjectTask<?>) task).getProjectNameKey();
                remoteName = ((ProjectTask<?>) task).getRemoteName();
                hasCustomizedPrint = ((ProjectTask<?>) task).hasCustomizedPrint();
            }
            ProjectState e = null;
            if (projectName != null) {
                e = projectCache.get(projectName);
            }
            regularUserCanSee = e != null && e.controlFor(userProvider).isVisible();
            if (regularUserCanSee) {
                numberOfPendingTasks++;
            }
        }
        // Shows information about tasks depending on the user rights
        if (isAdministrator || (!hasCustomizedPrint && regularUserCanSee)) {
            p.print(// 
            String.format(// 
            "%8s %-12s %-8s %s\n", id(task.getTaskId()), start, "", format(task)));
        } else if (regularUserCanSee) {
            if (remoteName == null) {
                remoteName = projectName.get();
            } else {
                remoteName = remoteName + "/" + projectName;
            }
            p.print(// 
            String.format(// 
            "%8s %-12s %-8s %s\n", id(task.getTaskId()), start, "", remoteName));
        }
    }
    p.print("----------------------------------------------" + "--------------------------------\n");
    if (isAdministrator) {
        numberOfPendingTasks = pending.size();
    }
    p.print("  " + numberOfPendingTasks + " tasks\n");
    p.flush();
}
#end_block

#method_before
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task = null;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<V>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<V>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#method_after
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<V>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<V>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            PrintWriter p = toPrintWriter(out);
            try {
                parseCommandLine();
                final ProjectAccess projectAccess = db.projects();
                Project.NameKey parentNameKey = new Project.NameKey(parentName);
                final List<Project.NameKey> grandParents = new ArrayList<Project.NameKey>();
                if (parentName != null) {
                    final ProjectState projectState = projectCache.get(parentNameKey);
                    if (projectState == null) {
                        throw new Failure(1, "parent project " + parentName + " does not exist \n");
                    } else {
                        Project.NameKey grandParent = projectState.getProject().getParent();
                        // avoid deadlocks on retrieving the project rights
                        while (grandParent != null && !grandParent.equals(wildProject)) {
                            grandParents.add(grandParent);
                            grandParent = projectCache.get(grandParent).getProject().getParent();
                        }
                    }
                } else {
                    // if there is no parent, "All projects" is the default
                    parentName = wildProject.get();
                    parentNameKey = new Project.NameKey(parentName);
                }
                for (String child : children) {
                    final Project.NameKey childNameKey = new Project.NameKey(child);
                    Project projectChild = projectAccess.get(childNameKey);
                    // If the child project doesn't exist, just skip it
                    if (projectChild != null && !child.equals(wildProject.get()) && !child.equals(parentName) && (!grandParents.contains(childNameKey))) {
                        projectChild.setParent(parentNameKey);
                        projectAccess.update(Collections.singleton(projectChild));
                    } else {
                        p.print("It was not possible to set the parent project " + parentName + " to the following project : " + child + "\n");
                        p.flush();
                    }
                }
                // invalidates all projects on cache
                projectCache.evict();
            } catch (Throwable e) {
                p.print("Error when trying to set a parent to a project: " + e.getMessage() + "\n");
                p.flush();
            }
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            parseCommandLine();
            updateParents();
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ApproveCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(AdminCreateProject.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ApproveCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(CreateProject.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchProjectException, OrmException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    for (final RefRight.Key k : toRemove) {
        if (!projectName.equals(k.getProjectNameKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!controlForRef(projectControl, k.getRefPattern()).isOwner()) {
            throw new NoSuchRefException(k.getRefPattern());
        }
    }
    for (final RefRight.Key k : toRemove) {
        final RefRight m = db.refRights().get(k);
        if (m != null) {
            db.refRights().delete(Collections.singleton(m));
        }
    }
    projectCache.evict();
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws NoSuchProjectException, OrmException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    for (final RefRight.Key k : toRemove) {
        if (!projectName.equals(k.getProjectNameKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!controlForRef(projectControl, k.getRefPattern()).isOwner()) {
            throw new NoSuchRefException(k.getRefPattern());
        }
    }
    for (final RefRight.Key k : toRemove) {
        final RefRight m = db.refRights().get(k);
        if (m != null) {
            db.refRights().delete(Collections.singleton(m));
        }
    }
    projectCache.evictAll();
    return VoidResult.INSTANCE;
}
#end_block

#method_before
private ProjectState lookup(final Project.NameKey key) throws OrmException {
    if (key == null) {
        return null;
    }
    // handles the "wildcard" project state (recursion break)
    if (key.equals(wildProject) || key.get() == null || key.get().isEmpty()) {
        return getWildProjectState();
    }
    final ReviewDb db = schema.open();
    try {
        final Project project = db.projects().get(key);
        if (project == null) {
            return null;
        }
        // retrieves the parent project state (recursively)
        ProjectState parentProjectState = null;
        Project.NameKey parentNameKey = project.getParent();
        if (parentNameKey == null || parentNameKey.get() == null || parentNameKey.get().isEmpty()) {
            // if the parent project name is not defined, uses the wildcard project
            parentProjectState = getWildProjectState();
        } else {
            // gets parent project state recursively (unless its available on cache)
            parentProjectState = ProjectCacheImpl.this.get(parentNameKey);
            if (parentProjectState == null) {
                parentProjectState = lookup(parentNameKey);
            }
        }
        // retrieves the project rights
        final Collection<RefRight> projectRights = Collections.unmodifiableCollection(db.refRights().byProject(project.getNameKey()).toList());
        // evaluates the project inherited rights from parent project state
        final ProjectState.InheritedRights inheritedRights = new InheritedRightsComposer(parentProjectState);
        return projectStateFactory.create(project, projectRights, inheritedRights);
    } finally {
        db.close();
    }
}
#method_after
private ProjectState lookup(final Project.NameKey key) throws OrmException {
    final ReviewDb db = schema.open();
    try {
        final Project p = db.projects().get(key);
        if (p == null) {
            return null;
        }
        final Collection<RefRight> rights = Collections.unmodifiableCollection(db.refRights().byProject(p.getNameKey()).toList());
        return projectStateFactory.create(p, rights);
    } finally {
        db.close();
    }
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = "refs/heads/*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = "refs/heads/*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = "refs/tags/*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = "refs/*";
        } else {
            // Assume project wide for the default.
            refPattern = "refs/*";
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    // TODO Support per-branch READ access.
    if (ApprovalCategory.READ.equals(categoryId) && !refPattern.equals("refs/*")) {
        throw new UnsupportedOperationException("READ on " + refPattern + " not yet supported.");
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evict();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    InheritedRefRight inheritedRefRight = (InheritedRefRight) o;
    RefRight refRight = inheritedRefRight.getRight();
    if (refRight.getAccountGroupId().equals(this.getRight().getAccountGroupId()) && refRight.getApprovalCategoryId().equals(this.getRight().getApprovalCategoryId()) && refRight.getMinValue() == this.getRight().getMinValue() && refRight.getMaxValue() == this.getRight().getMaxValue() && refRight.getRefPattern().equals(this.getRight().getRefPattern())) {
        return true;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o instanceof InheritedRefRight) {
        InheritedRefRight a = this;
        InheritedRefRight b = (InheritedRefRight) o;
        return a.getRight().equals(b.getRight()) && a.isInherited() == b.isInherited();
    }
    return false;
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ErrorSlaveMode.class);
    command(gerrit, "create-account").to(ErrorSlaveMode.class);
    command(gerrit, "create-project").to(ErrorSlaveMode.class);
    command(gerrit, "set-project-parent").to(ErrorSlaveMode.class);
    command(gerrit, "gsql").to(ErrorSlaveMode.class);
    command(gerrit, "receive-pack").to(ErrorSlaveMode.class);
    command(gerrit, "replicate").to(ErrorSlaveMode.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ErrorSlaveMode.class);
    command(gerrit, "create-account").to(ErrorSlaveMode.class);
    command(gerrit, "create-project").to(ErrorSlaveMode.class);
    command(gerrit, "gsql").to(ErrorSlaveMode.class);
    command(gerrit, "receive-pack").to(ErrorSlaveMode.class);
    command(gerrit, "replicate").to(ErrorSlaveMode.class);
    command(gerrit, "set-project-parent").to(ErrorSlaveMode.class);
}
#end_block

#method_before
void display(final ProjectDetail result) {
    rights.display(result.groups, result.rights);
}
#method_after
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
}
#end_block

#method_before
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    // TODO Support per-branch READ access.
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        referenceTxt.setText("");
        referenceTxt.setEnabled(false);
    } else {
        referenceTxt.setEnabled(true);
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#method_after
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> am = ad.getApprovalMap();
    final StringBuilder hint = new StringBuilder();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    // TODO populate the account role
    table.clearCell(row, col++);
    for (final ApprovalType type : types) {
        final PatchSetApproval ca = am.get(type.getCategory().getId());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
            col++;
            continue;
        }
        final ApprovalCategoryValue acv = type.getValue(ca);
        if (acv != null) {
            if (hint.length() > 0) {
                hint.append("; ");
            }
            hint.append(acv.getName());
        }
        if (type.isMaxNegative(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (type.isMaxPositive(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    // 
    // Remove button
    // 
    Button removeButton = new Button("X");
    removeButton.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
    removeButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

                @Override
                public void onSuccess(ReviewerResult result) {
                    final ChangeDetail r = result.getChange();
                    display(r.getChange(), r.getMissingApprovals(), r.getApprovals());
                }
            });
        }
    });
    table.setWidget(row, col++, removeButton);
    table.setText(row, col++, hint.toString());
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> am = ad.getApprovalMap();
    final StringBuilder hint = new StringBuilder();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    // TODO populate the account role
    table.clearCell(row, col++);
    for (final ApprovalType type : types) {
        final PatchSetApproval ca = am.get(type.getCategory().getId());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
            col++;
            continue;
        }
        final ApprovalCategoryValue acv = type.getValue(ca);
        if (acv != null) {
            if (hint.length() > 0) {
                hint.append("; ");
            }
            hint.append(acv.getName());
        }
        if (type.isMaxNegative(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (type.isMaxPositive(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    // 
    if (Gerrit.isSignedIn()) {
        Button removeButton = new Button("X");
        removeButton.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        removeButton.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

                    @Override
                    public void onSuccess(ReviewerResult result) {
                        if (result.getErrors().isEmpty()) {
                            final ChangeDetail r = result.getChange();
                            display(r.getChange(), r.getMissingApprovals(), r.getApprovals());
                        } else {
                            new ErrorDialog(result.getErrors().get(0).toString()).center();
                        }
                    }
                });
            }
        });
        table.setWidget(row, col++, removeButton);
    }
    table.setText(row, col++, hint.toString());
}
#end_block

#method_before
@Override
public ReviewerResult call() throws Exception {
    ReviewerResult result = new ReviewerResult();
    List<Account.Id> accounts = Lists.newArrayList();
    Iterable<PatchSetApproval> patchSets = db.patchSetApprovals().byChange(changeId);
    List<PatchSetApproval> toDelete = Lists.newArrayList();
    for (PatchSetApproval psa : patchSets) {
        if (psa.getAccountId().equals(reviewerId)) {
            toDelete.add(psa);
        }
    }
    try {
        db.patchSetApprovals().delete(toDelete);
    } catch (OrmException ex) {
        result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.COULD_NOT_REMOVE, "Could not remove reviewer " + reviewerId));
    }
    // Note: call setChange() after the deletion has been made or it will still
    // contain the reviewer we want to delete.
    result.setChange(changeDetailFactory.create(changeId).call());
    return result;
}
#method_after
@Override
public ReviewerResult call() throws Exception {
    ReviewerResult result = new ReviewerResult();
    List<Account.Id> accounts = new ArrayList<Account.Id>();
    ChangeControl ctl = changeControlFactory.validateFor(changeId);
    boolean permitted = true;
    List<PatchSetApproval> toDelete = new ArrayList<PatchSetApproval>();
    for (PatchSetApproval psa : db.patchSetApprovals().byChange(changeId)) {
        if (psa.getAccountId().equals(reviewerId)) {
            if (ctl.canRemoveReviewer(psa)) {
                toDelete.add(psa);
            } else {
                permitted = false;
                break;
            }
        }
    }
    if (permitted) {
        try {
            db.patchSetApprovals().delete(toDelete);
        } catch (OrmException ex) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.COULD_NOT_REMOVE, "Could not remove reviewer " + reviewerId));
        }
    } else {
        result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.COULD_NOT_REMOVE, "Not allowed to remove reviewer " + reviewerId));
    }
    // Note: call setChange() after the deletion has been made or it will still
    // contain the reviewer we want to delete.
    result.setChange(changeDetailFactory.create(changeId).call());
    return result;
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = "refs/heads/*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = "refs/heads/*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = "refs/tags/*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = "refs/*";
        } else {
            // Assume project wide for the default.
            refPattern = "refs/*";
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evict(projectControl.getProject());
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evict(projectControl.getProject());
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException {
    final UploadPack up = new UploadPack(repo);
    up.setRefFilter(this);
    up.upload(in, out, err);
}
#method_after
@Override
protected void runImpl() throws IOException {
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db));
    }
    up.upload(in, out, err);
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        checkVisibility(cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#end_block

#method_before
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    final LdapSchema schema = getSchema(ctx);
    final Set<String> groupDNs = new HashSet<String>();
    if (!schema.groupMemberQueryList.isEmpty()) {
        final HashMap<String, String> params = new HashMap<String, String>();
        if (schema.groupNeedsAccount) {
            if (account == null) {
                account = findAccount(schema, ctx, username);
            }
            for (String name : schema.groupMemberQueryList.get(0).getParameters()) {
                params.put(name, account.get(name));
            }
        }
        params.put(USERNAME, username);
    }
    if (schema.accountMemberField != null) {
        if (account == null) {
            account = findAccount(schema, ctx, username);
        }
        final Attribute groupAtt = account.getAll(schema.accountMemberField);
        if (groupAtt != null) {
            final NamingEnumeration<?> groups = groupAtt.getAll();
            while (groups.hasMore()) {
                final String nextDN = (String) groups.next();
                recursivelyExpandGroups(groupDNs, schema, ctx, nextDN);
            }
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (String dn : groupDNs) {
        for (AccountGroup group : groupCache.get(new AccountGroup.ExternalNameKey(dn))) {
            if (group.getType() == AccountGroup.Type.LDAP) {
                actual.add(group.getId());
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#method_after
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    final LdapSchema schema = getSchema(ctx);
    final Set<String> groupDNs = new HashSet<String>();
    if (!schema.groupMemberQueryList.isEmpty()) {
        final HashMap<String, String> params = new HashMap<String, String>();
        if (schema.groupNeedsAccount) {
            if (account == null) {
                account = findAccount(schema, ctx, username);
            }
            for (String name : schema.groupMemberQueryList.get(0).getParameters()) {
                params.put(name, account.get(name));
            }
        }
        params.put(USERNAME, username);
        for (LdapQuery groupMemberQuery : schema.groupMemberQueryList) {
            for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
                recursivelyExpandGroups(groupDNs, schema, ctx, r.getDN());
            }
        }
    }
    if (schema.accountMemberField != null) {
        if (account == null) {
            account = findAccount(schema, ctx, username);
        }
        final Attribute groupAtt = account.getAll(schema.accountMemberField);
        if (groupAtt != null) {
            final NamingEnumeration<?> groups = groupAtt.getAll();
            while (groups.hasMore()) {
                final String nextDN = (String) groups.next();
                recursivelyExpandGroups(groupDNs, schema, ctx, nextDN);
            }
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (String dn : groupDNs) {
        for (AccountGroup group : groupCache.get(new AccountGroup.ExternalNameKey(dn))) {
            if (group.getType() == AccountGroup.Type.LDAP) {
                actual.add(group.getId());
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#end_block

#method_before
private void display() throws Failure {
    final PrintWriter stdout = toPrintWriter(out);
    try {
        for (final Project p : db.projects().all()) {
            if (p.getNameKey().equals(wildProject)) {
                // 
                continue;
            }
            final ProjectState e = projectCache.get(p.getNameKey());
            if (e != null && e.controlFor(currentUser).isVisible()) {
                stdout.print(p.getName());
                if (showBranch != null) {
                    RevId revId = getRevIdForBranch(p.getNameKey(), showBranch);
                    if (revId != null) {
                        stdout.print("\t" + revId.get());
                    }
                }
                stdout.println();
            }
        }
    } catch (OrmException e) {
        throw new Failure(1, "fatal: database error", e);
    } finally {
        stdout.flush();
    }
}
#method_after
private void display() throws Failure {
    final PrintWriter stdout = toPrintWriter(out);
    try {
        for (final Project p : db.projects().all()) {
            if (p.getNameKey().equals(wildProject)) {
                // 
                continue;
            }
            final ProjectState e = projectCache.get(p.getNameKey());
            if (e != null && e.controlFor(currentUser).isVisible()) {
                if (showBranch != null) {
                    ObjectId id = getObjectIdForBranch(p.getNameKey(), showBranch);
                    if (id != null) {
                        stdout.print(id.name() + " ");
                        stdout.print(p.getName());
                        stdout.println();
                    }
                } else {
                    stdout.print(p.getName());
                    stdout.println();
                }
            }
        }
    } catch (OrmException e) {
        throw new Failure(1, "fatal: database error", e);
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
@Override
public void authenticate(String username, final String password, final AsyncCallback<LoginResult> callback) {
    LoginResult result = new LoginResult();
    if (// 
    username == null || "".equals(username) || password == null || "".equals(password)) {
        result.success = false;
        callback.onSuccess(result);
        return;
    }
    username = username.trim().toLowerCase();
    final AuthRequest req = AuthRequest.forUser(username);
    req.setPassword(password);
    final AuthResult res;
    try {
        res = accountManager.authenticate(req);
    } catch (AccountException e) {
        result.success = false;
        callback.onSuccess(result);
        return;
    }
    result.success = true;
    result.isNew = res.isNew();
    webSession.get().login(res, false);
    callback.onSuccess(result);
}
#method_after
@Override
public void authenticate(String username, final String password, final AsyncCallback<LoginResult> callback) {
    LoginResult result = new LoginResult();
    if (// 
    username == null || "".equals(username.trim()) || password == null || "".equals(password)) {
        result.success = false;
        callback.onSuccess(result);
        return;
    }
    username = username.trim();
    final AuthRequest req = AuthRequest.forUser(username);
    req.setPassword(password);
    final AuthResult res;
    try {
        res = accountManager.authenticate(req);
    } catch (AccountException e) {
        result.success = false;
        callback.onSuccess(result);
        return;
    }
    result.success = true;
    result.isNew = res.isNew();
    webSession.get().login(res, false);
    callback.onSuccess(result);
}
#end_block

#method_before
static String[] split(String commandLine) {
    final List<String> list = new ArrayList<String>();
    boolean inquote = false;
    boolean indblquote = false;
    StringBuilder r = new StringBuilder();
    for (int ip = 0; ip < commandLine.length(); ) {
        final char b = commandLine.charAt(ip++);
        switch(b) {
            case '\t':
            case ' ':
                if (inquote || indblquote)
                    r.append(b);
                else if (r.length() > 0) {
                    list.add(r.toString());
                    r = new StringBuilder();
                }
                continue;
            case '\"':
                if (inquote)
                    r.append(b);
                indblquote = !indblquote;
                continue;
            case '\'':
                if (indblquote)
                    r.append(b);
                inquote = !inquote;
                continue;
            case '\\':
                if (inquote || indblquote || ip == commandLine.length())
                    // literal within a quote
                    r.append(b);
                else
                    r.append(commandLine.charAt(ip++));
                continue;
            default:
                r.append(b);
                continue;
        }
    }
    if (r.length() > 0) {
        list.add(r.toString());
    }
    return list.toArray(new String[list.size()]);
}
#method_after
static String[] split(String commandLine) {
    final List<String> list = new ArrayList<String>();
    boolean inquote = false;
    boolean inDblQuote = false;
    StringBuilder r = new StringBuilder();
    for (int ip = 0; ip < commandLine.length(); ) {
        final char b = commandLine.charAt(ip++);
        switch(b) {
            case '\t':
            case ' ':
                if (inquote || inDblQuote)
                    r.append(b);
                else if (r.length() > 0) {
                    list.add(r.toString());
                    r = new StringBuilder();
                }
                continue;
            case '\"':
                if (inquote)
                    r.append(b);
                else
                    inDblQuote = !inDblQuote;
                continue;
            case '\'':
                if (inDblQuote)
                    r.append(b);
                else
                    inquote = !inquote;
                continue;
            case '\\':
                if (inquote || ip == commandLine.length())
                    // literal within a quote
                    r.append(b);
                else
                    r.append(commandLine.charAt(ip++));
                continue;
            default:
                r.append(b);
                continue;
        }
    }
    if (r.length() > 0) {
        list.add(r.toString());
    }
    return list.toArray(new String[list.size()]);
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(AdminFlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "show-caches").to(AdminShowCaches.class);
    command(gerrit, "show-connections").to(AdminShowConnections.class);
    command(gerrit, "show-queue").to(AdminShowQueue.class);
    command(gerrit, "stream-changes").to(StreamChangeEvents.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(AdminShowCaches.class);
    command("kill").to(AdminKill.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(AdminFlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "show-caches").to(AdminShowCaches.class);
    command(gerrit, "show-connections").to(AdminShowConnections.class);
    command(gerrit, "show-queue").to(AdminShowQueue.class);
    command(gerrit, "stream-events").to(StreamEvents.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(AdminShowCaches.class);
    command("kill").to(AdminKill.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
}
#end_block

#method_before
public void addChangeListener(ChangeListener listener) {
    listeners.add(listener);
}
#method_after
public void addChangeListener(ChangeListener listener, IdentifiedUser user) {
    listeners.put(listener, new ChangeListenerHolder(listener, user));
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    for (ChangeListener listener : listeners) {
        listener.onPatchsetCreated(change, patchSet);
    }
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    args.add("--patchset");
    args.add(Integer.toString(patchSet.getPatchSetId()));
    runHook(getRepo(change), args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.commit = patchSet.getRevision().get();
    event.patchSet = Integer.toString(patchSet.getPatchSetId());
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--commit");
    args.add(event.commit);
    args.add("--patchset");
    args.add(event.patchSet);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    for (ChangeListener listener : listeners) {
        listener.onCommentAdded(change, patchSet, account, approvals, comment);
    }
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.author = getAuthorAttribute(account);
    event.revision = patchSet.getRevision().get();
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            ApprovalAttribute a = new ApprovalAttribute();
            a.type = approval.getKey().get();
            a.value = Short.toString(approval.getValue().get());
            event.approvals[i++] = a;
        }
    }
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.revision);
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    for (ChangeListener listener : listeners) {
        listener.onChangeMerged(change, account, patchSet);
    }
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    runHook(getRepo(change), args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.submitter = getAuthorAttribute(account);
    event.patchSet = patchSet.getRevision().get();
    event.description = change.getSubject();
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    for (ChangeListener listener : listeners) {
        listener.onChangeAbandoned(change, account, reason);
    }
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.author = getAuthorAttribute(account);
    event.reason = reason;
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    // Get the LDAP authentication username and password
    // from the user's input.
    // 
    final String authUsername = who.getLocalUser();
    final String authPassword = who.getPassword();
    // 
    if (this.username == null) {
        this.username = authUsername;
        this.password = authPassword;
    }
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, authUsername);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), authPassword);
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(authUsername)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(authUsername));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(authUsername, queryForGroups(ctx, authUsername, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = authenticate(username, who.getPassword());
        } else {
            ctx = open();
        }
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private void authenticate(String dn, String password) throws AccountException {
    final Properties env = createContextProperties();
    env.put(Context.SECURITY_AUTHENTICATION, "simple");
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        new InitialDirContext(env).close();
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#method_after
private DirContext authenticate(String dn, String password) throws AccountException {
    final Properties env = createContextProperties();
    env.put(Context.SECURITY_AUTHENTICATION, "simple");
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        return new InitialDirContext(env);
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#end_block

#method_before
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#method_after
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false, false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final PatchSet.Id merged = c.currentPatchSetId();
    PatchSetApproval submitter = null;
    for (int attempts = 0; attempts < 10; attempts++) {
        c.setStatus(Change.Status.MERGED);
        ChangeUtil.updated(c);
        try {
            final Transaction txn = schema.beginTransaction();
            // Flatten out all existing approvals based upon the current
            // permissions. Once the change is closed the approvals are
            // not updated at presentation view time, so we need to make.
            // sure they are accurate now. This way if permissions get
            // modified in the future, historical records stay accurate.
            // 
            final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(c.getId()).toList();
            final FunctionState fs = functionState.create(c, merged, approvals);
            for (ApprovalType at : approvalTypes.getApprovalTypes()) {
                CategoryFunction.forCategory(at.getCategory()).run(at, fs);
            }
            for (PatchSetApproval a : approvals) {
                if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                    if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                        submitter = a;
                    }
                }
                a.cache(c);
            }
            schema.patchSetApprovals().update(approvals, txn);
            if (msg != null) {
                if (submitter != null && msg.getAuthor() == null) {
                    msg.setAuthor(submitter.getAccountId());
                }
                schema.changeMessages().insert(Collections.singleton(msg), txn);
            }
            schema.changes().update(Collections.singleton(c), txn);
            txn.commit();
            break;
        } catch (OrmException e) {
            final Change.Id id = c.getId();
            try {
                c = schema.changes().get(id);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
            } catch (OrmException e2) {
                log.error("Cannot set change " + id + " to merged " + merged, e2);
            }
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        ChangeHookRunner.get().doChangeMergedHook(c, schema.accounts().get(submitter.getAccountId()), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, boolean makeNew) {
    for (int attempts = 0; attempts < 10; attempts++) {
        if (makeNew) {
            c.setStatus(Change.Status.NEW);
        }
        ChangeUtil.updated(c);
        try {
            final Transaction txn = schema.beginTransaction();
            schema.changes().update(Collections.singleton(c), txn);
            if (msg != null) {
                schema.changeMessages().insert(Collections.singleton(msg), txn);
            }
            txn.commit();
            break;
        } catch (OrmException e) {
            try {
                c = schema.changes().get(c.getId());
                if (c.getStatus().isClosed()) {
                    // 
                    break;
                }
            } catch (OrmException e2) {
            }
        }
    }
    try {
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Transaction txn = db.beginTransaction();
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    final PatchSet ps = new PatchSet(change.newPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    final PatchSetImporter imp = importFactory.create(db, c, ps, true);
    imp.setTransaction(txn);
    imp.run();
    change.setCurrentPatchSet(imp.getPatchSetInfo());
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change), txn);
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = imp.getPatchSetInfo().getAuthor() != null ? imp.getPatchSetInfo().getAuthor().getAccount() : null;
        final Account.Id committerId = imp.getPatchSetInfo().getCommitter() != null ? imp.getPatchSetInfo().getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db, txn);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db, txn);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db, txn);
            }
        }
    }
    txn.commit();
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, imp.getPatchSetInfo());
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeHookRunner.get().doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    if (!validCommitter(request.cmd, c)) {
        return null;
    }
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result;
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    result = db.run(new OrmRunnable<ReplaceResult, ReviewDb>() {

        public ReplaceResult run(final ReviewDb db, final Transaction txn, final boolean isRetry) throws OrmException {
            final Change change = db.changes().get(request.ontoChange);
            if (change == null) {
                reject(request.cmd, "change " + request.ontoChange + " not found");
                return null;
            }
            if (change.getStatus().isClosed()) {
                reject(request.cmd, "change " + request.ontoChange + " closed");
                return null;
            }
            final PatchSet.Id priorPatchSet = change.currentPatchSetId();
            for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
                if (ps.getRevision() == null) {
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
                final String revIdStr = ps.getRevision().get();
                final ObjectId commitId;
                try {
                    commitId = ObjectId.fromString(revIdStr);
                } catch (IllegalArgumentException e) {
                    log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
                try {
                    final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
                    // 
                    if (rp.getRevWalk().isMergedInto(prior, c)) {
                        reject(request.cmd, "squash commits first");
                        return null;
                    }
                    // 
                    if (c == prior) {
                        reject(request.cmd, "commit already exists");
                        return null;
                    }
                    // 
                    if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                        rp.getRevWalk().parseBody(prior);
                        final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                        final boolean parentsEq = parentsEqual(c, prior);
                        if (messageEq && parentsEq) {
                            reject(request.cmd, "no changes made");
                            return null;
                        } else {
                            err.write(Constants.encode(// 
                            "warning: " + change.getKey().abbreviate() + // 
                            ": " + // 
                            " no files changed, but" + // 
                            (!messageEq ? " message updated" : "") + // 
                            (!messageEq && !parentsEq ? " and" : "") + // 
                            (!parentsEq ? " was rebased" : "") + // 
                            "\n"));
                        }
                    }
                } catch (IOException e) {
                    log.error("Change " + change.getId() + " missing " + revIdStr, e);
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
            }
            final PatchSet ps = new PatchSet(change.newPatchSetId());
            ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
            ps.setUploader(currentUser.getAccountId());
            final PatchSetImporter imp = importFactory.create(db, c, ps, true);
            imp.setTransaction(txn);
            imp.run();
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            final ReplaceResult result = new ReplaceResult();
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
            result.change = change;
            result.patchSet = ps;
            result.info = imp.getPatchSetInfo();
            final Account.Id authorId = imp.getPatchSetInfo().getAuthor() != null ? imp.getPatchSetInfo().getAuthor().getAccount() : null;
            final Account.Id committerId = imp.getPatchSetInfo().getCommitter() != null ? imp.getPatchSetInfo().getCommitter().getAccount() : null;
            boolean haveAuthor = false;
            boolean haveCommitter = false;
            final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
            oldReviewers.clear();
            oldCC.clear();
            for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
                haveApprovals.add(a.getAccountId());
                if (a.getValue() != 0) {
                    oldReviewers.add(a.getAccountId());
                } else {
                    oldCC.add(a.getAccountId());
                }
                final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)), txn);
                }
                if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                    haveAuthor = true;
                }
                if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                    haveCommitter = true;
                }
            }
            final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
            msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
            db.changeMessages().insert(Collections.singleton(msg), txn);
            result.msg = msg;
            if (result.mergedIntoRef != null) {
                // Change was already submitted to a branch, close it.
                // 
                markChangeMergedByPush(db, txn, result);
            } else {
                // Change should be new, so it can go through review again.
                // 
                change.setStatus(Change.Status.NEW);
                change.setCurrentPatchSet(imp.getPatchSetInfo());
                ChangeUtil.updated(change);
                db.changes().update(Collections.singleton(change), txn);
            }
            final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
            if (allTypes.size() > 0) {
                final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
                if (authorId != null && haveApprovals.add(authorId)) {
                    insertDummyApproval(result, authorId, catId, db, txn);
                }
                if (committerId != null && haveApprovals.add(committerId)) {
                    insertDummyApproval(result, committerId, catId, db, txn);
                }
                for (final Account.Id reviewer : reviewers) {
                    if (haveApprovals.add(reviewer)) {
                        insertDummyApproval(result, reviewer, catId, db, txn);
                    }
                }
            }
            return result;
        }
    });
    if (result != null) {
        final PatchSet ps = result.patchSet;
        final RefUpdate ru = repo.updateRef(ps.getRefName());
        ru.setNewObjectId(c);
        ru.disableRefLog();
        if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(project.getNameKey(), ru.getName());
        request.cmd.setResult(ReceiveCommand.Result.OK);
        try {
            final ReplacePatchSetSender cm;
            cm = replacePatchSetFactory.create(result.change);
            cm.setFrom(me);
            cm.setPatchSet(ps, result.info);
            cm.setChangeMessage(result.msg);
            cm.setReviewDb(db);
            cm.addReviewers(reviewers);
            cm.addExtraCC(cc);
            cm.addReviewers(oldReviewers);
            cm.addExtraCC(oldCC);
            cm.send();
        } catch (EmailException e) {
            log.error("Cannot send email for new patch set " + ps.getId(), e);
        }
        ChangeHookRunner.get().doPatchsetCreatedHook(result.change, ps);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    if (!validCommitter(request.cmd, c)) {
        return null;
    }
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                if (messageEq && parentsEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    err.write(Constants.encode(// 
                    "warning: " + change.getKey().abbreviate() + // 
                    ": " + // 
                    " no files changed, but" + // 
                    (!messageEq ? " message updated" : "") + // 
                    (!messageEq && !parentsEq ? " and" : "") + // 
                    (!parentsEq ? " was rebased" : "") + // 
                    "\n"));
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void insertDummyApproval(final Change change, final PatchSet.Id psId, final Account.Id forAccount, final ApprovalCategory.Id catId, final ReviewDb db, final Transaction txn) throws OrmException {
    final PatchSetApproval ca = new PatchSetApproval(new PatchSetApproval.Key(psId, forAccount, catId), (short) 0);
    ca.cache(change);
    db.patchSetApprovals().insert(Collections.singleton(ca), txn);
}
#method_after
private void insertDummyApproval(final ReplaceResult result, final Account.Id forAccount, final ApprovalCategory.Id catId, final ReviewDb db) throws OrmException {
    insertDummyApproval(result.change, result.patchSet.getId(), forAccount, catId, db);
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final ReplaceResult result = db.run(new OrmRunnable<ReplaceResult, ReviewDb>() {

        @Override
        public ReplaceResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
            final Change change = db.changes().get(cid);
            final PatchSet ps = db.patchSets().get(psi);
            if (change == null || ps == null) {
                log.warn(project.getName() + " " + psi + " is missing");
                return null;
            }
            if (change.getStatus() == Change.Status.MERGED) {
                // 
                return null;
            }
            final ReplaceResult result = new ReplaceResult();
            result.change = change;
            result.patchSet = ps;
            result.info = patchSetInfoFactory.get(commit, psi);
            result.mergedIntoRef = refName;
            markChangeMergedByPush(db, txn, result);
            return result;
        }
    });
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final Transaction txn, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.patchSetApprovals().update(approvals, txn);
    db.changeMessages().insert(Collections.singleton(msg), txn);
    db.changes().update(Collections.singleton(change), txn);
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        ChangeHookRunner.get().doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, PatchSetInfoNotAvailableException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    final Change change = changeControl.getChange();
    if (change.getStatus().isClosed()) {
        throw error("change " + changeId + " is closed");
    }
    final Transaction txn = db.beginTransaction();
    final StringBuffer msgBuf = new StringBuffer();
    msgBuf.append("Patch Set ");
    msgBuf.append(patchSetId.get());
    msgBuf.append(": ");
    String verified = "";
    String approved = "";
    for (ApproveOption co : optionList) {
        final ApprovalCategory.Id category = co.getCategoryId();
        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
        Short score = co.value();
        if (score != null) {
            addApproval(psaKey, score, change, co, txn);
        } else {
            if (psa == null) {
                score = 0;
                addApproval(psaKey, score, change, co, txn);
            } else {
                score = psa.getValue();
            }
        }
        String message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
        msgBuf.append(" " + message + ";");
        if (category.get().equalsIgnoreCase("VRIF")) {
            verified = Short.toString(score);
        } else if (category.get().equalsIgnoreCase("CVRW")) {
            approved = Short.toString(score);
        }
    }
    msgBuf.deleteCharAt(msgBuf.length() - 1);
    msgBuf.append("\n\n");
    if (changeComment != null) {
        msgBuf.append(changeComment);
    }
    String uuid = ChangeUtil.messageUUID(db);
    ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(changeId, uuid), currentUser.getAccountId());
    cm.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(cm), txn);
    ChangeUtil.updated(change);
    db.changes().update(Collections.singleton(change), txn);
    txn.commit();
    ChangeHookRunner.get().doCommentAddedHook(change, currentUser.getAccount(), verified, approved, changeComment);
    sendMail(change, change.currentPatchSetId(), cm);
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, PatchSetInfoNotAvailableException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    final Change change = changeControl.getChange();
    if (change.getStatus().isClosed()) {
        throw error("change " + changeId + " is closed");
    }
    final StringBuffer msgBuf = new StringBuffer();
    msgBuf.append("Patch Set ");
    msgBuf.append(patchSetId.get());
    msgBuf.append(": ");
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvalsMap = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (ApproveOption co : optionList) {
        final ApprovalCategory.Id category = co.getCategoryId();
        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
        Short score = co.value();
        if (score != null) {
            addApproval(psaKey, score, change, co);
        } else {
            if (psa == null) {
                score = 0;
                addApproval(psaKey, score, change, co);
            } else {
                score = psa.getValue();
            }
        }
        final ApprovalCategoryValue.Id val = new ApprovalCategoryValue.Id(category, score);
        String message = db.approvalCategoryValues().get(val).getName();
        msgBuf.append(" " + message + ";");
        approvalsMap.put(category, val);
    }
    msgBuf.deleteCharAt(msgBuf.length() - 1);
    msgBuf.append("\n\n");
    if (changeComment != null) {
        msgBuf.append(changeComment);
    }
    String uuid = ChangeUtil.messageUUID(db);
    ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(changeId, uuid), currentUser.getAccountId());
    cm.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(cm));
    ChangeUtil.touch(change, db);
    sendMail(change, change.currentPatchSetId(), cm);
    hooks.doCommentAddedHook(change, currentUser.getAccount(), changeComment, approvalsMap);
}
#end_block

#method_before
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final ApproveOption co, final Transaction txn) throws OrmException, UnloggedFailure {
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    boolean insert = false;
    if (psa == null) {
        insert = true;
        psa = new PatchSetApproval(psaKey, score);
    }
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, psaKey.getParentKey(), approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw error(co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    if (insert) {
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#method_after
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final ApproveOption co) throws OrmException, UnloggedFailure {
    final PatchSetApproval psa = new PatchSetApproval(psaKey, score);
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, psaKey.getParentKey(), approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw error(co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    db.patchSetApprovals().upsert(Collections.singleton(psa));
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    Boolean dbSuccess = db.run(new OrmRunnable<Boolean, ReviewDb>() {

        public Boolean run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
            return doAbandonChange(message, change, patchSetId, cmsg, db, txn);
        }
    });
    if (dbSuccess) {
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(currentUser.getAccountId());
        cm.setReviewDb(db);
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    ChangeHookRunner.get().doChangeAbandonedHook(change, currentUser.getAccount(), message);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(currentUser.getAccountId());
        cm.setReviewDb(db);
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, currentUser.getAccount(), message);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
private void generateProxyCallCreator(final TreeLogger logger, final SourceWriter w) throws UnableToCompleteException {
    // TODO: implement annotation for json-rpc versions selection
    String callName = getJsonCallClassName(logger);
    w.println();
    w.println("@Override");
    w.print("protected <T> ");
    w.print(callName);
    w.print("<T> newJsonCall(final AbstractJsonProxy proxy, ");
    w.print("final String methodName, final String reqData, ");
    w.println("final ResultDeserializer<T> ser, final AsyncCallback<T> cb) {");
    w.indent();
    w.print("return new ");
    w.print(callName);
    w.println("<T>(proxy, methodName, reqData, ser, cb);");
    w.outdent();
    w.println("}");
}
#method_after
private void generateProxyCallCreator(final TreeLogger logger, final SourceWriter w) throws UnableToCompleteException {
    String callName = getJsonCallClassName(logger);
    w.println();
    w.println("@Override");
    w.print("protected <T> ");
    w.print(callName);
    w.print("<T> newJsonCall(final AbstractJsonProxy proxy, ");
    w.print("final String methodName, final String reqData, ");
    w.println("final ResultDeserializer<T> ser, final AsyncCallback<T> cb) {");
    w.indent();
    w.print("return new ");
    w.print(callName);
    w.println("<T>(proxy, methodName, reqData, ser, cb);");
    w.outdent();
    w.println("}");
}
#end_block

#method_before
private void generateProxyMethod(final TreeLogger logger, final JMethod method, final SourceWriter w) {
    final JParameter[] params = method.getParameters();
    final JParameter callback = params[params.length - 1];
    final JClassType resultType = callback.getType().isParameterized().getTypeArgs()[0];
    final String[] serializerFields = new String[params.length];
    final HostPageCache hpc = method.getAnnotation(HostPageCache.class);
    w.println();
    for (int i = 0; i < params.length - 1; i++) {
        final JType pType = params[i].getType();
        if (SerializerCreator.needsTypeParameter(pType)) {
            serializerFields[i] = "serializer_" + instanceField++;
            w.print("private static final ");
            if (pType.isArray() != null)
                w.print(serializerCreator.serializerFor(pType));
            else
                w.print(JsonSerializer.class.getName());
            w.print(" ");
            w.print(serializerFields[i]);
            w.print(" = ");
            serializerCreator.generateSerializerReference(pType, w);
            w.println(";");
        }
    }
    if (resultType.isParameterized() != null) {
        serializerFields[params.length - 1] = "serializer_" + instanceField++;
        w.print("private static final ");
        w.print(ResultDeserializer.class.getName());
        w.print(" ");
        w.print(serializerFields[params.length - 1]);
        w.print(" = ");
        serializerCreator.generateSerializerReference(resultType, w);
        w.println(";");
    }
    w.print("public ");
    w.print(method.getReturnType().getQualifiedSourceName());
    w.print(" ");
    w.print(method.getName());
    w.print("(");
    boolean needsComma = false;
    final NameFactory nameFactory = new NameFactory();
    for (int i = 0; i < params.length; i++) {
        final JParameter param = params[i];
        if (needsComma) {
            w.print(", ");
        } else {
            needsComma = true;
        }
        final JType paramType = param.getType().getErasedType();
        w.print(paramType.getQualifiedSourceName());
        w.print(" ");
        nameFactory.addName(param.getName());
        w.print(param.getName());
    }
    w.println(") {");
    w.indent();
    if (returnsCallbackHandle(method)) {
        w.print("return new ");
        w.print(CallbackHandle.class.getName());
        w.print("(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.println(");");
        w.outdent();
        w.println("}");
        return;
    }
    if (hpc != null) {
        final String objName = nameFactory.createName("cached");
        w.print("final JavaScriptObject " + objName + " = ");
        w.print(AbstractJsonProxy.class.getName());
        w.print(".");
        w.print(hpc.once() ? "hostPageCacheGetOnce" : "hostPageCacheGetMany");
        w.println("(\"" + hpc.name() + "\");");
        w.println("if (" + objName + " != null) {");
        w.indent();
        w.print(JsonUtil.class.getName());
        w.print(".invoke(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.print(", " + objName);
        w.println(");");
        w.println("return;");
        w.outdent();
        w.println("}");
    }
    final String reqDataStr;
    if (params.length == 1) {
        reqDataStr = "\"\"";
    } else {
        final String reqData = nameFactory.createName("reqData");
        w.println("final StringBuilder " + reqData + " = new StringBuilder();");
        needsComma = false;
        for (int i = 0; i < params.length - 1; i++) {
            if (needsComma) {
                w.println(reqData + ".append(\",\");");
            } else {
                needsComma = true;
            }
            final JType pType = params[i].getType();
            final String pName = params[i].getName();
            if (pType == JPrimitiveType.CHAR || SerializerCreator.isBoxedCharacter(pType)) {
                w.println(reqData + ".append(\"\\\"\");");
                w.println(reqData + ".append(" + JsonSerializer.class.getSimpleName() + ".escapeChar(" + pName + "));");
                w.println(reqData + ".append(\"\\\"\");");
            } else if ((SerializerCreator.isJsonPrimitive(pType) || SerializerCreator.isBoxedPrimitive(pType)) && !SerializerCreator.isJsonString(pType)) {
                w.println(reqData + ".append(" + pName + ");");
            } else {
                w.println("if (" + pName + " != null) {");
                w.indent();
                if (SerializerCreator.needsTypeParameter(pType)) {
                    w.print(serializerFields[i]);
                } else {
                    serializerCreator.generateSerializerReference(pType, w);
                }
                w.println(".printJson(" + reqData + ", " + pName + ");");
                w.outdent();
                w.println("} else {");
                w.indent();
                w.println(reqData + ".append(" + JsonSerializer.class.getName() + ".JS_NULL);");
                w.outdent();
                w.println("}");
            }
        }
        reqDataStr = reqData + ".toString()";
    }
    w.print("doInvoke(");
    w.print("\"" + method.getName() + "\"");
    w.print(", " + reqDataStr);
    w.print(", ");
    if (resultType.isParameterized() != null) {
        w.print(serializerFields[params.length - 1]);
    } else {
        deserializerCreator.generateDeserializerReference(resultType, w);
    }
    w.print(", " + callback.getName());
    w.println(");");
    w.outdent();
    w.println("}");
}
#method_after
private void generateProxyMethod(final TreeLogger logger, final JMethod method, final SourceWriter w) {
    final JParameter[] params = method.getParameters();
    final JParameter callback = params[params.length - 1];
    final JClassType resultType = callback.getType().isParameterized().getTypeArgs()[0];
    final String[] serializerFields = new String[params.length];
    final HostPageCache hpc = method.getAnnotation(HostPageCache.class);
    w.println();
    for (int i = 0; i < params.length - 1; i++) {
        final JType pType = params[i].getType();
        if (SerializerCreator.needsTypeParameter(pType)) {
            serializerFields[i] = "serializer_" + instanceField++;
            w.print("private static final ");
            if (pType.isArray() != null)
                w.print(serializerCreator.serializerFor(pType));
            else
                w.print(JsonSerializer.class.getName());
            w.print(" ");
            w.print(serializerFields[i]);
            w.print(" = ");
            serializerCreator.generateSerializerReference(pType, w);
            w.println(";");
        }
    }
    if (resultType.isParameterized() != null) {
        serializerFields[params.length - 1] = "serializer_" + instanceField++;
        w.print("private static final ");
        w.print(ResultDeserializer.class.getName());
        w.print(" ");
        w.print(serializerFields[params.length - 1]);
        w.print(" = ");
        serializerCreator.generateSerializerReference(resultType, w);
        w.println(";");
    }
    w.print("public ");
    w.print(method.getReturnType().getQualifiedSourceName());
    w.print(" ");
    w.print(method.getName());
    w.print("(");
    boolean needsComma = false;
    final NameFactory nameFactory = new NameFactory();
    for (int i = 0; i < params.length; i++) {
        final JParameter param = params[i];
        if (needsComma) {
            w.print(", ");
        } else {
            needsComma = true;
        }
        final JType paramType = param.getType().getErasedType();
        w.print(paramType.getQualifiedSourceName());
        w.print(" ");
        nameFactory.addName(param.getName());
        w.print(param.getName());
    }
    w.println(") {");
    w.indent();
    if (returnsCallbackHandle(method)) {
        w.print("return new ");
        w.print(CallbackHandle.class.getName());
        w.print("(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.println(");");
        w.outdent();
        w.println("}");
        return;
    }
    if (hpc != null) {
        final String objName = nameFactory.createName("cached");
        w.print("final JavaScriptObject " + objName + " = ");
        w.print(AbstractJsonProxy.class.getName());
        w.print(".");
        w.print(hpc.once() ? "hostPageCacheGetOnce" : "hostPageCacheGetMany");
        w.println("(\"" + hpc.name() + "\");");
        w.println("if (" + objName + " != null) {");
        w.indent();
        w.print(JsonUtil.class.getName());
        w.print(".invoke(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.print(", " + objName);
        w.println(");");
        w.println("return;");
        w.outdent();
        w.println("}");
    }
    final String reqDataStr;
    if (params.length == 1) {
        reqDataStr = "\"[]\"";
    } else {
        final String reqData = nameFactory.createName("reqData");
        w.println("final StringBuilder " + reqData + " = new StringBuilder();");
        needsComma = false;
        w.println(reqData + ".append('[');");
        for (int i = 0; i < params.length - 1; i++) {
            if (needsComma) {
                w.println(reqData + ".append(\",\");");
            } else {
                needsComma = true;
            }
            final JType pType = params[i].getType();
            final String pName = params[i].getName();
            if (pType == JPrimitiveType.CHAR || SerializerCreator.isBoxedCharacter(pType)) {
                w.println(reqData + ".append(\"\\\"\");");
                w.println(reqData + ".append(" + JsonSerializer.class.getSimpleName() + ".escapeChar(" + pName + "));");
                w.println(reqData + ".append(\"\\\"\");");
            } else if ((SerializerCreator.isJsonPrimitive(pType) || SerializerCreator.isBoxedPrimitive(pType)) && !SerializerCreator.isJsonString(pType)) {
                w.println(reqData + ".append(" + pName + ");");
            } else {
                w.println("if (" + pName + " != null) {");
                w.indent();
                if (SerializerCreator.needsTypeParameter(pType)) {
                    w.print(serializerFields[i]);
                } else {
                    serializerCreator.generateSerializerReference(pType, w);
                }
                w.println(".printJson(" + reqData + ", " + pName + ");");
                w.outdent();
                w.println("} else {");
                w.indent();
                w.println(reqData + ".append(" + JsonSerializer.class.getName() + ".JS_NULL);");
                w.outdent();
                w.println("}");
            }
        }
        w.println(reqData + ".append(']');");
        reqDataStr = reqData + ".toString()";
    }
    w.print("doInvoke(");
    w.print("\"" + method.getName() + "\"");
    w.print(", " + reqDataStr);
    w.print(", ");
    if (resultType.isParameterized() != null) {
        w.print(serializerFields[params.length - 1]);
    } else {
        deserializerCreator.generateDeserializerReference(resultType, w);
    }
    w.print(", " + callback.getName());
    w.println(");");
    w.outdent();
    w.println("}");
}
#end_block

#method_before
@Override
void send() {
    final StringBuilder body = new StringBuilder();
    body.append("{\"version\":\"1.1\",\"method\":\"");
    body.append(methodName);
    body.append("\",\"params\":[");
    body.append(requestParams);
    body.append("]");
    final String xsrfKey = proxy.getXsrfManager().getToken(proxy);
    if (xsrfKey != null) {
        body.append(",\"xsrfKey\":");
        body.append(JsonSerializer.escapeString(xsrfKey));
    }
    body.append("}");
    final RequestBuilder rb;
    rb = new RequestBuilder(RequestBuilder.POST, proxy.url);
    rb.setHeader("Content-Type", JsonUtil.JSON_REQ_CT);
    rb.setHeader("Accept", JsonUtil.JSON_TYPE);
    rb.setCallback(this);
    rb.setRequestData(body.toString());
    send(rb);
}
#method_after
@Override
void send() {
    final StringBuilder body = new StringBuilder();
    body.append("{\"version\":\"1.1\",\"method\":\"");
    body.append(methodName);
    body.append("\",\"params\":");
    body.append(requestParams);
    final String xsrfKey = proxy.getXsrfManager().getToken(proxy);
    if (xsrfKey != null) {
        body.append(",\"xsrfKey\":");
        body.append(JsonSerializer.escapeString(xsrfKey));
    }
    body.append("}");
    final RequestBuilder rb;
    rb = new RequestBuilder(RequestBuilder.POST, proxy.url);
    rb.setHeader("Content-Type", JsonUtil.JSON_REQ_CT);
    rb.setHeader("Accept", JsonUtil.JSON_TYPE);
    rb.setCallback(this);
    rb.setRequestData(body.toString());
    send(rb);
}
#end_block

#method_before
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (rsp.getStatusCode() == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(rsp.getStatusCode(), rsp.getStatusText()));
    }
}
#method_after
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    // FIXME: implement version 2.0
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (rsp.getStatusCode() == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(rsp.getStatusCode(), rsp.getStatusText()));
    }
}
#method_after
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            // TODO: define status code for the invalid XSRF msg for 2.0 (-32099 ?)
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("data")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
private List<ReplicationConfig> allConfigs(final File path) throws ConfigInvalidException, IOException {
    final File cfgFile = new File(path, "replication.config");
    final FileBasedConfig cfg = new FileBasedConfig(cfgFile);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfgFile + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg));
    }
    return Collections.unmodifiableList(r);
}
#method_after
private List<ReplicationConfig> allConfigs(final File path) throws ConfigInvalidException, IOException {
    final File cfgFile = new File(path, "replication.config");
    final FileBasedConfig cfg = new FileBasedConfig(cfgFile);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfgFile + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg, database, replicationUserFactory));
    }
    return Collections.unmodifiableList(r);
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri) {
    try {
        if (!projectControlFactory.controlFor(project).isVisible()) {
            return;
        }
    } catch (NoSuchProjectException e1) {
        log.error("Internal error: project " + project + " not found during replication");
        return;
    }
    synchronized (pending) {
        PushOp e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project.get(), uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri) {
    try {
        if (authEnabled && !projectControlFactory.controlFor(project).isVisible()) {
            return;
        }
    } catch (NoSuchProjectException e1) {
        log.error("Internal error: project " + project + " not found during replication");
        return;
    }
    synchronized (pending) {
        PushOp e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project.get(), uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
    }
}
#end_block

#method_before
@Override
public Set<Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        effectiveGroups = new HashSet<Id>();
        if (authGroupNames == null) {
            effectiveGroups.addAll(authConfig.getAnonymousGroups());
        } else {
            effectiveGroups.addAll(authConfig.getRegisteredGroups());
            for (String authGroupName : authGroupNames) {
                AccountGroup group = groupCache.lookup(authGroupName);
                if (group != null) {
                    effectiveGroups.add(group.getId());
                }
            }
        }
    }
    return effectiveGroups;
}
#method_after
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    return Collections.unmodifiableSet(effectiveGroups);
}
#end_block

#method_before
@Override
public Set<Change.Id> getStarredChanges() {
    return null;
}
#method_after
@Override
public Set<Change.Id> getStarredChanges() {
    return Collections.emptySet();
}
#end_block

#method_before
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg.setFindReplaceList(Gerrit.getConfig().getCommentLinks());
    msg = msg.runFindReplaceList();
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#method_after
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg = msg.replaceAll(Gerrit.getConfig().getCommentLinks());
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#end_block

#method_before
protected void setMessageText(String message) {
    if (message == null) {
        message = "";
    } else {
        message = message.trim();
    }
    messageSummary.setText(summarize(message));
    SafeHtml msg = new SafeHtmlBuilder().append(message);
    msg.setFindReplaceList(Gerrit.getConfig().getCommentLinks());
    SafeHtml.set(messageText, msg.wikify().runFindReplaceList());
}
#method_after
protected void setMessageText(String message) {
    if (message == null) {
        message = "";
    } else {
        message = message.trim();
    }
    messageSummary.setText(summarize(message));
    SafeHtml.set(messageText, new SafeHtmlBuilder().append(message).wikify().replaceAll(Gerrit.getConfig().getCommentLinks()));
}
#end_block

#method_before
private GerritConfig create() {
    final GerritConfig config = new GerritConfig();
    config.setCanonicalUrl(canonicalWebUrl);
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseRepoDownload(cfg.getBoolean("repo", null, "showdownloadcommand", false));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    final String gitwebUrl = cfg.getString("gitweb", null, "url");
    if (gitwebUrl != null) {
        config.setGitwebLink(new GitwebLink(gitwebUrl));
    }
    config.setSshdAddress(sshInfo != null ? sshInfo.getSshdAddress() : null);
    ArrayList<String> commentLinkNames = new ArrayList<String>(cfg.getSubsections("CommentLink"));
    ArrayList<RegexFindReplace> commentLinks = new ArrayList<RegexFindReplace>(commentLinkNames.size());
    for (String commentLinkName : commentLinkNames) {
        String match = cfg.getString("CommentLink", commentLinkName, "match");
        String link = cfg.getString("CommentLink", commentLinkName, "link");
        commentLinks.add(new RegexFindReplace(match, link));
    }
    config.setCommentLinks(commentLinks);
    return config;
}
#method_after
private GerritConfig create() {
    final GerritConfig config = new GerritConfig();
    config.setCanonicalUrl(canonicalWebUrl);
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseRepoDownload(cfg.getBoolean("repo", null, "showdownloadcommand", false));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    final String gitwebUrl = cfg.getString("gitweb", null, "url");
    if (gitwebUrl != null) {
        config.setGitwebLink(new GitwebLink(gitwebUrl));
    }
    config.setSshdAddress(sshInfo != null ? sshInfo.getSshdAddress() : null);
    ArrayList<String> commentLinkNames = new ArrayList<String>(cfg.getSubsections("CommentLink"));
    ArrayList<RegexFindReplace> commentLinks = new ArrayList<RegexFindReplace>(commentLinkNames.size());
    for (String commentLinkName : commentLinkNames) {
        String match = cfg.getString("commentlink", commentLinkName, "match");
        String link = "<a href=\"" + cfg.getString("commentlink", commentLinkName, "link") + "\">$&</a>";
        commentLinks.add(new RegexFindReplace(match, link));
    }
    config.setCommentLinks(commentLinks);
    return config;
}
#end_block

#method_before
public SafeHtml replaceAll(final String regex, final String repl) {
    return new SafeHtmlString(asString().replaceAll(regex, repl));
}
#method_after
public SafeHtml replaceAll(final List<RegexFindReplace> findReplaceList) {
    if (findReplaceList == null) {
        return this;
    }
    String html = this.asString();
    for (RegexFindReplace findReplace : findReplaceList) {
        html = html.replaceAll(findReplace.find(), findReplace.replace());
    }
    return new SafeHtmlString(html);
}
#end_block

#method_before
private void initReadCategory(final ReviewDb c, final SystemConfig sConfig) throws OrmException {
    final Transaction txn = c.beginTransaction();
    final ApprovalCategory cat;
    final ArrayList<ApprovalCategoryValue> vals;
    cat = new ApprovalCategory(ApprovalCategory.READ, "Read Access");
    cat.setPosition((short) -1);
    cat.setFunctionName(NoOpFunction.NAME);
    vals = new ArrayList<ApprovalCategoryValue>();
    vals.add(value(cat, 2, "Upload permission"));
    vals.add(value(cat, 1, "Read access"));
    vals.add(value(cat, -1, "No access"));
    c.approvalCategories().insert(Collections.singleton(cat), txn);
    c.approvalCategoryValues().insert(vals, txn);
    txn.commit();
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.anonymousGroupId));
        read.setMaxValue((short) 1);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.adminGroupId));
        read.setMaxValue((short) 1);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
}
#method_after
private void initReadCategory(final ReviewDb c, final SystemConfig sConfig) throws OrmException {
    final Transaction txn = c.beginTransaction();
    final ApprovalCategory cat;
    final ArrayList<ApprovalCategoryValue> vals;
    cat = new ApprovalCategory(ApprovalCategory.READ, "Read Access");
    cat.setPosition((short) -1);
    cat.setFunctionName(NoOpFunction.NAME);
    vals = new ArrayList<ApprovalCategoryValue>();
    vals.add(value(cat, 2, "Upload permission"));
    vals.add(value(cat, 1, "Read access"));
    vals.add(value(cat, -1, "No access"));
    c.approvalCategories().insert(Collections.singleton(cat), txn);
    c.approvalCategoryValues().insert(vals, txn);
    txn.commit();
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.anonymousGroupId));
        read.setMaxValue((short) 2);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.adminGroupId));
        read.setMaxValue((short) 1);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    final String reqName = project.getName();
    if (!canUpload()) {
        throw new Failure(1, "fatal: Upload denied for project '" + reqName + "'", new SecurityException("Account lacks Upload permission"));
    }
    if (project.isUseContributorAgreements()) {
        verifyActiveContributorAgreement();
    }
    refLogIdent = currentUser.newPersonIdent();
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    rp = new ReceivePack(repo);
    rp.setAllowCreates(true);
    rp.setAllowDeletes(true);
    rp.setAllowNonFastForwards(true);
    rp.setCheckReceivedObjects(true);
    rp.setRefLogIdent(refLogIdent);
    rp.setPreReceiveHook(new PreReceiveHook() {

        public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            parseCommands(commands);
            if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
                createNewChanges();
            }
            doReplaces();
        }
    });
    rp.setPostReceiveHook(new PostReceiveHook() {

        public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            for (final ReceiveCommand c : commands) {
                if (c.getResult() == Result.OK) {
                    if (isHead(c)) {
                        switch(c.getType()) {
                            case CREATE:
                                insertBranchEntity(c);
                                autoCloseChanges(c);
                                break;
                            case DELETE:
                                deleteBranchEntity(c);
                                break;
                            case UPDATE:
                            case UPDATE_NONFASTFORWARD:
                                autoCloseChanges(c);
                                break;
                        }
                    }
                    if (isHead(c) || isTag(c)) {
                        // We only schedule heads and tags for replication.
                        // Change refs are scheduled when they are created.
                        // 
                        replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                    }
                }
            }
        }
    });
    rp.receive(in, out, err);
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        // Make sure there isn't anything buffered; we want to give the
        // push client a chance to display its status report before we
        // show our own messages on standard error.
        // 
        out.flush();
        final String url = canonicalWebUrl;
        final PrintWriter msg = toPrintWriter(err);
        msg.write("\nNew Changes:\n");
        for (final Change.Id c : allNewChanges) {
            msg.write("  " + url + c.get() + "\n");
        }
        msg.write('\n');
        msg.flush();
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!canUpload()) {
        final String reqName = project.getName();
        throw new Failure(1, "fatal: Upload denied for project '" + reqName + "'", new SecurityException("Account lacks Upload permission"));
    }
    if (project.isUseContributorAgreements()) {
        verifyActiveContributorAgreement();
    }
    refLogIdent = currentUser.newPersonIdent();
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    rp = new ReceivePack(repo);
    rp.setAllowCreates(true);
    rp.setAllowDeletes(true);
    rp.setAllowNonFastForwards(true);
    rp.setCheckReceivedObjects(true);
    rp.setRefLogIdent(refLogIdent);
    rp.setPreReceiveHook(new PreReceiveHook() {

        public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            parseCommands(commands);
            if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
                createNewChanges();
            }
            doReplaces();
        }
    });
    rp.setPostReceiveHook(new PostReceiveHook() {

        public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            for (final ReceiveCommand c : commands) {
                if (c.getResult() == Result.OK) {
                    if (isHead(c)) {
                        switch(c.getType()) {
                            case CREATE:
                                insertBranchEntity(c);
                                autoCloseChanges(c);
                                break;
                            case DELETE:
                                deleteBranchEntity(c);
                                break;
                            case UPDATE:
                            case UPDATE_NONFASTFORWARD:
                                autoCloseChanges(c);
                                break;
                        }
                    }
                    if (isHead(c) || isTag(c)) {
                        // We only schedule heads and tags for replication.
                        // Change refs are scheduled when they are created.
                        // 
                        replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                    }
                }
            }
        }
    });
    rp.receive(in, out, err);
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        // Make sure there isn't anything buffered; we want to give the
        // push client a chance to display its status report before we
        // show our own messages on standard error.
        // 
        out.flush();
        final String url = canonicalWebUrl;
        final PrintWriter msg = toPrintWriter(err);
        msg.write("\nNew Changes:\n");
        for (final Change.Id c : allNewChanges) {
            msg.write("  " + url + c.get() + "\n");
        }
        msg.write('\n');
        msg.flush();
    }
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            who.setDisplayName(m.get(accountFullName));
            who.setSshUserName(m.get(accountSshUserName));
            if (accountEmailAddress != null) {
                who.setEmailAddress(m.get(accountEmailAddress));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setSshUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    final HashMap<String, String> params = new HashMap<String, String>();
    params.put(USERNAME, username);
    if (groupNeedsAccount) {
        if (account == null) {
            account = findAccount(ctx, username);
        }
        for (final String name : groupMemberQueryList.get(0).getParameters()) {
            params.put(name, account.get(name));
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (LdapQuery groupMemberQuery : groupMemberQueryList) {
        for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
            NamingEnumeration groups = r.getAll(memberField).getAll();
            while (groups.hasMore()) {
                final String name = String.valueOf(groups.next());
                final AccountGroup group = groupCache.lookup(name);
                if (group != null && isLdapGroup(group)) {
                    actual.add(group.getId());
                }
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#method_after
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    if (account == null) {
        account = findAccount(ctx, username);
    }
    final HashMap<String, String> params = new HashMap<String, String>();
    params.put(USERNAME, username);
    if (groupNeedsAccount) {
        for (final String name : groupMemberQueryList.get(0).getParameters()) {
            params.put(name, account.get(name));
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (LdapQuery groupMemberQuery : groupMemberQueryList) {
        for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
            final String name = r.get(groupName);
            final AccountGroup group = groupCache.lookup(name);
            if (group != null && isLdapGroup(group)) {
                actual.add(group.getId());
            }
        }
    }
    NamingEnumeration groups = account.getAll(accountMemberField).getAll();
    while (groups.hasMore()) {
        final String dn = (String) groups.next();
        for (String cn : groupsFor(ctx, dn)) {
            AccountGroup group = groupCache.lookup(cn);
            if (null != group && isLdapGroup(group)) {
                actual.add(group.getId());
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#end_block

#method_before
@Override
public List<RealmProperty> getProperties(final AccountGroup group) {
    if (!isLdapGroup(group)) {
        return Collections.emptyList();
    }
    try {
        final DirContext ctx = open();
        try {
            final Map<String, String> params = new HashMap<String, String>();
            params.put(GROUPNAME, group.getName());
            final List<RealmProperty> props = new ArrayList<RealmProperty>();
            final List<LdapQuery.Result> q = new ArrayList<LdapQuery.Result>();
            for (LdapQuery groupByNameQuery : groupByNameQueryList) {
                q.addAll(groupByNameQuery.query(ctx, params));
            }
            switch(q.size()) {
                case 0:
                    log.warn("Group \"" + group.getName() + "\" not found in LDAP.");
                    props.add(new RealmProperty("error", "NOT FOUND"));
                    break;
                case 1:
                    for (final String name : q.get(0).keySet()) {
                        props.add(new RealmProperty(name, q.get(0).get(name)));
                    }
                    Collections.sort(props, new Comparator<RealmProperty>() {

                        @Override
                        public int compare(final RealmProperty a, final RealmProperty b) {
                            int sort = classOf(a) - classOf(b);
                            if (sort == 0)
                                sort = a.getName().compareTo(b.getName());
                            return sort;
                        }

                        private int classOf(final RealmProperty p) {
                            final String n = p.getName();
                            if ("dn".equals(n) || "distinguishedName".equals(n))
                                return 0;
                            if ("cn".equals(n))
                                return 1;
                            return 5000;
                        }
                    });
                    break;
                default:
                    log.warn("Group \"" + group.getName() + "\" has multiple matches in LDAP: " + q);
                    props.add(new RealmProperty("error", "MULTIPLE MATCHES"));
                    break;
            }
            return props;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP directory for group " + group.getName(), e);
        return Collections.emptyList();
    }
}
#method_after
@Override
public List<RealmProperty> getProperties(final AccountGroup group) {
    if (!isLdapGroup(group)) {
        return Collections.emptyList();
    }
    try {
        final DirContext ctx = open();
        try {
            final Map<String, String> params = new HashMap<String, String>();
            params.put(GROUPNAME, group.getName());
            final List<RealmProperty> props = new ArrayList<RealmProperty>();
            final List<LdapQuery.Result> q = new ArrayList<LdapQuery.Result>();
            for (LdapQuery groupByNameQuery : groupByNameQueryList) {
                q.addAll(groupByNameQuery.query(ctx, params));
            }
            switch(q.size()) {
                case 0:
                    log.warn("Group \"" + group.getName() + "\" not found in LDAP.");
                    props.add(new RealmProperty("error", "NOT FOUND"));
                    break;
                case 1:
                    for (final String name : q.get(0).map().keySet()) {
                        props.add(new RealmProperty(name, q.get(0).get(name)));
                    }
                    Collections.sort(props, new Comparator<RealmProperty>() {

                        @Override
                        public int compare(final RealmProperty a, final RealmProperty b) {
                            int sort = classOf(a) - classOf(b);
                            if (sort == 0)
                                sort = a.getName().compareTo(b.getName());
                            return sort;
                        }

                        private int classOf(final RealmProperty p) {
                            final String n = p.getName();
                            if ("dn".equals(n) || "distinguishedName".equals(n))
                                return 0;
                            if ("cn".equals(n))
                                return 1;
                            return 5000;
                        }
                    });
                    break;
                default:
                    log.warn("Group \"" + group.getName() + "\" has multiple matches in LDAP: " + q);
                    props.add(new RealmProperty("error", "MULTIPLE MATCHES"));
                    break;
            }
            return props;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP directory for group " + group.getName(), e);
        return Collections.emptyList();
    }
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            who.setDisplayName(m.get(accountFullName));
            who.setSshUserName(m.get(accountSshUserName));
            if (accountEmailAddress != null) {
                who.setEmailAddress(m.get(accountEmailAddress));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
private void authenticate(String dn, String password) throws AccountException {
    final Properties env = new Properties();
    env.put(Context.INITIAL_CONTEXT_FACTORY, LDAP);
    env.put(Context.PROVIDER_URL, server);
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        new InitialDirContext(env).close();
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#end_block

#method_before
@Override
public String toString() {
    String data = "";
    try {
        String.valueOf(atts.get("dn").get(0));
    } catch (NamingException e) {
    }
    return data;
}
#method_after
@Override
public String toString() {
    try {
        return getDN();
    } catch (NamingException e) {
        return "";
    }
}
#end_block

#method_before
public static String toProject(final Project.NameKey proj, Status status) {
    switch(status) {
        case ABANDONED:
            return "project,abandoned," + proj.toString() + ",n,z";
        case MERGED:
            return "project,merged," + proj.toString() + ",n,z";
        default:
            return "project,open," + proj.toString() + ",n,z";
    }
}
#method_after
public static String toProject(final Project.NameKey proj, Status status) {
    switch(status) {
        case ABANDONED:
            return "project,abandoned," + proj.toString() + ",n,z";
        case MERGED:
            return "project,merged," + proj.toString() + ",n,z";
        case NEW:
        case SUBMITTED:
        default:
            return "project,open," + proj.toString() + ",n,z";
    }
}
#end_block

#method_before
@Override
protected Screen createScreen() {
    switch(status) {
        case ABANDONED:
            return new ByProjectAbandonedChangesScreen(project, "n,z");
        case MERGED:
            return new ByProjectMergedChangesScreen(project, "n,z");
        default:
            return new ByProjectOpenChangesScreen(project, "n,z");
    }
}
#method_after
@Override
protected Screen createScreen() {
    switch(status) {
        case ABANDONED:
            return new ByProjectAbandonedChangesScreen(project, "n,z");
        case MERGED:
            return new ByProjectMergedChangesScreen(project, "n,z");
        case NEW:
        case SUBMITTED:
        default:
            return new ByProjectOpenChangesScreen(project, "n,z");
    }
}
#end_block

#method_before
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#method_after
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
public Account.Id getId() {
    return accountId;
}
#method_after
public Account.Id getId() {
    return oldAccountId;
}
#end_block

#method_before
public Account.Id getAccountId() {
    return accountId;
}
#method_after
public Account.Id getAccountId() {
    return oldAccountId;
}
#end_block

#method_before
public Account.Id getId() {
    return accountId;
}
#method_after
public Account.Id getId() {
    return oldAccountId;
}
#end_block

#method_before
public Account.Id getAccountId() {
    return accountId;
}
#method_after
public Account.Id getAccountId() {
    return oldAccountId;
}
#end_block

#method_before
@Override
public void changeSshUserName(final String newName, final AsyncCallback<VoidResult> callback) {
    if (!realm.allowsEdit(Account.FieldName.SSH_USER_NAME)) {
        callback.onFailure(new NameAlreadyUsedException());
        return;
    }
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final Account me = db.accounts().get(getAccountId());
            if (me == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (newName != null && !sshUserNamePattern.matcher(newName).matches()) {
                throw new Failure(new InvalidSshUserNameException());
            }
            final Account other;
            if (newName != null) {
                other = db.accounts().bySshUserName(newName);
            } else {
                other = null;
            }
            if (other != null) {
                if (other.getId().equals(me.getId())) {
                    return VoidResult.INSTANCE;
                } else {
                    throw new Failure(new NameAlreadyUsedException());
                }
            }
            final String oldName = me.getSshUserName();
            me.setSshUserName(newName);
            db.accounts().update(Collections.singleton(me));
            uncacheSshKeys(oldName);
            uncacheSshKeys(newName);
            accountCache.evict(me.getId());
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
@Override
public void changeSshUserName(final String newName, final AsyncCallback<VoidResult> callback) {
    if (!realm.allowsEdit(Account.FieldName.SSH_USER_NAME)) {
        callback.onFailure(new NameAlreadyUsedException());
        return;
    }
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final Account me = db.accounts().get(getAccountId());
            if (me == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (newName != null && !SSH_USER_NAME_PATTERN.matcher(newName).matches()) {
                throw new Failure(new InvalidSshUserNameException());
            }
            final Account other;
            if (newName != null) {
                other = db.accounts().bySshUserName(newName);
            } else {
                other = null;
            }
            if (other != null) {
                if (other.getId().equals(me.getId())) {
                    return VoidResult.INSTANCE;
                } else {
                    throw new Failure(new NameAlreadyUsedException());
                }
            }
            final String oldName = me.getSshUserName();
            me.setSshUserName(newName);
            db.accounts().update(Collections.singleton(me));
            uncacheSshKeys(oldName);
            uncacheSshKeys(newName);
            accountCache.evict(me.getId());
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Override
public PersonIdent get() {
    String name = gerritConfig.getString("user", null, "name");
    if (name == null) {
        name = "Gerrit Code Review";
    }
    String email = gerritConfig.get(UserConfig.KEY).getCommitterEmail();
    if (email == null || email.length() == 0) {
        email = "gerrit@localhost";
    }
    return new PersonIdent(name, email);
}
#method_after
@Override
public PersonIdent get() {
    return new PersonIdent(name, email);
}
#end_block

#method_before
private static List<String> optionalList(final Config config, final String name) {
    String[] s = config.getStringList("ldap", null, name);
    if (s == null || s.length == 0) {
        return null;
    }
    final List<String> vlist = new ArrayList<String>();
    for (int i = 0; i < s.length; i++) {
        vlist.add(s[i]);
    }
    return vlist;
}
#method_after
private static List<String> optionalList(final Config config, final String name) {
    String[] s = config.getStringList("ldap", null, name);
    return Arrays.asList(s);
}
#end_block

#method_before
private static List<String> requiredList(final Config config, final String name) {
    List<String> vlist = optionalList(config, name);
    if (vlist == null) {
        throw new IllegalArgumentException("No ldap." + name + " configured");
    }
    return vlist;
}
#method_after
private static List<String> requiredList(final Config config, final String name) {
    List<String> vlist = optionalList(config, name);
    if (vlist.isEmpty()) {
        throw new IllegalArgumentException("No ldap " + name + " configured");
    }
    return vlist;
}
#end_block

#method_before
public void strongestApprovals(final Change.Id id, final AsyncCallback<ApprovalDetail> callback) {
    run(callback, new Action<ApprovalDetail>() {

        public ApprovalDetail run(ReviewDb db) throws OrmException {
            final List<PatchSet> last_pset = db.patchSets().lastChange(id).toList();
            if (last_pset.isEmpty()) {
                return null;
            }
            final PatchSet.Id ps_id = last_pset.get(0).getId();
            final Map<ApprovalCategory.Id, PatchSetApproval> have = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
            for (PatchSetApproval a : db.patchSetApprovals().byPatchSet(ps_id)) {
                boolean keep = true;
                if (have.containsKey(a.getCategoryId())) {
                    final short oldValue = have.get(a.getCategoryId()).getValue();
                    final short newValue = a.getValue();
                    keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                }
                if (keep) {
                    have.put(a.getCategoryId(), a);
                }
            }
            final ApprovalDetail ad = new ApprovalDetail(getAccountId());
            for (PatchSetApproval a : have.values()) {
                ad.add(a);
            }
            return ad;
        }
    });
}
#method_after
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        fs.normalize(approvalTypes.getApprovalType(ca.getCategoryId()), ca);
                        boolean keep = true;
                        if (psas.containsKey(ca.getCategoryId())) {
                            final short oldValue = psas.get(ca.getCategoryId()).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(ca.getCategoryId(), ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /* The user has no access to see this change, so we
             * simply do not provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable(true);
    byOwner = new ChangeTable.Section("", ChangeTable.ApprovalViewType.STRONGEST);
    forReview = new ChangeTable.Section("", ChangeTable.ApprovalViewType.MINE);
    closed = new ChangeTable.Section("", ChangeTable.ApprovalViewType.STRONGEST);
    table.addSection(byOwner);
    table.addSection(forReview);
    table.addSection(closed);
    add(table);
    table.setSavePointerId(Link.toAccountDashboard(ownerId));
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable(true);
    byOwner = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null);
    forReview = new ChangeTable.Section("", ApprovalViewType.USER, ownerId);
    closed = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null);
    table.addSection(byOwner);
    table.addSection(forReview);
    table.addSection(closed);
    add(table);
    table.setSavePointerId(Link.toAccountDashboard(ownerId));
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, S_ICON_CELL);
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, S_DATA_CELL);
    }
    fmt.addStyleName(row, C_ID, S_C_ID);
    fmt.addStyleName(row, C_SUBJECT, S_C_SUBJECT);
    fmt.addStyleName(row, C_PROJECT, S_C_PROJECT);
    fmt.addStyleName(row, C_BRANCH, S_C_PROJECT);
    fmt.addStyleName(row, C_LAST_UPDATE, S_C_LAST_UPDATE);
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, "approvalscore");
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, S_ICON_CELL);
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, S_DATA_CELL);
    }
    fmt.addStyleName(row, C_ID, S_C_ID);
    fmt.addStyleName(row, C_SUBJECT, S_C_SUBJECT);
    fmt.addStyleName(row, C_PROJECT, S_C_PROJECT);
    fmt.addStyleName(row, C_BRANCH, S_C_PROJECT);
    fmt.addStyleName(row, C_LAST_UPDATE, S_C_LAST_UPDATE);
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, final ApprovalViewType viewType) {
    final String idstr = c.getKey().abbreviate();
    table.setWidget(row, C_ARROW, null);
    if (Gerrit.isSignedIn()) {
        setStar(row, c);
    }
    table.setWidget(row, C_ID, new TableChangeLink(idstr, c));
    String s = c.getSubject();
    if (s.length() > 80) {
        s = s.substring(0, 80);
    }
    if (c.getStatus() != null && c.getStatus() != Change.Status.NEW) {
        s += " (" + c.getStatus().name() + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(s, c));
    table.setWidget(row, C_OWNER, link(c.getOwner()));
    table.setWidget(row, C_PROJECT, new ProjectOpenLink(c.getProject().getKey()));
    table.setText(row, C_BRANCH, c.getBranch());
    table.setText(row, C_LAST_UPDATE, mediumFormat(c.getLastUpdatedOn()));
    switch(viewType) {
        case NONE:
            break;
        case MINE:
            PatchUtil.DETAIL_SVC.myApprovals(c.getId(), approvalFormatter(row));
            break;
        case STRONGEST:
            PatchUtil.DETAIL_SVC.strongestApprovals(c.getId(), approvalFormatter(row));
            break;
    }
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c) {
    final String idstr = c.getKey().abbreviate();
    table.setWidget(row, C_ARROW, null);
    if (Gerrit.isSignedIn()) {
        setStar(row, c);
    }
    table.setWidget(row, C_ID, new TableChangeLink(idstr, c));
    String s = c.getSubject();
    if (s.length() > 80) {
        s = s.substring(0, 80);
    }
    if (c.getStatus() != null && c.getStatus() != Change.Status.NEW) {
        s += " (" + c.getStatus().name() + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(s, c));
    table.setWidget(row, C_OWNER, link(c.getOwner()));
    table.setWidget(row, C_PROJECT, new ProjectOpenLink(c.getProject().getKey()));
    table.setText(row, C_BRANCH, c.getBranch());
    table.setText(row, C_LAST_UPDATE, mediumFormat(c.getLastUpdatedOn()));
    setRowItem(row, c);
}
#end_block

#method_before
GerritCallback<ApprovalDetail> approvalFormatter(final int row) {
    return new GerritCallback<ApprovalDetail>() {

        @Override
        public void onSuccess(final ApprovalDetail detail) {
            final CellFormatter fmt = table.getCellFormatter();
            final Map<ApprovalCategory.Id, PatchSetApproval> am = detail.getApprovalMap();
            int col = BASE_COLUMNS;
            for (final ApprovalType type : approvalTypes) {
                final PatchSetApproval ca = am.get(type.getCategory().getId());
                if (ca == null || ca.getValue() == 0) {
                    table.clearCell(row, col);
                } else if (type.isMaxNegative(ca)) {
                    table.setWidget(row, col, Gerrit.ICONS.redNot().createImage());
                } else if (type.isMaxPositive(ca)) {
                    table.setWidget(row, col, Gerrit.ICONS.greenCheck().createImage());
                } else {
                    String vstr = String.valueOf(ca.getValue());
                    if (ca.getValue() > 0) {
                        vstr = "+" + vstr;
                        fmt.removeStyleName(row, col, "negscore");
                        fmt.addStyleName(row, col, "posscore");
                    } else {
                        fmt.addStyleName(row, col, "negscore");
                        fmt.removeStyleName(row, col, "posscore");
                    }
                    table.setText(row, col, vstr);
                }
                col++;
            }
        }
    };
}
#method_after
GerritCallback<ApprovalSummarySet> approvalFormatter(final int dataBegin, final int rows) {
    return new GerritCallback<ApprovalSummarySet>() {

        @Override
        public void onSuccess(final ApprovalSummarySet as) {
            Map<Change.Id, ApprovalSummary> ids = as.getSummaryMap();
            AccountInfoCache aic = as.getAccountInfoCache();
            for (int row = dataBegin; row < dataBegin + rows; row++) {
                final ChangeInfo c = getRowItem(row);
                if (ids.containsKey(c.getId())) {
                    displayApprovals(row, ids.get(c.getId()), aic);
                }
            }
        }
    };
}
#end_block

#method_before
public void display(final List<ChangeInfo> changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    }
    if (sz == 0) {
        if (hadData) {
            parent.insertNoneRow(dataBegin);
        }
    } else {
        if (!hadData) {
            parent.removeRow(dataBegin);
        }
        while (rows < sz) {
            parent.insertChangeRow(dataBegin + rows);
            rows++;
        }
        for (int i = 0; i < sz; i++) {
            parent.populateChangeRow(dataBegin + i, changeList.get(i), viewType);
        }
    }
}
#method_after
public void display(final List<ChangeInfo> changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    }
    if (sz == 0) {
        if (hadData) {
            parent.insertNoneRow(dataBegin);
        }
    } else {
        Set<Change.Id> cids = new HashSet<Change.Id>();
        if (!hadData) {
            parent.removeRow(dataBegin);
        }
        while (rows < sz) {
            parent.insertChangeRow(dataBegin + rows);
            rows++;
        }
        for (int i = 0; i < sz; i++) {
            ChangeInfo c = changeList.get(i);
            parent.populateChangeRow(dataBegin + i, c);
            cids.add(c.getId());
        }
        switch(viewType) {
            case NONE:
                break;
            case USER:
                PatchUtil.DETAIL_SVC.userApprovals(cids, ownerId, parent.approvalFormatter(dataBegin, rows));
                break;
            case STRONGEST:
                PatchUtil.DETAIL_SVC.strongestApprovals(cids, parent.approvalFormatter(dataBegin, rows));
                break;
        }
    }
}
#end_block

#method_before
protected final CmdLineParser newCmdLineParserInstance(final Object bean) {
    Field f = null;
    ApproveCmdLineParser parser = new ApproveCmdLineParser(bean);
    try {
        f = CmdOption.class.getField("value");
        for (CmdOption c : optionList) {
            parser.addOption(new FieldSetter(c, f), c);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return parser;
}
#method_after
protected final CmdLineParser newCmdLineParserInstance(final Object bean) {
    CmdLineParser parser = new CmdLineParser(bean);
    for (CmdOption c : optionList) {
        parser.addOption(c, c);
    }
    return parser;
}
#end_block

#method_before
@Override
public final void start() throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            getApprovalNames();
            parseCommandLine();
            PrintWriter p = toPrintWriter(out);
            validateParameters();
            try {
                final Transaction txn = db.beginTransaction();
                final Change.Id cid = new Change.Id(changeId);
                final Change c = db.changes().get(cid);
                StringBuffer sb = new StringBuffer();
                sb.append("Patch Set: ");
                sb.append(c.currentPatchSetId().get());
                sb.append(" ");
                for (CmdOption co : optionList) {
                    String message = "";
                    Short score = co.value();
                    ApprovalCategory.Id category = new ApprovalCategory.Id(co.approvalKey());
                    if (co.value() != null) {
                        addApproval(c, category, co.value(), txn);
                    } else {
                        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(c.currentPatchSetId(), currentUser.getAccountId(), category);
                        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
                        if (psa == null) {
                            score = null;
                        } else {
                            score = psa.getValue();
                        }
                    }
                    if (score != null) {
                        message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
                    }
                    sb.append(" " + message + ";");
                }
                sb.deleteCharAt(sb.length() - 1);
                sb.append("\n\n");
                if (changeComment != null) {
                    sb.append(changeComment);
                }
                String uuid = ChangeUtil.messageUUID(db);
                ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(cid, uuid), currentUser.getAccountId());
                cm.setMessage(sb.toString());
                db.changeMessages().insert(Collections.singleton(cm), txn);
                ChangeUtil.updated(c);
                db.changes().update(Collections.singleton(c), txn);
                txn.commit();
                sendMail(c, c.currentPatchSetId(), cm);
                p.print(sb.toString() + "\n");
                p.flush();
            } catch (OrmException e) {
                throw new Failure(CMD_ERR, "Error accessing the database\n" + "Detailed message:\n" + e.getMessage());
            } catch (EmailException e) {
                throw new Failure(CMD_ERR, "Error when trying to send email\n" + "Detailed message:\n" + e.getMessage());
            } catch (Exception e) {
                throw new Failure(CMD_ERR, "Received an error\n" + "Detailed message:\n" + e.getMessage());
            }
        }
    });
}
#method_after
@Override
public final void start() throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            getApprovalNames();
            parseCommandLine();
            final Transaction txn = db.beginTransaction();
            final PatchSet ps = db.patchSets().get(patchSetId);
            if (ps == null) {
                throw new UnloggedFailure(CMD_ERR, "Invalid patchset id");
            }
            final Change.Id cid = ps.getId().getParentKey();
            final ChangeControl control = changeControlFactory.validateFor(cid);
            final Change c = control.getChange();
            if (c.getStatus().isClosed()) {
                throw new UnloggedFailure(CMD_ERR, "Change is closed.");
            }
            StringBuffer sb = new StringBuffer();
            sb.append("Patch Set ");
            sb.append(patchSetId.get());
            sb.append(": ");
            for (CmdOption co : optionList) {
                ApprovalCategory.Id category = new ApprovalCategory.Id(co.approvalKey());
                PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
                PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
                Short score = co.value();
                if (score != null) {
                    addApproval(psaKey, score, c, co, txn);
                } else {
                    if (psa == null) {
                        score = 0;
                        addApproval(psaKey, score, c, co, txn);
                    } else {
                        score = psa.getValue();
                    }
                }
                String message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
                sb.append(" " + message + ";");
            }
            sb.deleteCharAt(sb.length() - 1);
            sb.append("\n\n");
            if (changeComment != null) {
                sb.append(changeComment);
            }
            String uuid = ChangeUtil.messageUUID(db);
            ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(cid, uuid), currentUser.getAccountId());
            cm.setMessage(sb.toString());
            db.changeMessages().insert(Collections.singleton(cm), txn);
            ChangeUtil.updated(c);
            db.changes().update(Collections.singleton(c), txn);
            txn.commit();
            sendMail(c, c.currentPatchSetId(), cm);
        }
    });
}
#end_block

#method_before
private void addApproval(final Change c, final ApprovalCategory.Id cat, final short score, final Transaction txn) throws OrmException {
    PatchSetApproval.Key psaKey = new PatchSetApproval.Key(c.currentPatchSetId(), currentUser.getAccountId(), cat);
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    if (psa == null) {
        psa = new PatchSetApproval(psaKey, score);
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        psa.setGranted();
        psa.setValue(score);
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#method_after
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final CmdOption co, final Transaction txn) throws OrmException, UnloggedFailure {
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    boolean insert = false;
    if (psa == null) {
        insert = true;
        psa = new PatchSetApproval(psaKey, score);
    }
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, patchSetId, approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw new UnloggedFailure(CMD_ERR, co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    if (insert) {
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#end_block

#method_before
private void getApprovalNames() throws OrmException {
    SortedMap<Short, String> acvMap = new TreeMap<Short, String>();
    optionList = new ArrayList<CmdOption>();
    ResultSet<ApprovalCategory> rs = db.approvalCategories().all();
    for (ApprovalCategory c : rs) {
        if (c.getFunctionName().equals("MaxWithBlock")) {
            ResultSet<ApprovalCategoryValue> acvrs = db.approvalCategoryValues().byCategory(c.getId());
            short min = Short.MAX_VALUE;
            short max = Short.MIN_VALUE;
            String usage = "";
            for (ApprovalCategoryValue acv : acvrs) {
                if (min > acv.getValue()) {
                    min = acv.getValue();
                }
                if (max < acv.getValue()) {
                    max = acv.getValue();
                }
                acvMap.put(acv.getValue(), acv.getName());
            }
            usage += "Score for " + c.getName() + "\n";
            // This is to make sure that the values are in sorted order.
            Iterator<Short> i = acvMap.keySet().iterator();
            while (i.hasNext()) {
                Short key = i.next();
                usage += String.format("%4d", key) + "  -  " + acvMap.get(key) + "\n";
            }
            optionList.add(new CmdOption("--" + c.getName().toLowerCase().replace(' ', '-'), usage, c.getId().get(), min, max, c.getName()));
            usage = "";
            acvMap.clear();
        }
    }
}
#method_after
private void getApprovalNames() throws OrmException {
    optionList = new ArrayList<CmdOption>();
    for (ApprovalType type : approvalTypes.getApprovalTypes()) {
        String usage = "";
        final ApprovalCategory category = type.getCategory();
        usage = "Score for " + category.getName() + "\n";
        for (ApprovalCategoryValue v : type.getValues()) {
            usage += String.format("%4d", v.getValue()) + "  -  " + v.getName() + "\n";
        }
        optionList.add(new CmdOption("--" + category.getName().toLowerCase().replace(' ', '-'), usage, category.getId().get(), type.getMin().getValue(), type.getMax().getValue(), category.getName()));
    }
}
#end_block

#method_before
private void replicateProject(final URIish replicateURI) {
    SshSessionFactory sshFactory = SshSessionFactory.getInstance();
    Session sshSession;
    String projectPath = QuotedString.BOURNE.quote(replicateURI.getPath());
    if (!usingSSH(replicateURI)) {
        log.warn("Cannot create new project on remote site since the connection " + "methood is not SSH: " + replicateURI.toString());
        return;
    }
    OutputStream errStream = createErrStream();
    String cmd = "mkdir " + projectPath + "&& cd " + projectPath + "&& git init --bare";
    try {
        sshSession = sshFactory.getSession(replicateURI.getUser(), replicateURI.getPass(), replicateURI.getHost(), replicateURI.getPort());
        sshSession.connect();
        Channel channel = sshSession.openChannel("exec");
        ((ChannelExec) channel).setCommand(cmd);
        channel.setInputStream(null);
        ((ChannelExec) channel).setErrStream(errStream);
        channel.connect();
        while (!channel.isClosed()) {
            try {
                final int delay = 50;
                Thread.sleep(delay);
            } catch (InterruptedException e) {
            }
        }
        channel.disconnect();
        sshSession.disconnect();
    } catch (JSchException e) {
        log.error("Communication error when trying to replicate to: " + replicateURI.toString() + "\n" + "Error reported: " + e.getMessage() + "\n" + "Error in communication: " + errStream.toString());
    }
}
#method_after
private void replicateProject(final URIish replicateURI) {
    SshSessionFactory sshFactory = SshSessionFactory.getInstance();
    Session sshSession;
    String projectPath = QuotedString.BOURNE.quote(replicateURI.getPath());
    if (!usingSSH(replicateURI)) {
        log.warn("Cannot create new project on remote site since the connection " + "method is not SSH: " + replicateURI.toString());
        return;
    }
    OutputStream errStream = createErrStream();
    String cmd = "mkdir " + projectPath + "&& cd " + projectPath + "&& git init --bare";
    try {
        sshSession = sshFactory.getSession(replicateURI.getUser(), replicateURI.getPass(), replicateURI.getHost(), replicateURI.getPort());
        sshSession.connect();
        Channel channel = sshSession.openChannel("exec");
        ((ChannelExec) channel).setCommand(cmd);
        channel.setInputStream(null);
        ((ChannelExec) channel).setErrStream(errStream);
        channel.connect();
        while (!channel.isClosed()) {
            try {
                final int delay = 50;
                Thread.sleep(delay);
            } catch (InterruptedException e) {
            }
        }
        channel.disconnect();
        sshSession.disconnect();
    } catch (JSchException e) {
        log.error("Communication error when trying to replicate to: " + replicateURI.toString() + "\n" + "Error reported: " + e.getMessage() + "\n" + "Error in communication: " + errStream.toString());
    }
}
#end_block

#method_before
private boolean usingSSH(final URIish uri) {
    if (!uri.isRemote())
        return false;
    final String scheme = uri.getScheme();
    if (scheme != null && scheme.toLowerCase().contains("ssh"))
        return true;
    if (scheme == null && uri.getHost() != null && uri.getPath() != null)
        return true;
    return false;
}
#method_after
private boolean usingSSH(final URIish uri) {
    final String scheme = uri.getScheme();
    if (!uri.isRemote())
        return false;
    if (scheme != null && scheme.toLowerCase().contains("ssh"))
        return true;
    if (scheme == null && uri.getHost() != null && uri.getPath() != null)
        return true;
    return false;
}
#end_block

#method_before
public void setHttpServletRequest(final HttpServletRequest req) {
    myUrl = GerritServer.serverUrl(req);
}
#method_after
@Inject(optional = true)
void setHttpServletRequest(final HttpServletRequest req) {
    httpRequestUrl = GerritServer.serverUrl(req);
}
#end_block

#method_before
public void send() throws EmailException {
    if (!server.isOutgoingMailEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            // If we are impersonating a user, make sure they receive a CC of
            // this message so they can always review and audit what we sent
            // on their behalf to others.
            // 
            add(RecipientType.CC, fromId);
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
        }
        try {
            final SMTPClient client = server.createOutgoingMail();
            try {
                if (!client.setSender(smtpFromAddress.email)) {
                    throw new EmailException("SMTP server rejected from " + smtpFromAddress);
                }
                for (String emailAddress : smtpRcptTo) {
                    if (!client.addRecipient(emailAddress)) {
                        String error = client.getReplyString();
                        throw new EmailException("SMTP server rejected rcpt " + emailAddress + ": " + error);
                    }
                }
                if (headers.get("Message-ID").isEmpty()) {
                    final StringBuilder rndid = new StringBuilder();
                    rndid.append("<");
                    rndid.append(System.currentTimeMillis());
                    rndid.append("-");
                    rndid.append(Integer.toString(RNG.nextInt(999999), 36));
                    rndid.append("@");
                    rndid.append(InetAddress.getLocalHost().getCanonicalHostName());
                    rndid.append(">");
                    setHeader("Message-ID", rndid.toString());
                }
                Writer w = client.sendMessageData();
                if (w == null) {
                    throw new EmailException("SMTP server rejected message body");
                }
                w = new BufferedWriter(w);
                for (Map.Entry<String, EmailHeader> h : headers.entrySet()) {
                    if (!h.getValue().isEmpty()) {
                        w.write(h.getKey());
                        w.write(": ");
                        h.getValue().write(w);
                        w.write("\r\n");
                    }
                }
                w.write("\r\n");
                w.write(body.toString());
                w.flush();
                w.close();
                if (!client.completePendingCommand()) {
                    throw new EmailException("SMTP server rejected message body");
                }
                client.logout();
            } finally {
                client.disconnect();
            }
        } catch (IOException e) {
            throw new EmailException("Cannot send outgoing email", e);
        }
    }
}
#method_after
public void send() throws EmailException {
    if (!emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            // If we are impersonating a user, make sure they receive a CC of
            // this message so they can always review and audit what we sent
            // on their behalf to others.
            // 
            add(RecipientType.CC, fromId);
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
        }
        if (headers.get("Message-ID").isEmpty()) {
            final StringBuilder rndid = new StringBuilder();
            rndid.append("<");
            rndid.append(System.currentTimeMillis());
            rndid.append("-");
            rndid.append(Integer.toString(RNG.nextInt(999999), 36));
            rndid.append("@");
            rndid.append(SystemReader.getInstance().getHostname());
            rndid.append(">");
            setHeader("Message-ID", rndid.toString());
        }
        emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#end_block

#method_before
protected void init() {
    smtpFromAddress = computeFrom();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    setHeader("MIME-Version", "1.0");
    setHeader("Content-Type", "text/plain; charset=UTF-8");
    setHeader("Content-Disposition", "inline");
    setHeader("User-Agent", "Gerrit/" + Version.getVersion());
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-ChangeId", "" + change.getChangeId());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (change != null && db != null) {
        if (patchSet == null) {
            try {
                patchSet = db.patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = PatchSetInfoFactory.patchSetInfoFromPatchSetId(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#method_after
protected void init() {
    smtpFromAddress = computeFrom();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-ChangeId", "" + change.getChangeId());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (change != null && db != null) {
        if (patchSet == null) {
            try {
                patchSet = db.patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = patchSetInfoFactory.get(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#end_block

#method_before
private String getGerritHost() {
    if (server.getCanonicalURL() != null) {
        try {
            return new URL(server.getCanonicalURL()).getHost();
        } catch (MalformedURLException e) {
        // Try something else.
        }
    }
    if (myUrl != null) {
        try {
            return new URL(myUrl).getHost();
        } catch (MalformedURLException e) {
        // Try something else.
        }
    }
    // 
    try {
        return InetAddress.getLocalHost().getCanonicalHostName();
    } catch (UnknownHostException e) {
        return "localhost";
    }
}
#method_after
protected String getGerritHost() {
    if (getGerritUrl() != null) {
        try {
            return new URL(getGerritUrl()).getHost();
        } catch (MalformedURLException e) {
        // Try something else.
        }
    }
    // 
    return SystemReader.getInstance().getHostname();
}
#end_block

#method_before
private String getGerritUrl() {
    if (server.getCanonicalURL() != null) {
        return server.getCanonicalURL();
    }
    return myUrl;
}
#method_after
protected String getGerritUrl() {
    if (canonicalWebUrl != null) {
        return canonicalWebUrl;
    }
    return httpRequestUrl;
}
#end_block

#method_before
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr.email);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#method_after
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#end_block

#method_before
public void patchScript(final Patch.Key patchKey, final PatchSet.Id psa, final PatchSet.Id psb, final PatchScriptSettings s, final AsyncCallback<PatchScript> callback) {
    if (psb == null) {
        callback.onFailure(new NoSuchEntityException());
        return;
    }
    run(callback, new PatchScriptAction(server, registry, patchKey, psa, psb, s));
}
#method_after
public void patchScript(final Patch.Key patchKey, final PatchSet.Id psa, final PatchSet.Id psb, final PatchScriptSettings s, final AsyncCallback<PatchScript> callback) {
    if (psb == null) {
        callback.onFailure(new NoSuchEntityException());
        return;
    }
    run(callback, new PatchScriptAction(server, registry, diffCache, patchKey, psa, psb, s));
}
#end_block

#method_before
public void publishComments(final PatchSet.Id psid, final String message, final Set<ApprovalCategoryValue.Id> approvals, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final PublishResult r;
            r = db.run(new OrmRunnable<PublishResult, ReviewDb>() {

                public PublishResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doPublishComments(psid, message, approvals, db, txn);
                }
            });
            try {
                final CommentSender cm = new CommentSender(server, r.change);
                cm.setFrom(Common.getAccountId());
                cm.setPatchSet(r.patchSet, PatchSetInfoFactory.patchSetInfoFromPatchSetId(psid));
                cm.setChangeMessage(r.message);
                cm.setPatchLineComments(r.comments);
                cm.setReviewDb(db);
                cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send comments by email for patch set " + psid, e);
                throw new Failure(e);
            } catch (PatchSetInfoNotAvailableException e) {
                log.error("Failed to obtain PatchSetInfo for patch set " + psid, e);
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void publishComments(final PatchSet.Id psid, final String message, final Set<ApprovalCategoryValue.Id> approvals, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final PublishResult r;
            r = db.run(new OrmRunnable<PublishResult, ReviewDb>() {

                public PublishResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doPublishComments(psid, message, approvals, db, txn);
                }
            });
            try {
                final CommentSender cm;
                cm = commentSenderFactory.create(r.change);
                cm.setFrom(Common.getAccountId());
                cm.setPatchSet(r.patchSet, patchSetInfoFactory.get(psid));
                cm.setChangeMessage(r.message);
                cm.setPatchLineComments(r.comments);
                cm.setReviewDb(db);
                cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send comments by email for patch set " + psid, e);
                throw new Failure(e);
            } catch (PatchSetInfoNotAvailableException e) {
                log.error("Failed to obtain PatchSetInfo for patch set " + psid, e);
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public void addReviewers(final Change.Id id, final List<String> reviewers, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
            final Change change = db.changes().get(id);
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            for (final String email : reviewers) {
                final Account who = Account.find(db, email);
                if (who == null) {
                    throw new Failure(new NoSuchAccountException(email));
                }
                reviewerIds.add(who.getId());
            }
            // Add the reviewer to the database
            db.run(new OrmRunnable<VoidResult, ReviewDb>() {

                public VoidResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAddReviewers(reviewerIds, id, db, txn);
                }
            });
            // Email the reviewer
            try {
                final AddReviewerSender cm = new AddReviewerSender(server, change);
                cm.setFrom(Common.getAccountId());
                cm.setReviewDb(db);
                cm.addReviewers(reviewerIds);
                cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send review request by email for change " + id, e);
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void addReviewers(final Change.Id id, final List<String> reviewers, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
            final Change change = db.changes().get(id);
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            for (final String email : reviewers) {
                final Account who = Account.find(db, email);
                if (who == null) {
                    throw new Failure(new NoSuchAccountException(email));
                }
                reviewerIds.add(who.getId());
            }
            // Add the reviewer to the database
            db.run(new OrmRunnable<VoidResult, ReviewDb>() {

                public VoidResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAddReviewers(reviewerIds, id, db, txn);
                }
            });
            // Email the reviewer
            try {
                final AddReviewerSender cm;
                cm = addReviewerSenderFactory.create(change);
                cm.setFrom(Common.getAccountId());
                cm.setReviewDb(db);
                cm.addReviewers(reviewerIds);
                cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send review request by email for change " + id, e);
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public void abandonChange(final PatchSet.Id patchSetId, final String message, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(patchSetId);
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (me == null || patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !canPerform(me, projEnt, ApprovalCategory.OWN, (short) 1)) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            Boolean dbSuccess = db.run(new OrmRunnable<Boolean, ReviewDb>() {

                public Boolean run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, patchSetId, cmsg, db, txn);
                }
            });
            if (dbSuccess) {
                // Email the reviewers
                try {
                    final AbandonedSender cm = new AbandonedSender(server, change);
                    cm.setFrom(me);
                    cm.setReviewDb(db);
                    cm.setChangeMessage(cmsg);
                    cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                    cm.send();
                } catch (EmailException e) {
                    log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                    throw new Failure(e);
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void abandonChange(final PatchSet.Id patchSetId, final String message, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(patchSetId);
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (me == null || patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !canPerform(me, projEnt, ApprovalCategory.OWN, (short) 1)) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            Boolean dbSuccess = db.run(new OrmRunnable<Boolean, ReviewDb>() {

                public Boolean run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, patchSetId, cmsg, db, txn);
                }
            });
            if (dbSuccess) {
                // Email the reviewers
                try {
                    final AbandonedSender cm;
                    cm = abandonedSenderFactory.create(change);
                    cm.setFrom(me);
                    cm.setReviewDb(db);
                    cm.setChangeMessage(cmsg);
                    cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                    cm.send();
                } catch (EmailException e) {
                    log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                    throw new Failure(e);
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(DS).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
    bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }).to(new TypeLiteral<Database<ReviewDb>>() {
    });
    bind(new TypeLiteral<Database<ReviewDb>>() {
    }).toProvider(ReviewDbProvider.class).in(SINGLETON);
    bind(SystemConfig.class).toProvider(SystemConfigProvider.class).in(SINGLETON);
    bind(File.class).annotatedWith(SitePath.class).toProvider(SitePathProvider.class);
    bind(Config.class).annotatedWith(GerritServerConfig.class).toProvider(GerritServerConfigProvider.class).in(SINGLETON);
    bind(GerritServer.class);
    bind(ContactStore.class).toProvider(EncryptedContactStoreProvider.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(RegisterNewEmailSender.Factory.class).toProvider(FactoryProvider.newFactory(RegisterNewEmailSender.Factory.class, RegisterNewEmailSender.class));
    bind(AddReviewerSender.Factory.class).toProvider(FactoryProvider.newFactory(AddReviewerSender.Factory.class, AddReviewerSender.class));
    bind(CreateChangeSender.Factory.class).toProvider(FactoryProvider.newFactory(CreateChangeSender.Factory.class, CreateChangeSender.class));
    bind(AbandonedSender.Factory.class).toProvider(FactoryProvider.newFactory(AbandonedSender.Factory.class, AbandonedSender.class));
    bind(CommentSender.Factory.class).toProvider(FactoryProvider.newFactory(CommentSender.Factory.class, CommentSender.class));
}
#method_after
@Override
protected void configure() {
    bind(DS).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
    bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }).to(new TypeLiteral<Database<ReviewDb>>() {
    });
    bind(new TypeLiteral<Database<ReviewDb>>() {
    }).toProvider(ReviewDbProvider.class).in(SINGLETON);
    bind(SystemConfig.class).toProvider(SystemConfigProvider.class).in(SINGLETON);
    bind(File.class).annotatedWith(SitePath.class).toProvider(SitePathProvider.class);
    bind(Config.class).annotatedWith(GerritServerConfig.class).toProvider(GerritServerConfigProvider.class).in(SINGLETON);
    bind(AuthConfig.class);
    bind(CacheManager.class).toProvider(CacheManagerProvider.class).in(SINGLETON);
    bind(SshKeyCache.class);
    bind(DiffCache.class);
    bind(GerritServer.class);
    bind(ContactStore.class).toProvider(EncryptedContactStoreProvider.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(AddReviewerSender.Factory.class).toProvider(FactoryProvider.newFactory(AddReviewerSender.Factory.class, AddReviewerSender.class));
    bind(CreateChangeSender.Factory.class).toProvider(FactoryProvider.newFactory(CreateChangeSender.Factory.class, CreateChangeSender.class));
    bind(AbandonedSender.Factory.class).toProvider(FactoryProvider.newFactory(AbandonedSender.Factory.class, AbandonedSender.class));
    bind(CommentSender.Factory.class).toProvider(FactoryProvider.newFactory(CommentSender.Factory.class, CommentSender.class));
}
#end_block

#method_before
public void patchScript(final Patch.Key patchKey, final PatchSet.Id psa, final PatchSet.Id psb, final PatchScriptSettings s, final AsyncCallback<PatchScript> callback) {
    if (psb == null) {
        callback.onFailure(new NoSuchEntityException());
        return;
    }
    run(callback, new PatchScriptAction(server, registry, patchKey, psa, psb, s));
}
#method_after
public void patchScript(final Patch.Key patchKey, final PatchSet.Id psa, final PatchSet.Id psb, final PatchScriptSettings s, final AsyncCallback<PatchScript> callback) {
    if (psb == null) {
        callback.onFailure(new NoSuchEntityException());
        return;
    }
    run(callback, new PatchScriptAction(server, registry, diffCache, patchKey, psa, psb, s));
}
#end_block

#method_before
public void registerEmail(final String address, final AsyncCallback<VoidResult> cb) {
    final PersonIdent gi = server.newGerritPersonIdent();
    final HttpServletRequest req = GerritJsonServlet.getCurrentCall().getHttpServletRequest();
    try {
        final RegisterNewEmailSender sender;
        sender = this.emailSenderFactory.create(address);
        sender.send();
        cb.onSuccess(VoidResult.INSTANCE);
    } catch (EmailException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    } catch (RuntimeException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    }
}
#method_after
public void registerEmail(final String address, final AsyncCallback<VoidResult> cb) {
    final PersonIdent gi = server.newGerritPersonIdent();
    final HttpServletRequest req = GerritJsonServlet.getCurrentCall().getHttpServletRequest();
    try {
        final RegisterNewEmailSender sender;
        sender = registerNewEmailFactory.create(address);
        sender.send();
        cb.onSuccess(VoidResult.INSTANCE);
    } catch (EmailException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    } catch (RuntimeException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    }
}
#end_block

#method_before
private void createContext(final Grid parent, final int row, final int col) {
    parent.resizeRows(row + 1);
    // Show full files
    final CheckBox cb = new CheckBox(PatchUtil.C.showFullFiles());
    cb.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (event.getValue()) {
                // Show a diff of the full files
                scriptSettings.setContext(WHOLE_FILE_CONTEXT);
            } else {
                // Restore the context lines to the user's preference
                initContextLines();
            }
            refresh(false);
        }
    });
    parent.setWidget(row, col + 1, cb);
    // Keep unreviewed
    if (Gerrit.isSignedIn()) {
        final CheckBox ku = new CheckBox(PatchUtil.C.keepUnreviewed());
        ku.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

            @Override
            public void onValueChange(ValueChangeEvent<Boolean> event) {
                updateReviewedStatus(event.getValue() ? 0 : 1);
            }
        });
        parent.setWidget(row, col + 2, ku);
    }
}
#method_after
private void createContext(final Grid parent, final int row, final int col) {
    parent.resizeRows(row + 1);
    // Show full files
    final CheckBox cb = new CheckBox(PatchUtil.C.showFullFiles());
    cb.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (event.getValue()) {
                // Show a diff of the full files
                scriptSettings.setContext(WHOLE_FILE_CONTEXT);
            } else {
                // Restore the context lines to the user's preference
                initContextLines();
            }
            refresh(false);
        }
    });
    parent.setWidget(row, col + 1, cb);
    // "Reviewed" check box
    if (Gerrit.isSignedIn()) {
        final CheckBox ku = new CheckBox(PatchUtil.C.reviewed());
        ku.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

            @Override
            public void onValueChange(ValueChangeEvent<Boolean> event) {
                setReviewedByCurrentUser(event.getValue());
            }
        });
        // Checked by default
        ku.setValue(true);
        parent.setWidget(row, col + 2, ku);
    }
}
#end_block

#method_before
private Widget createNextPrevLinks() {
    final Grid table = new Grid(1, 3);
    final CellFormatter fmt = table.getCellFormatter();
    table.setStyleName("gerrit-SideBySideScreen-LinkTable");
    fmt.setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    fmt.setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_CENTER);
    fmt.setHorizontalAlignment(0, 2, HasHorizontalAlignment.ALIGN_RIGHT);
    // Next and previous
    if (fileList != null) {
        previousFileLink = fileList.getPreviousPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 0, previousFileLink);
        nextFileLink = fileList.getNextPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 2, nextFileLink);
    }
    // Keep unreviewed
    // Up
    final ChangeLink up = new ChangeLink("", patchKey.getParentKey().getParentKey());
    SafeHtml.set(up, SafeHtml.asis(Util.C.upToChangeIconLink()));
    table.setWidget(0, 1, up);
    return table;
}
#method_after
private Widget createNextPrevLinks() {
    final Grid table = new Grid(1, 3);
    final CellFormatter fmt = table.getCellFormatter();
    table.setStyleName("gerrit-SideBySideScreen-LinkTable");
    fmt.setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    fmt.setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_CENTER);
    fmt.setHorizontalAlignment(0, 2, HasHorizontalAlignment.ALIGN_RIGHT);
    if (fileList != null) {
        previousFileLink = fileList.getPreviousPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 0, previousFileLink);
        nextFileLink = fileList.getNextPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 2, nextFileLink);
    }
    final ChangeLink up = new ChangeLink("", patchKey.getParentKey().getParentKey());
    SafeHtml.set(up, SafeHtml.asis(Util.C.upToChangeIconLink()));
    table.setWidget(0, 1, up);
    return table;
}
#end_block

#method_before
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    // Mark this file reviewed
    if (Gerrit.isSignedIn()) {
        updateReviewedStatus(1);
    }
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                if (isNoDifferences(caught) && !isFirst) {
                    historyTable.enableAll(true);
                    showPatch(false);
                } else {
                    super.onFailure(caught);
                }
            }
        }

        private boolean isNoDifferences(final Throwable caught) {
            if (caught instanceof NoDifferencesException) {
                return true;
            }
            return caught instanceof RemoteJsonException && caught.getMessage().equals(NoDifferencesException.MESSAGE);
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#method_after
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        setReviewedByCurrentUser(true);
    }
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        if (contentTable instanceof SideBySideTable && script.getEdits().isEmpty() && !script.getPatchHeader().isEmpty()) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        // True if there are differences between the two patch sets
        boolean hasEdits = !script.getEdits().isEmpty();
        // True if this change is a mode change or a pure rename/copy
        boolean hasMeta = !script.getPatchHeader().isEmpty();
        boolean hasDifferences = hasEdits || hasMeta;
        boolean pureMetaChange = !hasEdits && hasMeta;
        if (contentTable instanceof SideBySideTable && pureMetaChange) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        if (hasDifferences) {
            contentTable.display(patchKey, idSideA, idSideB, script);
            contentTable.display(comments);
            contentTable.finishDisplay();
        }
        showPatch(hasDifferences);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
public void saveDraft(final PatchLineComment comment, final AsyncCallback<PatchLineComment> callback) {
    run(callback, new Action<PatchLineComment>() {

        public PatchLineComment run(ReviewDb db) throws OrmException, Failure {
            if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                throw new Failure(new IllegalStateException("Comment published"));
            }
            final Patch patch = db.patches().get(comment.getKey().getParentKey());
            final Change change;
            if (patch == null) {
                throw new Failure(new NoSuchEntityException());
            }
            change = db.changes().get(patch.getKey().getParentKey().getParentKey());
            assertCanRead(change);
            final Account.Id me = Common.getAccountId();
            if (comment.getKey().get() == null) {
                final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patch.getKey(), ChangeUtil.messageUUID(db)), comment.getLine(), me);
                nc.setSide(comment.getSide());
                nc.setMessage(comment.getMessage());
                db.patchComments().insert(Collections.singleton(nc));
                return nc;
            } else {
                if (!me.equals(comment.getAuthor())) {
                    throw new Failure(new NoSuchEntityException());
                }
                comment.updated();
                db.patchComments().update(Collections.singleton(comment));
                return comment;
            }
        }
    });
}
#method_after
public void saveDraft(final PatchLineComment comment, final AsyncCallback<PatchLineComment> callback) {
    run(callback, new Action<PatchLineComment>() {

        public PatchLineComment run(ReviewDb db) throws OrmException, Failure {
            if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                throw new Failure(new IllegalStateException("Comment published"));
            }
            final Patch patch = db.patches().get(comment.getKey().getParentKey());
            final Change change;
            if (patch == null) {
                throw new Failure(new NoSuchEntityException());
            }
            change = db.changes().get(patch.getKey().getParentKey().getParentKey());
            assertCanRead(change);
            final Account.Id me = Common.getAccountId();
            if (comment.getKey().get() == null) {
                final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patch.getKey(), ChangeUtil.messageUUID(db)), comment.getLine(), me, comment.getParentUuid());
                nc.setSide(comment.getSide());
                nc.setMessage(comment.getMessage());
                db.patchComments().insert(Collections.singleton(nc));
                return nc;
            } else {
                if (!me.equals(comment.getAuthor())) {
                    throw new Failure(new NoSuchEntityException());
                }
                comment.updated();
                db.patchComments().update(Collections.singleton(comment));
                return comment;
            }
        }
    });
}
#end_block

#method_before
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(S_ICON_CELL);
    m.addStyleName("LeftMostCell");
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName("ChangeTypeCell");
    m.append(p.getChangeType().getCode());
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("FilePathCell");
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("CommentCell");
    appendCommentCount(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(S_DATA_CELL);
        if (Gerrit.isSignedIn() && p.hasBeenReviewedBy(Gerrit.getUserAccount().getSshUserName())) {
            m.append(SafeHtml.asis(Gerrit.ICONS.greenCheck().getHTML()));
        } else {
            m.nbsp();
        }
        m.closeTd();
    }
    m.closeTr();
}
#method_after
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(S_ICON_CELL);
    m.addStyleName("LeftMostCell");
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName("ChangeTypeCell");
    m.append(p.getChangeType().getCode());
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("FilePathCell");
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("CommentCell");
    appendCommentCount(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    // Green check mark if the user is logged in and they reviewed that file
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(S_DATA_CELL);
        if (p.isReviewedByCurrentUser()) {
            m.append(SafeHtml.asis(Gerrit.ICONS.greenCheck().getHTML()));
        } else {
            m.nbsp();
        }
        m.closeTd();
    }
    m.closeTr();
}
#end_block

#method_before
@Override
protected void render(final PatchScript script) {
    final SparseFileContent a = script.getA();
    final SparseFileContent b = script.getB();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    if (directUrlLeft != null || directUrlRight != null) {
        // The left url can be null if a file is being added and the right url can be null if a
        // file is being deleted. They will both be non-null if this change is modifying an existing
        // file.
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("halign", "center");
        nc.openTd();
        maybeAppendImgTag(nc, directUrlLeft);
        nc.closeTd();
        nc.openTd();
        maybeAppendImgTag(nc, directUrlRight);
        nc.closeTd();
        nc.closeTr();
    } else {
        // result
        for (final String line : script.getPatchHeader()) {
            appendFileHeader(nc, line);
        }
    }
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final PatchScript.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.hasNextLine()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && a.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && b.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            }
            hunk.next();
        }
    }
    resetHtml(nc);
    onlyOneHunk = script.getEdits().size() == 1;
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n = "DiffText-" + l.getType().name();
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#method_after
@Override
protected void render(final PatchScript script) {
    final SparseFileContent a = script.getA();
    final SparseFileContent b = script.getB();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            } else {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final PatchScript.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.hasNextLine()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && a.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && b.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            }
            hunk.next();
        }
    }
    resetHtml(nc);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n = "DiffText-" + l.getType().name();
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, final PatchLine.Type type, final SparseFileContent src, final int i) {
    final int len = PatchUtil.DEFAULT_LINE_LENGTH;
    final String text = src.get(i);
    m.openTd();
    m.addStyleName("DiffText");
    m.addStyleName("DiffText-" + type.name());
    switch(type) {
        case CONTEXT:
            if ("".equals(text)) {
                m.nbsp();
            } else {
                m.append(" ");
                m.append(PatchUtil.lineToSafeHtml(text, len, false));
            }
            break;
        case DELETE:
            m.append("-");
            m.append(PatchUtil.lineToSafeHtml(text, len, false));
            break;
        case INSERT:
            m.append("+");
            m.append(PatchUtil.lineToSafeHtml(text, len, true));
            break;
    }
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, final PatchLine.Type type, final SparseFileContent src, final int i) {
    final int len = PatchUtil.DEFAULT_LINE_LENGTH;
    final String text = src.get(i);
    m.openTd();
    m.addStyleName("DiffText");
    m.addStyleName("DiffText-" + type.name());
    switch(type) {
        case CONTEXT:
            m.nbsp();
            break;
        case DELETE:
            m.append("-");
            break;
        case INSERT:
            m.append("+");
            break;
    }
    m.append(PatchUtil.lineToSafeHtml(text, len, false));
    m.closeTd();
}
#end_block

#method_before
private void openLine(final SafeHtmlBuilder m) {
    m.openTr();
    m.setAttribute("valign", "top");
    m.openTd();
    m.setStyleName(S_ICON_CELL);
    m.nbsp();
    m.closeTd();
}
#method_after
private void openLine(final SafeHtmlBuilder m) {
    m.openTr();
    m.setAttribute("valign", "top");
    m.openTd();
    m.setStyleName(S_ICON_CELL);
    m.closeTd();
}
#end_block

#method_before
private void padLineNumber(final SafeHtmlBuilder m) {
    m.openTd();
    m.setStyleName("LineNumber");
    m.nbsp();
    m.closeTd();
}
#method_after
private void padLineNumber(final SafeHtmlBuilder m) {
    m.openTd();
    m.setStyleName("LineNumber");
    m.closeTd();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either side,
    // expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null);
    add(historyPanel);
    initDisplayControls();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
    // This must be done after calling createNextPrevLinks(), which initializes these fields
    if (previousFileLink != null) {
        installLinkShortCut(previousFileLink, SHORTCUT_PREVIOUS_FILE, PatchUtil.C.previousFileHelp());
    }
    if (nextFileLink != null) {
        installLinkShortCut(nextFileLink, SHORTCUT_NEXT_FILE, PatchUtil.C.nextFileHelp());
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either side,
    // expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null);
    add(historyPanel);
    initDisplayControls();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
    // This must be done after calling createNextPrevLinks(), which initializes these fields
    if (previousFileLink != null) {
        installLinkShortCut(previousFileLink, SHORTCUT_PREVIOUS_FILE, PatchUtil.C.previousFileHelp());
    }
    if (nextFileLink != null) {
        installLinkShortCut(nextFileLink, SHORTCUT_NEXT_FILE, PatchUtil.C.nextFileHelp());
    }
}
#end_block

#method_before
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                if (caught instanceof RemoteJsonException && !isFirst) {
                    historyTable.enableAll(true);
                    showPatch(false);
                } else {
                    super.onFailure(caught);
                }
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#method_after
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        if (contentTable instanceof SideBySideTable && script.getEdits().isEmpty() && !script.getPatchHeader().isEmpty()) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        // True if there are differences between the two patch sets
        boolean hasEdits = !script.getEdits().isEmpty();
        // True if this change is a mode change or a pure rename/copy
        boolean hasMeta = !script.getPatchHeader().isEmpty();
        boolean hasDifferences = hasEdits || hasMeta;
        boolean pureMetaChange = !hasEdits && hasMeta;
        if (contentTable instanceof SideBySideTable && pureMetaChange) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        if (hasDifferences) {
            contentTable.display(patchKey, idSideA, idSideB, script);
            contentTable.display(comments);
            contentTable.finishDisplay();
        }
        showPatch(hasDifferences);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either side,
    // expand the history panel
    historyPanel.setOpen(Cookies.getCookie(COOKIE_SIDE_A) != null || Cookies.getCookie(COOKIE_SIDE_A) != null);
    add(historyPanel);
    initDisplayControls();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either side,
    // expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null);
    add(historyPanel);
    initDisplayControls();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
}
#end_block

#method_before
public void setSideA(PatchSet.Id patchSetId) {
    idSideA = patchSetId;
    updateCookie(COOKIE_SIDE_A, patchSetId);
}
#method_after
public void setSideA(PatchSet.Id patchSetId) {
    idSideA = patchSetId;
    diffSideA = patchSetId;
}
#end_block

#method_before
public void setSideB(PatchSet.Id patchSetId) {
    idSideB = patchSetId;
    updateCookie(COOKIE_SIDE_B, patchSetId);
}
#method_after
public void setSideB(PatchSet.Id patchSetId) {
    idSideB = patchSetId;
    diffSideB = patchSetId;
}
#end_block

#method_before
private ResultSet<Change> searchQuery(final ReviewDb db, String query, final int limit, final String key, final Comparator<Change> cmp) throws OrmException {
    final HashSet<Change.Id> want = new HashSet<Change.Id>();
    query = query.trim();
    if (query.matches("^[1-9][0-9]*$")) {
        want.add(Change.Id.parse(query));
    } else if (query.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(query);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet p : patches) {
            want.add(p.getId().getParentKey());
        }
    }
    if (want.isEmpty()) {
        return new ListResultSet<Change>(Collections.<Change>emptyList());
    }
    List<Change> result = new ArrayList<Change>();
    final ResultSet<Change> rs = db.changes().get(want);
    if (cmp == QUERY_PREV) {
        for (Change c : rs) {
            if (c.getSortKey().compareTo(key) > 0) {
                result.add(c);
            }
        }
    } else /* cmp == QUERY_NEXT */
    {
        for (Change c : rs) {
            if (c.getSortKey().compareTo(key) < 0) {
                result.add(c);
            }
        }
    }
    Collections.sort(result, cmp);
    if (limit < result.size()) {
        // GWT emulation unfortunately lacks subList(int,int).
        // 
        final List<Change> r = new ArrayList<Change>(limit);
        for (int i = 0; i < limit; i++) {
            r.add(result.get(i));
        }
        result = r;
    }
    return new ListResultSet<Change>(result);
}
#method_after
private ResultSet<Change> searchQuery(final ReviewDb db, String query, final int limit, final String key, final Comparator<Change> cmp) throws OrmException {
    List<Change> result = new ArrayList<Change>();
    final HashSet<Change.Id> want = new HashSet<Change.Id>();
    query = query.trim();
    if (query.matches("^[1-9][0-9]*$")) {
        want.add(Change.Id.parse(query));
    } else if (query.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(query);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet p : patches) {
            want.add(p.getId().getParentKey());
        }
    } else if (query.contains("owner:")) {
        String[] parsedQuery = query.split(":");
        if (parsedQuery.length > 1) {
            filterBySortKey(result, changesCreatedBy(db, parsedQuery[1]), cmp, key);
        }
    } else if (query.contains("reviewer:")) {
        String[] parsedQuery = query.split(":");
        if (parsedQuery.length > 1) {
            want.addAll(changesReviewedBy(db, parsedQuery[1]));
        }
    }
    if (result.isEmpty() && want.isEmpty()) {
        return new ListResultSet<Change>(Collections.<Change>emptyList());
    }
    filterBySortKey(result, db.changes().get(want), cmp, key);
    Collections.sort(result, cmp);
    if (limit < result.size()) {
        // GWT emulation unfortunately lacks subList(int,int).
        // 
        final List<Change> r = new ArrayList<Change>(limit);
        for (int i = 0; i < limit; i++) {
            r.add(result.get(i));
        }
        result = r;
    }
    return new ListResultSet<Change>(result);
}
#end_block

#method_before
public void changesCreatedBy(final String userName, final AsyncCallback<SingleListChangeInfo> callback) {
    run(callback, new UserNameAction(userName) {

        @Override
        void process(ReviewDb db, AccountInfoCacheFactory ac, Account account, Map<Id, Change> resultChanges) throws OrmException {
            final Set<Change> changes = createdBy(db, account.getId());
            ac.want(account.getId());
            for (Change change : changes) {
                resultChanges.put(change.getId(), change);
            }
        }
    });
}
#method_after
private List<Change> changesCreatedBy(final ReviewDb db, final String userName) throws OrmException {
    final List<Change> resultChanges = new ArrayList<Change>();
    for (Account.Id account : getAccountSources(db, userName)) {
        for (Change change : db.changes().byOwnerOpen(account)) {
            resultChanges.add(change);
        }
        for (Change change : db.changes().byOwnerClosedAll(account)) {
            resultChanges.add(change);
        }
    }
    return resultChanges;
}
#end_block

#method_before
// 
// UserNameAction
// ///
public void changesReviewedBy(final String userName, final AsyncCallback<SingleListChangeInfo> callback) {
    run(callback, new UserNameAction(userName) {

        @Override
        void process(ReviewDb db, AccountInfoCacheFactory ac, Account account, Map<Id, Change> outResultChanges) throws OrmException {
            ChangeApprovalAccess changes = db.changeApprovals();
            ChangeAccess changeAccess = db.changes();
            Iterator<ChangeApproval> changeIterator = changes.reviewedByUser(account.getId()).iterator();
            while (changeIterator.hasNext()) {
                ChangeApproval approval = changeIterator.next();
                Change change = changeAccess.get(approval.getChangeId());
                // This will return null if the change was submitted
                if (change != null) {
                    outResultChanges.put(change.getId(), change);
                }
            }
        }
    });
}
#method_after
private Set<Change.Id> changesReviewedBy(final ReviewDb db, final String userName) throws OrmException {
    final Set<Change.Id> resultChanges = new HashSet<Change.Id>();
    for (Account.Id account : getAccountSources(db, userName)) {
        for (ChangeApproval a : db.changeApprovals().openByUser(account)) {
            resultChanges.add(a.getChangeId());
        }
        for (ChangeApproval a : db.changeApprovals().closedByUserAll(account)) {
            resultChanges.add(a.getChangeId());
        }
    }
    return resultChanges;
}
#end_block

#method_before
public void display(final PatchSet.Id id, final List<Patch> list) {
    psid = id;
    myTable = null;
    final DisplayCommand cmd = new DisplayCommand(list);
    if (cmd.execute()) {
        cmd.initMeter();
        DeferredCommand.addCommand(cmd);
    } else {
        cmd.showTable();
    }
}
#method_after
public void display(final PatchSet.Id id, final List<Patch> list) {
    psid = id;
    myTable = null;
    patchList = list;
    final DisplayCommand cmd = new DisplayCommand(list);
    if (cmd.execute()) {
        cmd.initMeter();
        DeferredCommand.addCommand(cmd);
    } else {
        cmd.showTable();
    }
}
#end_block

#method_before
void initializeRow(List<Patch> patches, int row) {
    Patch patch = patches.get(row - 1);
    PatchSetKeys psk = new PatchSetKeys(patchesToKeys(patches), row - 1, PatchTable.this.psid.getParentKey());
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(patch.getFileName(), psk);
    } else {
        nameCol = new PatchLink.Unified(patch.getFileName(), psk);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName("SourceFilePath");
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), psk));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), psk));
}
#method_after
void initializeRow(int row) {
    Patch patch = PatchTable.this.patchList.get(row - 1);
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(patch.getFileName(), patch.getKey(), row - 1, PatchTable.this);
    } else {
        nameCol = new PatchLink.Unified(patch.getFileName(), patch.getKey(), row - 1, PatchTable.this);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName("SourceFilePath");
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), patch.getKey(), row - 1, PatchTable.this));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), patch.getKey(), row - 1, PatchTable.this));
}
#end_block

#method_before
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
            }
            while (row < list.size()) {
                table.appendRow(nc, list.get(row));
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(list, row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#method_after
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
            }
            while (row < list.size()) {
                table.appendRow(nc, list.get(row));
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    add(historyPanel);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    fileList = null;
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    fp.add(noDifference);
    fp.add(contentTable);
    add(fp);
    // Links to the next/previous file
    FlexTable dp = new FlexTable();
    dp.setStyleName("gerrit-SideBySideScreen-LinkTable");
    dp.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    dp.getFlexCellFormatter().setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_RIGHT);
    if (previousPatchLink != null)
        dp.setWidget(0, 0, previousPatchLink);
    if (nextPatchLink != null)
        dp.setWidget(0, 1, nextPatchLink);
    add(dp);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    add(historyPanel);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    fp.add(noDifference);
    fp.add(contentTable);
    add(fp);
    add(createNextPrevLinks());
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        display();
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
@Override
protected Screen createScreen() {
    return new PatchScreen.SideBySide(patch.getKey(), patch, parentPatchTable());
}
#method_after
@Override
protected Screen createScreen() {
    return new PatchScreen.SideBySide(patchKey, patchIndex, parentPatchTable);
}
#end_block

#method_before
@Override
protected Screen createScreen() {
    return new PatchScreen.Unified(patch.getKey(), patch, parentPatchTable());
}
#method_after
@Override
protected Screen createScreen() {
    return new PatchScreen.Unified(patchKey, patchIndex, parentPatchTable);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName("gerrit-PatchComments");
                draftsPanel.add(panel);
                panel.add(new PatchLink.SideBySide(fn, new PatchSetKeys(patchKey)));
                priorFile = fn;
            }
            Label m;
            m = new DoubleClickLinkLabel(patchKey);
            m.setText(Util.M.lineHeader(c.getLine()));
            m.setStyleName("gerrit-LineHeader");
            panel.add(m);
            m = new DoubleClickLinkLabel(patchKey);
            SafeHtml.set(m.getElement(), LineCommentPanel.toSafeHtml(c));
            m.setStyleName("gerrit-PatchLineComment");
            panel.add(m);
        }
    }
}
#method_after
private void display(final PatchSetPublishDetail r) {
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName("gerrit-PatchComments");
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any next/previous links
                panel.add(new PatchLink.SideBySide(fn, patchKey, 0, null));
                priorFile = fn;
            }
            Label m;
            m = new DoubleClickLinkLabel(patchKey);
            m.setText(Util.M.lineHeader(c.getLine()));
            m.setStyleName("gerrit-LineHeader");
            panel.add(m);
            m = new DoubleClickLinkLabel(patchKey);
            SafeHtml.set(m.getElement(), LineCommentPanel.toSafeHtml(c));
            m.setStyleName("gerrit-PatchLineComment");
            panel.add(m);
        }
    }
}
#end_block

#method_before
private Screen select(final String token) {
    String p;
    if (token == null) {
        return null;
    }
    if (SETTINGS.equals(token) || token.startsWith("settings,")) {
        if (SETTINGS_NEW_AGREEMENT.equals(token)) {
            return new NewAgreementScreen();
        }
        return new AccountSettings(token);
    }
    if (MINE.equals(token)) {
        return new AccountDashboardScreen(Common.getAccountId());
    }
    if (token.startsWith("mine,")) {
        if (MINE_STARRED.equals(token)) {
            return new MineStarredScreen();
        }
        if (MINE_DRAFTS.equals(token)) {
            return new MineDraftsScreen();
        }
    }
    if (token.startsWith("all,")) {
        p = "all,abandoned,";
        if (token.startsWith(p)) {
            return new AllAbandonedChangesScreen(skip(p, token));
        }
        p = "all,merged,";
        if (token.startsWith(p)) {
            return new AllMergedChangesScreen(skip(p, token));
        }
        p = "all,open,";
        if (token.startsWith(p)) {
            return new AllOpenChangesScreen(skip(p, token));
        }
    }
    if (token.startsWith("project,")) {
        p = "project,open,";
        if (token.startsWith(p)) {
            final String s = skip(p, token);
            final int c = s.indexOf(',');
            return new ByProjectOpenChangesScreen(Project.NameKey.parse(s.substring(0, c)), s.substring(c + 1));
        }
    }
    if (token.startsWith("patch,")) {
        p = "patch,sidebyside,";
        if (token.startsWith(p))
            return new PatchScreen.SideBySide(Patch.Key.parse(skip(p, token)), null, /* patch */
            null);
        p = "patch,unified,";
        if (token.startsWith(p))
            return new PatchScreen.Unified(Patch.Key.parse(skip(p, token)), null, /* patch */
            null);
    }
    p = "change,publish,";
    if (token.startsWith(p))
        return new PublishCommentScreen(PatchSet.Id.parse(skip(p, token)));
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    if (token.startsWith("admin,")) {
        p = "admin,group,";
        if (token.startsWith(p))
            return new AccountGroupScreen(AccountGroup.Id.parse(skip(p, token)));
        p = "admin,project,";
        if (token.startsWith(p)) {
            p = skip(p, token);
            final int c = p.indexOf(',');
            final String idstr = p.substring(0, c);
            return new ProjectAdminScreen(Project.Id.parse(idstr), token);
        }
        if (ADMIN_GROUPS.equals(token)) {
            return new GroupListScreen();
        }
        if (ADMIN_PROJECTS.equals(token)) {
            return new ProjectListScreen();
        }
    }
    p = "VE,";
    if (token.startsWith(p)) {
        return new ValidateEmailScreen(skip(p, token));
    }
    return null;
}
#method_after
private Screen select(final String token) {
    String p;
    if (token == null) {
        return null;
    }
    if (SETTINGS.equals(token) || token.startsWith("settings,")) {
        if (SETTINGS_NEW_AGREEMENT.equals(token)) {
            return new NewAgreementScreen();
        }
        return new AccountSettings(token);
    }
    if (MINE.equals(token)) {
        return new AccountDashboardScreen(Common.getAccountId());
    }
    if (token.startsWith("mine,")) {
        if (MINE_STARRED.equals(token)) {
            return new MineStarredScreen();
        }
        if (MINE_DRAFTS.equals(token)) {
            return new MineDraftsScreen();
        }
    }
    if (token.startsWith("all,")) {
        p = "all,abandoned,";
        if (token.startsWith(p)) {
            return new AllAbandonedChangesScreen(skip(p, token));
        }
        p = "all,merged,";
        if (token.startsWith(p)) {
            return new AllMergedChangesScreen(skip(p, token));
        }
        p = "all,open,";
        if (token.startsWith(p)) {
            return new AllOpenChangesScreen(skip(p, token));
        }
    }
    if (token.startsWith("project,")) {
        p = "project,open,";
        if (token.startsWith(p)) {
            final String s = skip(p, token);
            final int c = s.indexOf(',');
            return new ByProjectOpenChangesScreen(Project.NameKey.parse(s.substring(0, c)), s.substring(c + 1));
        }
    }
    if (token.startsWith("patch,")) {
        p = "patch,sidebyside,";
        if (token.startsWith(p))
            return new PatchScreen.SideBySide(Patch.Key.parse(skip(p, token)), 0, /* patchIndex */
            null);
        p = "patch,unified,";
        if (token.startsWith(p))
            return new PatchScreen.Unified(Patch.Key.parse(skip(p, token)), 0, /* patchIndex */
            null);
    }
    p = "change,publish,";
    if (token.startsWith(p))
        return new PublishCommentScreen(PatchSet.Id.parse(skip(p, token)));
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    if (token.startsWith("admin,")) {
        p = "admin,group,";
        if (token.startsWith(p))
            return new AccountGroupScreen(AccountGroup.Id.parse(skip(p, token)));
        p = "admin,project,";
        if (token.startsWith(p)) {
            p = skip(p, token);
            final int c = p.indexOf(',');
            final String idstr = p.substring(0, c);
            return new ProjectAdminScreen(Project.Id.parse(idstr), token);
        }
        if (ADMIN_GROUPS.equals(token)) {
            return new GroupListScreen();
        }
        if (ADMIN_PROJECTS.equals(token)) {
            return new ProjectListScreen();
        }
    }
    p = "VE,";
    if (token.startsWith(p)) {
        return new ValidateEmailScreen(skip(p, token));
    }
    return null;
}
#end_block

#method_before
public void setHttpServletRequest(final HttpServletRequest req) {
    final StringBuffer url = req.getRequestURL();
    final int rpc = url.indexOf("/rpc/");
    if (rpc >= 0) {
        // cut "rpc/..."
        url.setLength(rpc + 1);
    }
    if (url.length() == 0 || url.charAt(url.length() - 1) != '/') {
        url.append('/');
    }
    myUrl = url.toString();
}
#method_after
public void setHttpServletRequest(final HttpServletRequest req) {
    myUrl = GerritServer.serverUrl(req);
}
#end_block

#method_before
void create(TreeLogger logger, JArrayType targetType) throws UnableToCompleteException {
    // Set up variables
    this.targetType = targetType;
    this.componentType = targetType.getComponentType();
    if (componentType.isPrimitive() != null || SerializerCreator.isBoxedPrimitive(componentType)) {
        logger.log(TreeLogger.DEBUG, "No need to create array deserializer for primitive array " + targetType);
        return;
    }
    if (deserializerFor(targetType) != null)
        return;
    logger.log(TreeLogger.DEBUG, "Creating result deserializer for " + targetType.getSimpleSourceName());
    final SourceWriter srcWriter = getSourceWriter(logger, context);
    if (srcWriter == null)
        return;
    final String dsn = getDeserializerQualifiedName(targetType);
    generatedDeserializers.put(targetType.getQualifiedSourceName(), dsn);
    generateSingleton(srcWriter);
    generateInstanceMembers(srcWriter);
    generateFromResult(srcWriter);
    srcWriter.commit(logger);
}
#method_after
void create(TreeLogger logger, JArrayType targetType) throws UnableToCompleteException {
    this.targetType = targetType;
    this.componentType = targetType.getComponentType();
    if (componentType.isPrimitive() != null || SerializerCreator.isBoxedPrimitive(componentType)) {
        logger.log(TreeLogger.DEBUG, "No need to create array deserializer for primitive array " + targetType);
        return;
    }
    if (deserializerFor(targetType) != null) {
        return;
    }
    logger.log(TreeLogger.DEBUG, "Creating result deserializer for " + targetType.getSimpleSourceName());
    final SourceWriter srcWriter = getSourceWriter(logger, context);
    if (srcWriter == null) {
        return;
    }
    final String dsn = getDeserializerQualifiedName(targetType);
    generatedDeserializers.put(targetType.getQualifiedSourceName(), dsn);
    generateSingleton(srcWriter);
    generateInstanceMembers(srcWriter);
    generateFromResult(srcWriter);
    srcWriter.commit(logger);
}
#end_block

#method_before
private String getDeserializerPackageName(JArrayType targetType) {
    final String compSerializer = serializerCreator.serializerFor(targetType.getComponentType());
    if (compSerializer.startsWith(CUSTOM_SERIALIZER_PACKAGE))
        return CUSTOM_SERIALIZER_PACKAGE;
    else
        return ProxyCreator.synthesizeTopLevelClassName(targetType, DSER_SUFFIX)[0];
}
#method_after
private String getDeserializerPackageName(JArrayType targetType) {
    // Place array deserializer in same package as the component deserializer
    final String compSerializer = serializerCreator.serializerFor(targetType.getComponentType());
    final int end = compSerializer.lastIndexOf('.');
    return end >= 0 ? compSerializer.substring(0, end) : "";
}
#end_block

#method_before
private SourceWriter getSourceWriter(TreeLogger logger, GeneratorContext context) {
    String pkgName = getDeserializerPackageName(targetType);
    final String simpleName = getDeserializerSimpleName(targetType);
    final PrintWriter pw;
    final ClassSourceFileComposerFactory cf;
    pw = context.tryCreate(logger, pkgName, simpleName);
    if (pw == null)
        return null;
    cf = new ClassSourceFileComposerFactory(pkgName, simpleName);
    cf.addImport(JavaScriptObject.class.getCanonicalName());
    cf.addImport(ResultDeserializer.class.getCanonicalName());
    cf.setSuperclass(ArrayResultDeserializer.class.getCanonicalName());
    cf.addImplementedInterface(ResultDeserializer.class.getCanonicalName() + "<" + targetType.getQualifiedSourceName() + ">");
    return cf.createSourceWriter(context, pw);
}
#method_after
private SourceWriter getSourceWriter(TreeLogger logger, GeneratorContext context) {
    String pkgName = getDeserializerPackageName(targetType);
    final String simpleName = getDeserializerSimpleName(targetType);
    final PrintWriter pw;
    final ClassSourceFileComposerFactory cf;
    pw = context.tryCreate(logger, pkgName, simpleName);
    if (pw == null) {
        return null;
    }
    cf = new ClassSourceFileComposerFactory(pkgName, simpleName);
    cf.addImport(JavaScriptObject.class.getCanonicalName());
    cf.addImport(ResultDeserializer.class.getCanonicalName());
    cf.setSuperclass(ArrayResultDeserializer.class.getCanonicalName());
    cf.addImplementedInterface(ResultDeserializer.class.getCanonicalName() + "<" + targetType.getQualifiedSourceName() + ">");
    return cf.createSourceWriter(context, pw);
}
#end_block

#method_before
public void generateDeserializerReference(JType targetType, SourceWriter w) {
    if (SerializerCreator.isBoxedPrimitive(targetType)) {
        w.print(PrimitiveResultDeserializers.class.getCanonicalName());
        w.print(".");
        w.print(targetType.getSimpleSourceName().toUpperCase());
        w.print("_INSTANCE");
    } else if (targetType.isArray() != null) {
        w.print(deserializerFor(targetType.isArray()));
    } else {
        // Predefined deserialisers
        // final String name =
        // arrayDeserializers.get(targetType.getQualifiedSourceName());
        // if (name != null) // Special deserializer
        // w.print(name + ".INSTANCE");
        // else
        // All others can be deserialized by the standard generated serializers
        serializerCreator.generateSerializerReference(targetType, w);
    }
}
#method_after
public void generateDeserializerReference(JType targetType, SourceWriter w) {
    if (SerializerCreator.isBoxedPrimitive(targetType)) {
        w.print(PrimitiveResultDeserializers.class.getCanonicalName());
        w.print(".");
        w.print(targetType.getSimpleSourceName().toUpperCase());
        w.print("_INSTANCE");
    } else if (targetType.isArray() != null) {
        w.print(deserializerFor(targetType.isArray()));
    } else {
        serializerCreator.generateSerializerReference(targetType, w);
    }
}
#end_block

#method_before
public void sendMergeFailed(String reason) throws MessagingException {
    if (begin("comment")) {
        body.append("Change ");
        body.append(change.getChangeId());
        if (patchSetInfo != null && patchSetInfo.getAuthor() != null && patchSetInfo.getAuthor().getName() != null) {
            body.append(" by ");
            body.append(patchSetInfo.getAuthor().getName());
        }
        body.append(" FAILED to submit to ");
        body.append(change.getDest().getShortName());
        if (reason != null) {
            body.append(" due to ");
            body.append(reason);
        }
        body.append(".\n\n");
        if (changeUrl() != null) {
            openFooter();
            body.append("To view visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        submittedTo();
        starredTo();
        send();
    }
}
#method_after
public void sendMergeFailed() throws MessagingException {
    if (begin("comment")) {
        body.append("Change ");
        body.append(change.getChangeId());
        if (patchSetInfo != null && patchSetInfo.getAuthor() != null && patchSetInfo.getAuthor().getName() != null) {
            body.append(" by ");
            body.append(patchSetInfo.getAuthor().getName());
        }
        body.append(" FAILED to submit to ");
        body.append(change.getDest().getShortName());
        body.append(".\n\n");
        if (message != null) {
            body.append("Error message:\n");
            body.append("....................................................\n");
            body.append(message.getMessage().trim());
            if (body.length() > 0) {
                body.append("\n\n");
            }
        }
        if (changeUrl() != null) {
            openFooter();
            body.append("To view visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        submittedTo();
        starredTo();
        send();
    }
}
#end_block

#method_before
private void initSubject() throws MessagingException {
    final StringBuilder subj = new StringBuilder();
    subj.append("Change ");
    subj.append(change.getChangeId());
    subj.append(": (");
    subj.append(projectName);
    subj.append(") ");
    if (change.getSubject().length() > 60) {
        subj.append(change.getSubject().substring(0, 60));
        subj.append("...");
    } else {
        subj.append(change.getSubject());
    }
    msg.setSubject(subj.toString());
}
#method_after
private void initSubject() throws MessagingException {
    final StringBuilder subj = new StringBuilder();
    subj.append("[");
    subj.append(change.getDest().getShortName());
    subj.append("] ");
    subj.append("Change ");
    subj.append(change.getChangeId());
    subj.append(": (");
    subj.append(projectName);
    subj.append(") ");
    if (change.getSubject().length() > 60) {
        subj.append(change.getSubject().substring(0, 60));
        subj.append("...");
    } else {
        subj.append(change.getSubject());
    }
    msg.setSubject(subj.toString());
}
#end_block

#method_before
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CommitMergeStatus s = status.get(c.getId());
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    break;
                }
            case CLEAN_PICK:
                {
                    final CodeReviewCommit commit = newCommits.get(c.getId());
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    try {
                        final String txt = "Change could not be merged because of a missing dependency.  As soon as its dependencies are submitted, the change will be submitted.";
                        final List<ChangeMessage> msgList = schema.changeMessages().byChange(c.getId()).toList();
                        if (msgList.size() > 0) {
                            final ChangeMessage last = msgList.get(msgList.size() - 1);
                            if (last.getAuthor() == null && txt.equals(last.getMessage())) {
                                // 
                                break;
                            }
                        }
                        schema.changeMessages().insert(Collections.singleton(message(c, txt)));
                    } catch (OrmException e) {
                    }
                    try {
                        final ChangeMail cm = new ChangeMail(server, c);
                        cm.setFrom(getSubmitter(c));
                        cm.setReviewDb(schema);
                        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()), schema.patchSetInfo().get(c.currentPatchSetId()));
                        cm.sendMergeFailed("missing dependency");
                    } catch (OrmException e) {
                        log.error("Cannot send email for submitted patch set " + c.getId(), e);
                    } catch (MessagingException e) {
                        log.error("Cannot send email for submitted patch set " + c.getId(), e);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#method_after
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CommitMergeStatus s = status.get(c.getId());
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    break;
                }
            case CLEAN_PICK:
                {
                    final CodeReviewCommit commit = newCommits.get(c.getId());
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    ChangeMessage msg = null;
                    try {
                        final String txt = "Change could not be merged because of a missing dependency. As soon as its dependencies are submitted, the change will be submitted.";
                        final List<ChangeMessage> msgList = schema.changeMessages().byChange(c.getId()).toList();
                        if (msgList.size() > 0) {
                            final ChangeMessage last = msgList.get(msgList.size() - 1);
                            if (last.getAuthor() == null && txt.equals(last.getMessage())) {
                                // 
                                break;
                            }
                        }
                        msg = message(c, txt);
                        schema.changeMessages().insert(Collections.singleton(msg));
                    } catch (OrmException e) {
                    }
                    try {
                        final ChangeMail cm = new ChangeMail(server, c);
                        cm.setFrom(getSubmitter(c));
                        cm.setReviewDb(schema);
                        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()), schema.patchSetInfo().get(c.currentPatchSetId()));
                        cm.setChangeMessage(msg);
                        cm.sendMergeFailed();
                    } catch (OrmException e) {
                        log.error("Cannot submit patch set for Change " + c.getId() + " due to a missing dependency.", e);
                    } catch (MessagingException e) {
                        log.error("Cannot submit patch set for Change " + c.getId() + " due to a missing dependency.", e);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#end_block

#method_before
private Account.Id getSubmitter(Change c) {
    ChangeApproval submitter = null;
    try {
        final List<ChangeApproval> approvals = schema.changeApprovals().byChange(c.getId()).toList();
        final FunctionState fs = new FunctionState(c, approvals);
        for (ChangeApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
        }
    } catch (OrmException e) {
    }
    return submitter != null ? submitter.getAccountId() : null;
}
#method_after
private Account.Id getSubmitter(Change c) {
    ChangeApproval submitter = null;
    try {
        final List<ChangeApproval> approvals = schema.changeApprovals().byChange(c.getId()).toList();
        for (ChangeApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
        }
    } catch (OrmException e) {
    }
    return submitter != null ? submitter.getAccountId() : null;
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    for (int attempts = 0; attempts < 10; attempts++) {
        c.setStatus(Change.Status.NEW);
        ChangeUtil.updated(c);
        try {
            final Transaction txn = schema.beginTransaction();
            schema.changes().update(Collections.singleton(c), txn);
            if (msg != null) {
                schema.changeMessages().insert(Collections.singleton(msg), txn);
            }
            txn.commit();
            break;
        } catch (OrmException e) {
            try {
                c = schema.changes().get(c.getId());
                if (c.getStatus().isClosed()) {
                    // 
                    break;
                }
            } catch (OrmException e2) {
            }
        }
    }
    try {
        final ChangeMail cm = new ChangeMail(server, c);
        // I don't know how to know who clicked the submit button
        cm.setFrom(getSubmitter(c));
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()), schema.patchSetInfo().get(c.currentPatchSetId()));
        if (msg.getMessage().indexOf("path conflict") == -1) {
            cm.sendMergeFailed(null);
        } else {
            cm.sendMergeFailed("path conflict");
        }
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (MessagingException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    for (int attempts = 0; attempts < 10; attempts++) {
        c.setStatus(Change.Status.NEW);
        ChangeUtil.updated(c);
        try {
            final Transaction txn = schema.beginTransaction();
            schema.changes().update(Collections.singleton(c), txn);
            if (msg != null) {
                schema.changeMessages().insert(Collections.singleton(msg), txn);
            }
            txn.commit();
            break;
        } catch (OrmException e) {
            try {
                c = schema.changes().get(c.getId());
                if (c.getStatus().isClosed()) {
                    // 
                    break;
                }
            } catch (OrmException e2) {
            }
        }
    }
    try {
        final ChangeMail cm = new ChangeMail(server, c);
        cm.setFrom(getSubmitter(c));
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()), schema.patchSetInfo().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.sendMergeFailed();
    } catch (OrmException e) {
        log.error("Cannot submit patch set for Change " + c.getId() + " due to a path conflict.", e);
    } catch (MessagingException e) {
        log.error("Cannot submit patch set for Change " + c.getId() + " due to a path conflict.", e);
    }
}
#end_block

#method_before
private void populateAbandonAction() {
    final Button b = new Button(Util.C.buttonAbandonChangeBegin());
    b.addClickListener(new ClickListener() {

        public void onClick(Widget sender) {
            b.setEnabled(false);
            new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<Object>() {

                public void onSuccess(Object result) {
                    actionsPanel.remove(b);
                    fireOnSuggestRefresh();
                }

                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                }
            }).center();
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateAbandonAction() {
    final Button b = new Button(Util.C.buttonAbandonChangeBegin());
    b.addClickListener(new ClickListener() {

        public void onClick(Widget sender) {
            new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<Object>() {

                public void onSuccess(Object result) {
                    actionsPanel.remove(b);
                    fireOnSuggestRefresh();
                }

                public void onFailure(Throwable caught) {
                }
            }).center();
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
public void changeDetail(final Change.Id id, final AsyncCallback<ChangeDetail> callback) {
    run(callback, new Action<ChangeDetail>() {

        public ChangeDetail run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(id);
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final Project proj = db.projects().get(change.getDest().getParentKey());
            if (change == null || patch == null || proj == null) {
                throw new Failure(new NoSuchEntityException());
            }
            assertCanRead(change);
            final boolean anon;
            boolean canAbandon = false;
            if (me == null) {
                // Safe assumption, this wouldn't be allowed if it wasn't.
                // 
                anon = true;
            } else {
                // Ask if the anonymous user can read this project; even if
                // we can that doesn't mean the anonymous user could.
                // 
                anon = canRead(null, change.getDest().getParentKey());
                // The change owner, current patchset uploader, Gerrit administrator,
                // and project administrator can mark the change as abandoned.
                // 
                canAbandon = me.equals(change.getOwner()) || me.equals(patch.getUploader()) || Common.getGroupCache().isAdministrator(me) || Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId());
            }
            final ChangeDetail d = new ChangeDetail();
            d.load(db, new AccountInfoCacheFactory(db), change, anon, canAbandon);
            return d;
        }
    });
}
#method_after
public void changeDetail(final Change.Id id, final AsyncCallback<ChangeDetail> callback) {
    run(callback, new Action<ChangeDetail>() {

        public ChangeDetail run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(id);
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            assertCanRead(change);
            final boolean anon;
            boolean canAbandon = false;
            if (me == null) {
                // Safe assumption, this wouldn't be allowed if it wasn't.
                // 
                anon = true;
            } else {
                // Ask if the anonymous user can read this project; even if
                // we can that doesn't mean the anonymous user could.
                // 
                anon = canRead(null, change.getDest().getParentKey());
                // The change owner, current patchset uploader, Gerrit administrator,
                // and project administrator can mark the change as abandoned.
                // 
                canAbandon = me.equals(change.getOwner()) || me.equals(patch.getUploader()) || Common.getGroupCache().isAdministrator(me) || Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId());
            }
            final ChangeDetail d = new ChangeDetail();
            d.load(db, new AccountInfoCacheFactory(db), change, anon, canAbandon);
            return d;
        }
    });
}
#end_block

#method_before
public void abandonChange(final String message, final PatchSet.Id patchSetId, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final Project proj = db.projects().get(change.getDest().getParentKey());
            if (me == null || change == null || patch == null || proj == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId())) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            db.run(new OrmRunnable<VoidResult, ReviewDb>() {

                public VoidResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, cmsg, db, txn);
                }
            });
            // Email the reviewers
            try {
                final ChangeMail cm = new ChangeMail(server, change);
                cm.setFrom(Common.getAccountId());
                cm.setReviewDb(db);
                cm.setChangeMessage(cmsg);
                cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                cm.sendAbandoned();
            } catch (MessagingException e) {
                log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void abandonChange(final PatchSet.Id patchSetId, final String message, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(patchSetId);
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (me == null || patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId())) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            Boolean dbSuccess = db.run(new OrmRunnable<Boolean, ReviewDb>() {

                public Boolean run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, patchSetId, cmsg, db, txn);
                }
            });
            if (dbSuccess) {
                // Email the reviewers
                try {
                    final ChangeMail cm = new ChangeMail(server, change);
                    cm.setFrom(me);
                    cm.setReviewDb(db);
                    cm.setChangeMessage(cmsg);
                    cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                    cm.sendAbandoned();
                } catch (MessagingException e) {
                    log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                    throw new Failure(e);
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
private VoidResult doAbandonChange(final String message, final Change change, final ChangeMessage cm, final ReviewDb db, final Transaction txn) throws OrmException {
    if (change.getStatus() == Change.Status.NEW) {
        change.setStatus(Change.Status.ABANDONED);
        ChangeUtil.updated(change);
    }
    db.changeMessages().insert(Collections.singleton(cm), txn);
    db.changes().update(Collections.singleton(change), txn);
    return VoidResult.INSTANCE;
}
#method_after
private Boolean doAbandonChange(final String message, final Change change, final PatchSet.Id psid, final ChangeMessage cm, final ReviewDb db, final Transaction txn) throws OrmException {
    // changed while the user was typing an abandon message
    if (change.getStatus() == Change.Status.NEW && change.currentPatchSetId().equals(psid)) {
        change.setStatus(Change.Status.ABANDONED);
        ChangeUtil.updated(change);
        final List<ChangeApproval> approvals = db.changeApprovals().byChange(change.getId()).toList();
        for (ChangeApproval a : approvals) {
            a.cache(change);
        }
        db.changeApprovals().update(approvals, txn);
        db.changeMessages().insert(Collections.singleton(cm), txn);
        db.changes().update(Collections.singleton(change), txn);
        return Boolean.TRUE;
    }
    return Boolean.FALSE;
}
#end_block

#method_before
private void initUI() {
    addStyleName("gerrit-ChangeScreen");
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    dependencies = new ChangeTable();
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    approvals = new ApprovalTable(changeId);
    approvalsPanel = new DisclosurePanel(Util.C.changeScreenApprovals());
    approvalsPanel.setContent(wrap(approvals));
    dependenciesPanel.setWidth("95%");
    add(approvalsPanel);
    patchSetPanels = new FlowPanel();
    add(patchSetPanels);
    messagesContent = new FlowPanel();
    messagesContent.setStyleName("gerrit-ChangeMessages");
    messagesPanel = new DisclosurePanel(Util.C.changeScreenMessages());
    messagesPanel.setContent(messagesContent);
    add(messagesPanel);
}
#method_after
private void initUI() {
    addStyleName("gerrit-ChangeScreen");
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    dependencies = new ChangeTable();
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    approvals = new ApprovalTable();
    approvalsPanel = new DisclosurePanel(Util.C.changeScreenApprovals());
    approvalsPanel.setContent(wrap(approvals));
    dependenciesPanel.setWidth("95%");
    add(approvalsPanel);
    patchSetPanels = new FlowPanel();
    add(patchSetPanels);
    messagesContent = new FlowPanel();
    messagesContent.setStyleName("gerrit-ChangeMessages");
    messagesPanel = new DisclosurePanel(Util.C.changeScreenMessages());
    messagesPanel.setContent(messagesContent);
    add(messagesPanel);
}
#end_block

#method_before
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getSubject());
    refreshOnSignIn = !detail.getChange().getStatus().isClosed();
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getMissingApprovals(), detail.getApprovals());
    addPatchSets(detail);
    addMessages(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    approvalsPanel.setOpen(true);
}
#method_after
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getSubject());
    refreshOnSignIn = !detail.getChange().getStatus().isClosed();
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getChange(), detail.getMissingApprovals(), detail.getApprovals());
    addPatchSets(detail);
    addMessages(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    approvalsPanel.setOpen(true);
}
#end_block

#method_before
public void sendRequestReview() throws MessagingException {
    if (begin("requestReview")) {
        final Account a = Common.getAccountCache().get(fromId);
        if (a == null) {
            body.append("A Gerrit user");
        } else {
            final String e = a.getFullName();
            body.append(e);
        }
        body.append(" has requested that you review a change\n\n");
        if (changeUrl() != null) {
            openFooter();
            body.append("To respond visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
        if (fromId != null) {
            add(RecipientType.CC, fromId);
        }
        send();
    }
}
#method_after
public void sendRequestReview() throws MessagingException {
    if (begin("requestReview")) {
        final Account a = Common.getAccountCache().get(fromId);
        if (a == null || a.getFullName() == null || a.getFullName().length() == 0) {
            body.append("A Gerrit user");
        } else {
            body.append(a.getFullName());
        }
        body.append(" has requested that you review a change:\n\n");
        body.append(change.getChangeId());
        body.append(" - ");
        body.append(change.getSubject());
        body.append("\n\n");
        if (changeUrl() != null) {
            openFooter();
            body.append("To respond visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
        if (fromId != null) {
            add(RecipientType.CC, fromId);
        }
        send();
    }
}
#end_block

#method_before
private String changeMessageThreadId() {
    final StringBuilder r = new StringBuilder();
    r.append('<');
    r.append("gerrit");
    r.append('.');
    r.append(change.getCreatedOn().getTime());
    r.append('.');
    r.append(change.getChangeId());
    if (fromId != null) {
        r.append('.');
        r.append(fromId.get());
    }
    r.append('@');
    r.append(gerritHost());
    r.append('>');
    return r.toString();
}
#method_after
private String changeMessageThreadId() {
    final StringBuilder r = new StringBuilder();
    r.append('<');
    r.append("gerrit");
    r.append('.');
    r.append(change.getCreatedOn().getTime());
    r.append('.');
    r.append(change.getChangeId());
    r.append('@');
    r.append(gerritHost());
    r.append('>');
    return r.toString();
}
#end_block

#method_before
public void display(final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    final int oldcnt = table.getRowCount();
    table.resizeRows(1 + rows.size());
    if (oldcnt < 1 + rows.size()) {
        for (int row = oldcnt; row < 1 + rows.size(); row++) {
            applyEdgeStyles(row);
            applyScoreStyles(row);
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.setVisible(true);
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i));
        }
    }
    missing.clear();
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Label l = new Label(Util.M.needApproval(at.getCategory().getName()));
                l.setStyleName("gerrit-Change-MissingApproval");
                missing.add(l);
                missing.setVisible(true);
            }
        }
    }
    addReviewer.clear();
    if (need != null && Gerrit.isSignedIn()) {
        final Label l = new Label(Util.C.approvalTableAddReviewer());
        l.setStyleName("gerrit-Change-AddReviewer");
        addReviewer.add(l);
        addReviewer.add(addMemberBox);
    }
}
#method_after
public void display(final Change change, final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    changeId = change.getId();
    final int oldcnt = table.getRowCount();
    table.resizeRows(1 + rows.size());
    if (oldcnt < 1 + rows.size()) {
        for (int row = oldcnt; row < 1 + rows.size(); row++) {
            applyEdgeStyles(row);
            applyScoreStyles(row);
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.setVisible(true);
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i));
        }
    }
    missing.clear();
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Label l = new Label(Util.M.needApproval(at.getCategory().getName()));
                l.setStyleName("gerrit-Change-MissingApproval");
                missing.add(l);
                missing.setVisible(true);
            }
        }
    }
    changeIsOpen = change.getStatus().isOpen();
    addReviewer.setVisible(Gerrit.isSignedIn() && changeIsOpen);
}
#end_block

#method_before
private void doAddReviewer() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail == null || nameEmail.length() == 0 || com.google.gerrit.client.admin.Util.C.defaultAccountName().equals(nameEmail)) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = Arrays.asList(nameEmail.split(";"));
    Util.DETAIL_SVC.addReviewers(reviewers, changeId, new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddReviewer() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(nameEmail);
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

