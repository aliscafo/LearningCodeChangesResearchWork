76
#method_before
@VisibleForTesting
void handleSimStateChange(int subId, int slotId, State state) {
    checkIsHandlerThread();
    if (DEBUG_SIM_STATES) {
        Log.d(TAG, "handleSimStateChange(subId=" + subId + ", slotId=" + slotId + ", state=" + state + ")");
    }
    if (!SubscriptionManager.isValidSubscriptionId(subId)) {
        Log.w(TAG, "invalid subId in handleSimStateChange()");
        return;
    }
    SimData data = mSimDatas.get(subId);
    final boolean changed;
    if (data == null) {
        data = new SimData(state, slotId, subId);
        mSimDatas.put(subId, data);
        // no data yet; force update
        changed = true;
    } else {
        changed = (data.simState != state || data.subId != subId || data.slotId != slotId);
        data.simState = state;
        data.subId = subId;
        data.slotId = slotId;
    }
    if (changed && state != State.UNKNOWN) {
        for (int i = 0; i < mCallbacks.size(); i++) {
            KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
            if (cb != null) {
                cb.onSimStateChanged(subId, slotId, state);
            }
        }
    }
}
#method_after
@VisibleForTesting
void handleSimStateChange(int subId, int slotId, State state) {
    checkIsHandlerThread();
    if (DEBUG_SIM_STATES) {
        Log.d(TAG, "handleSimStateChange(subId=" + subId + ", slotId=" + slotId + ", state=" + state + ")");
    }
    SimData data = mSimDatas.get(subId);
    final boolean changed;
    if (data == null) {
        data = new SimData(state, slotId, subId);
        mSimDatas.put(subId, data);
        // no data yet; force update
        changed = true;
    } else {
        changed = (data.simState != state || data.subId != subId || data.slotId != slotId);
        data.simState = state;
        data.subId = subId;
        data.slotId = slotId;
    }
    if (changed && state != State.UNKNOWN) {
        for (int i = 0; i < mCallbacks.size(); i++) {
            KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
            if (cb != null) {
                cb.onSimStateChanged(subId, slotId, state);
            }
        }
    }
}
#end_block

#method_before
private void processValuesLocked(boolean force) {
    boolean logOutlier = false;
    long dischargeDuration = 0;
    mBatteryLevelCritical = mHealthInfo.batteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mHealthInfo.batteryLevel <= mCriticalBatteryLevel;
    if (mHealthInfo.chargerAcOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_AC;
    } else if (mHealthInfo.chargerUsbOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_USB;
    } else if (mHealthInfo.chargerWirelessOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_WIRELESS;
    } else {
        mPlugType = BATTERY_PLUGGED_NONE;
    }
    if (DEBUG) {
        Slog.d(TAG, "Processing new values: " + "info=" + mHealthInfo + ", mBatteryLevelCritical=" + mBatteryLevelCritical + ", mPlugType=" + mPlugType);
    }
    // Let the battery stats keep track of the current level.
    try {
        mBatteryStats.setBatteryState(mHealthInfo.batteryStatus, mHealthInfo.batteryHealth, mPlugType, mHealthInfo.batteryLevel, mHealthInfo.batteryTemperature, mHealthInfo.batteryVoltage, mHealthInfo.batteryChargeCounter, mHealthInfo.batteryFullCharge);
    } catch (RemoteException e) {
    // Should never happen.
    }
    shutdownIfNoPowerLocked();
    shutdownIfOverTempLocked();
    mDashCharger = mHasDashCharger && isDashCharger();
    if (force || (mHealthInfo.batteryStatus != mLastBatteryStatus || mHealthInfo.batteryHealth != mLastBatteryHealth || mHealthInfo.batteryPresent != mLastBatteryPresent || mHealthInfo.batteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mHealthInfo.batteryVoltage != mLastBatteryVoltage || mHealthInfo.batteryTemperature != mLastBatteryTemperature || mHealthInfo.maxChargingCurrent != mLastMaxChargingCurrent || mHealthInfo.maxChargingVoltage != mLastMaxChargingVoltage || mHealthInfo.batteryChargeCounter != mLastChargeCounter || mInvalidCharger != mLastInvalidCharger || mDashCharger != mLastDashCharger)) {
        if (mPlugType != mLastPlugType) {
            if (mLastPlugType == BATTERY_PLUGGED_NONE) {
                // discharging -> charging
                mChargeStartLevel = mHealthInfo.batteryLevel;
                mChargeStartTime = SystemClock.elapsedRealtime();
                final LogMaker builder = new LogMaker(MetricsEvent.ACTION_CHARGE);
                builder.setType(MetricsEvent.TYPE_ACTION);
                builder.addTaggedData(MetricsEvent.FIELD_PLUG_TYPE, mPlugType);
                builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_START, mHealthInfo.batteryLevel);
                mMetricsLogger.write(builder);
                // battery level has changed; so don't log until it does.
                if (mDischargeStartTime != 0 && mDischargeStartLevel != mHealthInfo.batteryLevel) {
                    dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
                    logOutlier = true;
                    EventLog.writeEvent(EventLogTags.BATTERY_DISCHARGE, dischargeDuration, mDischargeStartLevel, mHealthInfo.batteryLevel);
                    // make sure we see a discharge event before logging again
                    mDischargeStartTime = 0;
                }
            } else if (mPlugType == BATTERY_PLUGGED_NONE) {
                // charging -> discharging or we just powered up
                mDischargeStartTime = SystemClock.elapsedRealtime();
                mDischargeStartLevel = mHealthInfo.batteryLevel;
                long chargeDuration = SystemClock.elapsedRealtime() - mChargeStartTime;
                if (mChargeStartTime != 0 && chargeDuration != 0) {
                    final LogMaker builder = new LogMaker(MetricsEvent.ACTION_CHARGE);
                    builder.setType(MetricsEvent.TYPE_DISMISS);
                    builder.addTaggedData(MetricsEvent.FIELD_PLUG_TYPE, mLastPlugType);
                    builder.addTaggedData(MetricsEvent.FIELD_CHARGING_DURATION_MILLIS, chargeDuration);
                    builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_START, mChargeStartLevel);
                    builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_END, mHealthInfo.batteryLevel);
                    mMetricsLogger.write(builder);
                }
                mChargeStartTime = 0;
            }
        }
        if (mHealthInfo.batteryStatus != mLastBatteryStatus || mHealthInfo.batteryHealth != mLastBatteryHealth || mHealthInfo.batteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
            EventLog.writeEvent(EventLogTags.BATTERY_STATUS, mHealthInfo.batteryStatus, mHealthInfo.batteryHealth, mHealthInfo.batteryPresent ? 1 : 0, mPlugType, mHealthInfo.batteryTechnology);
        }
        if (mHealthInfo.batteryLevel != mLastBatteryLevel) {
            // Don't do this just from voltage or temperature changes, that is
            // too noisy.
            EventLog.writeEvent(EventLogTags.BATTERY_LEVEL, mHealthInfo.batteryLevel, mHealthInfo.batteryVoltage, mHealthInfo.batteryTemperature);
        }
        if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
            // We want to make sure we log discharge cycle outliers
            // if the battery is about to die.
            dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
            logOutlier = true;
        }
        if (!mBatteryLevelLow) {
            // Should we now switch in to low battery mode?
            if (mPlugType == BATTERY_PLUGGED_NONE && mHealthInfo.batteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mHealthInfo.batteryLevel <= mLowBatteryWarningLevel) {
                mBatteryLevelLow = true;
            }
        } else {
            // Should we now switch out of low battery mode?
            if (mPlugType != BATTERY_PLUGGED_NONE) {
                mBatteryLevelLow = false;
            } else if (mHealthInfo.batteryLevel >= mLowBatteryCloseWarningLevel) {
                mBatteryLevelLow = false;
            } else if (force && mHealthInfo.batteryLevel >= mLowBatteryWarningLevel) {
                // If being forced, the previous state doesn't matter, we will just
                // absolutely check to see if we are now above the warning level.
                mBatteryLevelLow = false;
            }
        }
        mSequence++;
        // applications may want to have smart behavior based on this.
        if (mPlugType != 0 && mLastPlugType == 0) {
            final Intent statusIntent = new Intent(Intent.ACTION_POWER_CONNECTED);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mPlugType == 0 && mLastPlugType != 0) {
            final Intent statusIntent = new Intent(Intent.ACTION_POWER_DISCONNECTED);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        if (shouldSendBatteryLowLocked()) {
            mSentLowBatteryBroadcast = true;
            final Intent statusIntent = new Intent(Intent.ACTION_BATTERY_LOW);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mSentLowBatteryBroadcast && mHealthInfo.batteryLevel >= mLowBatteryCloseWarningLevel) {
            mSentLowBatteryBroadcast = false;
            final Intent statusIntent = new Intent(Intent.ACTION_BATTERY_OKAY);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        // We are doing this after sending the above broadcasts, so anything processing
        // them will get the new sequence number at that point.  (See for example how testing
        // of JobScheduler's BatteryController works.)
        sendBatteryChangedIntentLocked();
        if (mLastBatteryLevel != mHealthInfo.batteryLevel || mLastPlugType != mPlugType) {
            sendBatteryLevelChangedIntentLocked();
        }
        // Update the battery LED
        mLed.updateLightsLocked();
        // This needs to be done after sendIntent() so that we get the lastest battery stats.
        if (logOutlier && dischargeDuration != 0) {
            logOutlierLocked(dischargeDuration);
        }
        mLastBatteryStatus = mHealthInfo.batteryStatus;
        mLastBatteryHealth = mHealthInfo.batteryHealth;
        mLastBatteryPresent = mHealthInfo.batteryPresent;
        mLastBatteryLevel = mHealthInfo.batteryLevel;
        mLastPlugType = mPlugType;
        mLastBatteryVoltage = mHealthInfo.batteryVoltage;
        mLastBatteryTemperature = mHealthInfo.batteryTemperature;
        mLastMaxChargingCurrent = mHealthInfo.maxChargingCurrent;
        mLastMaxChargingVoltage = mHealthInfo.maxChargingVoltage;
        mLastChargeCounter = mHealthInfo.batteryChargeCounter;
        mLastBatteryLevelCritical = mBatteryLevelCritical;
        mLastInvalidCharger = mInvalidCharger;
        mLastDashCharger = mDashCharger;
    }
}
#method_after
private void processValuesLocked(boolean force) {
    boolean logOutlier = false;
    long dischargeDuration = 0;
    mBatteryLevelCritical = mHealthInfo.batteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mHealthInfo.batteryLevel <= mCriticalBatteryLevel;
    if (mHealthInfo.chargerAcOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_AC;
    } else if (mHealthInfo.chargerUsbOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_USB;
    } else if (mHealthInfo.chargerWirelessOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_WIRELESS;
    } else {
        mPlugType = BATTERY_PLUGGED_NONE;
    }
    if (DEBUG) {
        Slog.d(TAG, "Processing new values: " + "info=" + mHealthInfo + ", mBatteryLevelCritical=" + mBatteryLevelCritical + ", mPlugType=" + mPlugType);
    }
    // Let the battery stats keep track of the current level.
    try {
        mBatteryStats.setBatteryState(mHealthInfo.batteryStatus, mHealthInfo.batteryHealth, mPlugType, mHealthInfo.batteryLevel, mHealthInfo.batteryTemperature, mHealthInfo.batteryVoltage, mHealthInfo.batteryChargeCounter, mHealthInfo.batteryFullCharge);
    } catch (RemoteException e) {
    // Should never happen.
    }
    shutdownIfNoPowerLocked();
    shutdownIfOverTempLocked();
    mDashCharger = mHasDashCharger && Utils.isDashCharger();
    if (force || (mHealthInfo.batteryStatus != mLastBatteryStatus || mHealthInfo.batteryHealth != mLastBatteryHealth || mHealthInfo.batteryPresent != mLastBatteryPresent || mHealthInfo.batteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mHealthInfo.batteryVoltage != mLastBatteryVoltage || mHealthInfo.batteryTemperature != mLastBatteryTemperature || mHealthInfo.maxChargingCurrent != mLastMaxChargingCurrent || mHealthInfo.maxChargingVoltage != mLastMaxChargingVoltage || mHealthInfo.batteryChargeCounter != mLastChargeCounter || mInvalidCharger != mLastInvalidCharger || mDashCharger != mLastDashCharger)) {
        if (mPlugType != mLastPlugType) {
            if (mLastPlugType == BATTERY_PLUGGED_NONE) {
                // discharging -> charging
                mChargeStartLevel = mHealthInfo.batteryLevel;
                mChargeStartTime = SystemClock.elapsedRealtime();
                final LogMaker builder = new LogMaker(MetricsEvent.ACTION_CHARGE);
                builder.setType(MetricsEvent.TYPE_ACTION);
                builder.addTaggedData(MetricsEvent.FIELD_PLUG_TYPE, mPlugType);
                builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_START, mHealthInfo.batteryLevel);
                mMetricsLogger.write(builder);
                // battery level has changed; so don't log until it does.
                if (mDischargeStartTime != 0 && mDischargeStartLevel != mHealthInfo.batteryLevel) {
                    dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
                    logOutlier = true;
                    EventLog.writeEvent(EventLogTags.BATTERY_DISCHARGE, dischargeDuration, mDischargeStartLevel, mHealthInfo.batteryLevel);
                    // make sure we see a discharge event before logging again
                    mDischargeStartTime = 0;
                }
            } else if (mPlugType == BATTERY_PLUGGED_NONE) {
                // charging -> discharging or we just powered up
                mDischargeStartTime = SystemClock.elapsedRealtime();
                mDischargeStartLevel = mHealthInfo.batteryLevel;
                long chargeDuration = SystemClock.elapsedRealtime() - mChargeStartTime;
                if (mChargeStartTime != 0 && chargeDuration != 0) {
                    final LogMaker builder = new LogMaker(MetricsEvent.ACTION_CHARGE);
                    builder.setType(MetricsEvent.TYPE_DISMISS);
                    builder.addTaggedData(MetricsEvent.FIELD_PLUG_TYPE, mLastPlugType);
                    builder.addTaggedData(MetricsEvent.FIELD_CHARGING_DURATION_MILLIS, chargeDuration);
                    builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_START, mChargeStartLevel);
                    builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_END, mHealthInfo.batteryLevel);
                    mMetricsLogger.write(builder);
                }
                mChargeStartTime = 0;
            }
        }
        if (mHealthInfo.batteryStatus != mLastBatteryStatus || mHealthInfo.batteryHealth != mLastBatteryHealth || mHealthInfo.batteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
            EventLog.writeEvent(EventLogTags.BATTERY_STATUS, mHealthInfo.batteryStatus, mHealthInfo.batteryHealth, mHealthInfo.batteryPresent ? 1 : 0, mPlugType, mHealthInfo.batteryTechnology);
        }
        if (mHealthInfo.batteryLevel != mLastBatteryLevel) {
            // Don't do this just from voltage or temperature changes, that is
            // too noisy.
            EventLog.writeEvent(EventLogTags.BATTERY_LEVEL, mHealthInfo.batteryLevel, mHealthInfo.batteryVoltage, mHealthInfo.batteryTemperature);
        }
        if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
            // We want to make sure we log discharge cycle outliers
            // if the battery is about to die.
            dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
            logOutlier = true;
        }
        if (!mBatteryLevelLow) {
            // Should we now switch in to low battery mode?
            if (mPlugType == BATTERY_PLUGGED_NONE && mHealthInfo.batteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mHealthInfo.batteryLevel <= mLowBatteryWarningLevel) {
                mBatteryLevelLow = true;
            }
        } else {
            // Should we now switch out of low battery mode?
            if (mPlugType != BATTERY_PLUGGED_NONE) {
                mBatteryLevelLow = false;
            } else if (mHealthInfo.batteryLevel >= mLowBatteryCloseWarningLevel) {
                mBatteryLevelLow = false;
            } else if (force && mHealthInfo.batteryLevel >= mLowBatteryWarningLevel) {
                // If being forced, the previous state doesn't matter, we will just
                // absolutely check to see if we are now above the warning level.
                mBatteryLevelLow = false;
            }
        }
        mSequence++;
        // applications may want to have smart behavior based on this.
        if (mPlugType != 0 && mLastPlugType == 0) {
            final Intent statusIntent = new Intent(Intent.ACTION_POWER_CONNECTED);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mPlugType == 0 && mLastPlugType != 0) {
            final Intent statusIntent = new Intent(Intent.ACTION_POWER_DISCONNECTED);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        if (shouldSendBatteryLowLocked()) {
            mSentLowBatteryBroadcast = true;
            final Intent statusIntent = new Intent(Intent.ACTION_BATTERY_LOW);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mSentLowBatteryBroadcast && mHealthInfo.batteryLevel >= mLowBatteryCloseWarningLevel) {
            mSentLowBatteryBroadcast = false;
            final Intent statusIntent = new Intent(Intent.ACTION_BATTERY_OKAY);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        // We are doing this after sending the above broadcasts, so anything processing
        // them will get the new sequence number at that point.  (See for example how testing
        // of JobScheduler's BatteryController works.)
        sendBatteryChangedIntentLocked();
        if (mLastBatteryLevel != mHealthInfo.batteryLevel || mLastPlugType != mPlugType) {
            sendBatteryLevelChangedIntentLocked();
        }
        // Update the battery LED
        mLed.updateLightsLocked();
        // This needs to be done after sendIntent() so that we get the lastest battery stats.
        if (logOutlier && dischargeDuration != 0) {
            logOutlierLocked(dischargeDuration);
        }
        mLastBatteryStatus = mHealthInfo.batteryStatus;
        mLastBatteryHealth = mHealthInfo.batteryHealth;
        mLastBatteryPresent = mHealthInfo.batteryPresent;
        mLastBatteryLevel = mHealthInfo.batteryLevel;
        mLastPlugType = mPlugType;
        mLastBatteryVoltage = mHealthInfo.batteryVoltage;
        mLastBatteryTemperature = mHealthInfo.batteryTemperature;
        mLastMaxChargingCurrent = mHealthInfo.maxChargingCurrent;
        mLastMaxChargingVoltage = mHealthInfo.maxChargingVoltage;
        mLastChargeCounter = mHealthInfo.batteryChargeCounter;
        mLastBatteryLevelCritical = mBatteryLevelCritical;
        mLastInvalidCharger = mInvalidCharger;
        mLastDashCharger = mDashCharger;
    }
}
#end_block

#method_before
private View createDialogView(final Context context, Map<String, IconPackInfo> supportedPackages) {
    final LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    final View view = inflater.inflate(R.layout.dialog_iconpack, null);
    final IconAdapter adapter = new IconAdapter(context, supportedPackages);
    mListView = (ListView) view.findViewById(R.id.iconpack_list);
    mListView.setAdapter(adapter);
    mListView.setOnItemClickListener(new OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            if (adapter.isCurrentIconPack(position)) {
                return;
            }
            String selectedPackage = adapter.getItem(position);
            Settings.System.putString(getContext().getContentResolver(), Settings.System.RECENTS_ICON_PACK, selectedPackage);
            mDialog.dismiss();
        }
    });
    return view;
}
#method_after
private View createDialogView(final Context context, Map<String, IconPackInfo> supportedPackages) {
    final LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    final View view = inflater.inflate(R.layout.dialog_iconpack, null);
    final IconAdapter adapter = new IconAdapter(context, supportedPackages);
    ListView mListView = (ListView) view.findViewById(R.id.iconpack_list);
    mListView.setAdapter(adapter);
    mListView.setOnItemClickListener(new OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            if (adapter.isCurrentIconPack(position)) {
                return;
            }
            String selectedPackage = adapter.getItem(position);
            Settings.System.putString(getContext().getContentResolver(), Settings.System.RECENTS_ICON_PACK, selectedPackage);
            mDialog.dismiss();
        }
    });
    return view;
}
#end_block

#method_before
@Override
public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    mNavigationBarView = (NavigationBarView) view;
    mNavigationBarView.setDisabledFlags(mDisabledFlags1);
    mNavigationBarView.setComponents(mRecents, mDivider, mStatusBar.getPanel());
    mNavigationBarView.setOnVerticalChangedListener(this::onVerticalChanged);
    mNavigationBarView.setOnTouchListener(this::onNavigationTouch);
    if (savedInstanceState != null) {
        mNavigationBarView.getLightTransitionsController().restoreState(savedInstanceState);
    }
    prepareNavigationBarView();
    checkNavBarModes();
    setDisabled2Flags(mDisabledFlags2);
    IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    getContext().registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    notifyNavigationBarScreenOn();
    mOverviewProxyService.addCallback(mOverviewProxyListener);
    setFullGestureMode();
}
#method_after
@Override
public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    mNavigationBarView = (NavigationBarView) view;
    mNavigationBarView.setComponents(mRecents, mDivider, mStatusBar.getPanel());
    mNavigationBarView.setDisabledFlags(mDisabledFlags1);
    mNavigationBarView.setOnVerticalChangedListener(this::onVerticalChanged);
    mNavigationBarView.setOnTouchListener(this::onNavigationTouch);
    if (savedInstanceState != null) {
        mNavigationBarView.getLightTransitionsController().restoreState(savedInstanceState);
    }
    prepareNavigationBarView();
    checkNavBarModes();
    setDisabled2Flags(mDisabledFlags2);
    IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    getContext().registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    notifyNavigationBarScreenOn();
    mOverviewProxyService.addCallback(mOverviewProxyListener);
    setFullGestureMode();
}
#end_block

#method_before
private void updateSize() {
    final Rect bounds = getBounds();
    if (mMeterStyle != BATTERY_STYLE_LANDSCAPE) {
        mHeight = (bounds.bottom - mPadding.bottom) - (bounds.top + mPadding.top);
        mWidth = (bounds.right - mPadding.right) - (bounds.left + mPadding.left);
    } else {
        mHeight = (bounds.right - mPadding.right) - (bounds.left + mPadding.left);
        mWidth = (bounds.bottom - mPadding.bottom) - (bounds.top + mPadding.top);
    }
    switch(mMeterStyle) {
        case BATTERY_STYLE_PORTRAIT:
        case BATTERY_STYLE_LANDSCAPE:
            mIntrinsicWidth = mContext.getResources().getDimensionPixelSize(R.dimen.battery_width);
            mIntrinsicHeight = mContext.getResources().getDimensionPixelSize(R.dimen.battery_height);
        default:
            mIntrinsicWidth = mContext.getResources().getDimensionPixelSize(R.dimen.battery_height);
            mIntrinsicHeight = mContext.getResources().getDimensionPixelSize(R.dimen.battery_height);
    }
}
#method_after
private void updateSize() {
    final Rect bounds = getBounds();
    mHeight = (bounds.bottom - mPadding.bottom) - (bounds.top + mPadding.top);
    mWidth = (bounds.right - mPadding.right) - (bounds.left + mPadding.left);
    mWarningTextPaint.setTextSize(mHeight * 0.75f);
    mWarningTextHeight = -mWarningTextPaint.getFontMetrics().ascent;
    switch(mMeterStyle) {
        case BATTERY_STYLE_PORTRAIT:
            mIntrinsicWidth = mContext.getResources().getDimensionPixelSize(R.dimen.battery_width);
            mIntrinsicHeight = mContext.getResources().getDimensionPixelSize(R.dimen.battery_height);
        case BATTERY_STYLE_LANDSCAPE:
            mIntrinsicWidth = mContext.getResources().getDimensionPixelSize(R.dimen.battery_height);
            mIntrinsicHeight = mContext.getResources().getDimensionPixelSize(R.dimen.battery_width);
        default:
            mIntrinsicWidth = mContext.getResources().getDimensionPixelSize(R.dimen.battery_height);
            mIntrinsicHeight = mContext.getResources().getDimensionPixelSize(R.dimen.battery_height);
    }
}
#end_block

#method_before
@Override
public void draw(Canvas c) {
    switch(mMeterStyle) {
        case BATTERY_STYLE_PORTRAIT:
            drawRectangle(c, false);
            break;
        case BATTERY_STYLE_LANDSCAPE:
            drawRectangle(c, true);
            break;
        case BATTERY_STYLE_CIRCLE:
            drawCircle(c);
            break;
        default:
            drawRectangle(c, false);
            break;
    }
}
#method_after
@Override
public void draw(Canvas c) {
    switch(mMeterStyle) {
        case BATTERY_STYLE_CIRCLE:
            drawCircle(c);
            break;
        case BATTERY_STYLE_PORTRAIT:
        case BATTERY_STYLE_LANDSCAPE:
        default:
            drawRectangle(c);
            break;
    }
}
#end_block

#method_before
private void drawRectangle(Canvas c, boolean horizontal) {
    final int level = mLevel;
    final Rect bounds = getBounds();
    if (level == -1)
        return;
    float drawFrac = (float) level / 100f;
    final int height = mHeight;
    final int width = (int) (getAspectRatio() * mHeight);
    final int px = (mWidth - width) / 2;
    final int buttonHeight = Math.round((horizontal ? width : height) * mButtonHeightFraction);
    final int left = mPadding.left + bounds.left;
    final int top = bounds.bottom - mPadding.bottom - height;
    mFramePaint.setStrokeWidth(0);
    mFramePaint.setStyle(Paint.Style.FILL_AND_STROKE);
    mBatteryPaint.setStrokeWidth(0);
    mBatteryPaint.setStyle(Paint.Style.FILL_AND_STROKE);
    mFrame.set(left, top, width + left, height + top);
    mFrame.offset(px, 0);
    // button-frame: area above the battery body
    if (horizontal) {
        mButtonFrame.set(width - buttonHeight - mFrame.left, mFrame.top + Math.round(height * 0.28f), mFrame.right, mFrame.bottom - Math.round(height * 0.28f));
    } else {
        mButtonFrame.set(mFrame.left + Math.round(width * 0.28f), mFrame.top, mFrame.right - Math.round(width * 0.28f), mFrame.top + buttonHeight);
    }
    // frame: battery body area
    if (horizontal) {
        mFrame.right -= buttonHeight;
    } else {
        mFrame.top += buttonHeight;
    }
    // set the battery charging color
    mBatteryPaint.setColor(batteryColorForLevel(level));
    if (level >= FULL) {
        drawFrac = 1f;
    } else if (level <= mCriticalLevel) {
        drawFrac = 0f;
    }
    final float levelTop;
    if (drawFrac == 1f) {
        if (horizontal) {
            levelTop = mButtonFrame.right;
        } else {
            levelTop = mButtonFrame.top;
        }
    } else {
        if (horizontal) {
            levelTop = (mFrame.right - (mFrame.width() * (1f - drawFrac)));
        } else {
            levelTop = (mFrame.top + (mFrame.height() * (1f - drawFrac)));
        }
    }
    // define the battery shape
    mShapePath.reset();
    final float radius = getRadiusRatio() * (mFrame.height() + buttonHeight);
    mShapePath.setFillType(FillType.WINDING);
    mShapePath.addRoundRect(mFrame, radius, radius, Direction.CW);
    mShapePath.addRect(mButtonFrame, Direction.CW);
    if (mCharging) {
        // define the bolt shape
        // Shift right by 1px for maximal bolt-goodness
        final float bl = mFrame.left + mFrame.width() / (horizontal ? 9f : (4f + 1));
        final float bt = mFrame.top + mFrame.height() / (horizontal ? (4f + 1) : 6f);
        final float br = mFrame.right - mFrame.width() / (horizontal ? 6f : (4f + 1));
        final float bb = mFrame.bottom - mFrame.height() / (horizontal ? 7f : 10f);
        if (mBoltFrame.left != bl || mBoltFrame.top != bt || mBoltFrame.right != br || mBoltFrame.bottom != bb) {
            mBoltFrame.set(bl, bt, br, bb);
            mBoltPath.reset();
            mBoltPath.moveTo(mBoltFrame.left + mBoltPoints[0] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[1] * mBoltFrame.height());
            for (int i = 2; i < mBoltPoints.length; i += 2) {
                mBoltPath.lineTo(mBoltFrame.left + mBoltPoints[i] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[i + 1] * mBoltFrame.height());
            }
            mBoltPath.lineTo(mBoltFrame.left + mBoltPoints[0] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[1] * mBoltFrame.height());
        }
        float boltPct = (mBoltFrame.bottom - levelTop) / (mBoltFrame.bottom - mBoltFrame.top);
        boltPct = Math.min(Math.max(boltPct, 0), 1);
        if (boltPct <= BOLT_LEVEL_THRESHOLD) {
            // draw the bolt if opaque
            c.drawPath(mBoltPath, mBoltPaint);
        } else {
            // otherwise cut the bolt out of the overall shape
            mShapePath.op(mBoltPath, Path.Op.DIFFERENCE);
        }
    } else if (mPowerSaveEnabled) {
        // define the plus shape
        final float pw = mFrame.width() * 2 / 3;
        final float pl = mFrame.left + (mFrame.width() - pw) / 2;
        final float pt = mFrame.top + (mFrame.height() - pw) / 2;
        final float pr = mFrame.right - (mFrame.width() - pw) / 2;
        final float pb = mFrame.bottom - (mFrame.height() - pw) / 2;
        if (mPlusFrame.left != pl || mPlusFrame.top != pt || mPlusFrame.right != pr || mPlusFrame.bottom != pb) {
            mPlusFrame.set(pl, pt, pr, pb);
            mPlusPath.reset();
            mPlusPath.moveTo(mPlusFrame.left + mPlusPoints[0] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[1] * mPlusFrame.height());
            for (int i = 2; i < mPlusPoints.length; i += 2) {
                mPlusPath.lineTo(mPlusFrame.left + mPlusPoints[i] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[i + 1] * mPlusFrame.height());
            }
            mPlusPath.lineTo(mPlusFrame.left + mPlusPoints[0] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[1] * mPlusFrame.height());
        }
        float boltPct = (mPlusFrame.bottom - levelTop) / (mPlusFrame.bottom - mPlusFrame.top);
        boltPct = Math.min(Math.max(boltPct, 0), 1);
        if (boltPct <= BOLT_LEVEL_THRESHOLD) {
            // draw the bolt if opaque
            c.drawPath(mPlusPath, mPlusPaint);
        } else {
            // otherwise cut the bolt out of the overall shape
            mShapePath.op(mPlusPath, Path.Op.DIFFERENCE);
        }
    }
    // compute percentage text
    boolean pctOpaque = false;
    float pctX = 0, pctY = 0;
    String pctText = null;
    if (!mCharging && !mPowerSaveEnabled && level > mCriticalLevel && mShowPercent) {
        mTextPaint.setColor(getColorForLevel(level));
        final float full = horizontal ? 0.60f : 0.38f;
        final float nofull = horizontal ? 0.75f : 0.5f;
        final float single = horizontal ? 0.86f : 0.75f;
        mTextPaint.setTextSize(height * (SINGLE_DIGIT_PERCENT ? single : (mLevel == 100 ? full : nofull)));
        mTextHeight = -mTextPaint.getFontMetrics().ascent;
        pctText = String.valueOf(SINGLE_DIGIT_PERCENT ? (level / 10) : level);
        pctX = mWidth * 0.5f;
        pctY = (mHeight + mTextHeight) * 0.47f;
        if (horizontal) {
            // Switch at 25% for landscape icon
            pctOpaque = level <= 25;
        } else {
            pctOpaque = levelTop > pctY;
        }
        if (!pctOpaque) {
            mTextPath.reset();
            mTextPaint.getTextPath(pctText, 0, pctText.length(), pctX, pctY, mTextPath);
            // cut the percentage text out of the overall shape
            mShapePath.op(mTextPath, Path.Op.DIFFERENCE);
        }
    }
    // draw the battery shape background
    c.drawPath(mShapePath, mFramePaint);
    // draw the battery shape, clipped to charging level
    if (horizontal) {
        mFrame.right = levelTop;
    } else {
        mFrame.top = levelTop;
    }
    mClipPath.reset();
    mClipPath.addRect(mFrame, Path.Direction.CCW);
    mShapePath.op(mClipPath, Path.Op.INTERSECT);
    c.drawPath(mShapePath, mBatteryPaint);
    if (!mCharging && !mPowerSaveEnabled) {
        if (level <= mCriticalLevel) {
            // draw the warning text
            final float x = mWidth * 0.5f;
            final float y = (mHeight + mWarningTextHeight) * 0.48f;
            c.drawText(mWarningString, x, y, mWarningTextPaint);
        } else if (pctOpaque) {
            // draw the percentage text
            c.drawText(pctText, pctX, pctY, mTextPaint);
        }
    }
}
#method_after
private void drawRectangle(Canvas c) {
    final int level = mLevel;
    final Rect bounds = getBounds();
    if (level == -1)
        return;
    final boolean horizontal = mMeterStyle == BATTERY_STYLE_LANDSCAPE;
    mBoltPoints = loadPoints(mContext.getResources(), horizontal ? R.array.batterymeter_inverted_bolt_points : R.array.batterymeter_bolt_points);
    float drawFrac = (float) level / 100f;
    final int height;
    final int width;
    final int top;
    if (horizontal) {
        top = mPadding.top + (horizontal ? (int) (mHeight * 0.12f) : 0);
        height = mHeight - top - (mPadding.bottom + (horizontal ? (int) (mHeight * 0.08f) : 0));
        width = mWidth - mPadding.left - mPadding.right;
        mFrame.set(0, 0, width, height);
        mFrame.offset(mPadding.left, top);
    } else {
        height = mHeight;
        width = (int) (getAspectRatio() * mHeight);
        top = bounds.bottom - mPadding.bottom - height;
        final int left = mPadding.left + bounds.left;
        mFrame.set(left, top, width + left, height + top);
        mFrame.offset(((mWidth - width) / 2), 0);
    }
    final int buttonHeight = Math.round((horizontal ? width : height) * mButtonHeightFraction);
    mFramePaint.setStrokeWidth(0);
    mFramePaint.setStyle(Paint.Style.FILL_AND_STROKE);
    mBatteryPaint.setStrokeWidth(0);
    mBatteryPaint.setStyle(Paint.Style.FILL_AND_STROKE);
    // button-frame: area above the battery body
    if (horizontal) {
        mButtonFrame.set(width - buttonHeight - mFrame.left, mFrame.top + Math.round(height * 0.28f), mFrame.right, mFrame.bottom - Math.round(height * 0.28f));
    } else {
        mButtonFrame.set(mFrame.left + Math.round(width * 0.28f), mFrame.top, mFrame.right - Math.round(width * 0.28f), mFrame.top + buttonHeight);
    }
    // frame: battery body area
    if (horizontal) {
        mFrame.right -= buttonHeight;
    } else {
        mFrame.top += buttonHeight;
    }
    // set the battery charging color
    mBatteryPaint.setColor(batteryColorForLevel(level));
    if (level >= FULL) {
        drawFrac = 1f;
    } else if (level <= mCriticalLevel) {
        drawFrac = 0f;
    }
    final float levelTop;
    if (drawFrac == 1f) {
        if (horizontal) {
            levelTop = mButtonFrame.right;
        } else {
            levelTop = mButtonFrame.top;
        }
    } else {
        if (horizontal) {
            levelTop = (mFrame.right - (mFrame.width() * (1f - drawFrac)));
        } else {
            levelTop = (mFrame.top + (mFrame.height() * (1f - drawFrac)));
        }
    }
    // define the battery shape
    mShapePath.reset();
    final float radius = getRadiusRatio() * (mFrame.height() + buttonHeight);
    mShapePath.setFillType(FillType.WINDING);
    mShapePath.addRoundRect(mFrame, radius, radius, Direction.CW);
    mShapePath.addRect(mButtonFrame, Direction.CW);
    if (mCharging) {
        // define the bolt shape
        // Shift right by 1px for maximal bolt-goodness
        final float bl = mFrame.left + (mFrame.width() / (horizontal ? 9f : 4f)) + (horizontal ? 0 : 1);
        final float bt = mFrame.top + (mFrame.height() / (horizontal ? 4f : 6f)) + (horizontal ? 1 : 0);
        final float br = mFrame.right - (mFrame.width() / (horizontal ? 6f : 4f)) + (horizontal ? 0 : 1);
        final float bb = mFrame.bottom - (mFrame.height() / (horizontal ? 7f : 10f));
        if (mBoltFrame.left != bl || mBoltFrame.top != bt || mBoltFrame.right != br || mBoltFrame.bottom != bb) {
            mBoltFrame.set(bl, bt, br, bb);
            mBoltPath.reset();
            mBoltPath.moveTo(mBoltFrame.left + mBoltPoints[0] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[1] * mBoltFrame.height());
            for (int i = 2; i < mBoltPoints.length; i += 2) {
                mBoltPath.lineTo(mBoltFrame.left + mBoltPoints[i] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[i + 1] * mBoltFrame.height());
            }
            mBoltPath.lineTo(mBoltFrame.left + mBoltPoints[0] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[1] * mBoltFrame.height());
        }
        float boltPct = horizontal ? (mBoltFrame.left - levelTop) / (mBoltFrame.left - mBoltFrame.right) : (mBoltFrame.bottom - levelTop) / (mBoltFrame.bottom - mBoltFrame.top);
        boltPct = Math.min(Math.max(boltPct, 0), 1);
        if (boltPct <= BOLT_LEVEL_THRESHOLD) {
            // draw the bolt if opaque
            c.drawPath(mBoltPath, mBoltPaint);
        } else {
            // otherwise cut the bolt out of the overall shape
            mShapePath.op(mBoltPath, Path.Op.DIFFERENCE);
        }
    } else if (mPowerSaveEnabled) {
        // define the plus shape
        final float pw = mFrame.width() * 2 / 3;
        final float pl = mFrame.left + (mFrame.width() - pw) / 2;
        final float pt = mFrame.top + (mFrame.height() - pw) / 2;
        final float pr = mFrame.right - (mFrame.width() - pw) / 2;
        final float pb = mFrame.bottom - (mFrame.height() - pw) / 2;
        if (mPlusFrame.left != pl || mPlusFrame.top != pt || mPlusFrame.right != pr || mPlusFrame.bottom != pb) {
            mPlusFrame.set(pl, pt, pr, pb);
            mPlusPath.reset();
            mPlusPath.moveTo(mPlusFrame.left + mPlusPoints[0] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[1] * mPlusFrame.height());
            for (int i = 2; i < mPlusPoints.length; i += 2) {
                mPlusPath.lineTo(mPlusFrame.left + mPlusPoints[i] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[i + 1] * mPlusFrame.height());
            }
            mPlusPath.lineTo(mPlusFrame.left + mPlusPoints[0] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[1] * mPlusFrame.height());
        }
        float boltPct = horizontal ? (mPlusFrame.left - levelTop) / (mPlusFrame.left - mPlusFrame.right) : (mPlusFrame.bottom - levelTop) / (mPlusFrame.bottom - mPlusFrame.top);
        boltPct = Math.min(Math.max(boltPct, 0), 1);
        if (boltPct <= BOLT_LEVEL_THRESHOLD) {
            // draw the bolt if opaque
            c.drawPath(mPlusPath, mPlusPaint);
        } else {
            // otherwise cut the bolt out of the overall shape
            mShapePath.op(mPlusPath, Path.Op.DIFFERENCE);
        }
    }
    // compute percentage text
    boolean pctOpaque = false;
    float pctX = 0, pctY = 0;
    String pctText = null;
    if (!mCharging && !mPowerSaveEnabled && level > mCriticalLevel && mShowPercent) {
        mTextPaint.setColor(getColorForLevel(level));
        final float full = horizontal ? 0.60f : 0.38f;
        final float nofull = horizontal ? 0.75f : 0.5f;
        final float single = horizontal ? 0.86f : 0.75f;
        mTextPaint.setTextSize(height * (SINGLE_DIGIT_PERCENT ? single : (mLevel == 100 ? full : nofull)));
        mTextHeight = -mTextPaint.getFontMetrics().ascent;
        pctText = String.valueOf(SINGLE_DIGIT_PERCENT ? (level / 10) : (level != 100 ? level : ""));
        pctX = mWidth * 0.5f;
        pctY = (mHeight + mTextHeight) * 0.47f;
        if (horizontal) {
            // Switch at 25% for landscape icon
            pctOpaque = level <= 25;
        } else {
            pctOpaque = levelTop > pctY;
        }
        if (!pctOpaque) {
            mTextPath.reset();
            mTextPaint.getTextPath(pctText, 0, pctText.length(), pctX, pctY, mTextPath);
            // cut the percentage text out of the overall shape
            mShapePath.op(mTextPath, Path.Op.DIFFERENCE);
        }
    }
    // draw the battery shape background
    c.drawPath(mShapePath, mFramePaint);
    // draw the battery shape, clipped to charging level
    if (horizontal) {
        mFrame.right = levelTop;
    } else {
        mFrame.top = levelTop;
    }
    mClipPath.reset();
    mClipPath.addRect(mFrame, Path.Direction.CCW);
    mShapePath.op(mClipPath, Path.Op.INTERSECT);
    c.drawPath(mShapePath, mBatteryPaint);
    if (!mCharging && !mPowerSaveEnabled) {
        if (level <= mCriticalLevel) {
            // draw the warning text
            final float x = mWidth * 0.5f;
            final float y = (mHeight + mWarningTextHeight) * 0.48f;
            c.drawText(mWarningString, x, y, mWarningTextPaint);
        } else if (pctOpaque) {
            // draw the percentage text
            c.drawText(pctText, pctX, pctY, mTextPaint);
        }
    }
}
#end_block

#method_before
private void drawCircle(Canvas c) {
    final int level = mLevel;
    final Rect bounds = getBounds();
    if (level == -1)
        return;
    final int circleSize = Math.min(mWidth, mHeight);
    float strokeWidth = circleSize / 6.5f;
    mFramePaint.setStrokeWidth(strokeWidth);
    mFramePaint.setStyle(Paint.Style.STROKE);
    mBatteryPaint.setStrokeWidth(strokeWidth);
    mBatteryPaint.setStyle(Paint.Style.STROKE);
    mFrame.set(strokeWidth / 2.0f + mPadding.left, strokeWidth / 2.0f, circleSize - strokeWidth / 2.0f + mPadding.left, circleSize - strokeWidth / 2.0f);
    // set the battery charging color
    mBatteryPaint.setColor(batteryColorForLevel(level));
    if (mCharging) {
        // define the bolt shape
        // Shift right by 1px for maximal bolt-goodness
        final float bl = mFrame.left + mFrame.width() / 3.2f;
        final float bt = mFrame.top + mFrame.height() / 4f;
        final float br = mFrame.right - mFrame.width() / 5.2f;
        final float bb = mFrame.bottom - mFrame.height() / 8f;
        if (mBoltFrame.left != bl || mBoltFrame.top != bt || mBoltFrame.right != br || mBoltFrame.bottom != bb) {
            mBoltFrame.set(bl, bt, br, bb);
            mBoltPath.reset();
            mBoltPath.moveTo(mBoltFrame.left + mBoltPoints[0] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[1] * mBoltFrame.height());
            for (int i = 2; i < mBoltPoints.length; i += 2) {
                mBoltPath.lineTo(mBoltFrame.left + mBoltPoints[i] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[i + 1] * mBoltFrame.height());
            }
            mBoltPath.lineTo(mBoltFrame.left + mBoltPoints[0] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[1] * mBoltFrame.height());
        }
        float boltPct = mBoltFrame.bottom / (mBoltFrame.bottom - mBoltFrame.top);
        boltPct = Math.min(Math.max(boltPct, 0), 1);
        if (boltPct <= BOLT_LEVEL_THRESHOLD) {
            // draw the bolt if opaque
            c.drawPath(mBoltPath, mBoltPaint);
        }
    } else if (mPowerSaveEnabled) {
        // define the plus shape
        final float pw = mFrame.width() * 2 / 3;
        final float pl = mFrame.left + (mFrame.width() - pw) / 2;
        final float pt = mFrame.top + (mFrame.height() - pw) / 2;
        final float pr = mFrame.right - (mFrame.width() - pw) / 2;
        final float pb = mFrame.bottom - (mFrame.height() - pw) / 2;
        if (mPlusFrame.left != pl || mPlusFrame.top != pt || mPlusFrame.right != pr || mPlusFrame.bottom != pb) {
            mPlusFrame.set(pl, pt, pr, pb);
            mPlusPath.reset();
            mPlusPath.moveTo(mPlusFrame.left + mPlusPoints[0] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[1] * mPlusFrame.height());
            for (int i = 2; i < mPlusPoints.length; i += 2) {
                mPlusPath.lineTo(mPlusFrame.left + mPlusPoints[i] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[i + 1] * mPlusFrame.height());
            }
            mPlusPath.lineTo(mPlusFrame.left + mPlusPoints[0] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[1] * mPlusFrame.height());
        }
        float boltPct = mPlusFrame.bottom / (mPlusFrame.bottom - mPlusFrame.top);
        boltPct = Math.min(Math.max(boltPct, 0), 1);
        if (boltPct <= BOLT_LEVEL_THRESHOLD) {
            // draw the bolt if opaque
            c.drawPath(mPlusPath, mPlusPaint);
        }
    }
    // draw thin gray ring first
    c.drawArc(mFrame, 270, 360, false, mFramePaint);
    // draw colored arc representing charge level
    if (level > 0) {
        c.drawArc(mFrame, 270, 3.6f * level, false, mBatteryPaint);
    }
    if (!mCharging && !mPowerSaveEnabled) {
        if (level <= mCriticalLevel) {
            // draw the warning text
            float x = circleSize / 2.0f + mPadding.left;
            float y = circleSize / 2.0f + (bounds.bottom - bounds.top) / 2.0f - strokeWidth / 2.0f + mContext.getResources().getDisplayMetrics().density;
            c.drawText(mWarningString, x, y, mWarningTextPaint);
        }
    }
}
#method_after
private void drawCircle(Canvas c) {
    final int level = mLevel;
    final Rect bounds = getBounds();
    if (level == -1)
        return;
    final int circleSize = Math.min(mWidth, mHeight);
    float strokeWidth = circleSize / 6.5f;
    mBoltPoints = loadPoints(mContext.getResources(), R.array.batterymeter_bolt_points);
    mFramePaint.setStrokeWidth(strokeWidth);
    mFramePaint.setStyle(Paint.Style.STROKE);
    mBatteryPaint.setStrokeWidth(strokeWidth);
    mBatteryPaint.setStyle(Paint.Style.STROKE);
    mFrame.set(strokeWidth / 2.0f + mPadding.left, strokeWidth / 2.0f, circleSize - strokeWidth / 2.0f + mPadding.left, circleSize - strokeWidth / 2.0f);
    // set the battery charging color
    mBatteryPaint.setColor(batteryColorForLevel(level));
    // draw thin gray ring first
    c.drawArc(mFrame, 270, 360, false, mFramePaint);
    // draw colored arc representing charge level
    if (level > 0) {
        c.drawArc(mFrame, 270, 3.6f * level, false, mBatteryPaint);
    }
    if (mCharging) {
        // define the bolt shape
        // Shift right by 1px for maximal bolt-goodness
        final float bl = mFrame.left + mFrame.width() / 3.2f;
        final float bt = mFrame.top + mFrame.height() / 4f;
        final float br = mFrame.right - mFrame.width() / 5.2f;
        final float bb = mFrame.bottom - mFrame.height() / 8f;
        if (mBoltFrame.left != bl || mBoltFrame.top != bt || mBoltFrame.right != br || mBoltFrame.bottom != bb) {
            mBoltFrame.set(bl, bt, br, bb);
            mBoltPath.reset();
            mBoltPath.moveTo(mBoltFrame.left + mBoltPoints[0] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[1] * mBoltFrame.height());
            for (int i = 2; i < mBoltPoints.length; i += 2) {
                mBoltPath.lineTo(mBoltFrame.left + mBoltPoints[i] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[i + 1] * mBoltFrame.height());
            }
            mBoltPath.lineTo(mBoltFrame.left + mBoltPoints[0] * mBoltFrame.width(), mBoltFrame.top + mBoltPoints[1] * mBoltFrame.height());
        }
        // draw the bolt
        c.drawPath(mBoltPath, mBoltPaint);
    } else if (mPowerSaveEnabled) {
        // define the plus shape
        final float pw = mFrame.width() * 2 / 3;
        final float pl = mFrame.left + (mFrame.width() - pw) / 2;
        final float pt = mFrame.top + (mFrame.height() - pw) / 2;
        final float pr = mFrame.right - (mFrame.width() - pw) / 2;
        final float pb = mFrame.bottom - (mFrame.height() - pw) / 2;
        if (mPlusFrame.left != pl || mPlusFrame.top != pt || mPlusFrame.right != pr || mPlusFrame.bottom != pb) {
            mPlusFrame.set(pl, pt, pr, pb);
            mPlusPath.reset();
            mPlusPath.moveTo(mPlusFrame.left + mPlusPoints[0] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[1] * mPlusFrame.height());
            for (int i = 2; i < mPlusPoints.length; i += 2) {
                mPlusPath.lineTo(mPlusFrame.left + mPlusPoints[i] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[i + 1] * mPlusFrame.height());
            }
            mPlusPath.lineTo(mPlusFrame.left + mPlusPoints[0] * mPlusFrame.width(), mPlusFrame.top + mPlusPoints[1] * mPlusFrame.height());
        }
        // draw the plus
        c.drawPath(mPlusPath, mPlusPaint);
    }
    float pctX = 0, pctY = 0;
    String pctText = null;
    if (!mCharging && !mPowerSaveEnabled && level > mCriticalLevel && mShowPercent) {
        mTextPaint.setColor(mBoltPaint.getColor());
        mTextPaint.setTextSize(mHeight * (SINGLE_DIGIT_PERCENT ? 0.38f : (mLevel == 100 ? 0.75f : 0.5f)));
        mTextHeight = -mTextPaint.getFontMetrics().ascent;
        pctText = String.valueOf(SINGLE_DIGIT_PERCENT ? (level / 10) : (level != 100 ? level : ""));
        pctX = mWidth * 0.5f;
        pctY = (mHeight + mTextHeight) * 0.47f;
        c.drawText(pctText, pctX, pctY, mTextPaint);
    }
    if (!mCharging && !mPowerSaveEnabled) {
        if (level <= mCriticalLevel) {
            // draw the warning text
            float x = circleSize / 2.0f + mPadding.left;
            float y = circleSize / 2.0f + (bounds.bottom - bounds.top) / 2.0f - strokeWidth / 2.0f + mContext.getResources().getDisplayMetrics().density;
            c.drawText(mWarningString, x, y, mWarningTextPaint);
        }
    }
}
#end_block

#method_before
private void updateShowPercent() {
    final boolean showing = mBatteryPercentView != null;
    if (0 != Settings.System.getIntForUser(getContext().getContentResolver(), SHOW_BATTERY_PERCENT, 0, mUser) || mForceShowPercent) {
        if (!showing) {
            mBatteryPercentView = loadPercentView();
            if (mTextColor != 0)
                mBatteryPercentView.setTextColor(mTextColor);
            updatePercentText();
            addView(mBatteryPercentView, 0, new ViewGroup.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT));
        }
    } else {
        if (showing) {
            removeView(mBatteryPercentView);
            mBatteryPercentView = null;
        }
    }
}
#method_after
private void updateShowPercent() {
    final boolean showing = mBatteryPercentView != null;
    int style = Settings.System.getIntForUser(getContext().getContentResolver(), SHOW_BATTERY_PERCENT, 0, mUser);
    if (mForceShowPercent) {
        // Default view
        style = 1;
    }
    switch(style) {
        case 1:
            if (!showing) {
                mBatteryPercentView = loadPercentView();
                if (mTextColor != 0)
                    mBatteryPercentView.setTextColor(mTextColor);
                updatePercentText();
                addView(mBatteryPercentView, 0, new ViewGroup.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT));
            }
            mDrawable.setShowPercent(false);
            break;
        case 2:
            if (showing) {
                removeView(mBatteryPercentView);
                mBatteryPercentView = null;
            }
            mDrawable.setShowPercent(true);
            break;
        default:
            if (showing) {
                removeView(mBatteryPercentView);
                mBatteryPercentView = null;
            }
            mDrawable.setShowPercent(false);
            break;
    }
}
#end_block

#method_before
private int getScreenAnimationModeForDisplayState(int displayState) {
    switch(mScreenOffAnimation) {
        case SCREEN_OFF_SIMPLE_FADE:
            return ScreenStateAnimator.MODE_FADE;
        case SCREEN_OFF_COLOR_FADE:
            if (displayState == Display.STATE_OFF) {
                return ScreenStateAnimator.MODE_COOL_DOWN;
            } else {
                return mScreenOnAnimation ? ScreenStateAnimator.MODE_WARM_UP : ScreenStateAnimator.MODE_FADE;
            }
        case SCREEN_OFF_CRT:
            if (displayState == Display.STATE_OFF) {
                return ScreenStateAnimator.MODE_COOL_DOWN;
            } else {
                return mScreenOnAnimation ? ScreenStateAnimator.MODE_WARM_UP : ScreenStateAnimator.MODE_FADE;
            }
        case SCREEN_OFF_SCALE:
            if (displayState == Display.STATE_OFF) {
                return ScreenStateAnimator.MODE_SCALE_DOWN;
            } else {
                return ScreenStateAnimator.MODE_FADE;
            }
        default:
            return ScreenStateAnimator.MODE_FADE;
    }
}
#method_after
private int getScreenAnimationModeForDisplayState(int displayState) {
    switch(mScreenOffAnimation) {
        case SCREEN_OFF_FADE:
            return ScreenStateAnimator.MODE_FADE;
        case SCREEN_OFF_CRT:
            if (displayState == Display.STATE_OFF) {
                return ScreenStateAnimator.MODE_COOL_DOWN;
            } else {
                return USE_COLOR_FADE_ON_ANIMATION ? ScreenStateAnimator.MODE_WARM_UP : ScreenStateAnimator.MODE_FADE;
            }
        case SCREEN_OFF_SCALE:
            if (displayState == Display.STATE_OFF) {
                return ScreenStateAnimator.MODE_SCALE_DOWN;
            } else {
                return ScreenStateAnimator.MODE_FADE;
            }
        default:
            return ScreenStateAnimator.MODE_FADE;
    }
}
#end_block

#method_before
private void initialize() {
    // Initialize the power state object for the default display.
    // In the future, we might manage multiple displays independently.
    final ContentResolver cr = mContext.getContentResolver();
    final ContentObserver observer = new ContentObserver(mHandler) {

        @Override
        public void onChange(boolean selfChange, Uri uri) {
            mScreenOffAnimation = Settings.System.getIntForUser(cr, Settings.System.SCREEN_OFF_ANIMATION, SCREEN_OFF_CRT, UserHandle.USER_CURRENT);
            mScreenOnAnimation = Settings.System.getIntForUser(cr, Settings.System.SCREEN_OFF_ANIMATION, 0, UserHandle.USER_CURRENT) != 0;
            if (mPowerState != null) {
                mPowerState.setScreenStateAnimator(mScreenOffAnimation);
            }
        }
    };
    cr.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_ANIMATION), false, observer, UserHandle.USER_ALL);
    cr.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_ON_ANIMATION), false, observer, UserHandle.USER_ALL);
    mScreenOffAnimation = Settings.System.getIntForUser(cr, Settings.System.SCREEN_OFF_ANIMATION, SCREEN_OFF_CRT, UserHandle.USER_CURRENT);
    mScreenOnAnimation = Settings.System.getIntForUser(cr, Settings.System.SCREEN_OFF_ANIMATION, 1, UserHandle.USER_CURRENT) != 0;
    mPowerState = new DisplayPowerState(mBlanker, mScreenOffAnimation);
    if (mColorFadeEnabled) {
        mColorFadeOnAnimator = ObjectAnimator.ofFloat(mPowerState, DisplayPowerState.COLOR_FADE_LEVEL, 0.0f, 1.0f);
        mColorFadeOnAnimator.setDuration(COLOR_FADE_ON_ANIMATION_DURATION_MILLIS);
        mColorFadeOnAnimator.addListener(mAnimatorListener);
        mColorFadeOffAnimator = ObjectAnimator.ofFloat(mPowerState, DisplayPowerState.COLOR_FADE_LEVEL, 1.0f, 0.0f);
        mColorFadeOffAnimator.setDuration(COLOR_FADE_OFF_ANIMATION_DURATION_MILLIS);
        mColorFadeOffAnimator.addListener(mAnimatorListener);
    }
    mScreenBrightnessRampAnimator = new RampAnimator<DisplayPowerState>(mPowerState, DisplayPowerState.SCREEN_BRIGHTNESS);
    mScreenBrightnessRampAnimator.setListener(mRampAnimatorListener);
    // Initialize screen state for battery stats.
    try {
        mBatteryStats.noteScreenState(mPowerState.getScreenState());
        mBatteryStats.noteScreenBrightness(mPowerState.getScreenBrightness());
    } catch (RemoteException ex) {
    // same process
    }
}
#method_after
private void initialize() {
    // Initialize the power state object for the default display.
    // In the future, we might manage multiple displays independently.
    final ContentResolver cr = mContext.getContentResolver();
    final ContentObserver observer = new ContentObserver(mHandler) {

        @Override
        public void onChange(boolean selfChange, Uri uri) {
            mScreenOffAnimation = Settings.System.getIntForUser(cr, Settings.System.SCREEN_OFF_ANIMATION, SCREEN_OFF_FADE, UserHandle.USER_CURRENT);
            if (mPowerState != null) {
                mPowerState.setScreenStateAnimator(mScreenOffAnimation);
            }
        }
    };
    cr.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_ANIMATION), false, observer, UserHandle.USER_ALL);
    mScreenOffAnimation = Settings.System.getIntForUser(cr, Settings.System.SCREEN_OFF_ANIMATION, SCREEN_OFF_FADE, UserHandle.USER_CURRENT);
    mPowerState = new DisplayPowerState(mBlanker, mScreenOffAnimation);
    if (mColorFadeEnabled) {
        mColorFadeOnAnimator = ObjectAnimator.ofFloat(mPowerState, DisplayPowerState.COLOR_FADE_LEVEL, 0.0f, 1.0f);
        mColorFadeOnAnimator.setDuration(COLOR_FADE_ON_ANIMATION_DURATION_MILLIS);
        mColorFadeOnAnimator.addListener(mAnimatorListener);
        mColorFadeOffAnimator = ObjectAnimator.ofFloat(mPowerState, DisplayPowerState.COLOR_FADE_LEVEL, 1.0f, 0.0f);
        mColorFadeOffAnimator.setDuration(COLOR_FADE_OFF_ANIMATION_DURATION_MILLIS);
        mColorFadeOffAnimator.addListener(mAnimatorListener);
    }
    mScreenBrightnessRampAnimator = new RampAnimator<DisplayPowerState>(mPowerState, DisplayPowerState.SCREEN_BRIGHTNESS);
    mScreenBrightnessRampAnimator.setListener(mRampAnimatorListener);
    // Initialize screen state for battery stats.
    try {
        mBatteryStats.noteScreenState(mPowerState.getScreenState());
        mBatteryStats.noteScreenBrightness(mPowerState.getScreenBrightness());
    } catch (RemoteException ex) {
    // same process
    }
}
#end_block

#method_before
private void animateScreenStateChange(int target, boolean performScreenOffTransition) {
    // If there is already an animation in progress, don't interfere with it.
    if (mColorFadeEnabled && (mColorFadeOnAnimator.isStarted() || mColorFadeOffAnimator.isStarted())) {
        if (target != Display.STATE_ON) {
            return;
        }
        // If display state changed to on, proceed and stop the color fade and turn screen on.
        mPendingScreenOff = false;
    }
    if (mDisplayBlanksAfterDozeConfig && Display.isDozeState(mPowerState.getScreenState()) && !Display.isDozeState(target)) {
        // Skip the screen off animation and add a black surface to hide the
        // contents of the screen.
        mPowerState.prepareColorFade(mContext, getScreenAnimationModeForDisplayState(Display.STATE_ON));
        if (mColorFadeOffAnimator != null) {
            mColorFadeOffAnimator.end();
        }
        // Some display hardware will blank itself on the transition between doze and non-doze
        // but still on display states. In this case we want to report to policy that the
        // display has turned off so it can prepare the appropriate power on animation, but we
        // don't want to actually transition to the fully off state since that takes
        // significantly longer to transition from.
        setScreenState(Display.STATE_OFF, target != Display.STATE_OFF);
    }
    // to screen on if we skipped blocking screen on as usual.
    if (mPendingScreenOff && target != Display.STATE_OFF) {
        setScreenState(Display.STATE_OFF);
        mPendingScreenOff = false;
        mPowerState.dismissColorFadeResources();
    }
    if (target == Display.STATE_ON) {
        // its last frame of animation is solid black.
        if (!setScreenState(Display.STATE_ON)) {
            // screen on blocked
            return;
        }
        if (mScreenOnAnimation && mColorFadeEnabled && mPowerRequest.isBrightOrDim()) {
            // Perform screen on animation.
            if (mPowerState.getColorFadeLevel() == 1.0f) {
                mPowerState.dismissColorFade();
            } else if (mPowerState.prepareColorFade(mContext, getScreenAnimationModeForDisplayState(Display.STATE_ON))) {
                mColorFadeOnAnimator.start();
            } else {
                mColorFadeOnAnimator.end();
            }
        } else {
            // Skip screen on animation.
            mPowerState.setColorFadeLevel(1.0f);
            mPowerState.dismissColorFade();
        }
    } else if (target == Display.STATE_VR) {
        // differently when the display is configured for dozing.
        if (mScreenBrightnessRampAnimator.isAnimating() && mPowerState.getScreenState() == Display.STATE_ON) {
            return;
        }
        // Set screen state.
        if (!setScreenState(Display.STATE_VR)) {
            // screen on blocked
            return;
        }
        // Dismiss the black surface without fanfare.
        mPowerState.setColorFadeLevel(1.0f);
        mPowerState.dismissColorFade();
    } else if (target == Display.STATE_DOZE) {
        // differently when the display is configured for dozing.
        if (mScreenBrightnessRampAnimator.isAnimating() && mPowerState.getScreenState() == Display.STATE_ON) {
            return;
        }
        // Set screen state.
        if (!setScreenState(Display.STATE_DOZE)) {
            // screen on blocked
            return;
        }
        // Dismiss the black surface without fanfare.
        mPowerState.setColorFadeLevel(1.0f);
        mPowerState.dismissColorFade();
    } else if (target == Display.STATE_DOZE_SUSPEND) {
        // suspended because we may not be able to change it after suspension.
        if (mScreenBrightnessRampAnimator.isAnimating() && mPowerState.getScreenState() != Display.STATE_DOZE_SUSPEND) {
            return;
        }
        // screen on is unblocked, then suspend.
        if (mPowerState.getScreenState() != Display.STATE_DOZE_SUSPEND) {
            if (!setScreenState(Display.STATE_DOZE)) {
                // screen on blocked
                return;
            }
            // already on so can't block
            setScreenState(Display.STATE_DOZE_SUSPEND);
        }
        // Dismiss the black surface without fanfare.
        mPowerState.setColorFadeLevel(1.0f);
        mPowerState.dismissColorFade();
    } else {
        // Want screen off.
        mPendingScreenOff = true;
        if (!mColorFadeEnabled) {
            mPowerState.setColorFadeLevel(0.0f);
        }
        if (mPowerState.getColorFadeLevel() == 0.0f) {
            // Turn the screen off.
            // A black surface is already hiding the contents of the screen.
            setScreenState(Display.STATE_OFF);
            mPendingScreenOff = false;
            mPowerState.dismissColorFadeResources();
        } else if (performScreenOffTransition && mPowerState.prepareColorFade(mContext, getScreenAnimationModeForDisplayState(Display.STATE_OFF)) && mPowerState.getScreenState() != Display.STATE_OFF) {
            // Perform the screen off animation.
            mColorFadeOffAnimator.start();
        } else {
            // Skip the screen off animation and add a black surface to hide the
            // contents of the screen.
            mColorFadeOffAnimator.end();
        }
    }
}
#method_after
private void animateScreenStateChange(int target, boolean performScreenOffTransition) {
    // If there is already an animation in progress, don't interfere with it.
    if (mColorFadeEnabled && (mColorFadeOnAnimator.isStarted() || mColorFadeOffAnimator.isStarted())) {
        if (target != Display.STATE_ON) {
            return;
        }
        // If display state changed to on, proceed and stop the color fade and turn screen on.
        mPendingScreenOff = false;
    }
    if (mDisplayBlanksAfterDozeConfig && Display.isDozeState(mPowerState.getScreenState()) && !Display.isDozeState(target)) {
        // Skip the screen off animation and add a black surface to hide the
        // contents of the screen.
        mPowerState.prepareColorFade(mContext, getScreenAnimationModeForDisplayState(Display.STATE_ON));
        if (mColorFadeOffAnimator != null) {
            mColorFadeOffAnimator.end();
        }
        // Some display hardware will blank itself on the transition between doze and non-doze
        // but still on display states. In this case we want to report to policy that the
        // display has turned off so it can prepare the appropriate power on animation, but we
        // don't want to actually transition to the fully off state since that takes
        // significantly longer to transition from.
        setScreenState(Display.STATE_OFF, target != Display.STATE_OFF);
    }
    // to screen on if we skipped blocking screen on as usual.
    if (mPendingScreenOff && target != Display.STATE_OFF) {
        setScreenState(Display.STATE_OFF);
        mPendingScreenOff = false;
        mPowerState.dismissColorFadeResources();
    }
    if (target == Display.STATE_ON) {
        // its last frame of animation is solid black.
        if (!setScreenState(Display.STATE_ON)) {
            // screen on blocked
            return;
        }
        if (USE_COLOR_FADE_ON_ANIMATION && mColorFadeEnabled && mPowerRequest.isBrightOrDim()) {
            // Perform screen on animation.
            if (mPowerState.getColorFadeLevel() == 1.0f) {
                mPowerState.dismissColorFade();
            } else if (mPowerState.prepareColorFade(mContext, getScreenAnimationModeForDisplayState(Display.STATE_ON))) {
                mColorFadeOnAnimator.start();
            } else {
                mColorFadeOnAnimator.end();
            }
        } else {
            // Skip screen on animation.
            mPowerState.setColorFadeLevel(1.0f);
            mPowerState.dismissColorFade();
        }
    } else if (target == Display.STATE_VR) {
        // differently when the display is configured for dozing.
        if (mScreenBrightnessRampAnimator.isAnimating() && mPowerState.getScreenState() == Display.STATE_ON) {
            return;
        }
        // Set screen state.
        if (!setScreenState(Display.STATE_VR)) {
            // screen on blocked
            return;
        }
        // Dismiss the black surface without fanfare.
        mPowerState.setColorFadeLevel(1.0f);
        mPowerState.dismissColorFade();
    } else if (target == Display.STATE_DOZE) {
        // differently when the display is configured for dozing.
        if (mScreenBrightnessRampAnimator.isAnimating() && mPowerState.getScreenState() == Display.STATE_ON) {
            return;
        }
        // Set screen state.
        if (!setScreenState(Display.STATE_DOZE)) {
            // screen on blocked
            return;
        }
        // Dismiss the black surface without fanfare.
        mPowerState.setColorFadeLevel(1.0f);
        mPowerState.dismissColorFade();
    } else if (target == Display.STATE_DOZE_SUSPEND) {
        // suspended because we may not be able to change it after suspension.
        if (mScreenBrightnessRampAnimator.isAnimating() && mPowerState.getScreenState() != Display.STATE_DOZE_SUSPEND) {
            return;
        }
        // screen on is unblocked, then suspend.
        if (mPowerState.getScreenState() != Display.STATE_DOZE_SUSPEND) {
            if (!setScreenState(Display.STATE_DOZE)) {
                // screen on blocked
                return;
            }
            // already on so can't block
            setScreenState(Display.STATE_DOZE_SUSPEND);
        }
        // Dismiss the black surface without fanfare.
        mPowerState.setColorFadeLevel(1.0f);
        mPowerState.dismissColorFade();
    } else {
        // Want screen off.
        mPendingScreenOff = true;
        if (!mColorFadeEnabled) {
            mPowerState.setColorFadeLevel(0.0f);
        }
        if (mPowerState.getColorFadeLevel() == 0.0f) {
            // Turn the screen off.
            // A black surface is already hiding the contents of the screen.
            setScreenState(Display.STATE_OFF);
            mPendingScreenOff = false;
            mPowerState.dismissColorFadeResources();
        } else if (performScreenOffTransition && mPowerState.prepareColorFade(mContext, getScreenAnimationModeForDisplayState(Display.STATE_OFF)) && mPowerState.getScreenState() != Display.STATE_OFF) {
            // Perform the screen off animation.
            mColorFadeOffAnimator.start();
        } else {
            // Skip the screen off animation and add a black surface to hide the
            // contents of the screen.
            mColorFadeOffAnimator.end();
        }
    }
}
#end_block

#method_before
public void setScreenStateAnimator(int mode) {
    if (mColorFade != null) {
        mColorFade.dismiss();
    }
    if (mode == DisplayPowerController.SCREEN_OFF_SIMPLE_FADE || mode == DisplayPowerController.SCREEN_OFF_COLOR_FADE) {
        mColorFade = new ColorFade(Display.DEFAULT_DISPLAY);
    } else {
        mColorFade = new ElectronBeam(Display.DEFAULT_DISPLAY);
    }
}
#method_after
public void setScreenStateAnimator(int mode) {
    if (mColorFade != null) {
        mColorFade.dismiss();
    }
    if (mode == DisplayPowerController.SCREEN_OFF_FADE) {
        mColorFade = new ColorFade(Display.DEFAULT_DISPLAY);
    } else {
        mColorFade = new ElectronBeam(Display.DEFAULT_DISPLAY);
    }
}
#end_block

#method_before
public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) {
    int[] appOp = new int[1];
    int res = mPolicy.checkAddPermission(attrs, appOp);
    if (res != WindowManagerGlobal.ADD_OKAY) {
        return res;
    }
    boolean reportNewConfig = false;
    WindowState parentWindow = null;
    long origId;
    final int callingUid = Binder.getCallingUid();
    final int type = attrs.type;
    synchronized (mWindowMap) {
        if (!mDisplayReady) {
            throw new IllegalStateException("Display has not been initialialized");
        }
        final DisplayContent displayContent = mRoot.getDisplayContentOrCreate(displayId);
        if (displayContent == null) {
            Slog.w(TAG_WM, "Attempted to add window to a display that does not exist: " + displayId + ".  Aborting.");
            return WindowManagerGlobal.ADD_INVALID_DISPLAY;
        }
        if (!displayContent.hasAccess(session.mUid) && !mDisplayManagerInternal.isUidPresentOnDisplay(session.mUid, displayId)) {
            Slog.w(TAG_WM, "Attempted to add window to a display for which the application " + "does not have access: " + displayId + ".  Aborting.");
            return WindowManagerGlobal.ADD_INVALID_DISPLAY;
        }
        if (mWindowMap.containsKey(client.asBinder())) {
            Slog.w(TAG_WM, "Window " + client + " is already added");
            return WindowManagerGlobal.ADD_DUPLICATE_ADD;
        }
        if (type >= FIRST_SUB_WINDOW && type <= LAST_SUB_WINDOW) {
            parentWindow = windowForClientLocked(null, attrs.token, false);
            if (parentWindow == null) {
                Slog.w(TAG_WM, "Attempted to add window with token that is not a window: " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
            }
            if (parentWindow.mAttrs.type >= FIRST_SUB_WINDOW && parentWindow.mAttrs.type <= LAST_SUB_WINDOW) {
                Slog.w(TAG_WM, "Attempted to add window with token that is a sub-window: " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
            }
        }
        if (type == TYPE_PRIVATE_PRESENTATION && !displayContent.isPrivate()) {
            Slog.w(TAG_WM, "Attempted to add private presentation window to a non-private display.  Aborting.");
            return WindowManagerGlobal.ADD_PERMISSION_DENIED;
        }
        AppWindowToken atoken = null;
        final boolean hasParent = parentWindow != null;
        // Use existing parent window token for child windows since they go in the same token
        // as there parent window so we can apply the same policy on them.
        WindowToken token = displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token);
        // If this is a child window, we want to apply the same type checking rules as the
        // parent window type.
        final int rootType = hasParent ? parentWindow.mAttrs.type : type;
        boolean addToastWindowRequiresToken = false;
        if (token == null) {
            if (rootType >= FIRST_APPLICATION_WINDOW && rootType <= LAST_APPLICATION_WINDOW) {
                Slog.w(TAG_WM, "Attempted to add application window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_INPUT_METHOD) {
                Slog.w(TAG_WM, "Attempted to add input method window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_VOICE_INTERACTION) {
                Slog.w(TAG_WM, "Attempted to add voice interaction window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_WALLPAPER) {
                Slog.w(TAG_WM, "Attempted to add wallpaper window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_DREAM) {
                Slog.w(TAG_WM, "Attempted to add Dream window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_QS_DIALOG) {
                Slog.w(TAG_WM, "Attempted to add QS dialog window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_ACCESSIBILITY_OVERLAY) {
                Slog.w(TAG_WM, "Attempted to add Accessibility overlay window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (type == TYPE_TOAST) {
                // Apps targeting SDK above N MR1 cannot arbitrary add toast windows.
                if (doesAddToastWindowRequireToken(attrs.packageName, callingUid, parentWindow)) {
                    Slog.w(TAG_WM, "Attempted to add a toast window with unknown token " + attrs.token + ".  Aborting.");
                    return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
                }
            }
            final IBinder binder = attrs.token != null ? attrs.token : client.asBinder();
            token = new WindowToken(this, binder, type, false, displayContent, session.mCanAddInternalSystemWindow);
        } else if (rootType >= FIRST_APPLICATION_WINDOW && rootType <= LAST_APPLICATION_WINDOW) {
            atoken = token.asAppWindowToken();
            if (atoken == null) {
                Slog.w(TAG_WM, "Attempted to add window with non-application token " + token + ".  Aborting.");
                return WindowManagerGlobal.ADD_NOT_APP_TOKEN;
            } else if (atoken.removed) {
                Slog.w(TAG_WM, "Attempted to add window with exiting application token " + token + ".  Aborting.");
                return WindowManagerGlobal.ADD_APP_EXITING;
            }
        } else if (rootType == TYPE_INPUT_METHOD) {
            if (token.windowType != TYPE_INPUT_METHOD) {
                Slog.w(TAG_WM, "Attempted to add input method window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (rootType == TYPE_VOICE_INTERACTION) {
            if (token.windowType != TYPE_VOICE_INTERACTION) {
                Slog.w(TAG_WM, "Attempted to add voice interaction window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (rootType == TYPE_WALLPAPER) {
            if (token.windowType != TYPE_WALLPAPER) {
                Slog.w(TAG_WM, "Attempted to add wallpaper window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (rootType == TYPE_DREAM) {
            if (token.windowType != TYPE_DREAM) {
                Slog.w(TAG_WM, "Attempted to add Dream window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (rootType == TYPE_ACCESSIBILITY_OVERLAY) {
            if (token.windowType != TYPE_ACCESSIBILITY_OVERLAY) {
                Slog.w(TAG_WM, "Attempted to add Accessibility overlay window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (type == TYPE_TOAST) {
            // Apps targeting SDK above N MR1 cannot arbitrary add toast windows.
            addToastWindowRequiresToken = doesAddToastWindowRequireToken(attrs.packageName, callingUid, parentWindow);
            if (addToastWindowRequiresToken && token.windowType != TYPE_TOAST) {
                Slog.w(TAG_WM, "Attempted to add a toast window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (type == TYPE_QS_DIALOG) {
            if (token.windowType != TYPE_QS_DIALOG) {
                Slog.w(TAG_WM, "Attempted to add QS dialog window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (token.asAppWindowToken() != null) {
            Slog.w(TAG_WM, "Non-null appWindowToken for system window of rootType=" + rootType);
            // It is not valid to use an app token with other system types; we will
            // instead make a new token for it (as if null had been passed in for the token).
            attrs.token = null;
            token = new WindowToken(this, client.asBinder(), type, false, displayContent, session.mCanAddInternalSystemWindow);
        }
        final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], seq, attrs, viewVisibility, session.mUid, session.mCanAddInternalSystemWindow);
        if (win.mDeathRecipient == null) {
            // Client has apparently died, so there is no reason to
            // continue.
            Slog.w(TAG_WM, "Adding window client " + client.asBinder() + " that is dead, aborting.");
            return WindowManagerGlobal.ADD_APP_EXITING;
        }
        if (win.getDisplayContent() == null) {
            Slog.w(TAG_WM, "Adding window to Display that has been removed.");
            return WindowManagerGlobal.ADD_INVALID_DISPLAY;
        }
        mPolicy.adjustWindowParamsLw(win.mAttrs);
        win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs));
        res = mPolicy.prepareAddWindowLw(win, attrs);
        if (res != WindowManagerGlobal.ADD_OKAY) {
            return res;
        }
        final boolean openInputChannels = (outInputChannel != null && (attrs.inputFeatures & INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);
        if (openInputChannels) {
            win.openInputChannel(outInputChannel);
        }
        // schedule hiding all of its toast windows.
        if (type == TYPE_TOAST) {
            if (!getDefaultDisplayContentLocked().canAddToastWindowForUid(callingUid)) {
                Slog.w(TAG_WM, "Adding more than one toast window for UID at a time.");
                return WindowManagerGlobal.ADD_DUPLICATE_ADD;
            }
            // the screen after the activity goes away.
            if (addToastWindowRequiresToken || (attrs.flags & LayoutParams.FLAG_NOT_FOCUSABLE) == 0 || mCurrentFocus == null || mCurrentFocus.mOwnerUid != callingUid) {
                mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_HIDE_TIMEOUT, win), win.mAttrs.hideTimeoutMilliseconds);
            }
        }
        // From now on, no exceptions or errors allowed!
        res = WindowManagerGlobal.ADD_OKAY;
        if (mCurrentFocus == null) {
            mWinAddedSinceNullFocus.add(win);
        }
        if (excludeWindowTypeFromTapOutTask(type)) {
            displayContent.mTapExcludedWindows.add(win);
        }
        origId = Binder.clearCallingIdentity();
        win.attach();
        mWindowMap.put(client.asBinder(), win);
        if (win.mAppOp != AppOpsManager.OP_NONE) {
            int startOpResult = mAppOps.startOpNoThrow(win.mAppOp, win.getOwningUid(), win.getOwningPackage());
            if ((startOpResult != AppOpsManager.MODE_ALLOWED) && (startOpResult != AppOpsManager.MODE_DEFAULT)) {
                win.setAppOpVisibilityLw(false);
            }
        }
        final AppWindowToken aToken = token.asAppWindowToken();
        if (type == TYPE_APPLICATION_STARTING && aToken != null) {
            aToken.startingWindow = win;
            if (DEBUG_STARTING_WINDOW)
                Slog.v(TAG_WM, "addWindow: " + aToken + " startingWindow=" + win);
        }
        boolean imMayMove = true;
        win.mToken.addWindow(win);
        if (type == TYPE_INPUT_METHOD) {
            win.mGivenInsetsPending = true;
            setInputMethodWindowLocked(win);
            imMayMove = false;
        } else if (type == TYPE_INPUT_METHOD_DIALOG) {
            displayContent.computeImeTarget(true);
            imMayMove = false;
        } else {
            if (type == TYPE_WALLPAPER) {
                displayContent.mWallpaperController.clearLastWallpaperTimeoutTime();
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
            } else if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
            } else if (displayContent.mWallpaperController.isBelowWallpaperTarget(win)) {
                // If there is currently a wallpaper being shown, and
                // the base layer of the new window is below the current
                // layer of the target window, then adjust the wallpaper.
                // This is to avoid a new window being placed between the
                // wallpaper and its target.
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
            }
        }
        // If the window is being added to a stack that's currently adjusted for IME,
        // make sure to apply the same adjust to this new window.
        win.applyAdjustForImeIfNeeded();
        if (type == TYPE_DOCK_DIVIDER) {
            mRoot.getDisplayContent(displayId).getDockedDividerController().setWindow(win);
        }
        final WindowStateAnimator winAnimator = win.mWinAnimator;
        winAnimator.mEnterAnimationPending = true;
        winAnimator.mEnteringAnimation = true;
        // Check if we need to prepare a transition for replacing window first.
        if (atoken != null && atoken.isVisible() && !prepareWindowReplacementTransition(atoken)) {
            // If not, check if need to set up a dummy transition during display freeze
            // so that the unfreeze wait for the apps to draw. This might be needed if
            // the app is relaunching.
            prepareNoneTransitionForRelaunching(atoken);
        }
        if (displayContent.isDefaultDisplay) {
            final DisplayInfo displayInfo = displayContent.getDisplayInfo();
            final Rect taskBounds;
            if (atoken != null && atoken.getTask() != null) {
                taskBounds = mTmpRect;
                atoken.getTask().getBounds(mTmpRect);
            } else {
                taskBounds = null;
            }
            if (mPolicy.getInsetHintLw(win.mAttrs, taskBounds, displayInfo.rotation, displayInfo.logicalWidth, displayInfo.logicalHeight, outContentInsets, outStableInsets, outOutsets)) {
                res |= WindowManagerGlobal.ADD_FLAG_ALWAYS_CONSUME_NAV_BAR;
            }
        } else {
            outContentInsets.setEmpty();
            outStableInsets.setEmpty();
        }
        if (mInTouchMode) {
            res |= WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE;
        }
        if (win.mAppToken == null || !win.mAppToken.isClientHidden()) {
            res |= WindowManagerGlobal.ADD_FLAG_APP_VISIBLE;
        }
        mInputMonitor.setUpdateInputWindowsNeededLw();
        boolean focusChanged = false;
        if (win.canReceiveKeys()) {
            focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS, false);
            if (focusChanged) {
                imMayMove = false;
            }
        }
        if (imMayMove) {
            displayContent.computeImeTarget(true);
        }
        // Don't do layout here, the window must call
        // relayout to be displayed, so we'll do it there.
        displayContent.assignWindowLayers(false);
        if (focusChanged) {
            mInputMonitor.setInputFocusLw(mCurrentFocus, false);
        }
        mInputMonitor.updateInputWindowsLw(false);
        if (localLOGV || DEBUG_ADD_REMOVE)
            Slog.v(TAG_WM, "addWindow: New client " + client.asBinder() + ": window=" + win + " Callers=" + Debug.getCallers(5));
        if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked(false, displayId)) {
            reportNewConfig = true;
        }
    }
    if (reportNewConfig) {
        sendNewConfiguration(displayId);
    }
    Binder.restoreCallingIdentity(origId);
    return res;
}
#method_after
public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) {
    int[] appOp = new int[1];
    int res = mPolicy.checkAddPermission(attrs, appOp);
    if (res != WindowManagerGlobal.ADD_OKAY) {
        return res;
    }
    boolean reportNewConfig = false;
    WindowState parentWindow = null;
    long origId;
    final int callingUid = Binder.getCallingUid();
    final int type = attrs.type;
    synchronized (mWindowMap) {
        if (!mDisplayReady) {
            throw new IllegalStateException("Display has not been initialialized");
        }
        final DisplayContent displayContent = mRoot.getDisplayContentOrCreate(displayId);
        if (displayContent == null) {
            Slog.w(TAG_WM, "Attempted to add window to a display that does not exist: " + displayId + ".  Aborting.");
            return WindowManagerGlobal.ADD_INVALID_DISPLAY;
        }
        if (!displayContent.hasAccess(session.mUid) && !mDisplayManagerInternal.isUidPresentOnDisplay(session.mUid, displayId)) {
            Slog.w(TAG_WM, "Attempted to add window to a display for which the application " + "does not have access: " + displayId + ".  Aborting.");
            return WindowManagerGlobal.ADD_INVALID_DISPLAY;
        }
        if (mWindowMap.containsKey(client.asBinder())) {
            Slog.w(TAG_WM, "Window " + client + " is already added");
            return WindowManagerGlobal.ADD_DUPLICATE_ADD;
        }
        if (type >= FIRST_SUB_WINDOW && type <= LAST_SUB_WINDOW) {
            parentWindow = windowForClientLocked(null, attrs.token, false);
            if (parentWindow == null) {
                Slog.w(TAG_WM, "Attempted to add window with token that is not a window: " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
            }
            if (parentWindow.mAttrs.type >= FIRST_SUB_WINDOW && parentWindow.mAttrs.type <= LAST_SUB_WINDOW) {
                Slog.w(TAG_WM, "Attempted to add window with token that is a sub-window: " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
            }
        }
        if (type == TYPE_PRIVATE_PRESENTATION && !displayContent.isPrivate()) {
            Slog.w(TAG_WM, "Attempted to add private presentation window to a non-private display.  Aborting.");
            return WindowManagerGlobal.ADD_PERMISSION_DENIED;
        }
        AppWindowToken atoken = null;
        final boolean hasParent = parentWindow != null;
        // Use existing parent window token for child windows since they go in the same token
        // as there parent window so we can apply the same policy on them.
        WindowToken token = displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token);
        // If this is a child window, we want to apply the same type checking rules as the
        // parent window type.
        final int rootType = hasParent ? parentWindow.mAttrs.type : type;
        boolean addToastWindowRequiresToken = false;
        if (token == null) {
            if (rootType >= FIRST_APPLICATION_WINDOW && rootType <= LAST_APPLICATION_WINDOW) {
                Slog.w(TAG_WM, "Attempted to add application window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_INPUT_METHOD) {
                Slog.w(TAG_WM, "Attempted to add input method window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_VOICE_INTERACTION) {
                Slog.w(TAG_WM, "Attempted to add voice interaction window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_WALLPAPER) {
                Slog.w(TAG_WM, "Attempted to add wallpaper window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_DREAM) {
                Slog.w(TAG_WM, "Attempted to add Dream window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_QS_DIALOG) {
                Slog.w(TAG_WM, "Attempted to add QS dialog window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (rootType == TYPE_ACCESSIBILITY_OVERLAY) {
                Slog.w(TAG_WM, "Attempted to add Accessibility overlay window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (type == TYPE_TOAST) {
                // Apps targeting SDK above N MR1 cannot arbitrary add toast windows.
                if (doesAddToastWindowRequireToken(attrs.packageName, callingUid, parentWindow)) {
                    Slog.w(TAG_WM, "Attempted to add a toast window with unknown token " + attrs.token + ".  Aborting.");
                    return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
                }
            }
            final IBinder binder = attrs.token != null ? attrs.token : client.asBinder();
            token = new WindowToken(this, binder, type, false, displayContent, session.mCanAddInternalSystemWindow);
        } else if (rootType >= FIRST_APPLICATION_WINDOW && rootType <= LAST_APPLICATION_WINDOW) {
            atoken = token.asAppWindowToken();
            if (atoken == null) {
                Slog.w(TAG_WM, "Attempted to add window with non-application token " + token + ".  Aborting.");
                return WindowManagerGlobal.ADD_NOT_APP_TOKEN;
            } else if (atoken.removed) {
                Slog.w(TAG_WM, "Attempted to add window with exiting application token " + token + ".  Aborting.");
                return WindowManagerGlobal.ADD_APP_EXITING;
            }
        } else if (rootType == TYPE_INPUT_METHOD) {
            if (token.windowType != TYPE_INPUT_METHOD) {
                Slog.w(TAG_WM, "Attempted to add input method window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (rootType == TYPE_VOICE_INTERACTION) {
            if (token.windowType != TYPE_VOICE_INTERACTION) {
                Slog.w(TAG_WM, "Attempted to add voice interaction window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (rootType == TYPE_WALLPAPER) {
            if (token.windowType != TYPE_WALLPAPER) {
                Slog.w(TAG_WM, "Attempted to add wallpaper window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (rootType == TYPE_DREAM) {
            if (token.windowType != TYPE_DREAM) {
                Slog.w(TAG_WM, "Attempted to add Dream window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (rootType == TYPE_ACCESSIBILITY_OVERLAY) {
            if (token.windowType != TYPE_ACCESSIBILITY_OVERLAY) {
                Slog.w(TAG_WM, "Attempted to add Accessibility overlay window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (type == TYPE_TOAST) {
            // Apps targeting SDK above N MR1 cannot arbitrary add toast windows.
            addToastWindowRequiresToken = doesAddToastWindowRequireToken(attrs.packageName, callingUid, parentWindow);
            if (addToastWindowRequiresToken && token.windowType != TYPE_TOAST) {
                Slog.w(TAG_WM, "Attempted to add a toast window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (type == TYPE_QS_DIALOG) {
            if (token.windowType != TYPE_QS_DIALOG) {
                Slog.w(TAG_WM, "Attempted to add QS dialog window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (token.asAppWindowToken() != null) {
            Slog.w(TAG_WM, "Non-null appWindowToken for system window of rootType=" + rootType);
            // It is not valid to use an app token with other system types; we will
            // instead make a new token for it (as if null had been passed in for the token).
            attrs.token = null;
            token = new WindowToken(this, client.asBinder(), type, false, displayContent, session.mCanAddInternalSystemWindow);
        }
        final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], seq, attrs, viewVisibility, session.mUid, session.mCanAddInternalSystemWindow);
        if (win.mDeathRecipient == null) {
            // Client has apparently died, so there is no reason to
            // continue.
            Slog.w(TAG_WM, "Adding window client " + client.asBinder() + " that is dead, aborting.");
            return WindowManagerGlobal.ADD_APP_EXITING;
        }
        if (win.getDisplayContent() == null) {
            Slog.w(TAG_WM, "Adding window to Display that has been removed.");
            return WindowManagerGlobal.ADD_INVALID_DISPLAY;
        }
        mPolicy.adjustWindowParamsLw(win.mAttrs);
        win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs));
        res = mPolicy.prepareAddWindowLw(win, attrs);
        if (res != WindowManagerGlobal.ADD_OKAY) {
            return res;
        }
        final boolean openInputChannels = (outInputChannel != null && (attrs.inputFeatures & INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);
        if (openInputChannels) {
            win.openInputChannel(outInputChannel);
        }
        // schedule hiding all of its toast windows.
        if (type == TYPE_TOAST) {
            if (!getDefaultDisplayContentLocked().canAddToastWindowForUid(callingUid)) {
                Slog.w(TAG_WM, "Adding more than one toast window for UID at a time.");
                return WindowManagerGlobal.ADD_DUPLICATE_ADD;
            }
            // the screen after the activity goes away.
            if (addToastWindowRequiresToken || (attrs.flags & LayoutParams.FLAG_NOT_FOCUSABLE) == 0 || mCurrentFocus == null || mCurrentFocus.mOwnerUid != callingUid) {
                mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_HIDE_TIMEOUT, win), win.mAttrs.hideTimeoutMilliseconds);
            }
        }
        // From now on, no exceptions or errors allowed!
        res = WindowManagerGlobal.ADD_OKAY;
        if (mCurrentFocus == null) {
            mWinAddedSinceNullFocus.add(win);
        }
        if (excludeWindowTypeFromTapOutTask(type)) {
            displayContent.mTapExcludedWindows.add(win);
        }
        origId = Binder.clearCallingIdentity();
        win.attach();
        mWindowMap.put(client.asBinder(), win);
        if (win.mAppOp != AppOpsManager.OP_NONE) {
            int startOpResult = mAppOps.startOpNoThrow(win.mAppOp, win.getOwningUid(), win.getOwningPackage());
            if ((startOpResult != AppOpsManager.MODE_ALLOWED) && (startOpResult != AppOpsManager.MODE_DEFAULT)) {
                win.setAppOpVisibilityLw(false);
            }
        }
        final boolean hideSystemAlertWindows = !mHidingNonSystemOverlayWindows.isEmpty();
        win.setForceHideNonSystemOverlayWindowIfNeeded(hideSystemAlertWindows);
        final AppWindowToken aToken = token.asAppWindowToken();
        if (type == TYPE_APPLICATION_STARTING && aToken != null) {
            aToken.startingWindow = win;
            if (DEBUG_STARTING_WINDOW)
                Slog.v(TAG_WM, "addWindow: " + aToken + " startingWindow=" + win);
        }
        boolean imMayMove = true;
        win.mToken.addWindow(win);
        if (type == TYPE_INPUT_METHOD) {
            win.mGivenInsetsPending = true;
            setInputMethodWindowLocked(win);
            imMayMove = false;
        } else if (type == TYPE_INPUT_METHOD_DIALOG) {
            displayContent.computeImeTarget(true);
            imMayMove = false;
        } else {
            if (type == TYPE_WALLPAPER) {
                displayContent.mWallpaperController.clearLastWallpaperTimeoutTime();
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
            } else if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
            } else if (displayContent.mWallpaperController.isBelowWallpaperTarget(win)) {
                // If there is currently a wallpaper being shown, and
                // the base layer of the new window is below the current
                // layer of the target window, then adjust the wallpaper.
                // This is to avoid a new window being placed between the
                // wallpaper and its target.
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
            }
        }
        // If the window is being added to a stack that's currently adjusted for IME,
        // make sure to apply the same adjust to this new window.
        win.applyAdjustForImeIfNeeded();
        if (type == TYPE_DOCK_DIVIDER) {
            mRoot.getDisplayContent(displayId).getDockedDividerController().setWindow(win);
        }
        final WindowStateAnimator winAnimator = win.mWinAnimator;
        winAnimator.mEnterAnimationPending = true;
        winAnimator.mEnteringAnimation = true;
        // Check if we need to prepare a transition for replacing window first.
        if (atoken != null && atoken.isVisible() && !prepareWindowReplacementTransition(atoken)) {
            // If not, check if need to set up a dummy transition during display freeze
            // so that the unfreeze wait for the apps to draw. This might be needed if
            // the app is relaunching.
            prepareNoneTransitionForRelaunching(atoken);
        }
        if (displayContent.isDefaultDisplay) {
            final DisplayInfo displayInfo = displayContent.getDisplayInfo();
            final Rect taskBounds;
            if (atoken != null && atoken.getTask() != null) {
                taskBounds = mTmpRect;
                atoken.getTask().getBounds(mTmpRect);
            } else {
                taskBounds = null;
            }
            if (mPolicy.getInsetHintLw(win.mAttrs, taskBounds, displayInfo.rotation, displayInfo.logicalWidth, displayInfo.logicalHeight, outContentInsets, outStableInsets, outOutsets)) {
                res |= WindowManagerGlobal.ADD_FLAG_ALWAYS_CONSUME_NAV_BAR;
            }
        } else {
            outContentInsets.setEmpty();
            outStableInsets.setEmpty();
        }
        if (mInTouchMode) {
            res |= WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE;
        }
        if (win.mAppToken == null || !win.mAppToken.isClientHidden()) {
            res |= WindowManagerGlobal.ADD_FLAG_APP_VISIBLE;
        }
        mInputMonitor.setUpdateInputWindowsNeededLw();
        boolean focusChanged = false;
        if (win.canReceiveKeys()) {
            focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS, false);
            if (focusChanged) {
                imMayMove = false;
            }
        }
        if (imMayMove) {
            displayContent.computeImeTarget(true);
        }
        // Don't do layout here, the window must call
        // relayout to be displayed, so we'll do it there.
        displayContent.assignWindowLayers(false);
        if (focusChanged) {
            mInputMonitor.setInputFocusLw(mCurrentFocus, false);
        }
        mInputMonitor.updateInputWindowsLw(false);
        if (localLOGV || DEBUG_ADD_REMOVE)
            Slog.v(TAG_WM, "addWindow: New client " + client.asBinder() + ": window=" + win + " Callers=" + Debug.getCallers(5));
        if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked(false, displayId)) {
            reportNewConfig = true;
        }
    }
    if (reportNewConfig) {
        sendNewConfiguration(displayId);
    }
    Binder.restoreCallingIdentity(origId);
    return res;
}
#end_block

#method_before
void postWindowRemoveCleanupLocked(WindowState win) {
    if (DEBUG_ADD_REMOVE)
        Slog.v(TAG_WM, "postWindowRemoveCleanupLocked: " + win);
    mWindowMap.remove(win.mClient.asBinder());
    if (win.mAppOp != AppOpsManager.OP_NONE) {
        mAppOps.finishOp(win.mAppOp, win.getOwningUid(), win.getOwningPackage());
    }
    if (mCurrentFocus == null) {
        mWinRemovedSinceNullFocus.add(win);
    }
    mPendingRemove.remove(win);
    mResizingWindows.remove(win);
    mWindowsChanged = true;
    if (DEBUG_WINDOW_MOVEMENT)
        Slog.v(TAG_WM, "Final remove of window: " + win);
    if (mInputMethodWindow == win) {
        setInputMethodWindowLocked(null);
    }
    final WindowToken token = win.mToken;
    final AppWindowToken atoken = win.mAppToken;
    if (DEBUG_ADD_REMOVE)
        Slog.v(TAG_WM, "Removing " + win + " from " + token);
    // Window will already be removed from token before this post clean-up method is called.
    if (token.isEmpty()) {
        if (!token.mPersistOnEmpty) {
            token.removeImmediately();
        } else if (atoken != null) {
            // TODO: Should this be moved into AppWindowToken.removeWindow? Might go away after
            // re-factor.
            atoken.firstWindowDrawn = false;
            atoken.clearAllDrawn();
            final TaskStack stack = atoken.getStack();
            if (stack != null) {
                stack.mExitingAppTokens.remove(atoken);
            }
        }
    }
    if (atoken != null) {
        atoken.postWindowRemoveStartingWindowCleanup(win);
    }
    final DisplayContent dc = win.getDisplayContent();
    if (win.mAttrs.type == TYPE_WALLPAPER) {
        dc.mWallpaperController.clearLastWallpaperTimeoutTime();
        dc.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
    } else if ((win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        dc.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
    }
    if (dc != null && !mWindowPlacerLocked.isInLayout()) {
        dc.assignWindowLayers(true);
        mWindowPlacerLocked.performSurfacePlacement();
        if (win.mAppToken != null) {
            win.mAppToken.updateReportedVisibilityLocked();
        }
    }
    mInputMonitor.updateInputWindowsLw(true);
}
#method_after
void postWindowRemoveCleanupLocked(WindowState win) {
    if (DEBUG_ADD_REMOVE)
        Slog.v(TAG_WM, "postWindowRemoveCleanupLocked: " + win);
    mWindowMap.remove(win.mClient.asBinder());
    if (win.mAppOp != AppOpsManager.OP_NONE) {
        mAppOps.finishOp(win.mAppOp, win.getOwningUid(), win.getOwningPackage());
    }
    if (mCurrentFocus == null) {
        mWinRemovedSinceNullFocus.add(win);
    }
    mPendingRemove.remove(win);
    mResizingWindows.remove(win);
    updateNonSystemOverlayWindowsVisibilityIfNeeded(win, false);
    mWindowsChanged = true;
    if (DEBUG_WINDOW_MOVEMENT)
        Slog.v(TAG_WM, "Final remove of window: " + win);
    if (mInputMethodWindow == win) {
        setInputMethodWindowLocked(null);
    }
    final WindowToken token = win.mToken;
    final AppWindowToken atoken = win.mAppToken;
    if (DEBUG_ADD_REMOVE)
        Slog.v(TAG_WM, "Removing " + win + " from " + token);
    // Window will already be removed from token before this post clean-up method is called.
    if (token.isEmpty()) {
        if (!token.mPersistOnEmpty) {
            token.removeImmediately();
        } else if (atoken != null) {
            // TODO: Should this be moved into AppWindowToken.removeWindow? Might go away after
            // re-factor.
            atoken.firstWindowDrawn = false;
            atoken.clearAllDrawn();
            final TaskStack stack = atoken.getStack();
            if (stack != null) {
                stack.mExitingAppTokens.remove(atoken);
            }
        }
    }
    if (atoken != null) {
        atoken.postWindowRemoveStartingWindowCleanup(win);
    }
    final DisplayContent dc = win.getDisplayContent();
    if (win.mAttrs.type == TYPE_WALLPAPER) {
        dc.mWallpaperController.clearLastWallpaperTimeoutTime();
        dc.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
    } else if ((win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        dc.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
    }
    if (dc != null && !mWindowPlacerLocked.isInLayout()) {
        dc.assignWindowLayers(true);
        mWindowPlacerLocked.performSurfacePlacement();
        if (win.mAppToken != null) {
            win.mAppToken.updateReportedVisibilityLocked();
        }
    }
    mInputMonitor.updateInputWindowsLw(true);
}
#end_block

#method_before
private void dumpWindowsNoHeaderLocked(PrintWriter pw, boolean dumpAll, ArrayList<WindowState> windows) {
    mRoot.dumpWindowsNoHeader(pw, dumpAll, windows);
    if (mPendingRemove.size() > 0) {
        pw.println();
        pw.println("  Remove pending for:");
        for (int i = mPendingRemove.size() - 1; i >= 0; i--) {
            WindowState w = mPendingRemove.get(i);
            if (windows == null || windows.contains(w)) {
                pw.print("  Remove #");
                pw.print(i);
                pw.print(' ');
                pw.print(w);
                if (dumpAll) {
                    pw.println(":");
                    w.dump(pw, "    ", true);
                } else {
                    pw.println();
                }
            }
        }
    }
    if (mForceRemoves != null && mForceRemoves.size() > 0) {
        pw.println();
        pw.println("  Windows force removing:");
        for (int i = mForceRemoves.size() - 1; i >= 0; i--) {
            WindowState w = mForceRemoves.get(i);
            pw.print("  Removing #");
            pw.print(i);
            pw.print(' ');
            pw.print(w);
            if (dumpAll) {
                pw.println(":");
                w.dump(pw, "    ", true);
            } else {
                pw.println();
            }
        }
    }
    if (mDestroySurface.size() > 0) {
        pw.println();
        pw.println("  Windows waiting to destroy their surface:");
        for (int i = mDestroySurface.size() - 1; i >= 0; i--) {
            WindowState w = mDestroySurface.get(i);
            if (windows == null || windows.contains(w)) {
                pw.print("  Destroy #");
                pw.print(i);
                pw.print(' ');
                pw.print(w);
                if (dumpAll) {
                    pw.println(":");
                    w.dump(pw, "    ", true);
                } else {
                    pw.println();
                }
            }
        }
    }
    if (mLosingFocus.size() > 0) {
        pw.println();
        pw.println("  Windows losing focus:");
        for (int i = mLosingFocus.size() - 1; i >= 0; i--) {
            WindowState w = mLosingFocus.get(i);
            if (windows == null || windows.contains(w)) {
                pw.print("  Losing #");
                pw.print(i);
                pw.print(' ');
                pw.print(w);
                if (dumpAll) {
                    pw.println(":");
                    w.dump(pw, "    ", true);
                } else {
                    pw.println();
                }
            }
        }
    }
    if (mResizingWindows.size() > 0) {
        pw.println();
        pw.println("  Windows waiting to resize:");
        for (int i = mResizingWindows.size() - 1; i >= 0; i--) {
            WindowState w = mResizingWindows.get(i);
            if (windows == null || windows.contains(w)) {
                pw.print("  Resizing #");
                pw.print(i);
                pw.print(' ');
                pw.print(w);
                if (dumpAll) {
                    pw.println(":");
                    w.dump(pw, "    ", true);
                } else {
                    pw.println();
                }
            }
        }
    }
    if (mWaitingForDrawn.size() > 0) {
        pw.println();
        pw.println("  Clients waiting for these windows to be drawn:");
        for (int i = mWaitingForDrawn.size() - 1; i >= 0; i--) {
            WindowState win = mWaitingForDrawn.get(i);
            pw.print("  Waiting #");
            pw.print(i);
            pw.print(' ');
            pw.print(win);
        }
    }
    pw.println();
    pw.print("  mGlobalConfiguration=");
    pw.println(mRoot.getConfiguration());
    pw.print("  mHasPermanentDpad=");
    pw.println(mHasPermanentDpad);
    pw.print("  mCurrentFocus=");
    pw.println(mCurrentFocus);
    if (mLastFocus != mCurrentFocus) {
        pw.print("  mLastFocus=");
        pw.println(mLastFocus);
    }
    pw.print("  mFocusedApp=");
    pw.println(mFocusedApp);
    if (mInputMethodTarget != null) {
        pw.print("  mInputMethodTarget=");
        pw.println(mInputMethodTarget);
    }
    pw.print("  mInTouchMode=");
    pw.print(mInTouchMode);
    pw.print(" mLayoutSeq=");
    pw.println(mLayoutSeq);
    pw.print("  mLastDisplayFreezeDuration=");
    TimeUtils.formatDuration(mLastDisplayFreezeDuration, pw);
    if (mLastFinishedFreezeSource != null) {
        pw.print(" due to ");
        pw.print(mLastFinishedFreezeSource);
    }
    pw.println();
    pw.print("  mLastWakeLockHoldingWindow=");
    pw.print(mLastWakeLockHoldingWindow);
    pw.print(" mLastWakeLockObscuringWindow=");
    pw.print(mLastWakeLockObscuringWindow);
    pw.println();
    mInputMonitor.dump(pw, "  ");
    mUnknownAppVisibilityController.dump(pw, "  ");
    mTaskSnapshotController.dump(pw, "  ");
    if (dumpAll) {
        pw.print("  mSystemDecorLayer=");
        pw.print(mSystemDecorLayer);
        pw.print(" mScreenRect=");
        pw.println(mScreenRect.toShortString());
        if (mLastStatusBarVisibility != 0) {
            pw.print("  mLastStatusBarVisibility=0x");
            pw.println(Integer.toHexString(mLastStatusBarVisibility));
        }
        if (mInputMethodWindow != null) {
            pw.print("  mInputMethodWindow=");
            pw.println(mInputMethodWindow);
        }
        mWindowPlacerLocked.dump(pw, "  ");
        mRoot.mWallpaperController.dump(pw, "  ");
        pw.print("  mSystemBooted=");
        pw.print(mSystemBooted);
        pw.print(" mDisplayEnabled=");
        pw.println(mDisplayEnabled);
        mRoot.dumpLayoutNeededDisplayIds(pw);
        pw.print("  mTransactionSequence=");
        pw.println(mTransactionSequence);
        pw.print("  mDisplayFrozen=");
        pw.print(mDisplayFrozen);
        pw.print(" windows=");
        pw.print(mWindowsFreezingScreen);
        pw.print(" client=");
        pw.print(mClientFreezingScreen);
        pw.print(" apps=");
        pw.print(mAppsFreezingScreen);
        pw.print(" waitingForConfig=");
        pw.println(mWaitingForConfig);
        final DisplayContent defaultDisplayContent = getDefaultDisplayContentLocked();
        pw.print("  mRotation=");
        pw.print(defaultDisplayContent.getRotation());
        pw.print(" mAltOrientation=");
        pw.println(defaultDisplayContent.getAltOrientation());
        pw.print("  mLastWindowForcedOrientation=");
        pw.print(defaultDisplayContent.getLastWindowForcedOrientation());
        pw.print(" mLastOrientation=");
        pw.println(defaultDisplayContent.getLastOrientation());
        pw.print("  mDeferredRotationPauseCount=");
        pw.println(mDeferredRotationPauseCount);
        pw.print("  Animation settings: disabled=");
        pw.print(mAnimationsDisabled);
        pw.print(" window=");
        pw.print(mWindowAnimationScaleSetting);
        pw.print(" transition=");
        pw.print(mTransitionAnimationScaleSetting);
        pw.print(" animator=");
        pw.println(mAnimatorDurationScaleSetting);
        pw.print("  mSkipAppTransitionAnimation=");
        pw.println(mSkipAppTransitionAnimation);
        pw.println("  mLayoutToAnim:");
        mAppTransition.dump(pw, "    ");
    }
}
#method_after
private void dumpWindowsNoHeaderLocked(PrintWriter pw, boolean dumpAll, ArrayList<WindowState> windows) {
    mRoot.dumpWindowsNoHeader(pw, dumpAll, windows);
    if (!mHidingNonSystemOverlayWindows.isEmpty()) {
        pw.println();
        pw.println("  Hiding System Alert Windows:");
        for (int i = mHidingNonSystemOverlayWindows.size() - 1; i >= 0; i--) {
            final WindowState w = mHidingNonSystemOverlayWindows.get(i);
            pw.print("  #");
            pw.print(i);
            pw.print(' ');
            pw.print(w);
            if (dumpAll) {
                pw.println(":");
                w.dump(pw, "    ", true);
            } else {
                pw.println();
            }
        }
    }
    if (mPendingRemove.size() > 0) {
        pw.println();
        pw.println("  Remove pending for:");
        for (int i = mPendingRemove.size() - 1; i >= 0; i--) {
            WindowState w = mPendingRemove.get(i);
            if (windows == null || windows.contains(w)) {
                pw.print("  Remove #");
                pw.print(i);
                pw.print(' ');
                pw.print(w);
                if (dumpAll) {
                    pw.println(":");
                    w.dump(pw, "    ", true);
                } else {
                    pw.println();
                }
            }
        }
    }
    if (mForceRemoves != null && mForceRemoves.size() > 0) {
        pw.println();
        pw.println("  Windows force removing:");
        for (int i = mForceRemoves.size() - 1; i >= 0; i--) {
            WindowState w = mForceRemoves.get(i);
            pw.print("  Removing #");
            pw.print(i);
            pw.print(' ');
            pw.print(w);
            if (dumpAll) {
                pw.println(":");
                w.dump(pw, "    ", true);
            } else {
                pw.println();
            }
        }
    }
    if (mDestroySurface.size() > 0) {
        pw.println();
        pw.println("  Windows waiting to destroy their surface:");
        for (int i = mDestroySurface.size() - 1; i >= 0; i--) {
            WindowState w = mDestroySurface.get(i);
            if (windows == null || windows.contains(w)) {
                pw.print("  Destroy #");
                pw.print(i);
                pw.print(' ');
                pw.print(w);
                if (dumpAll) {
                    pw.println(":");
                    w.dump(pw, "    ", true);
                } else {
                    pw.println();
                }
            }
        }
    }
    if (mLosingFocus.size() > 0) {
        pw.println();
        pw.println("  Windows losing focus:");
        for (int i = mLosingFocus.size() - 1; i >= 0; i--) {
            WindowState w = mLosingFocus.get(i);
            if (windows == null || windows.contains(w)) {
                pw.print("  Losing #");
                pw.print(i);
                pw.print(' ');
                pw.print(w);
                if (dumpAll) {
                    pw.println(":");
                    w.dump(pw, "    ", true);
                } else {
                    pw.println();
                }
            }
        }
    }
    if (mResizingWindows.size() > 0) {
        pw.println();
        pw.println("  Windows waiting to resize:");
        for (int i = mResizingWindows.size() - 1; i >= 0; i--) {
            WindowState w = mResizingWindows.get(i);
            if (windows == null || windows.contains(w)) {
                pw.print("  Resizing #");
                pw.print(i);
                pw.print(' ');
                pw.print(w);
                if (dumpAll) {
                    pw.println(":");
                    w.dump(pw, "    ", true);
                } else {
                    pw.println();
                }
            }
        }
    }
    if (mWaitingForDrawn.size() > 0) {
        pw.println();
        pw.println("  Clients waiting for these windows to be drawn:");
        for (int i = mWaitingForDrawn.size() - 1; i >= 0; i--) {
            WindowState win = mWaitingForDrawn.get(i);
            pw.print("  Waiting #");
            pw.print(i);
            pw.print(' ');
            pw.print(win);
        }
    }
    pw.println();
    pw.print("  mGlobalConfiguration=");
    pw.println(mRoot.getConfiguration());
    pw.print("  mHasPermanentDpad=");
    pw.println(mHasPermanentDpad);
    pw.print("  mCurrentFocus=");
    pw.println(mCurrentFocus);
    if (mLastFocus != mCurrentFocus) {
        pw.print("  mLastFocus=");
        pw.println(mLastFocus);
    }
    pw.print("  mFocusedApp=");
    pw.println(mFocusedApp);
    if (mInputMethodTarget != null) {
        pw.print("  mInputMethodTarget=");
        pw.println(mInputMethodTarget);
    }
    pw.print("  mInTouchMode=");
    pw.print(mInTouchMode);
    pw.print(" mLayoutSeq=");
    pw.println(mLayoutSeq);
    pw.print("  mLastDisplayFreezeDuration=");
    TimeUtils.formatDuration(mLastDisplayFreezeDuration, pw);
    if (mLastFinishedFreezeSource != null) {
        pw.print(" due to ");
        pw.print(mLastFinishedFreezeSource);
    }
    pw.println();
    pw.print("  mLastWakeLockHoldingWindow=");
    pw.print(mLastWakeLockHoldingWindow);
    pw.print(" mLastWakeLockObscuringWindow=");
    pw.print(mLastWakeLockObscuringWindow);
    pw.println();
    mInputMonitor.dump(pw, "  ");
    mUnknownAppVisibilityController.dump(pw, "  ");
    mTaskSnapshotController.dump(pw, "  ");
    if (dumpAll) {
        pw.print("  mSystemDecorLayer=");
        pw.print(mSystemDecorLayer);
        pw.print(" mScreenRect=");
        pw.println(mScreenRect.toShortString());
        if (mLastStatusBarVisibility != 0) {
            pw.print("  mLastStatusBarVisibility=0x");
            pw.println(Integer.toHexString(mLastStatusBarVisibility));
        }
        if (mInputMethodWindow != null) {
            pw.print("  mInputMethodWindow=");
            pw.println(mInputMethodWindow);
        }
        mWindowPlacerLocked.dump(pw, "  ");
        mRoot.mWallpaperController.dump(pw, "  ");
        pw.print("  mSystemBooted=");
        pw.print(mSystemBooted);
        pw.print(" mDisplayEnabled=");
        pw.println(mDisplayEnabled);
        mRoot.dumpLayoutNeededDisplayIds(pw);
        pw.print("  mTransactionSequence=");
        pw.println(mTransactionSequence);
        pw.print("  mDisplayFrozen=");
        pw.print(mDisplayFrozen);
        pw.print(" windows=");
        pw.print(mWindowsFreezingScreen);
        pw.print(" client=");
        pw.print(mClientFreezingScreen);
        pw.print(" apps=");
        pw.print(mAppsFreezingScreen);
        pw.print(" waitingForConfig=");
        pw.println(mWaitingForConfig);
        final DisplayContent defaultDisplayContent = getDefaultDisplayContentLocked();
        pw.print("  mRotation=");
        pw.print(defaultDisplayContent.getRotation());
        pw.print(" mAltOrientation=");
        pw.println(defaultDisplayContent.getAltOrientation());
        pw.print("  mLastWindowForcedOrientation=");
        pw.print(defaultDisplayContent.getLastWindowForcedOrientation());
        pw.print(" mLastOrientation=");
        pw.println(defaultDisplayContent.getLastOrientation());
        pw.print("  mDeferredRotationPauseCount=");
        pw.println(mDeferredRotationPauseCount);
        pw.print("  Animation settings: disabled=");
        pw.print(mAnimationsDisabled);
        pw.print(" window=");
        pw.print(mWindowAnimationScaleSetting);
        pw.print(" transition=");
        pw.print(mTransitionAnimationScaleSetting);
        pw.print(" animator=");
        pw.println(mAnimatorDurationScaleSetting);
        pw.print("  mSkipAppTransitionAnimation=");
        pw.println(mSkipAppTransitionAnimation);
        pw.println("  mLayoutToAnim:");
        mAppTransition.dump(pw, "    ");
    }
}
#end_block

#method_before
// ----- Fragment Lifecycle Callbacks -----
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mCommandQueue = SysUiServiceProvider.getComponent(getContext(), CommandQueue.class);
    mCommandQueue.addCallbacks(this);
    mStatusBar = SysUiServiceProvider.getComponent(getContext(), StatusBar.class);
    mRecents = SysUiServiceProvider.getComponent(getContext(), Recents.class);
    mDivider = SysUiServiceProvider.getComponent(getContext(), Divider.class);
    mWindowManager = getContext().getSystemService(WindowManager.class);
    mAccessibilityManager = getContext().getSystemService(AccessibilityManager.class);
    Dependency.get(AccessibilityManagerWrapper.class).addCallback(mAccessibilityListener);
    mContentResolver = getContext().getContentResolver();
    mMagnificationObserver = new MagnificationContentObserver(getContext().getMainThreadHandler());
    mContentResolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED), false, mMagnificationObserver, UserHandle.USER_ALL);
    if (savedInstanceState != null) {
        mDisabledFlags1 = savedInstanceState.getInt(EXTRA_DISABLE_STATE, 0);
    }
    mAssistManager = Dependency.get(AssistManager.class);
    try {
        WindowManagerGlobal.getWindowManagerService().watchRotation(mRotationWatcher, getContext().getDisplay().getDisplayId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    mPulseController = new PulseController(getContext(), new Handler());
    mResourceMap = new NavbarOverlayResources(getContext(), getContext().getResources());
}
#method_after
// ----- Fragment Lifecycle Callbacks -----
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mCommandQueue = SysUiServiceProvider.getComponent(getContext(), CommandQueue.class);
    mCommandQueue.addCallbacks(this);
    mStatusBar = SysUiServiceProvider.getComponent(getContext(), StatusBar.class);
    mRecents = SysUiServiceProvider.getComponent(getContext(), Recents.class);
    mDivider = SysUiServiceProvider.getComponent(getContext(), Divider.class);
    mKeyguardMonitor = Dependency.get(KeyguardMonitor.class);
    mWindowManager = getContext().getSystemService(WindowManager.class);
    mAccessibilityManager = getContext().getSystemService(AccessibilityManager.class);
    Dependency.get(AccessibilityManagerWrapper.class).addCallback(mAccessibilityListener);
    mContentResolver = getContext().getContentResolver();
    mMagnificationObserver = new MagnificationContentObserver(getContext().getMainThreadHandler());
    mContentResolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED), false, mMagnificationObserver, UserHandle.USER_ALL);
    if (savedInstanceState != null) {
        mDisabledFlags1 = savedInstanceState.getInt(EXTRA_DISABLE_STATE, 0);
    }
    mAssistManager = Dependency.get(AssistManager.class);
    try {
        WindowManagerGlobal.getWindowManagerService().watchRotation(mRotationWatcher, getContext().getDisplay().getDisplayId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    mConfiguration = new Configuration();
    mConfiguration.updateFrom(getContext().getResources().getConfiguration());
    mPulseController = new PulseController(getContext(), new Handler());
    mResourceMap = new NavbarOverlayResources(getContext(), getContext().getResources());
    mBarMode = Settings.Secure.getIntForUser(mContentResolver, Settings.Secure.NAVIGATION_BAR_MODE, NAVIGATION_MODE_DEFAULT, UserHandle.USER_CURRENT);
    mNavbarObserver = new NavbarObserver(new Handler());
    mNavbarObserver.observe();
    mKeyguardMonitor.addCallback(this);
}
#end_block

#method_before
@Override
public void onDestroy() {
    super.onDestroy();
    mCommandQueue.removeCallbacks(this);
    Dependency.get(AccessibilityManagerWrapper.class).removeCallback(mAccessibilityListener);
    mContentResolver.unregisterContentObserver(mMagnificationObserver);
    try {
        WindowManagerGlobal.getWindowManagerService().removeRotationWatcher(mRotationWatcher);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Override
public void onDestroy() {
    super.onDestroy();
    mCommandQueue.removeCallbacks(this);
    mKeyguardMonitor.removeCallback(this);
    Dependency.get(AccessibilityManagerWrapper.class).removeCallback(mAccessibilityListener);
    mContentResolver.unregisterContentObserver(mMagnificationObserver);
    try {
        WindowManagerGlobal.getWindowManagerService().removeRotationWatcher(mRotationWatcher);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
    return getNavigator().getBaseView();
}
#method_after
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
    return createNavigator().getBaseView();
}
#end_block

#method_before
@Override
public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    mNavigationBarView = (Navigator) view;
    mNavigationBarView.setDisabledFlags(mDisabledFlags1);
    mNavigationBarView.setComponents(mRecents, mDivider);
    mNavigationBarView.setOnVerticalChangedListener(this::onVerticalChanged);
    mNavigationBarView.getBaseView().setOnTouchListener(this::onNavigationTouch);
    if (savedInstanceState != null) {
        mNavigationBarView.getLightTransitionsController().restoreState(savedInstanceState);
    }
    prepareNavigationBarView();
    checkNavBarModes();
    mNavigationBarView.setStatusBar(mStatusBar);
    mNavigationBarView.setResourceMap(mResourceMap);
    mNavigationBarView.setControllers(mPulseController);
    mNavigationBarView.setLeftInLandscape(mLeftInLandscape);
    IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    getContext().registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    PowerManager pm = getContext().getSystemService(PowerManager.class);
    notifyNavigationBarScreenOn(pm.isScreenOn());
}
#method_after
@Override
public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    mNavigationBarView = (Navigator) view;
    mNavigationBarView.setResourceMap(mResourceMap);
    mNavigationBarView.setControllers(mPulseController);
    mNavigationBarView.setLeftInLandscape(mLeftInLandscape);
    mNavigationBarView.setDisabledFlags(mDisabledFlags1);
    mNavigationBarView.setComponents(mRecents, mDivider);
    mNavigationBarView.setOnVerticalChangedListener(this::onVerticalChanged);
    if (isUsingStockNav()) {
        mNavigationBarView.getBaseView().setOnTouchListener(this::onNavigationTouch);
    }
    if (savedInstanceState != null) {
        mNavigationBarView.getLightTransitionsController().restoreState(savedInstanceState);
    }
    prepareNavigationBarView();
    checkNavBarModes();
    IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    getContext().registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    notifyNavigationBarScreenOn(true);
    mNavigationBarView.notifyInflateFromUser();
}
#end_block

#method_before
@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    final Locale locale = getContext().getResources().getConfiguration().locale;
    final int ld = TextUtils.getLayoutDirectionFromLocale(locale);
    if (!locale.equals(mLocale) || ld != mLayoutDirection) {
        if (DEBUG) {
            Log.v(TAG, String.format("config changed locale/LD: %s (%d) -> %s (%d)", mLocale, mLayoutDirection, locale, ld));
        }
        mLocale = locale;
        mLayoutDirection = ld;
        refreshLayout(ld);
    }
    repositionNavigationBar();
}
#method_after
@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    final Locale locale = getContext().getResources().getConfiguration().locale;
    final int ld = TextUtils.getLayoutDirectionFromLocale(locale);
    mConfiguration.updateFrom(newConfig);
    if (!locale.equals(mLocale) || ld != mLayoutDirection) {
        if (DEBUG) {
            Log.v(TAG, String.format("config changed locale/LD: %s (%d) -> %s (%d)", mLocale, mLayoutDirection, locale, ld));
        }
        mLocale = locale;
        mLayoutDirection = ld;
        refreshLayout(ld);
    }
    if (mConfiguration.densityDpi != newConfig.densityDpi) {
        // changeNavigator() will be triggered by onAttach later
        needsBarRefresh = true;
    }
    repositionNavigationBar();
}
#end_block

#method_before
@Override
public void screenPinningStateChanged(boolean enabled) {
}
#method_after
@Override
public void screenPinningStateChanged(boolean enabled) {
    mScreenPinningEnabled = enabled;
    changeNavigator();
}
#end_block

#method_before
private void repositionNavigationBar() {
    if (mNavigationBarView == null || !mNavigationBarView.getBaseView().isAttachedToWindow())
        return;
    prepareNavigationBarView();
    mWindowManager.updateViewLayout((View) mNavigationBarView.getBaseView().getParent(), ((View) mNavigationBarView.getBaseView().getParent()).getLayoutParams());
}
#method_after
private void repositionNavigationBar() {
    if (mNavigationBarView == null || !mNavigationBarView.getBaseView().isAttachedToWindow())
        return;
    prepareNavigationBarView();
    mWindowManager.updateViewLayout((View) mNavigationBarView.getBaseView().getParent(), (((View) mNavigationBarView.getBaseView().getParent()).getLayoutParams()));
}
#end_block

#method_before
private boolean onHomeTouch(View v, MotionEvent event) {
    if (mHomeBlockedThisTouch && event.getActionMasked() != MotionEvent.ACTION_DOWN) {
        return true;
    }
    // and his ONLY options are to answer or reject the call.)
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mHomeBlockedThisTouch = false;
            TelecomManager telecomManager = getContext().getSystemService(TelecomManager.class);
            if (telecomManager != null && telecomManager.isRinging()) {
                if (mStatusBar.isKeyguardShowing()) {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call. " + "No heads up");
                    mHomeBlockedThisTouch = true;
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            mStatusBar.awakenDreams();
            break;
    }
    return false;
}
#method_after
private boolean onHomeTouch(View v, MotionEvent event) {
    if (!isUsingStockNav()) {
        return false;
    }
    if (mHomeBlockedThisTouch && event.getActionMasked() != MotionEvent.ACTION_DOWN) {
        return true;
    }
    // and his ONLY options are to answer or reject the call.)
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mHomeBlockedThisTouch = false;
            TelecomManager telecomManager = getContext().getSystemService(TelecomManager.class);
            if (telecomManager != null && telecomManager.isRinging()) {
                if (mStatusBar.isKeyguardShowing()) {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call. " + "No heads up");
                    mHomeBlockedThisTouch = true;
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            mStatusBar.awakenDreams();
            break;
    }
    return false;
}
#end_block

#method_before
@VisibleForTesting
boolean onHomeLongClick(View v) {
    if (shouldDisableNavbarGestures()) {
        return false;
    }
    MetricsLogger.action(getContext(), MetricsEvent.ACTION_ASSIST_LONG_PRESS);
    mAssistManager.startAssist(new Bundle());
    mStatusBar.awakenDreams();
    if (mNavigationBarView != null) {
        mNavigationBarView.abortCurrentGesture();
    }
    return true;
}
#method_after
@VisibleForTesting
boolean onHomeLongClick(View v) {
    if (!isUsingStockNav()) {
        return false;
    }
    if (shouldDisableNavbarGestures()) {
        return false;
    }
    MetricsLogger.action(getContext(), MetricsEvent.ACTION_ASSIST_LONG_PRESS);
    mAssistManager.startAssist(new Bundle());
    mStatusBar.awakenDreams();
    if (mNavigationBarView != null) {
        mNavigationBarView.abortCurrentGesture();
    }
    return true;
}
#end_block

#method_before
// additional optimization when we have software system buttons - start loading the recent
private boolean onRecentsTouch(View v, MotionEvent event) {
    int action = event.getAction() & MotionEvent.ACTION_MASK;
    if (action == MotionEvent.ACTION_DOWN) {
        mCommandQueue.preloadRecentApps();
    } else if (action == MotionEvent.ACTION_CANCEL) {
        mCommandQueue.cancelPreloadRecentApps();
    } else if (action == MotionEvent.ACTION_UP) {
        if (!v.isPressed()) {
            mCommandQueue.cancelPreloadRecentApps();
        }
    }
    return false;
}
#method_after
// additional optimization when we have software system buttons - start loading the recent
private boolean onRecentsTouch(View v, MotionEvent event) {
    if (!isUsingStockNav()) {
        return false;
    }
    int action = event.getAction() & MotionEvent.ACTION_MASK;
    if (action == MotionEvent.ACTION_DOWN) {
        mCommandQueue.preloadRecentApps();
    } else if (action == MotionEvent.ACTION_CANCEL) {
        mCommandQueue.cancelPreloadRecentApps();
    } else if (action == MotionEvent.ACTION_UP) {
        if (!v.isPressed()) {
            mCommandQueue.cancelPreloadRecentApps();
        }
    }
    return false;
}
#end_block

#method_before
private boolean onLongPressBackRecents(View v) {
    try {
        boolean sendBackLongPress = false;
        IActivityManager activityManager = ActivityManagerNative.getDefault();
        boolean touchExplorationEnabled = mAccessibilityManager.isTouchExplorationEnabled();
        boolean inLockTaskMode = activityManager.isInLockTaskMode();
        if (inLockTaskMode && !touchExplorationEnabled) {
            long time = System.currentTimeMillis();
            // long-pressed 'together'
            if ((time - mLastLockToAppLongPress) < LOCK_TO_APP_GESTURE_TOLERENCE) {
                activityManager.stopLockTaskMode();
                // When exiting refresh disabled flags.
                mNavigationBarView.setDisabledFlags(mDisabledFlags1, true);
                return true;
            } else if ((v.getId() == R.id.back) && !mNavigationBarView.getRecentsButton().getCurrentView().isPressed()) {
                // If we aren't pressing recents right now then they presses
                // won't be together, so send the standard long-press action.
                sendBackLongPress = true;
            }
            mLastLockToAppLongPress = time;
        } else {
            // If this is back still need to handle sending the long-press event.
            if (v.getId() == R.id.back) {
                sendBackLongPress = true;
            } else if (touchExplorationEnabled && inLockTaskMode) {
                // When in accessibility mode a long press that is recents (not back)
                // should stop lock task.
                activityManager.stopLockTaskMode();
                // When exiting refresh disabled flags.
                mNavigationBarView.setDisabledFlags(mDisabledFlags1, true);
                return true;
            } else if (v.getId() == R.id.recent_apps) {
                return onLongPressRecents();
            }
        }
        if (sendBackLongPress) {
            KeyButtonView keyButtonView = (KeyButtonView) v;
            keyButtonView.sendEvent(KeyEvent.ACTION_DOWN, KeyEvent.FLAG_LONG_PRESS);
            keyButtonView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);
            return true;
        }
    } catch (RemoteException e) {
        Log.d(TAG, "Unable to reach activity manager", e);
    }
    return false;
}
#method_after
private boolean onLongPressBackRecents(View v) {
    if (!isUsingStockNav()) {
        return false;
    }
    try {
        boolean sendBackLongPress = false;
        IActivityManager activityManager = ActivityManagerNative.getDefault();
        boolean touchExplorationEnabled = mAccessibilityManager.isTouchExplorationEnabled();
        boolean inLockTaskMode = activityManager.isInLockTaskMode();
        if (inLockTaskMode && !touchExplorationEnabled) {
            long time = System.currentTimeMillis();
            // long-pressed 'together'
            if ((time - mLastLockToAppLongPress) < LOCK_TO_APP_GESTURE_TOLERENCE) {
                activityManager.stopLockTaskMode();
                // When exiting refresh disabled flags.
                mNavigationBarView.setDisabledFlags(mDisabledFlags1, true);
                return true;
            } else if ((v.getId() == R.id.back) && !mNavigationBarView.getRecentsButton().getCurrentView().isPressed()) {
                // If we aren't pressing recents right now then they presses
                // won't be together, so send the standard long-press action.
                sendBackLongPress = true;
            }
            mLastLockToAppLongPress = time;
        } else {
            // If this is back still need to handle sending the long-press event.
            if (v.getId() == R.id.back) {
                sendBackLongPress = true;
            } else if (touchExplorationEnabled && inLockTaskMode) {
                // When in accessibility mode a long press that is recents (not back)
                // should stop lock task.
                activityManager.stopLockTaskMode();
                // When exiting refresh disabled flags.
                mNavigationBarView.setDisabledFlags(mDisabledFlags1, true);
                return true;
            } else if (v.getId() == R.id.recent_apps) {
                return onLongPressRecents();
            }
        }
        if (sendBackLongPress) {
            KeyButtonView keyButtonView = (KeyButtonView) v;
            keyButtonView.sendEvent(KeyEvent.ACTION_DOWN, KeyEvent.FLAG_LONG_PRESS);
            keyButtonView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);
            return true;
        }
    } catch (RemoteException e) {
        Log.d(TAG, "Unable to reach activity manager", e);
    }
    return false;
}
#end_block

#method_before
public void changeNavigator() {
    removeNavigator();
    mNavigationBarView = getNavigator();
    mNavigationBarView.setDisabledFlags(mDisabledFlags1);
    mNavigationBarView.setComponents(mRecents, mDivider);
    mNavigationBarView.setOnVerticalChangedListener(this::onVerticalChanged);
    mNavigationBarView.getBaseView().setOnTouchListener(this::onNavigationTouch);
    prepareNavigationBarView();
    checkNavBarModes();
    mNavigationBarView.setStatusBar(mStatusBar);
    mNavigationBarView.setResourceMap(mResourceMap);
    mNavigationBarView.setControllers(mPulseController);
    mNavigationBarView.setLeftInLandscape(mLeftInLandscape);
    mRootView.addView(mNavigationBarView.getBaseView());
}
#method_after
public void changeNavigator() {
    if (mNavigationBarView == null)
        return;
    if (mIsAttached) {
        ViewGroup vg = (ViewGroup) mNavigationBarView.getBaseView().getParent();
        vg.removeAllViews();
        mNavigationBarView.dispose();
        mNavigationBarView = null;
        mNavigationBarView = createNavigator();
        mNavigationBarView.setResourceMap(mResourceMap);
        mNavigationBarView.setControllers(mPulseController);
        mNavigationBarView.setLeftInLandscape(mLeftInLandscape);
        mNavigationBarView.setDisabledFlags(mDisabledFlags1);
        mNavigationBarView.setComponents(mRecents, mDivider);
        mNavigationBarView.setOnVerticalChangedListener(this::onVerticalChanged);
        mNavigationBarView.notifyInflateFromUser();
        mLightBarController.setNavigationBar(mNavigationBarView.getLightTransitionsController());
        if (isUsingStockNav()) {
            mNavigationBarView.getBaseView().setOnTouchListener(this::onNavigationTouch);
        } else {
            ((NavigationBarFrame) vg).disableDeadZone();
            mStatusBar.setMediaPlaying();
        }
        vg.addView(mNavigationBarView.getBaseView());
        prepareNavigationBarView();
        checkNavBarModes();
        notifyNavigationBarScreenOn(true);
    }
}
#end_block

#method_before
public Navigator getNavigator() {
    int navMode = Settings.Secure.getIntForUser(mContentResolver, Settings.Secure.NAVIGATION_BAR_MODE, NAVIGATION_MODE_DEFAULT, UserHandle.USER_CURRENT);
    Navigator navigator;
    if (navMode == NAVIGATION_MODE_DEFAULT || mScreenPinningEnabled) {
        navigator = (Navigator) View.inflate(getContext(), R.layout.navigation_bar, null);
    } else if (navMode == NAVIGATION_MODE_SMARTBAR) {
        navigator = (Navigator) new SmartBarView(getContext(), false);
    } else if (navMode == NAVIGATION_MODE_FLING) {
        navigator = (Navigator) View.inflate(getContext(), R.layout.fling_bar, null);
    } else {
        navigator = (Navigator) View.inflate(getContext(), R.layout.navigation_bar, null);
    }
    return navigator;
}
#method_after
public Navigator getNavigator() {
    return mNavigationBarView;
}
#end_block

#method_before
public static View create(Context context, FragmentListener listener) {
    WindowManager.LayoutParams lp = new WindowManager.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.TYPE_NAVIGATION_BAR, WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_SLIPPERY, PixelFormat.TRANSLUCENT);
    lp.token = new Binder();
    // this will allow the navbar to run in an overlay on devices that support this
    if (ActivityManager.isHighEndGfx()) {
        lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    lp.setTitle("NavigationBar");
    lp.windowAnimations = 0;
    View navigationBarView = LayoutInflater.from(context).inflate(R.layout.navigation_bar_window, null);
    if (DEBUG)
        Log.v(TAG, "addNavigationBar: about to add " + navigationBarView);
    if (navigationBarView == null)
        return null;
    context.getSystemService(WindowManager.class).addView(navigationBarView, lp);
    FragmentHostManager fragmentHost = FragmentHostManager.get(navigationBarView);
    NavigationBarFragment fragment = new NavigationBarFragment();
    fragment.setRootView(navigationBarView);
    fragmentHost.getFragmentManager().beginTransaction().replace(R.id.navigation_bar_frame, fragment, TAG).commit();
    fragmentHost.addTagListener(TAG, listener);
    return navigationBarView;
}
#method_after
public static View create(Context context, FragmentListener listener) {
    WindowManager.LayoutParams lp = new WindowManager.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.TYPE_NAVIGATION_BAR, WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_SLIPPERY, PixelFormat.TRANSLUCENT);
    lp.token = new Binder();
    // this will allow the navbar to run in an overlay on devices that support this
    if (ActivityManager.isHighEndGfx()) {
        lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    lp.setTitle("NavigationBar");
    lp.windowAnimations = 0;
    View navigationBarView = LayoutInflater.from(context).inflate(R.layout.navigation_bar_window, null);
    if (DEBUG)
        Log.v(TAG, "addNavigationBar: about to add " + navigationBarView);
    if (navigationBarView == null)
        return null;
    context.getSystemService(WindowManager.class).addView(navigationBarView, lp);
    FragmentHostManager fragmentHost = FragmentHostManager.get(navigationBarView);
    NavigationBarFragment fragment = new NavigationBarFragment();
    fragmentHost.getFragmentManager().beginTransaction().replace(R.id.navigation_bar_frame, fragment, TAG).commit();
    fragmentHost.addTagListener(TAG, listener);
    return navigationBarView;
}
#end_block

#method_before
@Override
public void start() {
    mNetworkController = Dependency.get(NetworkController.class);
    mUserSwitcherController = Dependency.get(UserSwitcherController.class);
    mKeyguardMonitor = (KeyguardMonitorImpl) Dependency.get(KeyguardMonitor.class);
    mBatteryController = Dependency.get(BatteryController.class);
    mAssistManager = Dependency.get(AssistManager.class);
    mDeviceProvisionedController = Dependency.get(DeviceProvisionedController.class);
    mSystemServicesProxy = SystemServicesProxy.getInstance(mContext);
    mForegroundServiceController = Dependency.get(ForegroundServiceController.class);
    mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    mDisplay = mWindowManager.getDefaultDisplay();
    updateDisplaySize();
    mScrimSrcModeEnabled = mContext.getResources().getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    DateTimeView.setReceiverHandler(Dependency.get(Dependency.TIME_TICK_HANDLER));
    putComponent(StatusBar.class, this);
    // start old BaseStatusBar.start().
    mWindowManagerService = WindowManagerGlobal.getWindowManagerService();
    mDevicePolicyManager = (DevicePolicyManager) mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
    mNotificationData = new NotificationData(this);
    mMessagingUtil = new NotificationMessagingUtil(mContext);
    mAccessibilityManager = (AccessibilityManager) mContext.getSystemService(Context.ACCESSIBILITY_SERVICE);
    mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mDeviceProvisionedController = Dependency.get(DeviceProvisionedController.class);
    mDeviceProvisionedController.addCallback(mDeviceProvisionedListener);
    mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.ZEN_MODE), false, mSettingsObserver);
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_SHOW_NOTIFICATIONS), false, mLockscreenSettingsObserver, UserHandle.USER_ALL);
    if (ENABLE_LOCK_SCREEN_ALLOW_REMOTE_INPUT) {
        mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_ALLOW_REMOTE_INPUT), false, mSettingsObserver, UserHandle.USER_ALL);
    }
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS), true, mLockscreenSettingsObserver, UserHandle.USER_ALL);
    mBarService = IStatusBarService.Stub.asInterface(ServiceManager.getService(Context.STATUS_BAR_SERVICE));
    mRecents = getComponent(Recents.class);
    final Configuration currentConfig = mContext.getResources().getConfiguration();
    mLocale = currentConfig.locale;
    mLayoutDirection = TextUtils.getLayoutDirectionFromLocale(mLocale);
    mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
    mLockPatternUtils = new LockPatternUtils(mContext);
    // Connect in to the status bar manager service
    mCommandQueue = getComponent(CommandQueue.class);
    mCommandQueue.addCallbacks(this);
    int[] switches = new int[9];
    ArrayList<IBinder> binders = new ArrayList<IBinder>();
    ArrayList<String> iconSlots = new ArrayList<>();
    ArrayList<StatusBarIcon> icons = new ArrayList<>();
    Rect fullscreenStackBounds = new Rect();
    Rect dockedStackBounds = new Rect();
    try {
        mBarService.registerStatusBar(mCommandQueue, iconSlots, icons, switches, binders, fullscreenStackBounds, dockedStackBounds);
    } catch (RemoteException ex) {
    // If the system process isn't there we're doomed anyway.
    }
    createAndAddWindows();
    // set up
    mSettingsObserver.onChange(false);
    mCommandQueue.disable(switches[0], switches[6], false);
    setSystemUiVisibility(switches[1], switches[7], switches[8], 0xffffffff, fullscreenStackBounds, dockedStackBounds);
    topAppWindowChanged(switches[2] != 0);
    // StatusBarManagerService has a back up of IME token and it's restored here.
    setImeWindowStatus(binders.get(0), switches[3], switches[4], switches[5] != 0);
    // Set up the initial icon state
    int N = iconSlots.size();
    int viewIndex = 0;
    for (int i = 0; i < N; i++) {
        mCommandQueue.setIcon(iconSlots.get(i), icons.get(i));
    }
    // Set up the initial notification state.
    try {
        mNotificationListener.registerAsSystemService(mContext, new ComponentName(mContext.getPackageName(), getClass().getCanonicalName()), UserHandle.USER_ALL);
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to register notification listener", e);
    }
    if (DEBUG) {
        Log.d(TAG, String.format("init: icons=%d disabled=0x%08x lights=0x%08x menu=0x%08x imeButton=0x%08x", icons.size(), switches[0], switches[1], switches[2], switches[3]));
    }
    mCurrentUserId = ActivityManager.getCurrentUser();
    setHeadsUpUser(mCurrentUserId);
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    filter.addAction(Intent.ACTION_USER_ADDED);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    mContext.registerReceiver(mBaseBroadcastReceiver, filter);
    IntentFilter internalFilter = new IntentFilter();
    internalFilter.addAction(NOTIFICATION_UNLOCKED_BY_WORK_CHALLENGE_ACTION);
    internalFilter.addAction(BANNER_ACTION_CANCEL);
    internalFilter.addAction(BANNER_ACTION_SETUP);
    mContext.registerReceiver(mBaseBroadcastReceiver, internalFilter, PERMISSION_SELF, null);
    IntentFilter allUsersFilter = new IntentFilter();
    allUsersFilter.addAction(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);
    allUsersFilter.addAction(Intent.ACTION_DEVICE_LOCKED_CHANGED);
    mContext.registerReceiverAsUser(mAllUsersReceiver, UserHandle.ALL, allUsersFilter, null, null);
    updateCurrentProfilesCache();
    IVrManager vrManager = IVrManager.Stub.asInterface(ServiceManager.getService(Context.VR_SERVICE));
    try {
        vrManager.registerListener(mVrStateCallbacks);
    } catch (RemoteException e) {
        Slog.e(TAG, "Failed to register VR mode state listener: " + e);
    }
    mNonBlockablePkgs = new HashSet<String>();
    Collections.addAll(mNonBlockablePkgs, mContext.getResources().getStringArray(com.android.internal.R.array.config_nonBlockableNotificationPackages));
    // end old BaseStatusBar.start().
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mIconController);
    // set up
    mSettingsObserver.onChange(false);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED), true, mHeadsUpObserver);
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP_TICKER), true, mHeadsUpObserver);
    }
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    mUnlockMethodCache.addListener(this);
    startKeyguard();
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mUpdateCallback);
    mDozeServiceHost = new DozeServiceHost();
    putComponent(DozeHost.class, mDozeServiceHost);
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    mFalsingManager = FalsingManager.getInstance(mContext);
    Dependency.get(ActivityStarterDelegate.class).setActivityStarterImpl(this);
    mConfigurationListener = new ConfigurationListener() {

        @Override
        public void onConfigChanged(Configuration newConfig) {
            StatusBar.this.onConfigurationChanged(newConfig);
        }

        @Override
        public void onDensityOrFontScaleChanged() {
            StatusBar.this.onDensityOrFontScaleChanged();
        }
    };
    Dependency.get(ConfigurationController.class).addCallback(mConfigurationListener);
    mFlashlightController = Dependency.get(FlashlightController.class);
}
#method_after
@Override
public void start() {
    mNetworkController = Dependency.get(NetworkController.class);
    mUserSwitcherController = Dependency.get(UserSwitcherController.class);
    mKeyguardMonitor = (KeyguardMonitorImpl) Dependency.get(KeyguardMonitor.class);
    mBatteryController = Dependency.get(BatteryController.class);
    mAssistManager = Dependency.get(AssistManager.class);
    mDeviceProvisionedController = Dependency.get(DeviceProvisionedController.class);
    mSystemServicesProxy = SystemServicesProxy.getInstance(mContext);
    mForegroundServiceController = Dependency.get(ForegroundServiceController.class);
    mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    mDisplay = mWindowManager.getDefaultDisplay();
    mPackageMonitor = new DUPackageMonitor();
    mPackageMonitor.register(mContext, mHandler);
    mPackageMonitor.addListener(this);
    updateDisplaySize();
    mScrimSrcModeEnabled = mContext.getResources().getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    DateTimeView.setReceiverHandler(Dependency.get(Dependency.TIME_TICK_HANDLER));
    putComponent(StatusBar.class, this);
    // start old BaseStatusBar.start().
    mWindowManagerService = WindowManagerGlobal.getWindowManagerService();
    mDevicePolicyManager = (DevicePolicyManager) mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
    mNotificationData = new NotificationData(this);
    mMessagingUtil = new NotificationMessagingUtil(mContext);
    mAccessibilityManager = (AccessibilityManager) mContext.getSystemService(Context.ACCESSIBILITY_SERVICE);
    mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mAm = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
    mDeviceProvisionedController = Dependency.get(DeviceProvisionedController.class);
    mDeviceProvisionedController.addCallback(mDeviceProvisionedListener);
    mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.ZEN_MODE), false, mSettingsObserver);
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_SHOW_NOTIFICATIONS), false, mLockscreenSettingsObserver, UserHandle.USER_ALL);
    if (ENABLE_LOCK_SCREEN_ALLOW_REMOTE_INPUT) {
        mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_ALLOW_REMOTE_INPUT), false, mSettingsObserver, UserHandle.USER_ALL);
    }
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS), true, mLockscreenSettingsObserver, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.NAVIGATION_BAR_VISIBLE), false, mNavbarObserver, UserHandle.USER_ALL);
    mBarService = IStatusBarService.Stub.asInterface(ServiceManager.getService(Context.STATUS_BAR_SERVICE));
    mRecents = getComponent(Recents.class);
    final Configuration currentConfig = mContext.getResources().getConfiguration();
    mLocale = currentConfig.locale;
    mLayoutDirection = TextUtils.getLayoutDirectionFromLocale(mLocale);
    mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
    mLockPatternUtils = new LockPatternUtils(mContext);
    // Connect in to the status bar manager service
    mCommandQueue = getComponent(CommandQueue.class);
    mCommandQueue.addCallbacks(this);
    int[] switches = new int[9];
    ArrayList<IBinder> binders = new ArrayList<IBinder>();
    ArrayList<String> iconSlots = new ArrayList<>();
    ArrayList<StatusBarIcon> icons = new ArrayList<>();
    Rect fullscreenStackBounds = new Rect();
    Rect dockedStackBounds = new Rect();
    try {
        mBarService.registerStatusBar(mCommandQueue, iconSlots, icons, switches, binders, fullscreenStackBounds, dockedStackBounds);
    } catch (RemoteException ex) {
    // If the system process isn't there we're doomed anyway.
    }
    createAndAddWindows();
    // set up
    mSettingsObserver.onChange(false);
    mCustomSettingsObserver.observe();
    mCustomSettingsObserver.update();
    mCommandQueue.disable(switches[0], switches[6], false);
    setSystemUiVisibility(switches[1], switches[7], switches[8], 0xffffffff, fullscreenStackBounds, dockedStackBounds);
    topAppWindowChanged(switches[2] != 0);
    // StatusBarManagerService has a back up of IME token and it's restored here.
    setImeWindowStatus(binders.get(0), switches[3], switches[4], switches[5] != 0);
    // Set up the initial icon state
    int N = iconSlots.size();
    int viewIndex = 0;
    for (int i = 0; i < N; i++) {
        mCommandQueue.setIcon(iconSlots.get(i), icons.get(i));
    }
    // Set up the initial notification state.
    try {
        mNotificationListener.registerAsSystemService(mContext, new ComponentName(mContext.getPackageName(), getClass().getCanonicalName()), UserHandle.USER_ALL);
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to register notification listener", e);
    }
    if (DEBUG) {
        Log.d(TAG, String.format("init: icons=%d disabled=0x%08x lights=0x%08x menu=0x%08x imeButton=0x%08x", icons.size(), switches[0], switches[1], switches[2], switches[3]));
    }
    mCurrentUserId = ActivityManager.getCurrentUser();
    setHeadsUpUser(mCurrentUserId);
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    filter.addAction(Intent.ACTION_USER_ADDED);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    mContext.registerReceiver(mBaseBroadcastReceiver, filter);
    IntentFilter internalFilter = new IntentFilter();
    internalFilter.addAction(NOTIFICATION_UNLOCKED_BY_WORK_CHALLENGE_ACTION);
    internalFilter.addAction(BANNER_ACTION_CANCEL);
    internalFilter.addAction(BANNER_ACTION_SETUP);
    mContext.registerReceiver(mBaseBroadcastReceiver, internalFilter, PERMISSION_SELF, null);
    IntentFilter allUsersFilter = new IntentFilter();
    allUsersFilter.addAction(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);
    allUsersFilter.addAction(Intent.ACTION_DEVICE_LOCKED_CHANGED);
    mContext.registerReceiverAsUser(mAllUsersReceiver, UserHandle.ALL, allUsersFilter, null, null);
    updateCurrentProfilesCache();
    IVrManager vrManager = IVrManager.Stub.asInterface(ServiceManager.getService(Context.VR_SERVICE));
    try {
        vrManager.registerListener(mVrStateCallbacks);
    } catch (RemoteException e) {
        Slog.e(TAG, "Failed to register VR mode state listener: " + e);
    }
    mNonBlockablePkgs = new HashSet<String>();
    Collections.addAll(mNonBlockablePkgs, mContext.getResources().getStringArray(com.android.internal.R.array.config_nonBlockableNotificationPackages));
    // end old BaseStatusBar.start().
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mIconController);
    // set up
    mSettingsObserver.onChange(false);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED), true, mHeadsUpObserver);
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP_TICKER), true, mHeadsUpObserver);
    }
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    mUnlockMethodCache.addListener(this);
    startKeyguard();
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mUpdateCallback);
    mDozeServiceHost = new DozeServiceHost();
    putComponent(DozeHost.class, mDozeServiceHost);
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    mFalsingManager = FalsingManager.getInstance(mContext);
    Dependency.get(ActivityStarterDelegate.class).setActivityStarterImpl(this);
    mConfigurationListener = new ConfigurationListener() {

        @Override
        public void onConfigChanged(Configuration newConfig) {
            StatusBar.this.onConfigurationChanged(newConfig);
        }

        @Override
        public void onDensityOrFontScaleChanged() {
            StatusBar.this.onDensityOrFontScaleChanged();
        }
    };
    Dependency.get(ConfigurationController.class).addCallback(mConfigurationListener);
    mFlashlightController = Dependency.get(FlashlightController.class);
}
#end_block

#method_before
// ================================================================================
// Constructing the view
protected void makeStatusBarView() {
    final Context context = mContext;
    // populates mDisplayMetrics
    updateDisplaySize();
    updateResources();
    inflateStatusBarWindow(context);
    mStatusBarWindow.setService(this);
    mStatusBarWindow.setOnTouchListener(getStatusBarWindowTouchListener());
    // TODO: Deal with the ugliness that comes from having some of the statusbar broken out
    // into fragments, but the rest here, it leaves some awkward lifecycle and whatnot.
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mStackScroller = (NotificationStackScrollLayout) mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
    mNotificationPanel.setStatusBar(this);
    mNotificationPanel.setGroupManager(mGroupManager);
    mKeyguardStatusBar = (KeyguardStatusBarView) mStatusBarWindow.findViewById(R.id.keyguard_header);
    mNotificationIconAreaController = SystemUIFactory.getInstance().createNotificationIconAreaController(context, this);
    inflateShelf();
    mNotificationIconAreaController.setupShelf(mNotificationShelf);
    Dependency.get(DarkIconDispatcher.class).addDarkReceiver(mNotificationIconAreaController);
    FragmentHostManager.get(mStatusBarWindow).addTagListener(CollapsedStatusBarFragment.TAG, (tag, fragment) -> {
        CollapsedStatusBarFragment statusBarFragment = (CollapsedStatusBarFragment) fragment;
        statusBarFragment.initNotificationIconArea(mNotificationIconAreaController);
        mStatusBarView = (PhoneStatusBarView) fragment.getView();
        mStatusBarView.setBar(this);
        mStatusBarView.setPanel(mNotificationPanel);
        mStatusBarView.setScrimController(mScrimController);
        setAreThereNotifications();
        checkBarModes();
    }).getFragmentManager().beginTransaction().replace(R.id.status_bar_container, new CollapsedStatusBarFragment(), CollapsedStatusBarFragment.TAG).commit();
    Dependency.get(StatusBarIconController.class).addIconGroup(new IconManager((ViewGroup) mKeyguardStatusBar.findViewById(R.id.statusIcons)));
    mIconController = Dependency.get(StatusBarIconController.class);
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
    }
    mHeadsUpManager = new HeadsUpManager(context, mStatusBarWindow, mGroupManager);
    mHeadsUpManager.setBar(this);
    mHeadsUpManager.addListener(this);
    mHeadsUpManager.addListener(mNotificationPanel);
    mHeadsUpManager.addListener(mGroupManager);
    mHeadsUpManager.addListener(mVisualStabilityManager);
    mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
    mNotificationData.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setHeadsUpManager(mHeadsUpManager);
    mHeadsUpManager.setVisualStabilityManager(mVisualStabilityManager);
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    try {
        boolean showNav = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + showNav);
        if (showNav) {
            createNavigationBar();
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mStackScroller.setLongPressListener(getNotificationLongClicker());
    mStackScroller.setStatusBar(this);
    mStackScroller.setGroupManager(mGroupManager);
    mStackScroller.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setOnGroupChangeListener(mStackScroller);
    mVisualStabilityManager.setVisibilityLocationProvider(mStackScroller);
    inflateEmptyShadeView();
    inflateDismissView();
    mExpandedContents = mStackScroller;
    mBackdrop = (BackDropView) mStatusBarWindow.findViewById(R.id.backdrop);
    mBackdropFront = (ImageView) mBackdrop.findViewById(R.id.backdrop_front);
    mBackdropBack = (ImageView) mBackdrop.findViewById(R.id.backdrop_back);
    if (ENABLE_LOCKSCREEN_WALLPAPER) {
        mLockscreenWallpaper = new LockscreenWallpaper(mContext, this, mHandler);
    }
    mKeyguardStatusView = (KeyguardStatusView) mStatusBarWindow.findViewById(R.id.keyguard_status_view);
    mKeyguardBottomArea = (KeyguardBottomAreaView) mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
    mKeyguardIndicationController = SystemUIFactory.getInstance().createKeyguardIndicationController(mContext, (ViewGroup) mStatusBarWindow.findViewById(R.id.keyguard_indication_area), mKeyguardBottomArea.getLockIcon());
    mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
    // set the initial view visibility
    setAreThereNotifications();
    // TODO: Find better place for this callback.
    mBatteryController.addCallback(new BatteryStateChangeCallback() {

        @Override
        public void onPowerSaveChanged(boolean isPowerSave) {
            mHandler.post(mCheckBarModes);
            if (mDozeServiceHost != null) {
                mDozeServiceHost.firePowerSaveChanged(isPowerSave);
            }
        }

        @Override
        public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) {
        // noop
        }
    });
    mLightBarController = new LightBarController();
    if (mNavigationBar != null) {
        mNavigationBar.setLightBarController(mLightBarController);
    }
    ScrimView scrimBehind = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_behind);
    ScrimView scrimInFront = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_in_front);
    View headsUpScrim = mStatusBarWindow.findViewById(R.id.heads_up_scrim);
    mScrimController = SystemUIFactory.getInstance().createScrimController(mLightBarController, scrimBehind, scrimInFront, headsUpScrim, mLockscreenWallpaper);
    if (mScrimSrcModeEnabled) {
        Runnable runnable = new Runnable() {

            @Override
            public void run() {
                boolean asSrc = mBackdrop.getVisibility() != View.VISIBLE;
                mScrimController.setDrawBehindAsSrc(asSrc);
                mStackScroller.setDrawBackgroundAsSrc(asSrc);
            }
        };
        mBackdrop.setOnVisibilityChangedRunnable(runnable);
        runnable.run();
    }
    mHeadsUpManager.addListener(mScrimController);
    mStackScroller.setScrimController(mScrimController);
    mDozeScrimController = new DozeScrimController(mScrimController, context);
    // Other icons
    mVolumeComponent = getComponent(VolumeComponent.class);
    mKeyguardBottomArea.setStatusBar(this);
    mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
    if (UserManager.get(mContext).isUserSwitcherEnabled()) {
        createUserSwitcher();
    }
    // Set up the quick settings tile panel
    View container = mStatusBarWindow.findViewById(R.id.qs_frame);
    if (container != null) {
        FragmentHostManager fragmentHostManager = FragmentHostManager.get(container);
        fragmentHostManager.getFragmentManager().beginTransaction().replace(R.id.qs_frame, new QSFragment(), QS.TAG).commit();
        new PluginFragmentListener(container, QS.TAG, QSFragment.class, QS.class).startListening();
        final QSTileHost qsh = SystemUIFactory.getInstance().createQSTileHost(mContext, this, mIconController);
        mBrightnessMirrorController = new BrightnessMirrorController(mStatusBarWindow);
        fragmentHostManager.addTagListener(QS.TAG, (tag, f) -> {
            QS qs = (QS) f;
            if (qs instanceof QSFragment) {
                ((QSFragment) qs).setHost(qsh);
                mQSPanel = ((QSFragment) qs).getQsPanel();
                mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
                mKeyguardStatusBar.setQSPanel(mQSPanel);
            }
        });
    }
    mReportRejectedTouch = mStatusBarWindow.findViewById(R.id.report_rejected_touch);
    if (mReportRejectedTouch != null) {
        updateReportRejectedTouchVisibility();
        mReportRejectedTouch.setOnClickListener(v -> {
            Uri session = mFalsingManager.reportRejectedTouch();
            if (session == null) {
                return;
            }
            StringWriter message = new StringWriter();
            message.write("Build info: ");
            message.write(SystemProperties.get("ro.build.description"));
            message.write("\nSerial number: ");
            message.write(SystemProperties.get("ro.serialno"));
            message.write("\n");
            PrintWriter falsingPw = new PrintWriter(message);
            FalsingLog.dump(falsingPw);
            falsingPw.flush();
            startActivityDismissingKeyguard(Intent.createChooser(new Intent(Intent.ACTION_SEND).setType("*/*").putExtra(Intent.EXTRA_SUBJECT, "Rejected touch report").putExtra(Intent.EXTRA_STREAM, session).putExtra(Intent.EXTRA_TEXT, message.toString()), "Share rejected touch report").addFlags(Intent.FLAG_ACTIVITY_NEW_TASK), true, /* onlyProvisioned */
            true);
        });
    }
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    if (!pm.isScreenOn()) {
        mBroadcastReceiver.onReceive(mContext, new Intent(Intent.ACTION_SCREEN_OFF));
    }
    mGestureWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "GestureWakeLock");
    mVibrator = mContext.getSystemService(Vibrator.class);
    int[] pattern = mContext.getResources().getIntArray(R.array.config_cameraLaunchGestureVibePattern);
    mCameraLaunchGestureVibePattern = new long[pattern.length];
    for (int i = 0; i < pattern.length; i++) {
        mCameraLaunchGestureVibePattern[i] = pattern[i];
    }
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(DevicePolicyManager.ACTION_SHOW_DEVICE_MONITORING_DIALOG);
    context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    IntentFilter demoFilter = new IntentFilter();
    if (DEBUG_MEDIA_FAKE_ARTWORK) {
        demoFilter.addAction(ACTION_FAKE_ARTWORK);
    }
    demoFilter.addAction(ACTION_DEMO);
    context.registerReceiverAsUser(mDemoReceiver, UserHandle.ALL, demoFilter, android.Manifest.permission.DUMP, null);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    mDeviceProvisionedController.addCallback(mUserSetupObserver);
    mUserSetupObserver.onUserSetupChanged();
    // disable profiling bars, since they overlap and clutter the output on app windows
    ThreadedRenderer.overrideProperty("disableProfileBars", "true");
    // Private API call to make the shadows look better for Recents
    ThreadedRenderer.overrideProperty("ambientRatio", String.valueOf(1.5f));
}
#method_after
// ================================================================================
// Constructing the view
protected void makeStatusBarView() {
    final Context context = mContext;
    // populates mDisplayMetrics
    updateDisplaySize();
    updateResources();
    inflateStatusBarWindow(context);
    mStatusBarWindow.setService(this);
    mStatusBarWindow.setOnTouchListener(getStatusBarWindowTouchListener());
    // TODO: Deal with the ugliness that comes from having some of the statusbar broken out
    // into fragments, but the rest here, it leaves some awkward lifecycle and whatnot.
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mStackScroller = (NotificationStackScrollLayout) mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
    mNotificationPanel.setStatusBar(this);
    mNotificationPanel.setGroupManager(mGroupManager);
    mKeyguardStatusBar = (KeyguardStatusBarView) mStatusBarWindow.findViewById(R.id.keyguard_header);
    mNotificationIconAreaController = SystemUIFactory.getInstance().createNotificationIconAreaController(context, this);
    inflateShelf();
    mNotificationIconAreaController.setupShelf(mNotificationShelf);
    Dependency.get(DarkIconDispatcher.class).addDarkReceiver(mNotificationIconAreaController);
    FragmentHostManager.get(mStatusBarWindow).addTagListener(CollapsedStatusBarFragment.TAG, (tag, fragment) -> {
        CollapsedStatusBarFragment statusBarFragment = (CollapsedStatusBarFragment) fragment;
        statusBarFragment.initNotificationIconArea(mNotificationIconAreaController);
        mStatusBarView = (PhoneStatusBarView) fragment.getView();
        mStatusBarView.setBar(this);
        mStatusBarView.setPanel(mNotificationPanel);
        mStatusBarView.setScrimController(mScrimController);
        mStatusBarContent = (LinearLayout) mStatusBarView.findViewById(R.id.status_bar_contents);
        updateTickerSettings();
        initTickerView();
        setAreThereNotifications();
        checkBarModes();
    }).getFragmentManager().beginTransaction().replace(R.id.status_bar_container, new CollapsedStatusBarFragment(), CollapsedStatusBarFragment.TAG).commit();
    Dependency.get(StatusBarIconController.class).addIconGroup(new IconManager((ViewGroup) mKeyguardStatusBar.findViewById(R.id.statusIcons)));
    mIconController = Dependency.get(StatusBarIconController.class);
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
    }
    mHeadsUpManager = new HeadsUpManager(context, mStatusBarWindow, mGroupManager);
    mHeadsUpManager.setBar(this);
    mHeadsUpManager.addListener(this);
    mHeadsUpManager.addListener(mNotificationPanel);
    mHeadsUpManager.addListener(mGroupManager);
    mHeadsUpManager.addListener(mVisualStabilityManager);
    mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
    mNotificationData.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setHeadsUpManager(mHeadsUpManager);
    mHeadsUpManager.setVisualStabilityManager(mVisualStabilityManager);
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    boolean showNav = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.NAVIGATION_BAR_VISIBLE, DUActionUtils.hasNavbarByDefault(mContext) ? 1 : 0) != 0;
    if (DEBUG)
        Log.v(TAG, "hasNavigationBar=" + showNav);
    if (showNav) {
        createNavigationBar();
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mStackScroller.setLongPressListener(getNotificationLongClicker());
    mStackScroller.setStatusBar(this);
    mStackScroller.setGroupManager(mGroupManager);
    mStackScroller.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setOnGroupChangeListener(mStackScroller);
    mVisualStabilityManager.setVisibilityLocationProvider(mStackScroller);
    inflateEmptyShadeView();
    inflateDismissView();
    mExpandedContents = mStackScroller;
    mBackdrop = (BackDropView) mStatusBarWindow.findViewById(R.id.backdrop);
    mBackdropFront = (ImageView) mBackdrop.findViewById(R.id.backdrop_front);
    mBackdropBack = (ImageView) mBackdrop.findViewById(R.id.backdrop_back);
    if (ENABLE_LOCKSCREEN_WALLPAPER) {
        mLockscreenWallpaper = new LockscreenWallpaper(mContext, this, mHandler);
    }
    mKeyguardStatusView = (KeyguardStatusView) mStatusBarWindow.findViewById(R.id.keyguard_status_view);
    mKeyguardBottomArea = (KeyguardBottomAreaView) mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
    mKeyguardIndicationController = SystemUIFactory.getInstance().createKeyguardIndicationController(mContext, (ViewGroup) mStatusBarWindow.findViewById(R.id.keyguard_indication_area), mKeyguardBottomArea.getLockIcon());
    mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
    // set the initial view visibility
    setAreThereNotifications();
    // TODO: Find better place for this callback.
    mBatteryController.addCallback(new BatteryStateChangeCallback() {

        @Override
        public void onPowerSaveChanged(boolean isPowerSave) {
            mHandler.post(mCheckBarModes);
            if (mDozeServiceHost != null) {
                mDozeServiceHost.firePowerSaveChanged(isPowerSave);
            }
        }

        @Override
        public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) {
        // noop
        }
    });
    mLightBarController = new LightBarController();
    if (mNavigationBar != null) {
        mNavigationBar.setLightBarController(mLightBarController);
    }
    ScrimView scrimBehind = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_behind);
    ScrimView scrimInFront = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_in_front);
    View headsUpScrim = mStatusBarWindow.findViewById(R.id.heads_up_scrim);
    mScrimController = SystemUIFactory.getInstance().createScrimController(mLightBarController, scrimBehind, scrimInFront, headsUpScrim, mLockscreenWallpaper);
    if (mScrimSrcModeEnabled) {
        Runnable runnable = new Runnable() {

            @Override
            public void run() {
                boolean asSrc = mBackdrop.getVisibility() != View.VISIBLE;
                mScrimController.setDrawBehindAsSrc(asSrc);
                mStackScroller.setDrawBackgroundAsSrc(asSrc);
            }
        };
        mBackdrop.setOnVisibilityChangedRunnable(runnable);
        runnable.run();
    }
    mHeadsUpManager.addListener(mScrimController);
    mStackScroller.setScrimController(mScrimController);
    mDozeScrimController = new DozeScrimController(mScrimController, context);
    // Other icons
    mVolumeComponent = getComponent(VolumeComponent.class);
    mKeyguardBottomArea.setStatusBar(this);
    mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
    if (UserManager.get(mContext).isUserSwitcherEnabled()) {
        createUserSwitcher();
    }
    // Set up the quick settings tile panel
    View container = mStatusBarWindow.findViewById(R.id.qs_frame);
    if (container != null) {
        FragmentHostManager fragmentHostManager = FragmentHostManager.get(container);
        fragmentHostManager.getFragmentManager().beginTransaction().replace(R.id.qs_frame, new QSFragment(), QS.TAG).commit();
        new PluginFragmentListener(container, QS.TAG, QSFragment.class, QS.class).startListening();
        final QSTileHost qsh = SystemUIFactory.getInstance().createQSTileHost(mContext, this, mIconController);
        mBrightnessMirrorController = new BrightnessMirrorController(mContext, mStatusBarWindow);
        fragmentHostManager.addTagListener(QS.TAG, (tag, f) -> {
            QS qs = (QS) f;
            if (qs instanceof QSFragment) {
                ((QSFragment) qs).setHost(qsh);
                mQSPanel = ((QSFragment) qs).getQsPanel();
                mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
                mKeyguardStatusBar.setQSPanel(mQSPanel);
            }
        });
    }
    mReportRejectedTouch = mStatusBarWindow.findViewById(R.id.report_rejected_touch);
    if (mReportRejectedTouch != null) {
        updateReportRejectedTouchVisibility();
        mReportRejectedTouch.setOnClickListener(v -> {
            Uri session = mFalsingManager.reportRejectedTouch();
            if (session == null) {
                return;
            }
            StringWriter message = new StringWriter();
            message.write("Build info: ");
            message.write(SystemProperties.get("ro.build.description"));
            message.write("\nSerial number: ");
            message.write(SystemProperties.get("ro.serialno"));
            message.write("\n");
            PrintWriter falsingPw = new PrintWriter(message);
            FalsingLog.dump(falsingPw);
            falsingPw.flush();
            startActivityDismissingKeyguard(Intent.createChooser(new Intent(Intent.ACTION_SEND).setType("*/*").putExtra(Intent.EXTRA_SUBJECT, "Rejected touch report").putExtra(Intent.EXTRA_STREAM, session).putExtra(Intent.EXTRA_TEXT, message.toString()), "Share rejected touch report").addFlags(Intent.FLAG_ACTIVITY_NEW_TASK), true, /* onlyProvisioned */
            true);
        });
    }
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    if (!pm.isScreenOn()) {
        mBroadcastReceiver.onReceive(mContext, new Intent(Intent.ACTION_SCREEN_OFF));
    }
    mGestureWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "GestureWakeLock");
    mVibrator = mContext.getSystemService(Vibrator.class);
    int[] pattern = mContext.getResources().getIntArray(R.array.config_cameraLaunchGestureVibePattern);
    mCameraLaunchGestureVibePattern = new long[pattern.length];
    for (int i = 0; i < pattern.length; i++) {
        mCameraLaunchGestureVibePattern[i] = pattern[i];
    }
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(DevicePolicyManager.ACTION_SHOW_DEVICE_MONITORING_DIALOG);
    context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    IntentFilter demoFilter = new IntentFilter();
    if (DEBUG_MEDIA_FAKE_ARTWORK) {
        demoFilter.addAction(ACTION_FAKE_ARTWORK);
    }
    demoFilter.addAction(ACTION_DEMO);
    context.registerReceiverAsUser(mDemoReceiver, UserHandle.ALL, demoFilter, android.Manifest.permission.DUMP, null);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    mDeviceProvisionedController.addCallback(mUserSetupObserver);
    mUserSetupObserver.onUserSetupChanged();
    // disable profiling bars, since they overlap and clutter the output on app windows
    ThreadedRenderer.overrideProperty("disableProfileBars", "true");
    // Private API call to make the shadows look better for Recents
    ThreadedRenderer.overrideProperty("ambientRatio", String.valueOf(1.5f));
}
#end_block

#method_before
protected void createNavigationBar() {
    mNavigationBarView = NavigationBarFragment.create(mContext, (tag, fragment) -> {
        mNavigationBar = (NavigationBarFragment) fragment;
        if (mLightBarController != null) {
            mNavigationBar.setLightBarController(mLightBarController);
        }
        mNavigationBar.setCurrentSysuiVisibility(mSystemUiVisibility);
    });
}
#method_after
protected void createNavigationBar() {
    mNavigationBarView = NavigationBarFragment.create(mContext, (tag, fragment) -> {
        mNavigationBar = (NavigationBarFragment) fragment;
        if (mLightBarController != null) {
            mNavigationBar.setLightBarController(mLightBarController);
        }
        if (!mNavigationBar.isUsingStockNav()) {
            ((NavigationBarFrame) mNavigationBarView).disableDeadZone();
            setMediaPlaying();
        }
        mNavigationBar.setCurrentSysuiVisibility(mSystemUiVisibility);
    });
}
#end_block

#method_before
private void addEntry(Entry shadeEntry) {
    boolean isHeadsUped = shouldPeek(shadeEntry);
    if (isHeadsUped) {
        mHeadsUpManager.showNotification(shadeEntry);
        // Mark as seen immediately
        setNotificationShown(shadeEntry.notification);
    }
    addNotificationViews(shadeEntry);
    // Recalculate the position of the sliding windows and the titles.
    setAreThereNotifications();
}
#method_after
private void addEntry(Entry shadeEntry) {
    boolean isHeadsUped = shouldPeek(shadeEntry);
    if (isHeadsUped) {
        mHeadsUpManager.showNotification(shadeEntry);
        // Mark as seen immediately
        setNotificationShown(shadeEntry.notification);
    } else {
        tick(shadeEntry.notification, true, false, null);
    }
    addNotificationViews(shadeEntry);
    // Recalculate the position of the sliding windows and the titles.
    setAreThereNotifications();
}
#end_block

#method_before
public void removeNotification(String key, RankingMap ranking) {
    boolean deferRemoval = false;
    abortExistingInflation(key);
    if (mHeadsUpManager.isHeadsUp(key)) {
        // A cancel() in repsonse to a remote input shouldn't be delayed, as it makes the
        // sending look longer than it takes.
        // Also we should not defer the removal if reordering isn't allowed since otherwise
        // some notifications can't disappear before the panel is closed.
        boolean ignoreEarliestRemovalTime = mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY || !mVisualStabilityManager.isReorderingAllowed();
        deferRemoval = !mHeadsUpManager.removeNotification(key, ignoreEarliestRemovalTime);
    }
    if (key.equals(mMediaNotificationKey)) {
        clearCurrentMediaNotification();
        updateMediaMetaData(true, true);
    }
    if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
        Entry entry = mNotificationData.get(key);
        StatusBarNotification sbn = entry.notification;
        Notification.Builder b = Notification.Builder.recoverBuilder(mContext, sbn.getNotification().clone());
        CharSequence[] oldHistory = sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
        CharSequence[] newHistory;
        if (oldHistory == null) {
            newHistory = new CharSequence[1];
        } else {
            newHistory = new CharSequence[oldHistory.length + 1];
            for (int i = 0; i < oldHistory.length; i++) {
                newHistory[i + 1] = oldHistory[i];
            }
        }
        newHistory[0] = String.valueOf(entry.remoteInputText);
        b.setRemoteInputHistory(newHistory);
        Notification newNotification = b.build();
        // Undo any compatibility view inflation
        newNotification.contentView = sbn.getNotification().contentView;
        newNotification.bigContentView = sbn.getNotification().bigContentView;
        newNotification.headsUpContentView = sbn.getNotification().headsUpContentView;
        StatusBarNotification newSbn = new StatusBarNotification(sbn.getPackageName(), sbn.getOpPkg(), sbn.getId(), sbn.getTag(), sbn.getUid(), sbn.getInitialPid(), newNotification, sbn.getUser(), sbn.getOverrideGroupKey(), sbn.getPostTime());
        boolean updated = false;
        try {
            updateNotification(newSbn, null);
            updated = true;
        } catch (InflationException e) {
            deferRemoval = false;
        }
        if (updated) {
            mKeysKeptForRemoteInput.add(entry.key);
            return;
        }
    }
    if (deferRemoval) {
        mLatestRankingMap = ranking;
        mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
        return;
    }
    Entry entry = mNotificationData.get(key);
    if (entry != null && mRemoteInputController.isRemoteInputActive(entry) && (entry.row != null && !entry.row.isDismissed())) {
        mLatestRankingMap = ranking;
        mRemoteInputEntriesToRemoveOnCollapse.add(entry);
        return;
    }
    if (entry != null) {
        mForegroundServiceController.removeNotification(entry.notification);
    }
    if (entry != null && entry.row != null) {
        entry.row.setRemoved();
        mStackScroller.cleanUpViewState(entry.row);
    }
    // Let's remove the children if this was a summary
    handleGroupSummaryRemoved(key, ranking);
    StatusBarNotification old = removeNotificationViews(key, ranking);
    if (SPEW)
        Log.d(TAG, "removeNotification key=" + key + " old=" + old);
    if (old != null) {
        if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking() && !mNotificationPanel.isQsExpanded()) {
            if (mState == StatusBarState.SHADE) {
                animateCollapsePanels();
            } else if (mState == StatusBarState.SHADE_LOCKED && !isCollapsing()) {
                goToKeyguard();
            }
        }
    }
    setAreThereNotifications();
}
#method_after
public void removeNotification(String key, RankingMap ranking) {
    boolean deferRemoval = false;
    abortExistingInflation(key);
    if (mHeadsUpManager.isHeadsUp(key)) {
        // A cancel() in repsonse to a remote input shouldn't be delayed, as it makes the
        // sending look longer than it takes.
        // Also we should not defer the removal if reordering isn't allowed since otherwise
        // some notifications can't disappear before the panel is closed.
        boolean ignoreEarliestRemovalTime = mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY || !mVisualStabilityManager.isReorderingAllowed();
        deferRemoval = !mHeadsUpManager.removeNotification(key, ignoreEarliestRemovalTime);
    }
    if (key.equals(mMediaNotificationKey)) {
        clearCurrentMediaNotification();
        updateMediaMetaData(true, true);
    }
    if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
        Entry entry = mNotificationData.get(key);
        StatusBarNotification sbn = entry.notification;
        Notification.Builder b = Notification.Builder.recoverBuilder(mContext, sbn.getNotification().clone());
        CharSequence[] oldHistory = sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
        CharSequence[] newHistory;
        if (oldHistory == null) {
            newHistory = new CharSequence[1];
        } else {
            newHistory = new CharSequence[oldHistory.length + 1];
            for (int i = 0; i < oldHistory.length; i++) {
                newHistory[i + 1] = oldHistory[i];
            }
        }
        newHistory[0] = String.valueOf(entry.remoteInputText);
        b.setRemoteInputHistory(newHistory);
        Notification newNotification = b.build();
        // Undo any compatibility view inflation
        newNotification.contentView = sbn.getNotification().contentView;
        newNotification.bigContentView = sbn.getNotification().bigContentView;
        newNotification.headsUpContentView = sbn.getNotification().headsUpContentView;
        StatusBarNotification newSbn = new StatusBarNotification(sbn.getPackageName(), sbn.getOpPkg(), sbn.getId(), sbn.getTag(), sbn.getUid(), sbn.getInitialPid(), newNotification, sbn.getUser(), sbn.getOverrideGroupKey(), sbn.getPostTime());
        boolean updated = false;
        try {
            updateNotification(newSbn, null);
            updated = true;
        } catch (InflationException e) {
            deferRemoval = false;
        }
        if (updated) {
            mKeysKeptForRemoteInput.add(entry.key);
            return;
        }
    }
    if (deferRemoval) {
        mLatestRankingMap = ranking;
        mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
        return;
    }
    Entry entry = mNotificationData.get(key);
    if (entry != null && mRemoteInputController.isRemoteInputActive(entry) && (entry.row != null && !entry.row.isDismissed())) {
        mLatestRankingMap = ranking;
        mRemoteInputEntriesToRemoveOnCollapse.add(entry);
        return;
    }
    if (entry != null) {
        mForegroundServiceController.removeNotification(entry.notification);
    }
    if (entry != null && entry.row != null) {
        entry.row.setRemoved();
        mStackScroller.cleanUpViewState(entry.row);
    }
    // Let's remove the children if this was a summary
    handleGroupSummaryRemoved(key, ranking);
    StatusBarNotification old = removeNotificationViews(key, ranking);
    if (SPEW)
        Log.d(TAG, "removeNotification key=" + key + " old=" + old);
    if (old != null) {
        // Cancel the ticker if it's still running
        if (mTickerEnabled != 0) {
            try {
                mTicker.removeEntry(old);
            } catch (Exception e) {
            }
        }
        if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking() && !mNotificationPanel.isQsExpanded()) {
            if (mState == StatusBarState.SHADE) {
                animateCollapsePanels();
            } else if (mState == StatusBarState.SHADE_LOCKED && !isCollapsing()) {
                goToKeyguard();
            }
        }
    }
    setAreThereNotifications();
}
#end_block

#method_before
public void findAndUpdateMediaNotifications() {
    boolean metaDataChanged = false;
    synchronized (mNotificationData) {
        ArrayList<Entry> activeNotifications = mNotificationData.getActiveNotifications();
        final int N = activeNotifications.size();
        // Promote the media notification with a controller in 'playing' state, if any.
        Entry mediaNotification = null;
        MediaController controller = null;
        for (int i = 0; i < N; i++) {
            final Entry entry = activeNotifications.get(i);
            if (isMediaNotification(entry)) {
                final MediaSession.Token token = entry.notification.getNotification().extras.getParcelable(Notification.EXTRA_MEDIA_SESSION);
                if (token != null) {
                    MediaController aController = new MediaController(mContext, token);
                    if (PlaybackState.STATE_PLAYING == getMediaControllerPlaybackState(aController)) {
                        if (DEBUG_MEDIA) {
                            Log.v(TAG, "DEBUG_MEDIA: found mediastyle controller matching " + entry.notification.getKey());
                        }
                        mediaNotification = entry;
                        controller = aController;
                        break;
                    }
                }
            }
        }
        if (mediaNotification == null) {
            if (mMediaSessionManager != null) {
                final List<MediaController> sessions = mMediaSessionManager.getActiveSessionsForUser(null, UserHandle.USER_ALL);
                for (MediaController aController : sessions) {
                    if (PlaybackState.STATE_PLAYING == getMediaControllerPlaybackState(aController)) {
                        // now to see if we have one like this
                        final String pkg = aController.getPackageName();
                        for (int i = 0; i < N; i++) {
                            final Entry entry = activeNotifications.get(i);
                            if (entry.notification.getPackageName().equals(pkg)) {
                                if (DEBUG_MEDIA) {
                                    Log.v(TAG, "DEBUG_MEDIA: found controller matching " + entry.notification.getKey());
                                }
                                controller = aController;
                                mediaNotification = entry;
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (controller != null && !sameSessions(mMediaController, controller)) {
            // We have a new media session
            clearCurrentMediaNotification();
            mMediaController = controller;
            mMediaController.registerCallback(mMediaListener);
            mMediaMetadata = mMediaController.getMetadata();
            if (DEBUG_MEDIA) {
                Log.v(TAG, "DEBUG_MEDIA: insert listener, receive metadata: " + mMediaMetadata);
            }
            if (mediaNotification != null) {
                mMediaNotificationKey = mediaNotification.notification.getKey();
                if (DEBUG_MEDIA) {
                    Log.v(TAG, "DEBUG_MEDIA: Found new media notification: key=" + mMediaNotificationKey + " controller=" + mMediaController);
                }
            }
            metaDataChanged = true;
        }
    }
    if (metaDataChanged) {
        updateNotifications();
    }
    updateMediaMetaData(metaDataChanged, true);
}
#method_after
public void findAndUpdateMediaNotifications() {
    boolean metaDataChanged = false;
    synchronized (mNotificationData) {
        ArrayList<Entry> activeNotifications = mNotificationData.getActiveNotifications();
        final int N = activeNotifications.size();
        // Promote the media notification with a controller in 'playing' state, if any.
        Entry mediaNotification = null;
        MediaController controller = null;
        for (int i = 0; i < N; i++) {
            final Entry entry = activeNotifications.get(i);
            if (isMediaNotification(entry)) {
                final MediaSession.Token token = entry.notification.getNotification().extras.getParcelable(Notification.EXTRA_MEDIA_SESSION);
                if (token != null) {
                    MediaController aController = new MediaController(mContext, token);
                    if (PlaybackState.STATE_PLAYING == getMediaControllerPlaybackState(aController)) {
                        if (DEBUG_MEDIA) {
                            Log.v(TAG, "DEBUG_MEDIA: found mediastyle controller matching " + entry.notification.getKey());
                        }
                        mediaNotification = entry;
                        controller = aController;
                        break;
                    }
                }
            }
        }
        if (mediaNotification == null) {
            if (mMediaSessionManager != null) {
                final List<MediaController> sessions = mMediaSessionManager.getActiveSessionsForUser(null, UserHandle.USER_ALL);
                for (MediaController aController : sessions) {
                    if (PlaybackState.STATE_PLAYING == getMediaControllerPlaybackState(aController)) {
                        // now to see if we have one like this
                        final String pkg = aController.getPackageName();
                        for (int i = 0; i < N; i++) {
                            final Entry entry = activeNotifications.get(i);
                            if (entry.notification.getPackageName().equals(pkg)) {
                                if (DEBUG_MEDIA) {
                                    Log.v(TAG, "DEBUG_MEDIA: found controller matching " + entry.notification.getKey());
                                }
                                controller = aController;
                                mediaNotification = entry;
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (controller != null && !sameSessions(mMediaController, controller)) {
            // We have a new media session
            clearCurrentMediaNotification();
            mMediaController = controller;
            mMediaController.registerCallback(mMediaListener);
            if (mNavigationBar != null) {
                setMediaPlaying();
            }
            mMediaMetadata = mMediaController.getMetadata();
            if (DEBUG_MEDIA) {
                Log.v(TAG, "DEBUG_MEDIA: insert listener, receive metadata: " + mMediaMetadata);
            }
            if (mediaNotification != null) {
                mMediaNotificationKey = mediaNotification.notification.getKey();
                if (DEBUG_MEDIA) {
                    Log.v(TAG, "DEBUG_MEDIA: Found new media notification: key=" + mMediaNotificationKey + " controller=" + mMediaController);
                }
            }
            metaDataChanged = true;
        }
    }
    if (metaDataChanged) {
        updateNotifications();
    }
    updateMediaMetaData(metaDataChanged, true);
}
#end_block

#method_before
private void clearCurrentMediaNotification() {
    mMediaNotificationKey = null;
    mMediaMetadata = null;
    if (mMediaController != null) {
        if (DEBUG_MEDIA) {
            Log.v(TAG, "DEBUG_MEDIA: Disconnecting from old controller: " + mMediaController.getPackageName());
        }
        mMediaController.unregisterCallback(mMediaListener);
    }
    mMediaController = null;
}
#method_after
private void clearCurrentMediaNotification() {
    mMediaNotificationKey = null;
    mMediaMetadata = null;
    if (mMediaController != null) {
        if (DEBUG_MEDIA) {
            Log.v(TAG, "DEBUG_MEDIA: Disconnecting from old controller: " + mMediaController.getPackageName());
        }
        mMediaController.unregisterCallback(mMediaListener);
        if (mNavigationBar != null) {
            setMediaPlaying();
        }
    }
    mMediaController = null;
}
#end_block

#method_before
@Override
public void disable(int state1, int state2, boolean animate) {
    animate &= mStatusBarWindowState != WINDOW_STATE_HIDDEN;
    mDisabledUnmodified1 = state1;
    mDisabledUnmodified2 = state2;
    final int old1 = mDisabled1;
    final int diff1 = state1 ^ old1;
    mDisabled1 = state1;
    final int old2 = mDisabled2;
    final int diff2 = state2 ^ old2;
    mDisabled2 = state2;
    if (DEBUG) {
        Log.d(TAG, String.format("disable1: 0x%08x -> 0x%08x (diff1: 0x%08x)", old1, state1, diff1));
        Log.d(TAG, String.format("disable2: 0x%08x -> 0x%08x (diff2: 0x%08x)", old2, state2, diff2));
    }
    StringBuilder flagdbg = new StringBuilder();
    flagdbg.append("disable<");
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_EXPAND)) ? 'E' : 'e');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_EXPAND)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_NOTIFICATION_ICONS)) ? 'I' : 'i');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_NOTIFICATION_ICONS)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_NOTIFICATION_ALERTS)) ? 'A' : 'a');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_NOTIFICATION_ALERTS)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_SYSTEM_INFO)) ? 'S' : 's');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_SYSTEM_INFO)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_BACK)) ? 'B' : 'b');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_BACK)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_HOME)) ? 'H' : 'h');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_HOME)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_RECENT)) ? 'R' : 'r');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_RECENT)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_CLOCK)) ? 'C' : 'c');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_CLOCK)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_SEARCH)) ? 'S' : 's');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_SEARCH)) ? '!' : ' ');
    flagdbg.append(0 != ((state2 & StatusBarManager.DISABLE2_QUICK_SETTINGS)) ? 'Q' : 'q');
    flagdbg.append(0 != ((diff2 & StatusBarManager.DISABLE2_QUICK_SETTINGS)) ? '!' : ' ');
    flagdbg.append('>');
    Log.d(TAG, flagdbg.toString());
    if ((diff1 & StatusBarManager.DISABLE_EXPAND) != 0) {
        if ((state1 & StatusBarManager.DISABLE_EXPAND) != 0) {
            animateCollapsePanels();
        }
    }
    if ((diff1 & StatusBarManager.DISABLE_RECENT) != 0) {
        if ((state1 & StatusBarManager.DISABLE_RECENT) != 0) {
            // close recents if it's visible
            mHandler.removeMessages(MSG_HIDE_RECENT_APPS);
            mHandler.sendEmptyMessage(MSG_HIDE_RECENT_APPS);
        }
    }
    if ((diff1 & StatusBarManager.DISABLE_NOTIFICATION_ALERTS) != 0) {
        mDisableNotificationAlerts = (state1 & StatusBarManager.DISABLE_NOTIFICATION_ALERTS) != 0;
        mHeadsUpObserver.onChange(true);
    }
    if ((diff2 & StatusBarManager.DISABLE2_QUICK_SETTINGS) != 0) {
        updateQsExpansionEnabled();
    }
}
#method_after
@Override
public void disable(int state1, int state2, boolean animate) {
    animate &= mStatusBarWindowState != WINDOW_STATE_HIDDEN;
    mDisabledUnmodified1 = state1;
    mDisabledUnmodified2 = state2;
    final int old1 = mDisabled1;
    final int diff1 = state1 ^ old1;
    mDisabled1 = state1;
    final int old2 = mDisabled2;
    final int diff2 = state2 ^ old2;
    mDisabled2 = state2;
    if (DEBUG) {
        Log.d(TAG, String.format("disable1: 0x%08x -> 0x%08x (diff1: 0x%08x)", old1, state1, diff1));
        Log.d(TAG, String.format("disable2: 0x%08x -> 0x%08x (diff2: 0x%08x)", old2, state2, diff2));
    }
    StringBuilder flagdbg = new StringBuilder();
    flagdbg.append("disable<");
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_EXPAND)) ? 'E' : 'e');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_EXPAND)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_NOTIFICATION_ICONS)) ? 'I' : 'i');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_NOTIFICATION_ICONS)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_NOTIFICATION_ALERTS)) ? 'A' : 'a');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_NOTIFICATION_ALERTS)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_SYSTEM_INFO)) ? 'S' : 's');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_SYSTEM_INFO)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_BACK)) ? 'B' : 'b');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_BACK)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_HOME)) ? 'H' : 'h');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_HOME)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_RECENT)) ? 'R' : 'r');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_RECENT)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_CLOCK)) ? 'C' : 'c');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_CLOCK)) ? '!' : ' ');
    flagdbg.append(0 != ((state1 & StatusBarManager.DISABLE_SEARCH)) ? 'S' : 's');
    flagdbg.append(0 != ((diff1 & StatusBarManager.DISABLE_SEARCH)) ? '!' : ' ');
    flagdbg.append(0 != ((state2 & StatusBarManager.DISABLE2_QUICK_SETTINGS)) ? 'Q' : 'q');
    flagdbg.append(0 != ((diff2 & StatusBarManager.DISABLE2_QUICK_SETTINGS)) ? '!' : ' ');
    flagdbg.append('>');
    Log.d(TAG, flagdbg.toString());
    if ((diff1 & StatusBarManager.DISABLE_EXPAND) != 0) {
        if ((state1 & StatusBarManager.DISABLE_EXPAND) != 0) {
            animateCollapsePanels();
        }
    }
    if ((diff1 & StatusBarManager.DISABLE_RECENT) != 0) {
        if ((state1 & StatusBarManager.DISABLE_RECENT) != 0) {
            // close recents if it's visible
            mHandler.removeMessages(MSG_HIDE_RECENT_APPS);
            mHandler.sendEmptyMessage(MSG_HIDE_RECENT_APPS);
        }
    }
    if ((diff1 & StatusBarManager.DISABLE_NOTIFICATION_ALERTS) != 0) {
        mDisableNotificationAlerts = (state1 & StatusBarManager.DISABLE_NOTIFICATION_ALERTS) != 0;
        mHeadsUpObserver.onChange(true);
    }
    if ((diff1 & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0 && (state1 & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0 && mTicking) {
        haltTicker();
    }
    if ((diff2 & StatusBarManager.DISABLE2_QUICK_SETTINGS) != 0) {
        updateQsExpansionEnabled();
    }
}
#end_block

#method_before
public void setPanelExpanded(boolean isExpanded) {
    mPanelExpanded = isExpanded;
    mStatusBarWindowManager.setPanelExpanded(isExpanded);
    mVisualStabilityManager.setPanelExpanded(isExpanded);
    if (isExpanded && getBarState() != StatusBarState.KEYGUARD) {
        if (DEBUG) {
            Log.v(TAG, "clearing notification effects from setPanelExpanded");
        }
        clearNotificationEffects();
    }
    if (!isExpanded) {
        removeRemoteInputEntriesKeptUntilCollapsed();
    }
}
#method_after
public void setPanelExpanded(boolean isExpanded) {
    mPanelExpanded = isExpanded;
    mStatusBarWindowManager.setPanelExpanded(isExpanded);
    mVisualStabilityManager.setPanelExpanded(isExpanded);
    if (isExpanded && getBarState() != StatusBarState.KEYGUARD) {
        if (DEBUG) {
            Log.v(TAG, "clearing notification effects from setPanelExpanded");
        }
        clearNotificationEffects();
    }
    if (!isExpanded) {
        removeRemoteInputEntriesKeptUntilCollapsed();
    }
    if (mNavigationBar != null) {
        mNavigationBar.setPanelExpanded(isExpanded);
    }
}
#end_block

#method_before
// CommandQueue
@Override
public void setSystemUiVisibility(int vis, int fullscreenStackVis, int dockedStackVis, int mask, Rect fullscreenStackBounds, Rect dockedStackBounds) {
    final int oldVal = mSystemUiVisibility;
    final int newVal = (oldVal & ~mask) | (vis & mask);
    final int diff = newVal ^ oldVal;
    if (DEBUG)
        Log.d(TAG, String.format("setSystemUiVisibility vis=%s mask=%s oldVal=%s newVal=%s diff=%s", Integer.toHexString(vis), Integer.toHexString(mask), Integer.toHexString(oldVal), Integer.toHexString(newVal), Integer.toHexString(diff)));
    boolean sbModeChanged = false;
    if (diff != 0) {
        mSystemUiVisibility = newVal;
        // update low profile
        if ((diff & View.SYSTEM_UI_FLAG_LOW_PROFILE) != 0) {
            setAreThereNotifications();
        }
        // ready to unhide
        if ((vis & View.STATUS_BAR_UNHIDE) != 0) {
            mSystemUiVisibility &= ~View.STATUS_BAR_UNHIDE;
            mNoAnimationOnNextBarModeChange = true;
        }
        // update status bar mode
        final int sbMode = computeStatusBarMode(oldVal, newVal);
        sbModeChanged = sbMode != -1;
        if (sbModeChanged && sbMode != mStatusBarMode) {
            if (sbMode != mStatusBarMode) {
                mStatusBarMode = sbMode;
                checkBarModes();
            }
            touchAutoHide();
        }
        if ((vis & View.NAVIGATION_BAR_UNHIDE) != 0) {
            mSystemUiVisibility &= ~View.NAVIGATION_BAR_UNHIDE;
        }
        // send updated sysui visibility to window manager
        notifyUiVisibilityChanged(mSystemUiVisibility);
    }
    mLightBarController.onSystemUiVisibilityChanged(fullscreenStackVis, dockedStackVis, mask, fullscreenStackBounds, dockedStackBounds, sbModeChanged, mStatusBarMode);
}
#method_after
// CommandQueue
@Override
public void setSystemUiVisibility(int vis, int fullscreenStackVis, int dockedStackVis, int mask, Rect fullscreenStackBounds, Rect dockedStackBounds) {
    final int oldVal = mSystemUiVisibility;
    final int newVal = (oldVal & ~mask) | (vis & mask);
    final int diff = newVal ^ oldVal;
    if (DEBUG)
        Log.d(TAG, String.format("setSystemUiVisibility vis=%s mask=%s oldVal=%s newVal=%s diff=%s", Integer.toHexString(vis), Integer.toHexString(mask), Integer.toHexString(oldVal), Integer.toHexString(newVal), Integer.toHexString(diff)));
    boolean sbModeChanged = false;
    if (diff != 0) {
        mSystemUiVisibility = newVal;
        // update low profile
        if ((diff & View.SYSTEM_UI_FLAG_LOW_PROFILE) != 0) {
            final boolean lightsOut = (vis & View.SYSTEM_UI_FLAG_LOW_PROFILE) != 0;
            if (lightsOut) {
                animateCollapsePanels();
                if (mTicking) {
                    haltTicker();
                }
            }
            setAreThereNotifications();
        }
        // ready to unhide
        if ((vis & View.STATUS_BAR_UNHIDE) != 0) {
            mSystemUiVisibility &= ~View.STATUS_BAR_UNHIDE;
            mNoAnimationOnNextBarModeChange = true;
        }
        // update status bar mode
        final int sbMode = computeStatusBarMode(oldVal, newVal);
        sbModeChanged = sbMode != -1;
        if (sbModeChanged && sbMode != mStatusBarMode) {
            if (sbMode != mStatusBarMode) {
                mStatusBarMode = sbMode;
                checkBarModes();
            }
            touchAutoHide();
        }
        if ((vis & View.NAVIGATION_BAR_UNHIDE) != 0) {
            mSystemUiVisibility &= ~View.NAVIGATION_BAR_UNHIDE;
        }
        // send updated sysui visibility to window manager
        notifyUiVisibilityChanged(mSystemUiVisibility);
    }
    mLightBarController.onSystemUiVisibilityChanged(fullscreenStackVis, dockedStackVis, mask, fullscreenStackBounds, dockedStackBounds, sbModeChanged, mStatusBarMode);
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    synchronized (mQueueLock) {
        pw.println("Current Status Bar state:");
        pw.println("  mExpandedVisible=" + mExpandedVisible + ", mTrackingPosition=" + mTrackingPosition);
        pw.println("  mTracking=" + mTracking);
        pw.println("  mDisplayMetrics=" + mDisplayMetrics);
        pw.println("  mStackScroller: " + viewInfo(mStackScroller));
        pw.println("  mStackScroller: " + viewInfo(mStackScroller) + " scroll " + mStackScroller.getScrollX() + "," + mStackScroller.getScrollY());
    }
    pw.print("  mPendingNotifications=");
    if (mPendingNotifications.size() == 0) {
        pw.println("null");
    } else {
        for (Entry entry : mPendingNotifications.values()) {
            pw.println(entry.notification);
        }
    }
    pw.print("  mInteractingWindows=");
    pw.println(mInteractingWindows);
    pw.print("  mStatusBarWindowState=");
    pw.println(windowStateToString(mStatusBarWindowState));
    pw.print("  mStatusBarMode=");
    pw.println(BarTransitions.modeToString(mStatusBarMode));
    pw.print("  mDozing=");
    pw.println(mDozing);
    pw.print("  mZenMode=");
    pw.println(Settings.Global.zenModeToString(mZenMode));
    pw.print("  mUseHeadsUp=");
    pw.println(mUseHeadsUp);
    dumpBarTransitions(pw, "mStatusBarView", mStatusBarView.getBarTransitions());
    pw.print("  mMediaSessionManager=");
    pw.println(mMediaSessionManager);
    pw.print("  mMediaNotificationKey=");
    pw.println(mMediaNotificationKey);
    pw.print("  mMediaController=");
    pw.print(mMediaController);
    if (mMediaController != null) {
        pw.print(" state=" + mMediaController.getPlaybackState());
    }
    pw.println();
    pw.print("  mMediaMetadata=");
    pw.print(mMediaMetadata);
    if (mMediaMetadata != null) {
        pw.print(" title=" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
    }
    pw.println();
    pw.println("  Panels: ");
    if (mNotificationPanel != null) {
        pw.println("    mNotificationPanel=" + mNotificationPanel + " params=" + mNotificationPanel.getLayoutParams().debug(""));
        pw.print("      ");
        mNotificationPanel.dump(fd, pw, args);
    }
    DozeLog.dump(pw);
    if (DUMPTRUCK) {
        synchronized (mNotificationData) {
            mNotificationData.dump(pw, "  ");
        }
        if (false) {
            pw.println("see the logcat for a dump of the views we have created.");
            // must happen on ui thread
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mStatusBarView.getLocationOnScreen(mAbsPos);
                    Log.d(TAG, "mStatusBarView: ----- (" + mAbsPos[0] + "," + mAbsPos[1] + ") " + mStatusBarView.getWidth() + "x" + getStatusBarHeight());
                    mStatusBarView.debug();
                }
            });
        }
    }
    if (DEBUG_GESTURES) {
        pw.print("  status bar gestures: ");
        mGestureRec.dump(fd, pw, args);
    }
    if (mHeadsUpManager != null) {
        mHeadsUpManager.dump(fd, pw, args);
    } else {
        pw.println("  mHeadsUpManager: null");
    }
    if (mGroupManager != null) {
        mGroupManager.dump(fd, pw, args);
    } else {
        pw.println("  mGroupManager: null");
    }
    mLightBarController.dump(fd, pw, args);
    if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
        KeyguardUpdateMonitor.getInstance(mContext).dump(fd, pw, args);
    }
    FalsingManager.getInstance(mContext).dump(pw);
    FalsingLog.dump(pw);
    pw.println("SharedPreferences:");
    for (Map.Entry<String, ?> entry : Prefs.getAll(mContext).entrySet()) {
        pw.print("  ");
        pw.print(entry.getKey());
        pw.print("=");
        pw.println(entry.getValue());
    }
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    synchronized (mQueueLock) {
        pw.println("Current Status Bar state:");
        pw.println("  mExpandedVisible=" + mExpandedVisible + ", mTrackingPosition=" + mTrackingPosition);
        pw.println("  mTickerEnabled=" + mTickerEnabled);
        if (mTickerEnabled != 0) {
            pw.println("  mTicking=" + mTicking);
            pw.println("  mTickerView: " + viewInfo(mTickerView));
        }
        pw.println("  mTracking=" + mTracking);
        pw.println("  mDisplayMetrics=" + mDisplayMetrics);
        pw.println("  mStackScroller: " + viewInfo(mStackScroller));
        pw.println("  mStackScroller: " + viewInfo(mStackScroller) + " scroll " + mStackScroller.getScrollX() + "," + mStackScroller.getScrollY());
    }
    pw.print("  mPendingNotifications=");
    if (mPendingNotifications.size() == 0) {
        pw.println("null");
    } else {
        for (Entry entry : mPendingNotifications.values()) {
            pw.println(entry.notification);
        }
    }
    pw.print("  mInteractingWindows=");
    pw.println(mInteractingWindows);
    pw.print("  mStatusBarWindowState=");
    pw.println(windowStateToString(mStatusBarWindowState));
    pw.print("  mStatusBarMode=");
    pw.println(BarTransitions.modeToString(mStatusBarMode));
    pw.print("  mDozing=");
    pw.println(mDozing);
    pw.print("  mZenMode=");
    pw.println(Settings.Global.zenModeToString(mZenMode));
    pw.print("  mUseHeadsUp=");
    pw.println(mUseHeadsUp);
    dumpBarTransitions(pw, "mStatusBarView", mStatusBarView.getBarTransitions());
    pw.print("  mMediaSessionManager=");
    pw.println(mMediaSessionManager);
    pw.print("  mMediaNotificationKey=");
    pw.println(mMediaNotificationKey);
    pw.print("  mMediaController=");
    pw.print(mMediaController);
    if (mMediaController != null) {
        pw.print(" state=" + mMediaController.getPlaybackState());
    }
    pw.println();
    pw.print("  mMediaMetadata=");
    pw.print(mMediaMetadata);
    if (mMediaMetadata != null) {
        pw.print(" title=" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
    }
    pw.println();
    pw.println("  Panels: ");
    if (mNotificationPanel != null) {
        pw.println("    mNotificationPanel=" + mNotificationPanel + " params=" + mNotificationPanel.getLayoutParams().debug(""));
        pw.print("      ");
        mNotificationPanel.dump(fd, pw, args);
    }
    DozeLog.dump(pw);
    if (DUMPTRUCK) {
        synchronized (mNotificationData) {
            mNotificationData.dump(pw, "  ");
        }
        if (false) {
            pw.println("see the logcat for a dump of the views we have created.");
            // must happen on ui thread
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mStatusBarView.getLocationOnScreen(mAbsPos);
                    Log.d(TAG, "mStatusBarView: ----- (" + mAbsPos[0] + "," + mAbsPos[1] + ") " + mStatusBarView.getWidth() + "x" + getStatusBarHeight());
                    mStatusBarView.debug();
                }
            });
        }
    }
    if (DEBUG_GESTURES) {
        pw.print("  status bar gestures: ");
        mGestureRec.dump(fd, pw, args);
    }
    if (mHeadsUpManager != null) {
        mHeadsUpManager.dump(fd, pw, args);
    } else {
        pw.println("  mHeadsUpManager: null");
    }
    if (mGroupManager != null) {
        mGroupManager.dump(fd, pw, args);
    } else {
        pw.println("  mGroupManager: null");
    }
    mLightBarController.dump(fd, pw, args);
    if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
        KeyguardUpdateMonitor.getInstance(mContext).dump(fd, pw, args);
    }
    FalsingManager.getInstance(mContext).dump(pw);
    FalsingLog.dump(pw);
    pw.println("SharedPreferences:");
    for (Map.Entry<String, ?> entry : Prefs.getAll(mContext).entrySet()) {
        pw.print("  ");
        pw.print(entry.getKey());
        pw.print("=");
        pw.println(entry.getValue());
    }
}
#end_block

#method_before
public void destroy() {
    // Begin old BaseStatusBar.destroy().
    mContext.unregisterReceiver(mBaseBroadcastReceiver);
    try {
        mNotificationListener.unregisterAsSystemService();
    } catch (RemoteException e) {
    // Ignore.
    }
    mDeviceProvisionedController.removeCallback(mDeviceProvisionedListener);
    // End old BaseStatusBar.destroy().
    if (mStatusBarWindow != null) {
        mWindowManager.removeViewImmediate(mStatusBarWindow);
        mStatusBarWindow = null;
    }
    if (mNavigationBarView != null) {
        mWindowManager.removeViewImmediate(mNavigationBarView);
        mNavigationBarView = null;
    }
    mContext.unregisterReceiver(mBroadcastReceiver);
    mContext.unregisterReceiver(mDemoReceiver);
    mAssistManager.destroy();
    if (mQSPanel != null && mQSPanel.getHost() != null) {
        mQSPanel.getHost().destroy();
    }
    Dependency.get(ActivityStarterDelegate.class).setActivityStarterImpl(null);
    mDeviceProvisionedController.removeCallback(mUserSetupObserver);
    Dependency.get(ConfigurationController.class).removeCallback(mConfigurationListener);
}
#method_after
public void destroy() {
    // Begin old BaseStatusBar.destroy().
    mContext.unregisterReceiver(mBaseBroadcastReceiver);
    try {
        mNotificationListener.unregisterAsSystemService();
    } catch (RemoteException e) {
    // Ignore.
    }
    mDeviceProvisionedController.removeCallback(mDeviceProvisionedListener);
    // End old BaseStatusBar.destroy().
    if (mStatusBarWindow != null) {
        mWindowManager.removeViewImmediate(mStatusBarWindow);
        mStatusBarWindow = null;
    }
    if (mNavigationBarView != null) {
        mWindowManager.removeViewImmediate(mNavigationBarView);
        mNavigationBarView = null;
    }
    mContext.unregisterReceiver(mBroadcastReceiver);
    mContext.unregisterReceiver(mDemoReceiver);
    mAssistManager.destroy();
    if (mQSPanel != null && mQSPanel.getHost() != null) {
        mQSPanel.getHost().destroy();
    }
    mPackageMonitor.removeListener(this);
    mPackageMonitor.unregister();
    Dependency.get(ActivityStarterDelegate.class).setActivityStarterImpl(null);
    mDeviceProvisionedController.removeCallback(mUserSetupObserver);
    Dependency.get(ConfigurationController.class).removeCallback(mConfigurationListener);
}
#end_block

#method_before
private void updateDozingState() {
    Trace.beginSection("StatusBar#updateDozingState");
    boolean animate = !mDozing && mDozeServiceHost.shouldAnimateWakeup();
    mNotificationPanel.setDozing(mDozing, animate);
    mStackScroller.setDark(mDozing, animate, mWakeUpTouchLocation);
    mScrimController.setDozing(mDozing);
    mKeyguardIndicationController.setDozing(mDozing);
    mNotificationPanel.setDark(mDozing, animate);
    updateQsExpansionEnabled();
    mDozeScrimController.setDozing(mDozing, animate);
    updateRowStates();
    Trace.endSection();
}
#method_after
private void updateDozingState() {
    Trace.beginSection("StatusBar#updateDozingState");
    boolean animate = !mDozing && mDozeServiceHost.shouldAnimateWakeup();
    mNotificationPanel.setDozing(mDozing, animate);
    mStackScroller.setDark(mDozing, animate, mWakeUpTouchLocation);
    mScrimController.setDozing(mDozing);
    mKeyguardIndicationController.setDozing(mDozing);
    mNotificationPanel.setDark(mDozing, animate);
    updateQsExpansionEnabled();
    mDozeScrimController.setDozing(mDozing, animate);
    updateRowStates();
    if (isDozing()) {
        haltTicker();
    }
    Trace.endSection();
}
#end_block

#method_before
public NavigationBarView getNavigationBarView() {
    return mNavigationBar != null ? (NavigationBarView) mNavigationBar.getView() : null;
}
#method_after
// TODO: Figure out way to remove this.
public Navigator getNavigationBarView() {
    return mNavigationBar != null ? mNavigationBar.getNavigator() : null;
}
#end_block

#method_before
@Override
public void onCameraLaunchGestureDetected(int source) {
    mLastCameraLaunchSource = source;
    if (mStartedGoingToSleep) {
        mLaunchCameraOnFinishedGoingToSleep = true;
        return;
    }
    if (!mNotificationPanel.canCameraGestureBeLaunched(mStatusBarKeyguardViewManager.isShowing() && mExpandedVisible)) {
        return;
    }
    if (!mDeviceInteractive) {
        PowerManager pm = mContext.getSystemService(PowerManager.class);
        pm.wakeUp(SystemClock.uptimeMillis(), "com.android.systemui:CAMERA_GESTURE");
        mStatusBarKeyguardViewManager.notifyDeviceWakeUpRequested();
    }
    vibrateForCameraGesture();
    if (!mStatusBarKeyguardViewManager.isShowing()) {
        startActivity(KeyguardBottomAreaView.INSECURE_CAMERA_INTENT, true);
    } else {
        if (!mDeviceInteractive) {
            // Avoid flickering of the scrim when we instant launch the camera and the bouncer
            // comes on.
            mScrimController.dontAnimateBouncerChangesUntilNextFrame();
            mGestureWakeLock.acquire(LAUNCH_TRANSITION_TIMEOUT_MS + 1000L);
        }
        if (mScreenTurningOn || mStatusBarKeyguardViewManager.isScreenTurnedOn()) {
            mNotificationPanel.launchCamera(mDeviceInteractive, /* animate */
            source);
        } else {
            // We need to defer the camera launch until the screen comes on, since otherwise
            // we will dismiss us too early since we are waiting on an activity to be drawn and
            // incorrectly get notified because of the screen on event (which resumes and pauses
            // some activities)
            mLaunchCameraOnScreenTurningOn = true;
        }
    }
}
#method_after
@Override
public void onCameraLaunchGestureDetected(int source) {
    mLastCameraLaunchSource = source;
    if (mStartedGoingToSleep) {
        mLaunchCameraOnFinishedGoingToSleep = true;
        return;
    }
    if (!mNotificationPanel.canCameraGestureBeLaunched(mStatusBarKeyguardViewManager.isShowing() && mExpandedVisible, source)) {
        return;
    }
    if (!mDeviceInteractive) {
        PowerManager pm = mContext.getSystemService(PowerManager.class);
        pm.wakeUp(SystemClock.uptimeMillis(), "com.android.systemui:CAMERA_GESTURE");
        mStatusBarKeyguardViewManager.notifyDeviceWakeUpRequested();
    }
    vibrateForCameraGesture();
    if (!mStatusBarKeyguardViewManager.isShowing()) {
        startActivity(KeyguardBottomAreaView.INSECURE_CAMERA_INTENT, true);
    } else {
        if (!mDeviceInteractive) {
            // Avoid flickering of the scrim when we instant launch the camera and the bouncer
            // comes on.
            mScrimController.dontAnimateBouncerChangesUntilNextFrame();
            mGestureWakeLock.acquire(LAUNCH_TRANSITION_TIMEOUT_MS + 1000L);
        }
        if (mScreenTurningOn || mStatusBarKeyguardViewManager.isScreenTurnedOn()) {
            mNotificationPanel.launchCamera(mDeviceInteractive, /* animate */
            source);
        } else {
            // We need to defer the camera launch until the screen comes on, since otherwise
            // we will dismiss us too early since we are waiting on an activity to be drawn and
            // incorrectly get notified because of the screen on event (which resumes and pauses
            // some activities)
            mLaunchCameraOnScreenTurningOn = true;
        }
    }
}
#end_block

#method_before
public boolean isKeyguardShowing() {
    if (mStatusBarKeyguardViewManager == null) {
        Slog.i(TAG, "isKeyguardShowing() called before startKeyguard(), returning true");
        return true;
    }
    return mStatusBarKeyguardViewManager.isShowing();
}
#method_after
public boolean isKeyguardShowing() {
    if (mStatusBarKeyguardViewManager == null) {
        if (DEBUG) {
            Slog.i(TAG, "isKeyguardShowing() called before startKeyguard(), returning true");
        }
        return true;
    }
    return mStatusBarKeyguardViewManager.isShowing();
}
#end_block

#method_before
public void updateNotification(StatusBarNotification notification, RankingMap ranking) throws InflationException {
    if (DEBUG)
        Log.d(TAG, "updateNotification(" + notification + ")");
    final String key = notification.getKey();
    abortExistingInflation(key);
    Entry entry = mNotificationData.get(key);
    if (entry == null) {
        return;
    } else {
        mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
        mRemoteInputEntriesToRemoveOnCollapse.remove(entry);
    }
    Notification n = notification.getNotification();
    mNotificationData.updateRanking(ranking);
    final StatusBarNotification oldNotification = entry.notification;
    entry.notification = notification;
    mGroupManager.onEntryUpdated(entry, oldNotification);
    entry.updateIcons(mContext, notification);
    inflateViews(entry, mStackScroller);
    mForegroundServiceController.updateNotification(notification, mNotificationData.getImportance(key));
    boolean shouldPeek = shouldPeek(entry, notification);
    boolean alertAgain = alertAgain(entry, n);
    updateHeadsUp(key, entry, shouldPeek, alertAgain);
    updateNotifications();
    if (!notification.isClearable()) {
        // The user may have performed a dismiss action on the notification, since it's
        // not clearable we should snap it back.
        mStackScroller.snapViewIfNeeded(entry.row);
    }
    if (DEBUG) {
        // Is this for you?
        boolean isForCurrentUser = isNotificationForCurrentProfiles(notification);
        Log.d(TAG, "notification is " + (isForCurrentUser ? "" : "not ") + "for you");
    }
    setAreThereNotifications();
}
#method_after
public void updateNotification(StatusBarNotification notification, RankingMap ranking) throws InflationException {
    if (DEBUG)
        Log.d(TAG, "updateNotification(" + notification + ")");
    final String key = notification.getKey();
    abortExistingInflation(key);
    Entry entry = mNotificationData.get(key);
    if (entry == null) {
        return;
    } else {
        mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
        mRemoteInputEntriesToRemoveOnCollapse.remove(entry);
    }
    Notification n = notification.getNotification();
    mNotificationData.updateRanking(ranking);
    boolean updateTicker = n.tickerText != null && !TextUtils.equals(n.tickerText, entry.notification.getNotification().tickerText);
    final StatusBarNotification oldNotification = entry.notification;
    entry.notification = notification;
    mGroupManager.onEntryUpdated(entry, oldNotification);
    entry.updateIcons(mContext, notification);
    inflateViews(entry, mStackScroller);
    mForegroundServiceController.updateNotification(notification, mNotificationData.getImportance(key));
    boolean shouldPeek = shouldPeek(entry, notification);
    boolean alertAgain = alertAgain(entry, n);
    updateHeadsUp(key, entry, shouldPeek, alertAgain);
    updateNotifications();
    if (!notification.isClearable()) {
        // The user may have performed a dismiss action on the notification, since it's
        // not clearable we should snap it back.
        mStackScroller.snapViewIfNeeded(entry.row);
    }
    boolean isForCurrentUser = isNotificationForCurrentProfiles(notification);
    if (DEBUG) {
        // Is this for you?
        Log.d(TAG, "notification is " + (isForCurrentUser ? "" : "not ") + "for you");
    }
    // Restart the ticker if it's still running
    if (updateTicker && isForCurrentUser) {
        haltTicker();
        if (!shouldPeek) {
            tick(notification, false, false, null);
        }
    }
    setAreThereNotifications();
}
#end_block

#method_before
protected boolean shouldPeek(Entry entry, StatusBarNotification sbn) {
    if (!mUseHeadsUp || isDeviceInVrMode()) {
        if (DEBUG)
            Log.d(TAG, "No peeking: no huns or vr mode");
        return false;
    }
    if (mNotificationData.shouldFilterOut(sbn)) {
        if (DEBUG)
            Log.d(TAG, "No peeking: filtered notification: " + sbn.getKey());
        return false;
    }
    boolean inUse = mPowerManager.isScreenOn() && !mSystemServicesProxy.isDreaming();
    if (!inUse && !isDozing()) {
        if (DEBUG) {
            Log.d(TAG, "No peeking: not in use: " + sbn.getKey());
        }
        return false;
    }
    if (mNotificationData.shouldSuppressScreenOn(sbn.getKey())) {
        if (DEBUG)
            Log.d(TAG, "No peeking: suppressed by DND: " + sbn.getKey());
        return false;
    }
    if (entry.hasJustLaunchedFullScreenIntent()) {
        if (DEBUG)
            Log.d(TAG, "No peeking: recent fullscreen: " + sbn.getKey());
        return false;
    }
    if (isSnoozedPackage(sbn)) {
        if (DEBUG)
            Log.d(TAG, "No peeking: snoozed package: " + sbn.getKey());
        return false;
    }
    // Allow peeking for DEFAULT notifications only if we're on Ambient Display.
    int importanceLevel = isDozing() ? NotificationManager.IMPORTANCE_DEFAULT : NotificationManager.IMPORTANCE_HIGH;
    if (mNotificationData.getImportance(sbn.getKey()) < importanceLevel) {
        if (DEBUG)
            Log.d(TAG, "No peeking: unimportant notification: " + sbn.getKey());
        return false;
    }
    if (sbn.getNotification().fullScreenIntent != null) {
        if (mAccessibilityManager.isTouchExplorationEnabled()) {
            if (DEBUG)
                Log.d(TAG, "No peeking: accessible fullscreen: " + sbn.getKey());
            return false;
        } else {
            // we only allow head-up on the lockscreen if it doesn't have a fullscreen intent
            return !mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded();
        }
    }
    // Don't peek notifications that are suppressed due to group alert behavior
    if (sbn.isGroup() && sbn.getNotification().suppressAlertingDueToGrouping()) {
        if (DEBUG)
            Log.d(TAG, "No peeking: suppressed due to group alert behavior");
        return false;
    }
    return true;
}
#method_after
protected boolean shouldPeek(Entry entry, StatusBarNotification sbn) {
    if (!mUseHeadsUp && !isDozing() || isDeviceInVrMode()) {
        if (DEBUG)
            Log.d(TAG, "No peeking: no huns or vr mode");
        return false;
    }
    if (isPackageInBlacklist(sbn.getPackageName())) {
        return false;
    }
    if (mNotificationData.shouldFilterOut(sbn)) {
        if (DEBUG)
            Log.d(TAG, "No peeking: filtered notification: " + sbn.getKey());
        return false;
    }
    boolean inUse = mPowerManager.isScreenOn() && !mSystemServicesProxy.isDreaming();
    if (!inUse && !isDozing()) {
        if (DEBUG) {
            Log.d(TAG, "No peeking: not in use: " + sbn.getKey());
        }
        return false;
    }
    if (mNotificationData.shouldSuppressScreenOn(sbn.getKey())) {
        if (DEBUG)
            Log.d(TAG, "No peeking: suppressed by DND: " + sbn.getKey());
        return false;
    }
    if (entry.hasJustLaunchedFullScreenIntent()) {
        if (DEBUG)
            Log.d(TAG, "No peeking: recent fullscreen: " + sbn.getKey());
        return false;
    }
    if (isSnoozedPackage(sbn)) {
        if (DEBUG)
            Log.d(TAG, "No peeking: snoozed package: " + sbn.getKey());
        return false;
    }
    // Allow peeking for DEFAULT notifications only if we're on Ambient Display.
    int importanceLevel = isDozing() ? NotificationManager.IMPORTANCE_DEFAULT : NotificationManager.IMPORTANCE_HIGH;
    if (mNotificationData.getImportance(sbn.getKey()) < importanceLevel) {
        if (DEBUG)
            Log.d(TAG, "No peeking: unimportant notification: " + sbn.getKey());
        return false;
    }
    if (sbn.getNotification().fullScreenIntent != null) {
        if (mAccessibilityManager.isTouchExplorationEnabled()) {
            if (DEBUG)
                Log.d(TAG, "No peeking: accessible fullscreen: " + sbn.getKey());
            return false;
        } else {
            // we only allow head-up on the lockscreen if it doesn't have a fullscreen intent
            return !mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded();
        }
    }
    // Don't peek notifications that are suppressed due to group alert behavior
    if (sbn.isGroup() && sbn.getNotification().suppressAlertingDueToGrouping()) {
        if (DEBUG)
            Log.d(TAG, "No peeking: suppressed due to group alert behavior");
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean isKeyguardSecure() {
    if (mStatusBarKeyguardViewManager == null) {
        // startKeyguard() hasn't been called yet, so we don't know.
        // Make sure anything that needs to know isKeyguardSecure() checks and re-checks this
        // value onVisibilityChanged().
        Slog.w(TAG, "isKeyguardSecure() called before startKeyguard(), returning false", new Throwable());
        return false;
    }
    return mStatusBarKeyguardViewManager.isSecure();
}
#method_after
public boolean isKeyguardSecure() {
    if (mStatusBarKeyguardViewManager == null) {
        // value onVisibilityChanged().
        if (DEBUG) {
            Slog.w(TAG, "isKeyguardSecure() called before startKeyguard(), returning false", new Throwable());
        }
        return false;
    }
    return mStatusBarKeyguardViewManager.isSecure();
}
#end_block

#method_before
@Override
public void shutdown() {
    enforceStatusBarService();
    long identity = Binder.clearCallingIdentity();
    try {
        // ShutdownThread displays UI, so give it a UI context.
        mHandler.post(() -> ShutdownThread.shutdown(getUiContext(), PowerManager.SHUTDOWN_USER_REQUESTED, false));
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#method_after
@Override
public void shutdown(boolean confirm) {
    enforceStatusBarService();
    long identity = Binder.clearCallingIdentity();
    try {
        // ShutdownThread displays UI, so give it a UI context.
        mHandler.post(() -> ShutdownThread.shutdown(getUiContext(), PowerManager.SHUTDOWN_USER_REQUESTED, confirm));
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#end_block

#method_before
@Override
public void reboot(boolean safeMode) {
    enforceStatusBarService();
    long identity = Binder.clearCallingIdentity();
    try {
        mHandler.post(() -> {
            // ShutdownThread displays UI, so give it a UI context.
            if (safeMode) {
                ShutdownThread.rebootSafeMode(getUiContext(), false);
            } else {
                ShutdownThread.reboot(getUiContext(), PowerManager.SHUTDOWN_USER_REQUESTED, false);
            }
        });
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#method_after
@Override
public void reboot(boolean confirm) {
    enforceStatusBarService();
    long identity = Binder.clearCallingIdentity();
    try {
        mHandler.post(() -> ShutdownThread.reboot(getUiContext(), PowerManager.SHUTDOWN_USER_REQUESTED, confirm));
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#end_block

#method_before
private void readPersistedSettings() {
    final ContentResolver cr = mContentResolver;
    int ringerModeFromSettings = Settings.Global.getInt(cr, Settings.Global.MODE_RINGER, AudioManager.RINGER_MODE_NORMAL);
    int ringerMode = ringerModeFromSettings;
    // ringer modes
    if (!isValidRingerMode(ringerMode)) {
        ringerMode = AudioManager.RINGER_MODE_NORMAL;
    }
    if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
        ringerMode = AudioManager.RINGER_MODE_SILENT;
    }
    if (ringerMode != ringerModeFromSettings) {
        Settings.Global.putInt(cr, Settings.Global.MODE_RINGER, ringerMode);
    }
    if (mUseFixedVolume || mIsSingleVolume) {
        ringerMode = AudioManager.RINGER_MODE_NORMAL;
    }
    synchronized (mSettingsLock) {
        mRingerMode = ringerMode;
        if (mRingerModeExternal == -1) {
            mRingerModeExternal = mRingerMode;
        }
        // System.VIBRATE_ON is not used any more but defaults for mVibrateSetting
        // are still needed while setVibrateSetting() and getVibrateSetting() are being
        // deprecated.
        mVibrateSetting = AudioSystem.getValueForVibrateSetting(0, AudioManager.VIBRATE_TYPE_NOTIFICATION, mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT : AudioManager.VIBRATE_SETTING_OFF);
        mVibrateSetting = AudioSystem.getValueForVibrateSetting(mVibrateSetting, AudioManager.VIBRATE_TYPE_RINGER, mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT : AudioManager.VIBRATE_SETTING_OFF);
        updateRingerModeAffectedStreams();
        readDockAudioSettings(cr);
        sendEncodedSurroundMode(cr);
    }
    mMuteAffectedStreams = System.getIntForUser(cr, System.MUTE_STREAMS_AFFECTED, AudioSystem.DEFAULT_MUTE_STREAMS_AFFECTED, UserHandle.USER_CURRENT);
    updateMasterMono(cr);
    // Each stream will read its own persisted settings
    // Broadcast the sticky intents
    broadcastRingerMode(AudioManager.RINGER_MODE_CHANGED_ACTION, mRingerModeExternal);
    broadcastRingerMode(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION, mRingerMode);
    // Broadcast vibrate settings
    broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER);
    broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_NOTIFICATION);
    // Load settings for the volume controller
    mVolumeController.loadSettings(cr);
}
#method_after
private void readPersistedSettings() {
    final ContentResolver cr = mContentResolver;
    int ringerModeFromSettings = Settings.Global.getInt(cr, Settings.Global.MODE_RINGER, AudioManager.RINGER_MODE_NORMAL);
    int ringerMode = ringerModeFromSettings;
    // ringer modes
    if (!isValidRingerMode(ringerMode)) {
        ringerMode = AudioManager.RINGER_MODE_NORMAL;
    }
    if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
        ringerMode = AudioManager.RINGER_MODE_SILENT;
    }
    if (ringerMode != ringerModeFromSettings) {
        Settings.Global.putInt(cr, Settings.Global.MODE_RINGER, ringerMode);
    }
    if (mUseFixedVolume || mIsSingleVolume) {
        ringerMode = AudioManager.RINGER_MODE_NORMAL;
    }
    synchronized (mSettingsLock) {
        mRingerMode = ringerMode;
        if (mRingerModeExternal == -1) {
            mRingerModeExternal = mRingerMode;
        }
        // System.VIBRATE_ON is not used any more but defaults for mVibrateSetting
        // are still needed while setVibrateSetting() and getVibrateSetting() are being
        // deprecated.
        mVibrateSetting = AudioSystem.getValueForVibrateSetting(0, AudioManager.VIBRATE_TYPE_NOTIFICATION, mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT : AudioManager.VIBRATE_SETTING_OFF);
        mVibrateSetting = AudioSystem.getValueForVibrateSetting(mVibrateSetting, AudioManager.VIBRATE_TYPE_RINGER, mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT : AudioManager.VIBRATE_SETTING_OFF);
        updateRingerModeAffectedStreams();
        readDockAudioSettings(cr);
        sendEncodedSurroundMode(cr);
        setVolumeKeysControlMediaStream();
    }
    mMuteAffectedStreams = System.getIntForUser(cr, System.MUTE_STREAMS_AFFECTED, AudioSystem.DEFAULT_MUTE_STREAMS_AFFECTED, UserHandle.USER_CURRENT);
    updateMasterMono(cr);
    // Each stream will read its own persisted settings
    // Broadcast the sticky intents
    broadcastRingerMode(AudioManager.RINGER_MODE_CHANGED_ACTION, mRingerModeExternal);
    broadcastRingerMode(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION, mRingerMode);
    // Broadcast vibrate settings
    broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER);
    broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_NOTIFICATION);
    // Load settings for the volume controller
    mVolumeController.loadSettings(cr);
}
#end_block

#method_before
void setBtScoDeviceConnectionState(BluetoothDevice btDevice, int state) {
    if (btDevice == null) {
        return;
    }
    String address = btDevice.getAddress();
    BluetoothClass btClass = btDevice.getBluetoothClass();
    int outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
    int inDevice = AudioSystem.DEVICE_IN_BLUETOOTH_SCO_HEADSET;
    if (btClass != null) {
        switch(btClass.getDeviceClass()) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                break;
            case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                break;
        }
    }
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        address = "";
    }
    boolean connected = (state == BluetoothProfile.STATE_CONNECTED);
    String btDeviceName = btDevice.getName();
    boolean success = handleDeviceConnection(connected, outDevice, address, btDeviceName) && handleDeviceConnection(connected, inDevice, address, btDeviceName);
    if (!success) {
        return;
    }
    /* When one BT headset is disconnected while another BT headset
         * is connected, don't mess with the headset device.
         */
    if ((state == BluetoothProfile.STATE_DISCONNECTED || state == BluetoothProfile.STATE_DISCONNECTING) && mBluetoothHeadset != null && mBluetoothHeadset.getAudioState(btDevice) == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
        Log.w(TAG, "SCO connected through another device, returning");
        return;
    }
    synchronized (mScoClients) {
        if (connected) {
            mBluetoothHeadsetDevice = btDevice;
        } else {
            mBluetoothHeadsetDevice = null;
            resetBluetoothSco();
        }
    }
}
#method_after
void setBtScoDeviceConnectionState(BluetoothDevice btDevice, int state) {
    if (btDevice == null) {
        return;
    }
    String address = btDevice.getAddress();
    BluetoothClass btClass = btDevice.getBluetoothClass();
    int outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
    int inDevice = AudioSystem.DEVICE_IN_BLUETOOTH_SCO_HEADSET;
    if (btClass != null) {
        switch(btClass.getDeviceClass()) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                break;
            case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                break;
        }
    }
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        address = "";
    }
    boolean connected = (state == BluetoothProfile.STATE_CONNECTED);
    String btDeviceName = btDevice.getName();
    boolean success = handleDeviceConnection(connected, outDevice, address, btDeviceName) && handleDeviceConnection(connected, inDevice, address, btDeviceName);
    if (!success) {
        return;
    }
    /* When one BT headset is disconnected while another BT headset
         * is connected, don't mess with the headset device.
         */
    if ((state == BluetoothProfile.STATE_DISCONNECTED || state == BluetoothProfile.STATE_DISCONNECTING) && mBluetoothHeadset != null && mBluetoothHeadset.getAudioState(btDevice) == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
        Log.w(TAG, "SCO connected through another device, returning");
        return;
    }
    synchronized (mScoClients) {
        if (connected) {
            mBluetoothHeadsetDevice = btDevice;
            switch(mLaunchPlayer) {
                case 0:
                case 1:
                    // do nothing
                    break;
                case 2:
                case 4:
                    // launch the player if bt headset is not a carkit
                    if (outDevice != AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT) {
                        startMusicPlayer();
                    }
                    break;
                case 3:
                case 5:
                    // launch the player for all bt headsets
                    startMusicPlayer();
                    break;
            }
        } else {
            mBluetoothHeadsetDevice = null;
            resetBluetoothSco();
        }
    }
}
#end_block

#method_before
private int getActiveStreamType(int suggestedStreamType) {
    if (mIsSingleVolume && suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
        return AudioSystem.STREAM_MUSIC;
    }
    switch(mPlatformType) {
        case AudioSystem.PLATFORM_VOICE:
            if (isInCommunication()) {
                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_BT_SCO) {
                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO...");
                    return AudioSystem.STREAM_BLUETOOTH_SCO;
                } else {
                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL...");
                    return AudioSystem.STREAM_VOICE_CALL;
                }
            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
                if (isAfMusicActiveRecently(sStreamOverrideDelayMs)) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
                    return AudioSystem.STREAM_MUSIC;
                } else {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_RING b/c default");
                    return AudioSystem.STREAM_RING;
                }
            } else if (isAfMusicActiveRecently(0)) {
                if (DEBUG_VOL)
                    Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
                return AudioSystem.STREAM_MUSIC;
            }
            break;
        default:
            if (isInCommunication()) {
                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_BT_SCO) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO");
                    return AudioSystem.STREAM_BLUETOOTH_SCO;
                } else {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL");
                    return AudioSystem.STREAM_VOICE_CALL;
                }
            } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_NOTIFICATION, sStreamOverrideDelayMs) || AudioSystem.isStreamActive(AudioSystem.STREAM_RING, sStreamOverrideDelayMs)) {
                if (DEBUG_VOL)
                    Log.v(TAG, "getActiveStreamType: Forcing STREAM_NOTIFICATION");
                return AudioSystem.STREAM_NOTIFICATION;
            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
                if (isAfMusicActiveRecently(sStreamOverrideDelayMs)) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: forcing STREAM_MUSIC");
                    return AudioSystem.STREAM_MUSIC;
                } else {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: using STREAM_NOTIFICATION as default");
                    return AudioSystem.STREAM_NOTIFICATION;
                }
            }
            break;
    }
    if (DEBUG_VOL)
        Log.v(TAG, "getActiveStreamType: Returning suggested type " + suggestedStreamType);
    return suggestedStreamType;
}
#method_after
private int getActiveStreamType(int suggestedStreamType) {
    if (mIsSingleVolume && suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
        return AudioSystem.STREAM_MUSIC;
    }
    switch(mPlatformType) {
        case AudioSystem.PLATFORM_VOICE:
            if (isInCommunication()) {
                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_BT_SCO) {
                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO...");
                    return AudioSystem.STREAM_BLUETOOTH_SCO;
                } else {
                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL...");
                    return AudioSystem.STREAM_VOICE_CALL;
                }
            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
                if (isAfMusicActiveRecently(sStreamOverrideDelayMs)) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
                    return AudioSystem.STREAM_MUSIC;
                } else {
                    if (mVolumeKeysControlMediaStream) {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC b/c user selected");
                        return AudioSystem.STREAM_MUSIC;
                    } else {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_RING b/c default");
                        return AudioSystem.STREAM_RING;
                    }
                }
            } else if (isAfMusicActiveRecently(0)) {
                if (DEBUG_VOL)
                    Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
                return AudioSystem.STREAM_MUSIC;
            }
            break;
        default:
            if (isInCommunication()) {
                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_BT_SCO) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO");
                    return AudioSystem.STREAM_BLUETOOTH_SCO;
                } else {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL");
                    return AudioSystem.STREAM_VOICE_CALL;
                }
            } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_NOTIFICATION, sStreamOverrideDelayMs) || AudioSystem.isStreamActive(AudioSystem.STREAM_RING, sStreamOverrideDelayMs)) {
                if (DEBUG_VOL)
                    Log.v(TAG, "getActiveStreamType: Forcing STREAM_NOTIFICATION");
                return AudioSystem.STREAM_NOTIFICATION;
            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
                if (isAfMusicActiveRecently(sStreamOverrideDelayMs)) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: forcing STREAM_MUSIC");
                    return AudioSystem.STREAM_MUSIC;
                } else {
                    if (mVolumeKeysControlMediaStream) {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC b/c user selected");
                        return AudioSystem.STREAM_MUSIC;
                    } else {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: using STREAM_NOTIFICATION as default");
                        return AudioSystem.STREAM_NOTIFICATION;
                    }
                }
            }
            break;
    }
    if (DEBUG_VOL)
        Log.v(TAG, "getActiveStreamType: Returning suggested type " + suggestedStreamType);
    return suggestedStreamType;
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange) {
    super.onChange(selfChange);
    // mRingerModeMutedStreams and mMuteAffectedStreams are safe (only accessed once).
    synchronized (mSettingsLock) {
        if (updateRingerModeAffectedStreams()) {
            /*
                     * Ensure all stream types that should be affected by ringer mode
                     * are in the proper state.
                     */
            setRingerModeInt(getRingerModeInternal(), false);
        }
        readDockAudioSettings(mContentResolver);
        updateMasterMono(mContentResolver);
        updateEncodedSurroundOutput();
    }
}
#method_after
@Override
public void onChange(boolean selfChange) {
    super.onChange(selfChange);
    // mRingerModeMutedStreams and mMuteAffectedStreams are safe (only accessed once).
    synchronized (mSettingsLock) {
        if (updateRingerModeAffectedStreams()) {
            /*
                     * Ensure all stream types that should be affected by ringer mode
                     * are in the proper state.
                     */
            setRingerModeInt(getRingerModeInternal(), false);
        }
        readDockAudioSettings(mContentResolver);
        updateMasterMono(mContentResolver);
        updateEncodedSurroundOutput();
        setVolumeKeysControlMediaStream();
    }
    mLaunchPlayer = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HEADSET_CONNECT_PLAYER, 0, UserHandle.USER_CURRENT);
}
#end_block

#method_before
private void sendDeviceConnectionIntent(int device, int state, String address, String deviceName) {
    if (DEBUG_DEVICES) {
        Slog.i(TAG, "sendDeviceConnectionIntent(dev:0x" + Integer.toHexString(device) + " state:0x" + Integer.toHexString(state) + " address:" + address + " name:" + deviceName + ");");
    }
    Intent intent = new Intent();
    intent.putExtra(CONNECT_INTENT_KEY_STATE, state);
    intent.putExtra(CONNECT_INTENT_KEY_ADDRESS, address);
    intent.putExtra(CONNECT_INTENT_KEY_PORT_NAME, deviceName);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int connType = 0;
    if (device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) {
        connType = AudioRoutesInfo.MAIN_HEADSET;
        intent.setAction(Intent.ACTION_HEADSET_PLUG);
        intent.putExtra("microphone", 1);
    } else if (device == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE || device == AudioSystem.DEVICE_OUT_LINE) {
        /*do apps care about line-out vs headphones?*/
        connType = AudioRoutesInfo.MAIN_HEADPHONES;
        intent.setAction(Intent.ACTION_HEADSET_PLUG);
        intent.putExtra("microphone", 0);
    } else if (device == AudioSystem.DEVICE_OUT_HDMI || device == AudioSystem.DEVICE_OUT_HDMI_ARC) {
        connType = AudioRoutesInfo.MAIN_HDMI;
        configureHdmiPlugIntent(intent, state);
    } else if (device == AudioSystem.DEVICE_OUT_USB_DEVICE) {
        connType = AudioRoutesInfo.MAIN_USB;
    }
    synchronized (mCurAudioRoutes) {
        if (connType != 0) {
            int newConn = mCurAudioRoutes.mainType;
            if (state != 0) {
                newConn |= connType;
            } else {
                newConn &= ~connType;
            }
            if (newConn != mCurAudioRoutes.mainType) {
                mCurAudioRoutes.mainType = newConn;
                sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES, SENDMSG_NOOP, 0, 0, null, 0);
            }
        }
    }
    final long ident = Binder.clearCallingIdentity();
    try {
        ActivityManager.broadcastStickyIntent(intent, UserHandle.USER_ALL);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
private void sendDeviceConnectionIntent(int device, int state, String address, String deviceName) {
    if (DEBUG_DEVICES) {
        Slog.i(TAG, "sendDeviceConnectionIntent(dev:0x" + Integer.toHexString(device) + " state:0x" + Integer.toHexString(state) + " address:" + address + " name:" + deviceName + ");");
    }
    Intent intent = new Intent();
    intent.putExtra(CONNECT_INTENT_KEY_STATE, state);
    intent.putExtra(CONNECT_INTENT_KEY_ADDRESS, address);
    intent.putExtra(CONNECT_INTENT_KEY_PORT_NAME, deviceName);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int connType = 0;
    if (device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) {
        connType = AudioRoutesInfo.MAIN_HEADSET;
        intent.setAction(Intent.ACTION_HEADSET_PLUG);
        intent.putExtra("microphone", 1);
        if ((mLaunchPlayer == 1 || mLaunchPlayer == 4 || mLaunchPlayer == 5) && state == 1) {
            startMusicPlayer();
        }
    } else if (device == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE || device == AudioSystem.DEVICE_OUT_LINE) {
        /*do apps care about line-out vs headphones?*/
        connType = AudioRoutesInfo.MAIN_HEADPHONES;
        intent.setAction(Intent.ACTION_HEADSET_PLUG);
        intent.putExtra("microphone", 0);
        if ((mLaunchPlayer == 1 || mLaunchPlayer == 4 || mLaunchPlayer == 5) && state == 1) {
            startMusicPlayer();
        }
    } else if (device == AudioSystem.DEVICE_OUT_HDMI || device == AudioSystem.DEVICE_OUT_HDMI_ARC) {
        connType = AudioRoutesInfo.MAIN_HDMI;
        configureHdmiPlugIntent(intent, state);
    } else if (device == AudioSystem.DEVICE_OUT_USB_DEVICE) {
        connType = AudioRoutesInfo.MAIN_USB;
    }
    synchronized (mCurAudioRoutes) {
        if (connType != 0) {
            int newConn = mCurAudioRoutes.mainType;
            if (state != 0) {
                newConn |= connType;
            } else {
                newConn &= ~connType;
            }
            if (newConn != mCurAudioRoutes.mainType) {
                mCurAudioRoutes.mainType = newConn;
                sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES, SENDMSG_NOOP, 0, 0, null, 0);
            }
        }
    }
    final long ident = Binder.clearCallingIdentity();
    try {
        ActivityManager.broadcastStickyIntent(intent, UserHandle.USER_ALL);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_ENABLE_POINTER_LOCATION:
            enablePointerLocation();
            break;
        case MSG_DISABLE_POINTER_LOCATION:
            disablePointerLocation();
            break;
        case MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK:
            dispatchMediaKeyWithWakeLock((KeyEvent) msg.obj);
            break;
        case MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK:
            dispatchMediaKeyRepeatWithWakeLock((KeyEvent) msg.obj);
            break;
        case MSG_DISPATCH_SHOW_RECENTS:
            showRecentApps(false, msg.arg1 != 0);
            break;
        case MSG_DISPATCH_SHOW_GLOBAL_ACTIONS:
            showGlobalActionsInternal();
            break;
        case MSG_KEYGUARD_DRAWN_COMPLETE:
            if (DEBUG_WAKEUP)
                Slog.w(TAG, "Setting mKeyguardDrawComplete");
            finishKeyguardDrawn();
            break;
        case MSG_KEYGUARD_DRAWN_TIMEOUT:
            Slog.w(TAG, "Keyguard drawn timeout. Setting mKeyguardDrawComplete");
            finishKeyguardDrawn();
            break;
        case MSG_WINDOW_MANAGER_DRAWN_COMPLETE:
            if (DEBUG_WAKEUP)
                Slog.w(TAG, "Setting mWindowManagerDrawComplete");
            finishWindowsDrawn();
            break;
        case MSG_HIDE_BOOT_MESSAGE:
            handleHideBootMessage();
            break;
        case MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK:
            launchVoiceAssistWithWakeLock(msg.arg1 != 0);
            break;
        case MSG_POWER_DELAYED_PRESS:
            powerPress((Long) msg.obj, msg.arg1 != 0, msg.arg2);
            finishPowerKeyPress();
            break;
        case MSG_POWER_LONG_PRESS:
            powerLongPress();
            break;
        case MSG_UPDATE_DREAMING_SLEEP_TOKEN:
            updateDreamingSleepToken(msg.arg1 != 0);
            break;
        case MSG_REQUEST_TRANSIENT_BARS:
            WindowState targetBar = (msg.arg1 == MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS) ? mStatusBar : mNavigationBar;
            if (targetBar != null) {
                requestTransientBars(targetBar);
            }
            break;
        case MSG_SHOW_PICTURE_IN_PICTURE_MENU:
            showPictureInPictureMenuInternal();
            break;
        case MSG_BACK_LONG_PRESS:
            backLongPress();
            finishBackKeyPress();
            break;
        case MSG_DISPOSE_INPUT_CONSUMER:
            disposeInputConsumer((InputConsumer) msg.obj);
            break;
        case MSG_BACK_DELAYED_PRESS:
            backMultiPressAction((Long) msg.obj, msg.arg1);
            finishBackKeyPress();
            break;
        case MSG_ACCESSIBILITY_SHORTCUT:
            accessibilityShortcutActivated();
            break;
        case MSG_BUGREPORT_TV:
            takeBugreport();
            break;
        case MSG_ACCESSIBILITY_TV:
            if (mAccessibilityShortcutController.isAccessibilityShortcutAvailable(false)) {
                accessibilityShortcutActivated();
            }
            break;
        case MSG_DISPATCH_BACK_KEY_TO_AUTOFILL:
            mAutofillManagerInternal.onBackKeyPressed();
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_ENABLE_POINTER_LOCATION:
            enablePointerLocation();
            break;
        case MSG_DISABLE_POINTER_LOCATION:
            disablePointerLocation();
            break;
        case MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK:
            dispatchMediaKeyWithWakeLock((KeyEvent) msg.obj);
            break;
        case MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK:
            dispatchMediaKeyRepeatWithWakeLock((KeyEvent) msg.obj);
            break;
        case MSG_DISPATCH_SHOW_RECENTS:
            showRecentApps(false, msg.arg1 != 0);
            break;
        case MSG_DISPATCH_SHOW_GLOBAL_ACTIONS:
            showGlobalActionsInternal();
            break;
        case MSG_KEYGUARD_DRAWN_COMPLETE:
            if (DEBUG_WAKEUP)
                Slog.w(TAG, "Setting mKeyguardDrawComplete");
            finishKeyguardDrawn();
            break;
        case MSG_KEYGUARD_DRAWN_TIMEOUT:
            Slog.w(TAG, "Keyguard drawn timeout. Setting mKeyguardDrawComplete");
            finishKeyguardDrawn();
            break;
        case MSG_WINDOW_MANAGER_DRAWN_COMPLETE:
            if (DEBUG_WAKEUP)
                Slog.w(TAG, "Setting mWindowManagerDrawComplete");
            finishWindowsDrawn();
            break;
        case MSG_HIDE_BOOT_MESSAGE:
            handleHideBootMessage();
            break;
        case MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK:
            launchVoiceAssistWithWakeLock(msg.arg1 != 0);
            break;
        case MSG_POWER_DELAYED_PRESS:
            powerPress((Long) msg.obj, msg.arg1 != 0, msg.arg2);
            finishPowerKeyPress();
            break;
        case MSG_POWER_LONG_PRESS:
            powerLongPress();
            break;
        case MSG_UPDATE_DREAMING_SLEEP_TOKEN:
            updateDreamingSleepToken(msg.arg1 != 0);
            break;
        case MSG_REQUEST_TRANSIENT_BARS:
            WindowState targetBar = (msg.arg1 == MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS) ? mStatusBar : mNavigationBar;
            if (targetBar != null) {
                requestTransientBars(targetBar);
            }
            break;
        case MSG_SHOW_PICTURE_IN_PICTURE_MENU:
            showPictureInPictureMenuInternal();
            break;
        case MSG_BACK_LONG_PRESS:
            backLongPress();
            finishBackKeyPress();
            break;
        case MSG_DISPOSE_INPUT_CONSUMER:
            disposeInputConsumer((InputConsumer) msg.obj);
            break;
        case MSG_BACK_DELAYED_PRESS:
            backMultiPressAction((Long) msg.obj, msg.arg1);
            finishBackKeyPress();
            break;
        case MSG_ACCESSIBILITY_SHORTCUT:
            accessibilityShortcutActivated();
            break;
        case MSG_BUGREPORT_TV:
            takeBugreport();
            break;
        case MSG_ACCESSIBILITY_TV:
            if (mAccessibilityShortcutController.isAccessibilityShortcutAvailable(false)) {
                accessibilityShortcutActivated();
            }
            break;
        case MSG_DISPATCH_BACK_KEY_TO_AUTOFILL:
            mAutofillManagerInternal.onBackKeyPressed();
            break;
        case MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK:
            {
                KeyEvent event = (KeyEvent) msg.obj;
                dispatchMediaKeyWithWakeLockToAudioService(event);
                dispatchMediaKeyWithWakeLockToAudioService(KeyEvent.changeAction(event, KeyEvent.ACTION_UP));
                mVolumeMusicControlActive = true;
                break;
            }
    }
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VOLUME_BUTTON_MUSIC_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VOLUME_ROCKER_WAKE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.NAVIGATION_BAR_VISIBLE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.NAVIGATION_BAR_HEIGHT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.NAVIGATION_BAR_HEIGHT_LANDSCAPE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.NAVIGATION_BAR_WIDTH), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mPanicPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_backPanicBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, Animation openAnimation, Animation closeAnimation) {
            return handleStartTransitionForKeyguardLw(transit, openAnimation);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, null);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }
    });
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mPanicPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_backPanicBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, Animation openAnimation, Animation closeAnimation) {
            return handleStartTransitionForKeyguardLw(transit, openAnimation);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, null);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }
    });
    String deviceKeyHandlerLib = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerLib);
    String deviceKeyHandlerClass = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerClass);
    if (!deviceKeyHandlerLib.isEmpty() && !deviceKeyHandlerClass.isEmpty()) {
        PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLib, getClass().getClassLoader());
        try {
            Class<?> klass = loader.loadClass(deviceKeyHandlerClass);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandler = (DeviceKeyHandler) constructor.newInstance(mContext);
            if (DEBUG)
                Slog.d(TAG, "Device key handler loaded");
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerClass + " from class " + deviceKeyHandlerLib, e);
        }
    }
}
#end_block

#method_before
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // TODO(multi-display): Define policy for secondary displays.
    if (mContext == null || display.getDisplayId() != Display.DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    // SystemUI (status bar) layout policy
    int shortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on non-square small devices (phones).
    mNavigationBarCanMove = width != height && shortSizeDp < 600;
    mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar);
    // Allow a system property to override this. Used by the emulator.
    // See also hasNavigationBar().
    String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
    if ("1".equals(navBarOverride)) {
        mHasNavigationBar = false;
    } else if ("0".equals(navBarOverride)) {
        mHasNavigationBar = true;
    }
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    mForceDefaultOrientation = longSizeDp >= 960 && shortSizeDp >= 720 && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#method_after
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // TODO(multi-display): Define policy for secondary displays.
    if (mContext == null || display.getDisplayId() != Display.DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    updateNavigationBarSize();
    // SystemUI (status bar) layout policy
    int shortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on non-square small devices (phones).
    mNavigationBarCanMove = width != height && shortSizeDp < 600;
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    mForceDefaultOrientation = longSizeDp >= 960 && shortSizeDp >= 720 && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#end_block

#method_before
private boolean canHideNavigationBar() {
    return mHasNavigationBar;
}
#method_after
private boolean canHideNavigationBar() {
    return hasNavigationBar() && !mAccessibilityManager.isTouchExplorationEnabled();
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        // volume rocker wake
        mVolumeRockerWake = Settings.System.getIntForUser(resolver, Settings.System.VOLUME_ROCKER_WAKE, 0, UserHandle.USER_CURRENT) != 0;
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
        mVolumeMusicControl = Settings.System.getIntForUser(resolver, Settings.System.VOLUME_BUTTON_MUSIC_CONTROL, 1, UserHandle.USER_CURRENT) != 0;
        boolean doShowNavbar = Settings.Secure.getIntForUser(resolver, Settings.Secure.NAVIGATION_BAR_VISIBLE, DUActionUtils.hasNavbarByDefault(mContext) ? 1 : 0, UserHandle.USER_CURRENT) == 1;
        if (doShowNavbar != mNavbarVisible) {
            mNavbarVisible = doShowNavbar;
        }
        updateNavigationBarSize();
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public void onConfigurationChanged() {
    // TODO(multi-display): Define policy for secondary displays.
    final Resources res = mContext.getResources();
    mStatusBarHeight = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    // Height of the navigation bar when presented horizontally at bottom
    mNavigationBarHeightForRotationDefault[mPortraitRotation] = mNavigationBarHeightForRotationDefault[mUpsideDownRotation] = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    mNavigationBarHeightForRotationDefault[mLandscapeRotation] = mNavigationBarHeightForRotationDefault[mSeascapeRotation] = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height_landscape);
    // Width of the navigation bar when presented vertically along one side
    mNavigationBarWidthForRotationDefault[mPortraitRotation] = mNavigationBarWidthForRotationDefault[mUpsideDownRotation] = mNavigationBarWidthForRotationDefault[mLandscapeRotation] = mNavigationBarWidthForRotationDefault[mSeascapeRotation] = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_width);
    if (ALTERNATE_CAR_MODE_NAV_SIZE) {
        // Height of the navigation bar when presented horizontally at bottom
        mNavigationBarHeightForRotationInCarMode[mPortraitRotation] = mNavigationBarHeightForRotationInCarMode[mUpsideDownRotation] = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height_car_mode);
        mNavigationBarHeightForRotationInCarMode[mLandscapeRotation] = mNavigationBarHeightForRotationInCarMode[mSeascapeRotation] = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height_landscape_car_mode);
        // Width of the navigation bar when presented vertically along one side
        mNavigationBarWidthForRotationInCarMode[mPortraitRotation] = mNavigationBarWidthForRotationInCarMode[mUpsideDownRotation] = mNavigationBarWidthForRotationInCarMode[mLandscapeRotation] = mNavigationBarWidthForRotationInCarMode[mSeascapeRotation] = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_width_car_mode);
    }
}
#method_after
@Override
public void onConfigurationChanged() {
    // TODO(multi-display): Define policy for secondary displays.
    final Resources res = mContext.getResources();
    mStatusBarHeight = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    updateNavigationBarSize();
    if (ALTERNATE_CAR_MODE_NAV_SIZE) {
        // Height of the navigation bar when presented horizontally at bottom
        mNavigationBarHeightForRotationInCarMode[mPortraitRotation] = mNavigationBarHeightForRotationInCarMode[mUpsideDownRotation] = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height_car_mode);
        mNavigationBarHeightForRotationInCarMode[mLandscapeRotation] = mNavigationBarHeightForRotationInCarMode[mSeascapeRotation] = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height_landscape_car_mode);
        // Width of the navigation bar when presented vertically along one side
        mNavigationBarWidthForRotationInCarMode[mPortraitRotation] = mNavigationBarWidthForRotationInCarMode[mUpsideDownRotation] = mNavigationBarWidthForRotationInCarMode[mLandscapeRotation] = mNavigationBarWidthForRotationInCarMode[mSeascapeRotation] = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_width_car_mode);
    }
}
#end_block

#method_before
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId) {
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == Display.DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            return fullWidth - getNavigationBarWidth(rotation, uiMode);
        }
    }
    return fullWidth;
}
#method_after
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId) {
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == Display.DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            return fullWidth - getNavigationBarWidth(rotation, uiMode);
        }
    }
    return fullWidth;
}
#end_block

#method_before
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId) {
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == Display.DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            return fullHeight - getNavigationBarHeight(rotation, uiMode);
        }
    }
    return fullHeight;
}
#method_after
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId) {
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == Display.DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            return fullHeight - getNavigationBarHeight(rotation, uiMode);
        }
    }
    return fullHeight;
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // know if it is complete or not
    if (mAccessibilityShortcutController.isAccessibilityShortcutAvailable(false) && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered ^ mA11yShortcutChordVolumeUpKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = (mScreenshotChordVolumeDownKeyTriggered ? mScreenshotChordVolumeDownKeyTime : mA11yShortcutChordVolumeUpKeyTime) + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mA11yShortcutChordVolumeUpKeyConsumed) {
            if (!down) {
                mA11yShortcutChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            if (mHasFeatureLeanback) {
                // Clear flags
                mAccessibilityTvKey2Pressed = down;
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (mHasFeatureLeanback) {
                mAccessibilityTvKey2Pressed = down;
                if (interceptAccessibilityGestureTv()) {
                    return -1;
                }
            }
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting || mHandleVolumeKeysInWM) {
            // On TVs or when the configuration is enabled, volume keys never
            // go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
        // forward it to the application/dispatch the audio event.
        if (mPersistentVrModeEnabled) {
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_TAB && event.isMetaPressed()) {
        // Pass through keyboard navigation keys.
        return 0;
    } else if (mHasFeatureLeanback && interceptBugreportGestureTv(keyCode, down)) {
        return -1;
    } else if (mHasFeatureLeanback && keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        mAccessibilityTvKey1Pressed = down;
        if (interceptAccessibilityGestureTv()) {
            return -1;
        }
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // know if it is complete or not
    if (mAccessibilityShortcutController.isAccessibilityShortcutAvailable(false) && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered ^ mA11yShortcutChordVolumeUpKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = (mScreenshotChordVolumeDownKeyTriggered ? mScreenshotChordVolumeDownKeyTime : mA11yShortcutChordVolumeUpKeyTime) + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mA11yShortcutChordVolumeUpKeyConsumed) {
            if (!down) {
                mA11yShortcutChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            if (mHasFeatureLeanback) {
                // Clear flags
                mAccessibilityTvKey2Pressed = down;
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (mHasFeatureLeanback) {
                mAccessibilityTvKey2Pressed = down;
                if (interceptAccessibilityGestureTv()) {
                    return -1;
                }
            }
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting || mHandleVolumeKeysInWM) {
            // On TVs or when the configuration is enabled, volume keys never
            // go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
        // forward it to the application/dispatch the audio event.
        if (mPersistentVrModeEnabled) {
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_TAB && event.isMetaPressed()) {
        // Pass through keyboard navigation keys.
        return 0;
    } else if (mHasFeatureLeanback && interceptBugreportGestureTv(keyCode, down)) {
        return -1;
    } else if (mHasFeatureLeanback && keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        mAccessibilityTvKey1Pressed = down;
        if (interceptAccessibilityGestureTv()) {
            return -1;
        }
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only should consume known keys.
            if (mDeviceKeyHandler.handleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
@Override
public void layoutWindowLw(WindowState win, WindowState attached) {
    // input, we need to layout it again to accomodate for the IME window.
    if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
        return;
    }
    final WindowManager.LayoutParams attrs = win.getAttrs();
    final boolean isDefaultDisplay = win.isDefaultDisplay();
    final boolean needsToOffsetInputMethodTarget = isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
    if (needsToOffsetInputMethodTarget) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "Offset ime target window by the last ime window state");
        offsetInputMethodWindowLw(mLastInputMethodWindow);
    }
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    final int pfl = attrs.privateFlags;
    final int sim = attrs.softInputMode;
    final int sysUiFl = PolicyControl.getSystemUiVisibility(win, null);
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect cf = mTmpContentFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    final Rect sf = mTmpStableFrame;
    Rect osf = null;
    dcf.setEmpty();
    final boolean hasNavBar = (isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
    final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
    if (isDefaultDisplay) {
        sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom);
    } else {
        sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom);
    }
    if (!isDefaultDisplay) {
        if (attached != null) {
            // If this window is attached to another, our display
            // frame is the same as the one we are attached to.
            setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
        } else {
            // Give the window full screen.
            pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
            pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
            pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
            pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
        }
    } else if (attrs.type == TYPE_INPUT_METHOD) {
        pf.left = df.left = of.left = cf.left = vf.left = mDockLeft;
        pf.top = df.top = of.top = cf.top = vf.top = mDockTop;
        pf.right = df.right = of.right = cf.right = vf.right = mDockRight;
        // IM dock windows layout below the nav bar...
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        // ...with content insets above the nav bar
        cf.bottom = vf.bottom = mStableBottom;
        if (mStatusBar != null && mFocusedWindow == mStatusBar && canReceiveInput(mStatusBar)) {
            // avoids the navigation bar in that case.
            if (mNavigationBarPosition == NAV_BAR_RIGHT) {
                pf.right = df.right = of.right = cf.right = vf.right = mStableRight;
            } else if (mNavigationBarPosition == NAV_BAR_LEFT) {
                pf.left = df.left = of.left = cf.left = vf.left = mStableLeft;
            }
        }
        // IM dock windows always go to the bottom of the screen.
        attrs.gravity = Gravity.BOTTOM;
        mDockLayer = win.getSurfaceLayer();
    } else if (attrs.type == TYPE_VOICE_INTERACTION) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
            cf.left = mDockLeft;
            cf.top = mDockTop;
            cf.right = mDockRight;
            cf.bottom = mDockBottom;
        } else {
            cf.left = mContentLeft;
            cf.top = mContentTop;
            cf.right = mContentRight;
            cf.bottom = mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
            vf.left = mCurLeft;
            vf.top = mCurTop;
            vf.right = mCurRight;
            vf.bottom = mCurBottom;
        } else {
            vf.set(cf);
        }
    } else if (attrs.type == TYPE_WALLPAPER) {
        layoutWallpaper(win, pf, df, of, cf);
    } else if (win == mStatusBar) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
        cf.left = vf.left = mStableLeft;
        cf.top = vf.top = mStableTop;
        cf.right = vf.right = mStableRight;
        vf.bottom = mStableBottom;
        if (adjust == SOFT_INPUT_ADJUST_RESIZE) {
            cf.bottom = mContentBottom;
        } else {
            cf.bottom = mDockBottom;
            vf.bottom = mContentBottom;
        }
    } else {
        // Default policy decor for the default display
        dcf.left = mSystemLeft;
        dcf.top = mSystemTop;
        dcf.right = mSystemRight;
        dcf.bottom = mSystemBottom;
        final boolean inheritTranslucentDecor = (attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
        final boolean isAppWindow = attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
        final boolean topAtRest = win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
        if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
            if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0 && (pfl & PRIVATE_FLAG_FORCE_DRAW_STATUS_BAR_BACKGROUND) == 0) {
                // Ensure policy decor includes status bar
                dcf.top = mStableTop;
            }
            if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                // Ensure policy decor includes navigation bar
                dcf.bottom = mStableBottom;
                dcf.right = mStableRight;
            }
        }
        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN, INSET_DECOR");
            // intrude into that space.
            if (attached != null) {
                // If this window is attached to another, our display
                // frame is the same as the one we are attached to.
                setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
            } else {
                if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
                    // Status bar panels are the only windows who can go on top of
                    // the status bar.  They are protected by the STATUS_BAR_SERVICE
                    // permission, so they have the same privileges as the status
                    // bar itself.
                    // 
                    // However, they should still dodge the navigation bar if it exists.
                    pf.left = df.left = of.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                    pf.top = df.top = of.top = mUnrestrictedScreenTop;
                    pf.right = df.right = of.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    pf.bottom = df.bottom = of.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, String.format("Laying out status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
                } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking to layout into the overscan region, so give it that pure
                    // unrestricted area.
                    pf.left = df.left = of.left = mOverscanScreenLeft;
                    pf.top = df.top = of.top = mOverscanScreenTop;
                    pf.right = df.right = of.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = of.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking for layout as if the nav bar is hidden, lets the
                    // application extend into the unrestricted overscan screen area.  We
                    // only do this for application windows to ensure no window that
                    // can be above the nav bar can do this.
                    pf.left = df.left = mOverscanScreenLeft;
                    pf.top = df.top = mOverscanScreenTop;
                    pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                } else {
                    pf.left = df.left = mRestrictedOverscanScreenLeft;
                    pf.top = df.top = mRestrictedOverscanScreenTop;
                    pf.right = df.right = mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
                    pf.bottom = df.bottom = mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                }
                if ((fl & FLAG_FULLSCREEN) == 0) {
                    if (win.isVoiceInteraction()) {
                        cf.left = mVoiceContentLeft;
                        cf.top = mVoiceContentTop;
                        cf.right = mVoiceContentRight;
                        cf.bottom = mVoiceContentBottom;
                    } else {
                        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                            cf.left = mDockLeft;
                            cf.top = mDockTop;
                            cf.right = mDockRight;
                            cf.bottom = mDockBottom;
                        } else {
                            cf.left = mContentLeft;
                            cf.top = mContentTop;
                            cf.right = mContentRight;
                            cf.bottom = mContentBottom;
                        }
                    }
                } else {
                    // Full screen windows are always given a layout that is as if the
                    // status bar and other transient decors are gone.  This is to avoid
                    // bad states when moving from a window that is not hding the
                    // status bar to one that is.
                    cf.left = mRestrictedScreenLeft;
                    cf.top = mRestrictedScreenTop;
                    cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                    cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                }
                applyStableConstraints(sysUiFl, fl, cf);
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN");
            // gets everything, period.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                pf.left = df.left = of.left = cf.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
                // The navigation bar has Real Ultimate Power.
                pf.left = df.left = of.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out navigation bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS || attrs.type == TYPE_SCREENSHOT) && ((fl & FLAG_FULLSCREEN) != 0)) {
                // Fullscreen secure system overlays get what they ask for. Screenshot region
                // selection overlay should also expand to full screen.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_BOOT_PROGRESS) {
                // Boot progress screen always covers entire display.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                // Asking to layout into the overscan region, so give it that pure
                // unrestricted area.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_DOCK_DIVIDER || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
                // Asking for layout as if the nav bar is hidden, lets the
                // application extend into the unrestricted screen area.  We
                // only do this for application windows (or toasts) to ensure no window that
                // can be above the nav bar can do this.
                // XXX This assumes that an app asking for this will also
                // ask for layout in only content.  We can't currently figure out
                // what the screen would be if only laying out to hide the nav bar.
                pf.left = df.left = of.left = cf.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else if ((sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN) != 0) {
                pf.left = df.left = of.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    cf.left = mDockLeft;
                    cf.top = mDockTop;
                    cf.right = mDockRight;
                    cf.bottom = mDockBottom;
                } else {
                    cf.left = mContentLeft;
                    cf.top = mContentTop;
                    cf.right = mContentRight;
                    cf.bottom = mContentBottom;
                }
            } else {
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            }
            applyStableConstraints(sysUiFl, fl, cf);
            if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                vf.left = mCurLeft;
                vf.top = mCurTop;
                vf.right = mCurRight;
                vf.bottom = mCurBottom;
            } else {
                vf.set(cf);
            }
        } else if (attached != null) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): attached to " + attached);
            // A child window should be placed inside of the same visible
            // frame that its parent had.
            setAttachedWindowFrames(win, fl, adjust, attached, false, pf, df, of, cf, vf);
        } else {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): normal window");
            // of all screen decorations.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                // Status bar panels and the volume dialog are the only windows who can go on
                // top of the status bar.  They are protected by the STATUS_BAR_SERVICE
                // permission, so they have the same privileges as the status
                // bar itself.
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            } else if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT) {
                // These dialogs are stable to interim decor changes.
                pf.left = df.left = of.left = cf.left = mStableLeft;
                pf.top = df.top = of.top = cf.top = mStableTop;
                pf.right = df.right = of.right = cf.right = mStableRight;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mStableBottom;
            } else {
                pf.left = mContentLeft;
                pf.top = mContentTop;
                pf.right = mContentRight;
                pf.bottom = mContentBottom;
                if (win.isVoiceInteraction()) {
                    df.left = of.left = cf.left = mVoiceContentLeft;
                    df.top = of.top = cf.top = mVoiceContentTop;
                    df.right = of.right = cf.right = mVoiceContentRight;
                    df.bottom = of.bottom = cf.bottom = mVoiceContentBottom;
                } else if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    df.left = of.left = cf.left = mDockLeft;
                    df.top = of.top = cf.top = mDockTop;
                    df.right = of.right = cf.right = mDockRight;
                    df.bottom = of.bottom = cf.bottom = mDockBottom;
                } else {
                    df.left = of.left = cf.left = mContentLeft;
                    df.top = of.top = cf.top = mContentTop;
                    df.right = of.right = cf.right = mContentRight;
                    df.bottom = of.bottom = cf.bottom = mContentBottom;
                }
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        }
    }
    // Also, we don't allow windows in multi-window mode to extend out of the screen.
    if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR && !win.isInMultiWindowMode()) {
        df.left = df.top = -10000;
        df.right = df.bottom = 10000;
        if (attrs.type != TYPE_WALLPAPER) {
            of.left = of.top = cf.left = cf.top = vf.left = vf.top = -10000;
            of.right = of.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
        }
    }
    // If the device has a chin (e.g. some watches), a dead area at the bottom of the screen we
    // need to provide information to the clients that want to pretend that you can draw there.
    // We only want to apply outsets to certain types of windows. For example, we never want to
    // apply the outsets to floating dialogs, because they wouldn't make sense there.
    final boolean useOutsets = shouldUseOutsets(attrs, fl);
    if (isDefaultDisplay && useOutsets) {
        osf = mTmpOutsetFrame;
        osf.set(cf.left, cf.top, cf.right, cf.bottom);
        int outset = ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
        if (outset > 0) {
            int rotation = mDisplayRotation;
            if (rotation == Surface.ROTATION_0) {
                osf.bottom += outset;
            } else if (rotation == Surface.ROTATION_90) {
                osf.right += outset;
            } else if (rotation == Surface.ROTATION_180) {
                osf.top -= outset;
            } else if (rotation == Surface.ROTATION_270) {
                osf.left -= outset;
            }
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "applying bottom outset of " + outset + " with rotation " + rotation + ", result: " + osf);
        }
    }
    if (DEBUG_LAYOUT)
        Slog.v(TAG, "Compute frame " + attrs.getTitle() + ": sim=#" + Integer.toHexString(sim) + " attach=" + attached + " type=" + attrs.type + String.format(" flags=0x%08x", fl) + " pf=" + pf.toShortString() + " df=" + df.toShortString() + " of=" + of.toShortString() + " cf=" + cf.toShortString() + " vf=" + vf.toShortString() + " dcf=" + dcf.toShortString() + " sf=" + sf.toShortString() + " osf=" + (osf == null ? "null" : osf.toShortString()));
    win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf);
    // can't appear underneath them.
    if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleLw() && !win.getGivenInsetsPendingLw()) {
        setLastInputMethodWindowLw(null, null);
        offsetInputMethodWindowLw(win);
    }
    if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleLw() && !win.getGivenInsetsPendingLw()) {
        offsetVoiceInputWindowLw(win);
    }
}
#method_after
@Override
public void layoutWindowLw(WindowState win, WindowState attached) {
    // input, we need to layout it again to accomodate for the IME window.
    if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
        return;
    }
    final WindowManager.LayoutParams attrs = win.getAttrs();
    final boolean isDefaultDisplay = win.isDefaultDisplay();
    final boolean needsToOffsetInputMethodTarget = isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
    if (needsToOffsetInputMethodTarget) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "Offset ime target window by the last ime window state");
        offsetInputMethodWindowLw(mLastInputMethodWindow);
    }
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    final int pfl = attrs.privateFlags;
    final int sim = attrs.softInputMode;
    final int sysUiFl = PolicyControl.getSystemUiVisibility(win, null);
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect cf = mTmpContentFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    final Rect sf = mTmpStableFrame;
    Rect osf = null;
    dcf.setEmpty();
    final boolean hasNavBar = (isDefaultDisplay && hasNavigationBar() && mNavigationBar != null && mNavigationBar.isVisibleLw());
    final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
    if (isDefaultDisplay) {
        sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom);
    } else {
        sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom);
    }
    if (!isDefaultDisplay) {
        if (attached != null) {
            // If this window is attached to another, our display
            // frame is the same as the one we are attached to.
            setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
        } else {
            // Give the window full screen.
            pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
            pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
            pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
            pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
        }
    } else if (attrs.type == TYPE_INPUT_METHOD) {
        pf.left = df.left = of.left = cf.left = vf.left = mDockLeft;
        pf.top = df.top = of.top = cf.top = vf.top = mDockTop;
        pf.right = df.right = of.right = cf.right = vf.right = mDockRight;
        // IM dock windows layout below the nav bar...
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        // ...with content insets above the nav bar
        cf.bottom = vf.bottom = mStableBottom;
        if (mStatusBar != null && mFocusedWindow == mStatusBar && canReceiveInput(mStatusBar)) {
            // avoids the navigation bar in that case.
            if (mNavigationBarPosition == NAV_BAR_RIGHT) {
                pf.right = df.right = of.right = cf.right = vf.right = mStableRight;
            } else if (mNavigationBarPosition == NAV_BAR_LEFT) {
                pf.left = df.left = of.left = cf.left = vf.left = mStableLeft;
            }
        }
        // IM dock windows always go to the bottom of the screen.
        attrs.gravity = Gravity.BOTTOM;
        mDockLayer = win.getSurfaceLayer();
    } else if (attrs.type == TYPE_VOICE_INTERACTION) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
            cf.left = mDockLeft;
            cf.top = mDockTop;
            cf.right = mDockRight;
            cf.bottom = mDockBottom;
        } else {
            cf.left = mContentLeft;
            cf.top = mContentTop;
            cf.right = mContentRight;
            cf.bottom = mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
            vf.left = mCurLeft;
            vf.top = mCurTop;
            vf.right = mCurRight;
            vf.bottom = mCurBottom;
        } else {
            vf.set(cf);
        }
    } else if (attrs.type == TYPE_WALLPAPER) {
        layoutWallpaper(win, pf, df, of, cf);
    } else if (win == mStatusBar) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
        cf.left = vf.left = mStableLeft;
        cf.top = vf.top = mStableTop;
        cf.right = vf.right = mStableRight;
        vf.bottom = mStableBottom;
        if (adjust == SOFT_INPUT_ADJUST_RESIZE) {
            cf.bottom = mContentBottom;
        } else {
            cf.bottom = mDockBottom;
            vf.bottom = mContentBottom;
        }
    } else {
        // Default policy decor for the default display
        dcf.left = mSystemLeft;
        dcf.top = mSystemTop;
        dcf.right = mSystemRight;
        dcf.bottom = mSystemBottom;
        final boolean inheritTranslucentDecor = (attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
        final boolean isAppWindow = attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
        final boolean topAtRest = win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
        if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
            if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0 && (pfl & PRIVATE_FLAG_FORCE_DRAW_STATUS_BAR_BACKGROUND) == 0) {
                // Ensure policy decor includes status bar
                dcf.top = mStableTop;
            }
            if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                // Ensure policy decor includes navigation bar
                dcf.bottom = mStableBottom;
                dcf.right = mStableRight;
            }
        }
        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN, INSET_DECOR");
            // intrude into that space.
            if (attached != null) {
                // If this window is attached to another, our display
                // frame is the same as the one we are attached to.
                setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
            } else {
                if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
                    // Status bar panels are the only windows who can go on top of
                    // the status bar.  They are protected by the STATUS_BAR_SERVICE
                    // permission, so they have the same privileges as the status
                    // bar itself.
                    // 
                    // However, they should still dodge the navigation bar if it exists.
                    pf.left = df.left = of.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                    pf.top = df.top = of.top = mUnrestrictedScreenTop;
                    pf.right = df.right = of.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    pf.bottom = df.bottom = of.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, String.format("Laying out status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
                } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking to layout into the overscan region, so give it that pure
                    // unrestricted area.
                    pf.left = df.left = of.left = mOverscanScreenLeft;
                    pf.top = df.top = of.top = mOverscanScreenTop;
                    pf.right = df.right = of.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = of.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking for layout as if the nav bar is hidden, lets the
                    // application extend into the unrestricted overscan screen area.  We
                    // only do this for application windows to ensure no window that
                    // can be above the nav bar can do this.
                    pf.left = df.left = mOverscanScreenLeft;
                    pf.top = df.top = mOverscanScreenTop;
                    pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                } else {
                    pf.left = df.left = mRestrictedOverscanScreenLeft;
                    pf.top = df.top = mRestrictedOverscanScreenTop;
                    pf.right = df.right = mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
                    pf.bottom = df.bottom = mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                }
                if ((fl & FLAG_FULLSCREEN) == 0) {
                    if (win.isVoiceInteraction()) {
                        cf.left = mVoiceContentLeft;
                        cf.top = mVoiceContentTop;
                        cf.right = mVoiceContentRight;
                        cf.bottom = mVoiceContentBottom;
                    } else {
                        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                            cf.left = mDockLeft;
                            cf.top = mDockTop;
                            cf.right = mDockRight;
                            cf.bottom = mDockBottom;
                        } else {
                            cf.left = mContentLeft;
                            cf.top = mContentTop;
                            cf.right = mContentRight;
                            cf.bottom = mContentBottom;
                        }
                    }
                } else {
                    // Full screen windows are always given a layout that is as if the
                    // status bar and other transient decors are gone.  This is to avoid
                    // bad states when moving from a window that is not hding the
                    // status bar to one that is.
                    cf.left = mRestrictedScreenLeft;
                    cf.top = mRestrictedScreenTop;
                    cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                    cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                }
                applyStableConstraints(sysUiFl, fl, cf);
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN");
            // gets everything, period.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                pf.left = df.left = of.left = cf.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
                // The navigation bar has Real Ultimate Power.
                pf.left = df.left = of.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out navigation bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS || attrs.type == TYPE_SCREENSHOT) && ((fl & FLAG_FULLSCREEN) != 0)) {
                // Fullscreen secure system overlays get what they ask for. Screenshot region
                // selection overlay should also expand to full screen.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_BOOT_PROGRESS) {
                // Boot progress screen always covers entire display.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                // Asking to layout into the overscan region, so give it that pure
                // unrestricted area.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_DOCK_DIVIDER || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
                // Asking for layout as if the nav bar is hidden, lets the
                // application extend into the unrestricted screen area.  We
                // only do this for application windows (or toasts) to ensure no window that
                // can be above the nav bar can do this.
                // XXX This assumes that an app asking for this will also
                // ask for layout in only content.  We can't currently figure out
                // what the screen would be if only laying out to hide the nav bar.
                pf.left = df.left = of.left = cf.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else if ((sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN) != 0) {
                pf.left = df.left = of.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    cf.left = mDockLeft;
                    cf.top = mDockTop;
                    cf.right = mDockRight;
                    cf.bottom = mDockBottom;
                } else {
                    cf.left = mContentLeft;
                    cf.top = mContentTop;
                    cf.right = mContentRight;
                    cf.bottom = mContentBottom;
                }
            } else {
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            }
            applyStableConstraints(sysUiFl, fl, cf);
            if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                vf.left = mCurLeft;
                vf.top = mCurTop;
                vf.right = mCurRight;
                vf.bottom = mCurBottom;
            } else {
                vf.set(cf);
            }
        } else if (attached != null) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): attached to " + attached);
            // A child window should be placed inside of the same visible
            // frame that its parent had.
            setAttachedWindowFrames(win, fl, adjust, attached, false, pf, df, of, cf, vf);
        } else {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): normal window");
            // of all screen decorations.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                // Status bar panels and the volume dialog are the only windows who can go on
                // top of the status bar.  They are protected by the STATUS_BAR_SERVICE
                // permission, so they have the same privileges as the status
                // bar itself.
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            } else if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT) {
                // These dialogs are stable to interim decor changes.
                pf.left = df.left = of.left = cf.left = mStableLeft;
                pf.top = df.top = of.top = cf.top = mStableTop;
                pf.right = df.right = of.right = cf.right = mStableRight;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mStableBottom;
            } else {
                pf.left = mContentLeft;
                pf.top = mContentTop;
                pf.right = mContentRight;
                pf.bottom = mContentBottom;
                if (win.isVoiceInteraction()) {
                    df.left = of.left = cf.left = mVoiceContentLeft;
                    df.top = of.top = cf.top = mVoiceContentTop;
                    df.right = of.right = cf.right = mVoiceContentRight;
                    df.bottom = of.bottom = cf.bottom = mVoiceContentBottom;
                } else if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    df.left = of.left = cf.left = mDockLeft;
                    df.top = of.top = cf.top = mDockTop;
                    df.right = of.right = cf.right = mDockRight;
                    df.bottom = of.bottom = cf.bottom = mDockBottom;
                } else {
                    df.left = of.left = cf.left = mContentLeft;
                    df.top = of.top = cf.top = mContentTop;
                    df.right = of.right = cf.right = mContentRight;
                    df.bottom = of.bottom = cf.bottom = mContentBottom;
                }
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        }
    }
    // Also, we don't allow windows in multi-window mode to extend out of the screen.
    if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR && !win.isInMultiWindowMode()) {
        df.left = df.top = -10000;
        df.right = df.bottom = 10000;
        if (attrs.type != TYPE_WALLPAPER) {
            of.left = of.top = cf.left = cf.top = vf.left = vf.top = -10000;
            of.right = of.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
        }
    }
    // If the device has a chin (e.g. some watches), a dead area at the bottom of the screen we
    // need to provide information to the clients that want to pretend that you can draw there.
    // We only want to apply outsets to certain types of windows. For example, we never want to
    // apply the outsets to floating dialogs, because they wouldn't make sense there.
    final boolean useOutsets = shouldUseOutsets(attrs, fl);
    if (isDefaultDisplay && useOutsets) {
        osf = mTmpOutsetFrame;
        osf.set(cf.left, cf.top, cf.right, cf.bottom);
        int outset = ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
        if (outset > 0) {
            int rotation = mDisplayRotation;
            if (rotation == Surface.ROTATION_0) {
                osf.bottom += outset;
            } else if (rotation == Surface.ROTATION_90) {
                osf.right += outset;
            } else if (rotation == Surface.ROTATION_180) {
                osf.top -= outset;
            } else if (rotation == Surface.ROTATION_270) {
                osf.left -= outset;
            }
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "applying bottom outset of " + outset + " with rotation " + rotation + ", result: " + osf);
        }
    }
    if (DEBUG_LAYOUT)
        Slog.v(TAG, "Compute frame " + attrs.getTitle() + ": sim=#" + Integer.toHexString(sim) + " attach=" + attached + " type=" + attrs.type + String.format(" flags=0x%08x", fl) + " pf=" + pf.toShortString() + " df=" + df.toShortString() + " of=" + of.toShortString() + " cf=" + cf.toShortString() + " vf=" + vf.toShortString() + " dcf=" + dcf.toShortString() + " sf=" + sf.toShortString() + " osf=" + (osf == null ? "null" : osf.toShortString()));
    win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf);
    // can't appear underneath them.
    if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleLw() && !win.getGivenInsetsPendingLw()) {
        setLastInputMethodWindowLw(null, null);
        offsetInputMethodWindowLw(win);
    }
    if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleLw() && !win.getGivenInsetsPendingLw()) {
        offsetVoiceInputWindowLw(win);
    }
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    final boolean isVolumeRockerWake = !isScreenOn() && mVolumeRockerWake && (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN);
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey() || isVolumeRockerWake;
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only should consume known keys.
            if (mDeviceKeyHandler.handleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (mUseTvRouting) {
                    // On TVs volume keys never go to the foreground app
                    result &= ~ACTION_PASS_TO_USER;
                }
                if (!interactive && isWakeKey && down) {
                    mVolumeWakeActive = true;
                    break;
                }
                if (!down && mVolumeWakeActive) {
                    isWakeKey = false;
                    result &= ~ACTION_PASS_TO_USER;
                    mVolumeWakeActive = false;
                    break;
                }
                // we come back from a handled music control event - ignore the up event
                if (!interactive && !down && mVolumeMusicControlActive) {
                    isWakeKey = false;
                    result &= ~ACTION_PASS_TO_USER;
                    mVolumeMusicControlActive = false;
                    break;
                }
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    boolean notHandledMusicControl = false;
                    if (!interactive && mVolumeMusicControl && isMusicActive()) {
                        if (down) {
                            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                                scheduleLongPressKeyEvent(event, KeyEvent.KEYCODE_MEDIA_PREVIOUS);
                                break;
                            } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                                scheduleLongPressKeyEvent(event, KeyEvent.KEYCODE_MEDIA_NEXT);
                                break;
                            }
                        } else {
                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                            notHandledMusicControl = true;
                        }
                    }
                    if (down || notHandledMusicControl) {
                        KeyEvent newEvent = event;
                        if (!down) {
                            // Rewrite the event to use key-down if required
                            newEvent = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
                        }
                        if (mUseTvRouting) {
                            dispatchDirectAudioEvent(newEvent);
                        } else {
                            // If we aren't passing to the user and no one else
                            // handled it send it to the session manager to
                            // figure out.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(newEvent, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", event.getKeyCode() == KeyEvent.KEYCODE_WAKEUP);
    }
    return result;
}
#end_block

#method_before
private boolean isWakeKeyWhenScreenOff(int keyCode) {
    switch(keyCode) {
        // ignore volume keys unless docked
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            return mDockMode != Intent.EXTRA_DOCK_STATE_UNDOCKED;
        // ignore media and camera keys
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
        case KeyEvent.KEYCODE_CAMERA:
            return false;
    }
    return true;
}
#method_after
private boolean isWakeKeyWhenScreenOff(int keyCode) {
    switch(keyCode) {
        // ignore volume keys unless docked
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            if (mVolumeRockerWake) {
                return true;
            }
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            return mDockMode != Intent.EXTRA_DOCK_STATE_UNDOCKED;
        // ignore media and camera keys
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
        case KeyEvent.KEYCODE_CAMERA:
            return false;
    }
    return true;
}
#end_block

#method_before
private boolean shouldDispatchInputWhenNonInteractive(KeyEvent event) {
    final boolean displayOff = (mDisplay == null || mDisplay.getState() == Display.STATE_OFF);
    if (displayOff && !mHasFeatureWatch) {
        return false;
    }
    // Send events to keyguard while the screen is on and it's showing.
    if (isKeyguardShowingAndNotOccluded() && !displayOff) {
        return true;
    }
    // Watches handle BACK specially
    if (mHasFeatureWatch && event != null && (event.getKeyCode() == KeyEvent.KEYCODE_BACK || event.getKeyCode() == KeyEvent.KEYCODE_STEM_PRIMARY)) {
        return false;
    }
    // Send events to a dozing dream even if the screen is off since the dream
    // is in control of the state of the screen.
    IDreamManager dreamManager = getDreamManager();
    try {
        if (dreamManager != null && dreamManager.isDreaming()) {
            return true;
        }
    } catch (RemoteException e) {
        Slog.e(TAG, "RemoteException when checking if dreaming", e);
    }
    // interacted with.
    return false;
}
#method_after
private boolean shouldDispatchInputWhenNonInteractive(KeyEvent event) {
    final boolean displayOff = (mDisplay == null || mDisplay.getState() == Display.STATE_OFF);
    if (displayOff && !mHasFeatureWatch) {
        return false;
    }
    // Send events to keyguard while the screen is on and it's showing.
    if (isKeyguardShowingAndNotOccluded() && !displayOff) {
        return true;
    }
    // Watches handle BACK specially
    if (mHasFeatureWatch && event != null && (event.getKeyCode() == KeyEvent.KEYCODE_BACK || event.getKeyCode() == KeyEvent.KEYCODE_STEM_PRIMARY)) {
        return false;
    }
    // Send events to a dozing dream even if the screen is off since the dream
    // is in control of the state of the screen.
    IDreamManager dreamManager = getDreamManager();
    try {
        if (dreamManager != null && dreamManager.isDreaming() && !dreamManager.isDozing()) {
            return true;
        }
    } catch (RemoteException e) {
        Slog.e(TAG, "RemoteException when checking if dreaming", e);
    }
    // interacted with.
    return false;
}
#end_block

#method_before
private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason) {
    final boolean theaterModeEnabled = isTheaterModeEnabled();
    if (!wakeInTheaterMode && theaterModeEnabled) {
        return false;
    }
    if (theaterModeEnabled) {
        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0);
    }
    mPowerManager.wakeUp(wakeTime, reason);
    return true;
}
#method_after
private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason) {
    return wakeUp(wakeTime, wakeInTheaterMode, reason, false);
}
#end_block

#method_before
private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason) {
    final boolean theaterModeEnabled = isTheaterModeEnabled();
    if (!wakeInTheaterMode && theaterModeEnabled) {
        return false;
    }
    if (theaterModeEnabled) {
        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0);
    }
    mPowerManager.wakeUp(wakeTime, reason);
    return true;
}
#method_after
private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason, final boolean withProximityCheck) {
    final boolean theaterModeEnabled = isTheaterModeEnabled();
    if (!wakeInTheaterMode && theaterModeEnabled) {
        return false;
    }
    if (theaterModeEnabled) {
        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0);
    }
    if (withProximityCheck) {
        mPowerManager.wakeUpWithProximityCheck(wakeTime, reason);
    } else {
        mPowerManager.wakeUp(wakeTime, reason);
    }
    return true;
}
#end_block

#method_before
@Override
public void getNonDecorInsetsLw(int displayRotation, int displayWidth, int displayHeight, Rect outInsets) {
    outInsets.setEmpty();
    // Only navigation bar
    if (mHasNavigationBar) {
        int position = navigationBarPosition(displayWidth, displayHeight, displayRotation);
        if (position == NAV_BAR_BOTTOM) {
            outInsets.bottom = getNavigationBarHeight(displayRotation, mUiMode);
        } else if (position == NAV_BAR_RIGHT) {
            outInsets.right = getNavigationBarWidth(displayRotation, mUiMode);
        } else if (position == NAV_BAR_LEFT) {
            outInsets.left = getNavigationBarWidth(displayRotation, mUiMode);
        }
    }
}
#method_after
@Override
public void getNonDecorInsetsLw(int displayRotation, int displayWidth, int displayHeight, Rect outInsets) {
    outInsets.setEmpty();
    // Only navigation bar
    if (hasNavigationBar()) {
        int position = navigationBarPosition(displayWidth, displayHeight, displayRotation);
        if (position == NAV_BAR_BOTTOM) {
            outInsets.bottom = getNavigationBarHeight(displayRotation, mUiMode);
        } else if (position == NAV_BAR_RIGHT) {
            outInsets.right = getNavigationBarWidth(displayRotation, mUiMode);
        } else if (position == NAV_BAR_LEFT) {
            outInsets.left = getNavigationBarWidth(displayRotation, mUiMode);
        }
    }
}
#end_block

#method_before
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar;
}
#method_after
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mNavbarVisible;
}
#end_block

#method_before
@Override
public void sendCustomAction(Intent intent) {
/*        String action = intent.getAction();
        if (action != null) {
            if (ActionHandler.INTENT_SHOW_POWER_MENU.equals(action)) {
                mHandler.removeMessages(MSG_DISPATCH_SHOW_GLOBAL_ACTIONS);
                mHandler.sendEmptyMessage(MSG_DISPATCH_SHOW_GLOBAL_ACTIONS);
            } else if (ActionHandler.INTENT_SCREENSHOT.equals(action)) {
                mContext.enforceCallingOrSelfPermission(Manifest.permission.ACCESS_SURFACE_FLINGER, TAG + "sendCustomAction permission denied");
                mHandler.removeCallbacks(mScreenshotRunnable);
                checkSettings();
                mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
                mHandler.post(mScreenshotRunnable);
            } else if (ActionHandler.INTENT_REGION_SCREENSHOT.equals(action)) {
                mContext.enforceCallingOrSelfPermission(Manifest.permission.ACCESS_SURFACE_FLINGER, TAG + "sendCustomAction permission denied");
                mHandler.removeCallbacks(mScreenshotRunnable);
                checkSettings();
                mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_SELECTED_REGION);
                mHandler.post(mScreenshotRunnable);
            } else if (ActionHandler.INTENT_TOGGLE_SCREENRECORD.equals(action)) {
                mContext.enforceCallingOrSelfPermission(Manifest.permission.ACCESS_SURFACE_FLINGER, TAG + "sendCustomAction permission denied");
                mHandler.removeCallbacks(mScreenrecordRunnable);
                mHandler.post(mScreenrecordRunnable);
            }
        }
*/
}
#method_after
@Override
public void sendCustomAction(Intent intent) {
    String action = intent.getAction();
    if (action != null) {
        if (ActionHandler.INTENT_SHOW_POWER_MENU.equals(action)) {
            showGlobalActions();
        } else if (ActionHandler.INTENT_SCREENSHOT.equals(action)) {
            mContext.enforceCallingOrSelfPermission(Manifest.permission.ACCESS_SURFACE_FLINGER, TAG + "sendCustomAction permission denied");
            mHandler.removeCallbacks(mScreenshotRunnable);
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        } else if (ActionHandler.INTENT_REGION_SCREENSHOT.equals(action)) {
            mContext.enforceCallingOrSelfPermission(Manifest.permission.ACCESS_SURFACE_FLINGER, TAG + "sendCustomAction permission denied");
            mHandler.removeCallbacks(mScreenshotRunnable);
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_SELECTED_REGION);
            mHandler.post(mScreenshotRunnable);
        }
    /* else if (ActionHandler.INTENT_TOGGLE_SCREENRECORD.equals(action)) {
                mContext.enforceCallingOrSelfPermission(Manifest.permission.ACCESS_SURFACE_FLINGER, TAG + "sendCustomAction permission denied");
                mHandler.removeCallbacks(mScreenrecordRunnable);
                mHandler.post(mScreenrecordRunnable);
            }*/
    }
}
#end_block

#method_before
private void handleCallEnd(DialerCall call) {
    long durationMillis = System.currentTimeMillis() - call.getConnectTimeMillis();
    DisconnectCause cause = call.getDisconnectCause();
    boolean localDisconnect = // Disconnection not yet processed
    call.getState() == DialerCall.State.DISCONNECTING || // Disconnection already processed
    (cause != null && cause.getCode() == DisconnectCause.LOCAL);
    Log.d(this, "Ending active call: duration = " + durationMillis + ", locally disconnected = " + localDisconnect);
    if (mPrefs.getBoolean(KEY_VIBRATE_HANGUP, false) && !localDisconnect && durationMillis > 500) {
        vibrate(50, 100, 50);
    }
    // Stop 50-second vibration
    removeMessages(MSG_VIBRATE_50_SEC);
}
#method_after
private void handleCallEnd(DialerCall call) {
    long durationMillis = System.currentTimeMillis() - call.getConnectTimeMillis();
    Log.d(this, "Ending active call: duration = " + durationMillis);
    if (mPrefs.getBoolean(KEY_VIBRATE_HANGUP, false) && durationMillis > 500) {
        vibrate(50, 100, 50);
    }
    // Stop 50-second vibration
    removeMessages(MSG_VIBRATE_50_SEC);
}
#end_block

